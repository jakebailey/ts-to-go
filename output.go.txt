package output

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)" /* as */ /* TODO(IntersectionType): __String & string */
type ReferenceHint int32

const (
	ReferenceHintUnspecified ReferenceHint = iota
	ReferenceHintIdentifier
	ReferenceHintProperty
	ReferenceHintExportAssignment
	ReferenceHintJsx
	ReferenceHintAsyncFunction
	ReferenceHintExportImportEquals
	ReferenceHintExportSpecifier
	ReferenceHintDecorator
)

var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1

type IterationUse int32

const (
	IterationUseAllowsSyncIterablesFlag  IterationUse = 1 << 0
	IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
	IterationUseAllowsStringInputFlag    IterationUse = 1 << 2
	IterationUseForOfFlag                IterationUse = 1 << 3
	IterationUseYieldStarFlag            IterationUse = 1 << 4
	IterationUseSpreadFlag               IterationUse = 1 << 5
	IterationUseDestructuringFlag        IterationUse = 1 << 6
	IterationUsePossiblyOutOfBounds      IterationUse = 1 << 7
	IterationUseElement                  IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseSpread                   IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
	IterationUseDestructuring            IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
	IterationUseForOf                    IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseForAwaitOf               IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseYieldStar                IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseAsyncYieldStar           IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseGeneratorReturnType      IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)

type IterationTypeKind int32

const (
	IterationTypeKindYield IterationTypeKind = iota
	IterationTypeKindReturn
	IterationTypeKindNext
)

type IterationTypesResolver struct {
	iterableCacheKey/* TODO(UnionType): "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	iteratorCacheKey/* TODO(UnionType): "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
	iteratorSymbolName/* TODO(UnionType): "asyncIterator" | "iterator" */ any
	getGlobalIteratorType         func(reportErrors bool) GenericType
	getGlobalIterableType         func(reportErrors bool) GenericType
	getGlobalIterableIteratorType func(reportErrors bool) GenericType
	getGlobalIteratorObjectType   func(reportErrors bool) GenericType
	getGlobalGeneratorType        func(reportErrors bool) GenericType
	getGlobalBuiltinIteratorTypes func() []GenericType
	resolveIterationType          func(type_ Type, errorNode Node) *Type
	mustHaveANextMethodDiagnostic DiagnosticMessage
	mustBeAMethodDiagnostic       DiagnosticMessage
	mustHaveAValueDiagnostic      DiagnosticMessage
}
type WideningKind int32

const (
	WideningKindNormal WideningKind = iota
	WideningKindFunctionReturn
	WideningKindGeneratorNext
	WideningKindGeneratorYield
)

type TypeFacts int32

const (
	TypeFactsNone                      TypeFacts = 0
	TypeFactsTypeofEQString            TypeFacts = 1 << 0
	TypeFactsTypeofEQNumber            TypeFacts = 1 << 1
	TypeFactsTypeofEQBigInt            TypeFacts = 1 << 2
	TypeFactsTypeofEQBoolean           TypeFacts = 1 << 3
	TypeFactsTypeofEQSymbol            TypeFacts = 1 << 4
	TypeFactsTypeofEQObject            TypeFacts = 1 << 5
	TypeFactsTypeofEQFunction          TypeFacts = 1 << 6
	TypeFactsTypeofEQHostObject        TypeFacts = 1 << 7
	TypeFactsTypeofNEString            TypeFacts = 1 << 8
	TypeFactsTypeofNENumber            TypeFacts = 1 << 9
	TypeFactsTypeofNEBigInt            TypeFacts = 1 << 10
	TypeFactsTypeofNEBoolean           TypeFacts = 1 << 11
	TypeFactsTypeofNESymbol            TypeFacts = 1 << 12
	TypeFactsTypeofNEObject            TypeFacts = 1 << 13
	TypeFactsTypeofNEFunction          TypeFacts = 1 << 14
	TypeFactsTypeofNEHostObject        TypeFacts = 1 << 15
	TypeFactsEQUndefined               TypeFacts = 1 << 16
	TypeFactsEQNull                    TypeFacts = 1 << 17
	TypeFactsEQUndefinedOrNull         TypeFacts = 1 << 18
	TypeFactsNEUndefined               TypeFacts = 1 << 19
	TypeFactsNENull                    TypeFacts = 1 << 20
	TypeFactsNEUndefinedOrNull         TypeFacts = 1 << 21
	TypeFactsTruthy                    TypeFacts = 1 << 22
	TypeFactsFalsy                     TypeFacts = 1 << 23
	TypeFactsIsUndefined               TypeFacts = 1 << 24
	TypeFactsIsNull                    TypeFacts = 1 << 25
	TypeFactsIsUndefinedOrNull         TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
	TypeFactsAll                       TypeFacts = (1 << 27) - 1
	TypeFactsBaseStringStrictFacts     TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseStringFacts           TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsStringStrictFacts         TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsStringFacts               TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsEmptyStringStrictFacts    TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
	TypeFactsEmptyStringFacts          TypeFacts = TypeFactsBaseTypeFactsStringFacts
	TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
	TypeFactsNonEmptyStringFacts       TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsBaseNumberStrictFacts     TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsNumberStrictFacts         TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsNumberFacts               TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsZeroNumberStrictFacts     TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
	TypeFactsZeroNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberFacts
	TypeFactsNonZeroNumberStrictFacts  TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroNumberFacts        TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsBaseBigIntStrictFacts     TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBigIntStrictFacts         TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBigIntFacts               TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsZeroBigIntStrictFacts     TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
	TypeFactsZeroBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
	TypeFactsNonZeroBigIntStrictFacts  TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroBigIntFacts        TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsBaseBooleanStrictFacts    TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBooleanFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBooleanStrictFacts        TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBooleanFacts              TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsFalseStrictFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
	TypeFactsFalseFacts                TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
	TypeFactsTrueStrictFacts           TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
	TypeFactsTrueFacts                 TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsSymbolStrictFacts         TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsSymbolFacts               TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsObjectStrictFacts         TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsObjectFacts               TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsFunctionStrictFacts       TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsFunctionFacts             TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsVoidFacts                 TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
	TypeFactsUndefinedFacts            TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
	TypeFactsNullFacts                 TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
	TypeFactsEmptyObjectStrictFacts    TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
	TypeFactsEmptyObjectFacts          TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsUnknownFacts              TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsAllTypeofNE               TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
	TypeFactsOrFactsMask               TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
	TypeFactsAndFactsMask              TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)

var typeofNEFacts ReadonlyMap[string, TypeFacts] = /* TODO(NewExpression): new Map(Object.entries({     string: TypeFacts.TypeofNEString,     number: TypeFacts.TypeofNENumber,     bigint: TypeFacts.TypeofNEBigInt,     boolean: TypeFacts.TypeofNEBoolean,     symbol: TypeFacts.TypeofNESymbol,     undefined: TypeFacts.NEUndefined,     object: TypeFacts.TypeofNEObject,     function: TypeFacts.TypeofNEFunction, })) */ TODO

type TypeSystemEntity /* TODO(UnionType): Node | Symbol | Type | Signature */ any
type TypeSystemPropertyName int32

const (
	TypeSystemPropertyNameType TypeSystemPropertyName = iota
	TypeSystemPropertyNameResolvedBaseConstructorType
	TypeSystemPropertyNameDeclaredType
	TypeSystemPropertyNameResolvedReturnType
	TypeSystemPropertyNameImmediateBaseConstraint
	TypeSystemPropertyNameResolvedTypeArguments
	TypeSystemPropertyNameResolvedBaseTypes
	TypeSystemPropertyNameWriteType
	TypeSystemPropertyNameParameterInitializerContainsUndefined
)

type CheckMode int32

const (
	CheckModeNormal               CheckMode = 0
	CheckModeContextual           CheckMode = 1 << 0
	CheckModeInferential          CheckMode = 1 << 1
	CheckModeSkipContextSensitive CheckMode = 1 << 2
	CheckModeSkipGenericFunctions CheckMode = 1 << 3
	CheckModeIsForSignatureHelp   CheckMode = 1 << 4
	CheckModeRestBindingElement   CheckMode = 1 << 5
	CheckModeTypeOnly             CheckMode = 1 << 6
)

type SignatureCheckMode int32

const (
	SignatureCheckModeNone               SignatureCheckMode = 0
	SignatureCheckModeBivariantCallback  SignatureCheckMode = 1 << 0
	SignatureCheckModeStrictCallback     SignatureCheckMode = 1 << 1
	SignatureCheckModeIgnoreReturnTypes  SignatureCheckMode = 1 << 2
	SignatureCheckModeStrictArity        SignatureCheckMode = 1 << 3
	SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
	SignatureCheckModeCallback           SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)

type IntersectionState int32

const (
	IntersectionStateNone   IntersectionState = 0
	IntersectionStateSource IntersectionState = 1 << 0
	IntersectionStateTarget IntersectionState = 1 << 1
)

type RecursionFlags int32

const (
	RecursionFlagsNone   RecursionFlags = 0
	RecursionFlagsSource RecursionFlags = 1 << 0
	RecursionFlagsTarget RecursionFlags = 1 << 1
	RecursionFlagsBoth   RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)

type MappedTypeModifiers int32

const (
	MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
	MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
	MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
	MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)

type MappedTypeNameTypeKind int32

const (
	MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
	MappedTypeNameTypeKindFiltering
	MappedTypeNameTypeKindRemapping
)

type ExpandingFlags int32

const (
	ExpandingFlagsNone   ExpandingFlags = 0
	ExpandingFlagsSource ExpandingFlags = 1
	ExpandingFlagsTarget ExpandingFlags = 1 << 1
	ExpandingFlagsBoth   ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)

type MembersOrExportsResolutionKind string

const (
	MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
	MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)

type UnusedKind int32

const (
	UnusedKindLocal UnusedKind = iota
	UnusedKindParameter
)

type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation)

var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)

type DeclarationMeaning int32

const (
	DeclarationMeaningGetAccessor                DeclarationMeaning = 1
	DeclarationMeaningSetAccessor                DeclarationMeaning = 2
	DeclarationMeaningPropertyAssignment         DeclarationMeaning = 4
	DeclarationMeaningMethod                     DeclarationMeaning = 8
	DeclarationMeaningPrivateStatic              DeclarationMeaning = 16
	DeclarationMeaningGetOrSetAccessor           DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
	DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)

type DeclarationSpaces int32

const (
	DeclarationSpacesNone            DeclarationSpaces = 0
	DeclarationSpacesExportValue     DeclarationSpaces = 1 << 0
	DeclarationSpacesExportType      DeclarationSpaces = 1 << 1
	DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)

type MinArgumentCountFlags int32

const (
	MinArgumentCountFlagsNone                    MinArgumentCountFlags = 0
	MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
	MinArgumentCountFlagsVoidIsNonOptional       MinArgumentCountFlags = 1 << 1
)

type IntrinsicTypeKind int32

const (
	IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
	IntrinsicTypeKindLowercase
	IntrinsicTypeKindCapitalize
	IntrinsicTypeKindUncapitalize
	IntrinsicTypeKindNoInfer
)

var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = /* TODO(NewExpression): new Map(Object.entries({     Uppercase: IntrinsicTypeKind.Uppercase,     Lowercase: IntrinsicTypeKind.Lowercase,     Capitalize: IntrinsicTypeKind.Capitalize,     Uncapitalize: IntrinsicTypeKind.Uncapitalize,     NoInfer: IntrinsicTypeKind.NoInfer, })) */ TODO
var SymbolLinks = /* TODO(ClassExpression): class implements SymbolLinks {     declare _symbolLinksBrand: any; } */ TODO

func NodeLinks(this NodeLinks) {
	/* TODO(ExpressionStatement): this.flags = NodeCheckFlags.None; */
}
func getNodeId(node Node) number {
	if ! /* TODO(PropertyAccessExpression): node.id */ TODO {
		/* TODO(ExpressionStatement): node.id = nextNodeId; */
		/* TODO(ExpressionStatement): nextNodeId++; */
	}
	return /* TODO(PropertyAccessExpression): node.id */ TODO
}
func getSymbolId(symbol Symbol) SymbolId {
	if ! /* TODO(PropertyAccessExpression): symbol.id */ TODO {
		/* TODO(ExpressionStatement): symbol.id = nextSymbolId; */
		/* TODO(ExpressionStatement): nextSymbolId++; */
	}
	return /* TODO(PropertyAccessExpression): symbol.id */ TODO
}
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) /* TODO(undefined): boolean */ TODO {
	moduleState := getModuleInstanceState(node)
	return moduleState == /* TODO(PropertyAccessExpression): ModuleInstanceState.Instantiated */ TODO || /* TODO(ParenthesizedExpression): (preserveConstEnums && moduleState === ModuleInstanceState.ConstEnumOnly) */ TODO
}
func createTypeChecker(host TypeCheckerHost) TypeChecker {
	var deferredDiagnosticsCallbacks []func() = /* TODO(ArrayLiteralExpression): [] */ TODO
	addLazyDiagnostic := /* TODO(ArrowFunction): (arg: () => void) => {         deferredDiagnosticsCallbacks.push(arg);     } */ TODO
	var cancellationToken *CancellationToken
	var scanner *Scanner
	Symbol := /* TODO(PropertyAccessExpression): objectAllocator.getSymbolConstructor */ TODO()
	Type := /* TODO(PropertyAccessExpression): objectAllocator.getTypeConstructor */ TODO()
	Signature := /* TODO(PropertyAccessExpression): objectAllocator.getSignatureConstructor */ TODO()
	typeCount := 0
	symbolCount := 0
	totalInstantiationCount := 0
	instantiationCount := 0
	instantiationDepth := 0
	inlineLevel := 0
	var currentNode Node
	var varianceTypeParameter *TypeParameter
	isInferencePartiallyBlocked := /* TODO(FalseKeyword): false */ TODO
	emptySymbols := createSymbolTable()
	arrayVariances := /* TODO(ArrayLiteralExpression): [VarianceFlags.Covariant] */ TODO
	compilerOptions := /* TODO(PropertyAccessExpression): host.getCompilerOptions */ TODO()
	languageVersion := getEmitScriptTarget(compilerOptions)
	moduleKind := getEmitModuleKind(compilerOptions)
	legacyDecorators := !! /* TODO(PropertyAccessExpression): compilerOptions.experimentalDecorators */ TODO
	useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
	emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
	allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
	strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
	strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
	strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
	strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
	strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
	noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
	noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
	useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
	exactOptionalPropertyTypes := /* TODO(PropertyAccessExpression): compilerOptions.exactOptionalPropertyTypes */ TODO
	noUncheckedSideEffectImports := !! /* TODO(PropertyAccessExpression): compilerOptions.noUncheckedSideEffectImports */ TODO
	checkBinaryExpression := createCheckBinaryExpression()
	emitResolver := createResolver()
	nodeBuilder := createNodeBuilder()
	syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions /* TODO(ObjectLiteralExpression): {         isEntityNameVisible,         isExpandoFunctionDeclaration,         getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,         requiresAddingImplicitUndefined,         isUndefinedIdentifierExpression(node: Identifier) {             Debug.assert(isExpressionNode(node));             return getSymbolAtLocation(node) === undefinedSymbol;         },         isDefinitelyReferenceToGlobalSymbolObject,     } */, TODO)
	evaluate := createEvaluator( /* TODO(ObjectLiteralExpression): {         evaluateElementAccessExpression,         evaluateEntityNameExpression,     } */ TODO)
	globals := createSymbolTable()
	undefinedSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "undefined" /* as */ /* TODO(TypeReference): __String */)
	/* TODO(ExpressionStatement): undefinedSymbol.declarations = []; */
	globalThisSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Module */ TODO, "globalThis" /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): CheckFlags.Readonly */, TODO)
	/* TODO(ExpressionStatement): globalThisSymbol.exports = globals; */
	/* TODO(ExpressionStatement): globalThisSymbol.declarations = []; */
	/* TODO(PropertyAccessExpression): globals.set */
	TODO( /* TODO(PropertyAccessExpression): globalThisSymbol.escapedName */ TODO, globalThisSymbol)
	argumentsSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "arguments" /* as */ /* TODO(TypeReference): __String */)
	requireSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "require" /* as */ /* TODO(TypeReference): __String */)
	isolatedModulesLikeFlagName := /* TODO(ConditionalExpression): compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules" */ TODO
	canCollectSymbolAliasAccessabilityData := ! /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO
	var apparentArgumentCount /* TODO(NumberKeyword): number */ any
	var lastGetCombinedNodeFlagsNode Node
	lastGetCombinedNodeFlagsResult := /* TODO(PropertyAccessExpression): NodeFlags.None */ TODO
	var lastGetCombinedModifierFlagsNode Declaration
	lastGetCombinedModifierFlagsResult := /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
	resolveName := createNameResolver( /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSymbol,         onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,         onFailedToResolveSymbol,         onSuccessfullyResolvedSymbol,     } */ TODO)
	resolveNameForSymbolSuggestion := createNameResolver( /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSuggestionForSymbolNameLookup,     } */ TODO)
	var checker TypeChecker = /* TODO(ObjectLiteralExpression): {         getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),         getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),         getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),         getTypeCount: () => typeCount,         getInstantiationCount: () => totalInstantiationCount,         getRelationCacheSizes: () => ({             assignable: assignableRelation.size,             identity: identityRelation.size,             subtype: subtypeRelation.size,             strictSubtype: strictSubtypeRelation.size,         }),         isUndefinedSymbol: symbol => symbol === undefinedSymbol,         isArgumentsSymbol: symbol => symbol === argumentsSymbol,         isUnknownSymbol: symbol => symbol === unknownSymbol,         getMergedSymbol,         symbolIsValue,         getDiagnostics,         getGlobalDiagnostics,         getRecursionIdentity,         getUnmatchedProperties,         getTypeOfSymbolAtLocation: (symbol, locationIn) => {             const location = getParseTreeNode(locationIn);             return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;         },         getTypeOfSymbol,         getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {             const parameter = getParseTreeNode(parameterIn, isParameter);             if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");             Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));             return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));         },         getDeclaredTypeOfSymbol,         getPropertiesOfType,         getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),         getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {             const node = getParseTreeNode(location);             if (!node) {                 return undefined;             }             const propName = escapeLeadingUnderscores(name);             const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);             return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;         },         getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),         getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexInfosOfType,         getIndexInfosOfIndexSymbol,         getSignaturesOfType,         getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexType: type => getIndexType(type),         getBaseTypes,         getBaseTypeOfLiteralType,         getWidenedType,         getWidenedLiteralType,         getTypeFromTypeNode: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node ? getTypeFromTypeNode(node) : errorType;         },         getParameterType: getTypeAtPosition,         getParameterIdentifierInfoAtPosition,         getPromisedTypeOfPromise,         getAwaitedType: type => getAwaitedType(type),         getReturnTypeOfSignature,         isNullableType,         getNullableType,         getNonNullableType,         getNonOptionalType: removeOptionalTypeMarker,         getTypeArguments,         typeToTypeNode: nodeBuilder.typeToTypeNode,         typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode,         indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,         signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,         symbolToEntityName: nodeBuilder.symbolToEntityName,         symbolToExpression: nodeBuilder.symbolToExpression,         symbolToNode: nodeBuilder.symbolToNode,         symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,         symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,         typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,         getSymbolsInScope: (locationIn, meaning) => {             const location = getParseTreeNode(locationIn);             return location ? getSymbolsInScope(location, meaning) : [];         },         getSymbolAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors             return node ? getSymbolAtLocation(node, /*ignoreErrors* / true) : undefined;         },         getIndexInfosAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getIndexInfosAtLocation(node) : undefined;         },         getShorthandAssignmentValueSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getShorthandAssignmentValueSymbol(node) : undefined;         },         getExportSpecifierLocalTargetSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn, isExportSpecifier);             return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;         },         getExportSymbolOfSymbol(symbol) {             return getMergedSymbol(symbol.exportSymbol || symbol);         },         getTypeAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getTypeOfNode(node) : errorType;         },         getTypeOfAssignmentPattern: nodeIn => {             const node = getParseTreeNode(nodeIn, isAssignmentPattern);             return node && getTypeOfAssignmentPattern(node) || errorType;         },         getPropertySymbolOfDestructuringAssignment: locationIn => {             const location = getParseTreeNode(locationIn, isIdentifier);             return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;         },         signatureToString: (signature, enclosingDeclaration, flags, kind) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);         },         typeToString: (type, enclosingDeclaration, flags) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);         },         symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);         },         typePredicateToString: (predicate, enclosingDeclaration, flags) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);         },         writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);         },         writeType: (type, enclosingDeclaration, flags, writer) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);         },         writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);         },         writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);         },         getAugmentedPropertiesOfType,         getRootSymbols,         getSymbolOfExpando,         getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {             const node = getParseTreeNode(nodeIn, isExpression);             if (!node) {                 return undefined;             }             if (contextFlags! & ContextFlags.Completions) {                 return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));             }             return getContextualType(node, contextFlags);         },         getContextualTypeForObjectLiteralElement: nodeIn => {             const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);             return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags* / undefined) : undefined;         },         getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {             const node = getParseTreeNode(nodeIn, isCallLikeExpression);             return node && getContextualTypeForArgumentAtIndex(node, argIndex);         },         getContextualTypeForJsxAttribute: nodeIn => {             const node = getParseTreeNode(nodeIn, isJsxAttributeLike);             return node && getContextualTypeForJsxAttribute(node, /*contextFlags* / undefined);         },         isContextSensitive,         getTypeOfPropertyOfContextualType,         getFullyQualifiedName,         getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),         getCandidateSignaturesForStringLiteralCompletions,         getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),         getExpandedParameters,         hasEffectiveRestParameter,         containsArgumentsReference,         getConstantValue: nodeIn => {             const node = getParseTreeNode(nodeIn, canHaveConstantValue);             return node ? getConstantValue(node) : undefined;         },         isValidPropertyAccess: (nodeIn, propertyName) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);             return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));         },         isValidPropertyAccessForCompletions: (nodeIn, type, property) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);             return !!node && isValidPropertyAccessForCompletions(node, type, property);         },         getSignatureFromDeclaration: declarationIn => {             const declaration = getParseTreeNode(declarationIn, isFunctionLike);             return declaration ? getSignatureFromDeclaration(declaration) : undefined;         },         isImplementationOfOverload: nodeIn => {             const node = getParseTreeNode(nodeIn, isFunctionLike);             return node ? isImplementationOfOverload(node) : undefined;         },         getImmediateAliasedSymbol,         getAliasedSymbol: resolveAlias,         getEmitResolver,         requiresAddingImplicitUndefined,         getExportsOfModule: getExportsOfModuleAsArray,         getExportsAndPropertiesOfModule,         forEachExportAndPropertyOfModule,         getSymbolWalker: createGetSymbolWalker(             getRestTypeOfSignature,             getTypePredicateOfSignature,             getReturnTypeOfSignature,             getBaseTypes,             resolveStructuredTypeMembers,             getTypeOfSymbol,             getResolvedSymbol,             getConstraintOfTypeParameter,             getFirstIdentifier,             getTypeArguments,         ),         getAmbientModules,         getJsxIntrinsicTagNamesAt,         isOptionalParameter: nodeIn => {             const node = getParseTreeNode(nodeIn, isParameter);             return node ? isOptionalParameter(node) : false;         },         tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),         tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),         tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations* / true),         getApparentType,         getUnionType,         isTypeAssignableTo,         createAnonymousType,         createSignature,         createSymbol,         createIndexInfo,         getAnyType: () => anyType,         getStringType: () => stringType,         getStringLiteralType,         getNumberType: () => numberType,         getNumberLiteralType,         getBigIntType: () => bigintType,         getBigIntLiteralType,         createPromiseType,         createArrayType,         getElementTypeOfArrayType,         getBooleanType: () => booleanType,         getFalseType: (fresh?) => fresh ? falseType : regularFalseType,         getTrueType: (fresh?) => fresh ? trueType : regularTrueType,         getVoidType: () => voidType,         getUndefinedType: () => undefinedType,         getNullType: () => nullType,         getESSymbolType: () => esSymbolType,         getNeverType: () => neverType,         getOptionalType: () => optionalType,         getPromiseType: () => getGlobalPromiseType(/*reportErrors* / false),         getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors* / false),         getAnyAsyncIterableType: () => {             const type = getGlobalAsyncIterableType(/*reportErrors* / false);             if (type === emptyGenericType) return undefined;             return createTypeReference(type, [anyType, anyType, anyType]);         },         isSymbolAccessible,         isArrayType,         isTupleType,         isArrayLikeType,         isEmptyAnonymousObjectType,         isTypeInvalidDueToUnionDiscriminant,         getExactOptionalProperties,         getAllPossiblePropertiesOfTypes,         getSuggestedSymbolForNonexistentProperty,         getSuggestedSymbolForNonexistentJSXAttribute,         getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),         getSuggestedSymbolForNonexistentModule,         getSuggestedSymbolForNonexistentClassMember,         getBaseConstraintOfType,         getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,         resolveName(name, location, meaning, excludeGlobals) {             return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage* / undefined, /*isUse* / false, excludeGlobals);         },         getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),         getJsxFragmentFactory: n => {             const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);             return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);         },         getAccessibleSymbolChain,         getTypePredicateOfSignature,         resolveExternalModuleName: moduleSpecifierIn => {             const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);             return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors* / true);         },         resolveExternalModuleSymbol,         tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {             const node = getParseTreeNode(nodeIn);             return node && tryGetThisTypeAt(node, includeGlobalThis, container);         },         getTypeArgumentConstraint: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node && getTypeArgumentConstraint(node);         },         getSuggestionDiagnostics: (fileIn, ct) => {             const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");             if (skipTypeChecking(file, compilerOptions, host)) {                 return emptyArray;             }              let diagnostics: DiagnosticWithLocation[] | undefined;             try {                 // Record the cancellation token so it can be checked later on during checkSourceElement.                 // Do this in a finally block so we can ensure that it gets reset back to nothing after                 // this call is done.                 cancellationToken = ct;                  // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused                 checkSourceFileWithEagerDiagnostics(file);                 Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));                  diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));                 checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {                     if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                         (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });                     }                 });                  return diagnostics || emptyArray;             }             finally {                 cancellationToken = undefined;             }         },          runWithCancellationToken: (token, callback) => {             try {                 cancellationToken = token;                 return callback(checker);             }             finally {                 cancellationToken = undefined;             }         },          getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,         isDeclarationVisible,         isPropertyAccessible,         getTypeOnlyAliasDeclaration,         getMemberOverrideModifierStatus,         isTypeParameterPossiblyReferenced,         typeHasCallOrConstructSignatures,         getSymbolFlags,     } */ TODO
	getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
		candidatesSet := /* TODO(NewExpression): new Set<Signature>() */ TODO
		var candidates []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		runWithInferenceBlockedFromSourceNode(editingArgument /* TODO(ArrowFunction): () => getResolvedSignatureWorker(call, candidates, /*argumentCount* / undefined, CheckMode.Normal) */, TODO)
		for _, candidate := range candidates {
			/* TODO(PropertyAccessExpression): candidatesSet.add */ TODO(candidate)
		}
		/* TODO(ExpressionStatement): candidates.length = 0; */
		runWithoutResolvedSignatureCaching(editingArgument /* TODO(ArrowFunction): () => getResolvedSignatureWorker(call, candidates, /*argumentCount* / undefined, CheckMode.Normal) */, TODO)
		for _, candidate := range candidates {
			/* TODO(PropertyAccessExpression): candidatesSet.add */ TODO(candidate)
		}
		return arrayFrom(candidatesSet)
	}
	runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
		/* TODO(ExpressionStatement): node = findAncestor(node, isCallLikeOrFunctionLikeExpression); */
		if node {
			cachedResolvedSignatures := /* TODO(ArrayLiteralExpression): [] */ TODO
			cachedTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(WhileStatement): while (node) {                 const nodeLinks = getNodeLinks(node);                 cachedResolvedSignatures.push([nodeLinks, nodeLinks.resolvedSignature] as const);                 nodeLinks.resolvedSignature = undefined;                 if (isFunctionExpressionOrArrowFunction(node)) {                     const symbolLinks = getSymbolLinks(getSymbolOfDeclaration(node));                     const type = symbolLinks.type;                     cachedTypes.push([symbolLinks, type] as const);                     symbolLinks.type = undefined;                 }                 node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression);             } */
			result := fn()
			for _, TODO_IDENTIFIER := range cachedResolvedSignatures {
				/* TODO(ExpressionStatement): nodeLinks.resolvedSignature = resolvedSignature; */
			}
			for _, TODO_IDENTIFIER := range cachedTypes {
				/* TODO(ExpressionStatement): symbolLinks.type = type; */
			}
			return result
		}
		return fn()
	}
	runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
		containingCall := findAncestor(node, isCallLikeExpression)
		if containingCall {
			toMarkSkip := /* TODO(NonNullExpression): node! */ TODO
			/* TODO(DoStatement): do {                 getNodeLinks(toMarkSkip).skipDirectInference = true;                 toMarkSkip = toMarkSkip.parent;             }             while (toMarkSkip && toMarkSkip !== containingCall); */
		}
		/* TODO(ExpressionStatement): isInferencePartiallyBlocked = true; */
		result := runWithoutResolvedSignatureCaching(node, fn)
		/* TODO(ExpressionStatement): isInferencePartiallyBlocked = false; */
		if containingCall {
			toMarkSkip := /* TODO(NonNullExpression): node! */ TODO
			/* TODO(DoStatement): do {                 getNodeLinks(toMarkSkip).skipDirectInference = undefined;                 toMarkSkip = toMarkSkip.parent;             }             while (toMarkSkip && toMarkSkip !== containingCall); */
		}
		return result
	}
	getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, argumentCount /* TODO(NumberKeyword): number */ any, checkMode CheckMode) *Signature {
		node := getParseTreeNode(nodeIn, isCallLikeExpression)
		/* TODO(ExpressionStatement): apparentArgumentCount = argumentCount; */
		res := /* TODO(ConditionalExpression): !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode) */ TODO
		/* TODO(ExpressionStatement): apparentArgumentCount = undefined; */
		return res
	}
	tupleTypes := /* TODO(NewExpression): new Map<string, GenericType>() */ TODO
	unionTypes := /* TODO(NewExpression): new Map<string, UnionType>() */ TODO
	unionOfUnionTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	intersectionTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	stringLiteralTypes := /* TODO(NewExpression): new Map<string, StringLiteralType>() */ TODO
	numberLiteralTypes := /* TODO(NewExpression): new Map<number, NumberLiteralType>() */ TODO
	bigIntLiteralTypes := /* TODO(NewExpression): new Map<string, BigIntLiteralType>() */ TODO
	enumLiteralTypes := /* TODO(NewExpression): new Map<string, LiteralType>() */ TODO
	indexedAccessTypes := /* TODO(NewExpression): new Map<string, IndexedAccessType>() */ TODO
	templateLiteralTypes := /* TODO(NewExpression): new Map<string, TemplateLiteralType>() */ TODO
	stringMappingTypes := /* TODO(NewExpression): new Map<string, StringMappingType>() */ TODO
	substitutionTypes := /* TODO(NewExpression): new Map<string, SubstitutionType>() */ TODO
	subtypeReductionCache := /* TODO(NewExpression): new Map<string, Type[]>() */ TODO
	decoratorContextOverrideTypeCache := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	cachedTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	var evolvingArrayTypes []EvolvingArrayType = /* TODO(ArrayLiteralExpression): [] */ TODO
	var undefinedProperties SymbolTable = /* TODO(NewExpression): new Map() */ TODO
	markerTypes := /* TODO(NewExpression): new Set<number>() */ TODO
	unknownSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "unknown" /* as */ /* TODO(TypeReference): __String */)
	resolvingSymbol := createSymbol(0 /* TODO(PropertyAccessExpression): InternalSymbolName.Resolving */, TODO)
	unresolvedSymbols := /* TODO(NewExpression): new Map<string, TransientSymbol>() */ TODO
	errorTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	seenIntrinsicNames := /* TODO(NewExpression): new Set<string>() */ TODO
	anyType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any")
	autoType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any" /* TODO(PropertyAccessExpression): ObjectFlags.NonInferrableType */, TODO, "auto")
	wildcardType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any", nil, "wildcard")
	blockedStringType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any", nil, "blocked string")
	errorType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "error")
	unresolvedType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "unresolved")
	nonInferrableAnyType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "any" /* TODO(PropertyAccessExpression): ObjectFlags.ContainsWideningType */, TODO, "non-inferrable")
	intrinsicMarkerType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Any */ TODO, "intrinsic")
	unknownType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Unknown */ TODO, "unknown")
	undefinedType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO, "undefined")
	undefinedWideningType := /* TODO(ConditionalExpression): strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening") */ TODO
	missingType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO, "undefined", nil, "missing")
	undefinedOrMissingType := /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? missingType : undefinedType */ TODO
	optionalType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO, "undefined", nil, "optional")
	nullType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Null */ TODO, "null")
	nullWideningType := /* TODO(ConditionalExpression): strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening") */ TODO
	stringType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.String */ TODO, "string")
	numberType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Number */ TODO, "number")
	bigintType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.BigInt */ TODO, "bigint")
	falseType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "false", nil, "fresh") /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	regularFalseType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "false")        /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	trueType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "true", nil, "fresh")   /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	regularTrueType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.BooleanLiteral */ TODO, "true")          /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	/* TODO(ExpressionStatement): trueType.regularType = regularTrueType; */
	/* TODO(ExpressionStatement): trueType.freshType = trueType; */
	/* TODO(ExpressionStatement): regularTrueType.regularType = regularTrueType; */
	/* TODO(ExpressionStatement): regularTrueType.freshType = trueType; */
	/* TODO(ExpressionStatement): falseType.regularType = regularFalseType; */
	/* TODO(ExpressionStatement): falseType.freshType = falseType; */
	/* TODO(ExpressionStatement): regularFalseType.regularType = regularFalseType; */
	/* TODO(ExpressionStatement): regularFalseType.freshType = falseType; */
	booleanType := getUnionType( /* TODO(ArrayLiteralExpression): [regularFalseType, regularTrueType] */ TODO)
	esSymbolType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.ESSymbol */ TODO, "symbol")
	voidType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Void */ TODO, "void")
	neverType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never")
	silentNeverType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never" /* TODO(PropertyAccessExpression): ObjectFlags.NonInferrableType */, TODO, "silent")
	implicitNeverType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", nil, "implicit")
	unreachableNeverType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", nil, "unreachable")
	nonPrimitiveType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */ TODO, "object")
	stringOrNumberType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType] */ TODO)
	stringNumberSymbolType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType, esSymbolType] */ TODO)
	numberOrBigIntType := getUnionType( /* TODO(ArrayLiteralExpression): [numberType, bigintType] */ TODO)
	templateConstraintType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType, booleanType, bigintType, nullType, undefinedType] */ TODO) /* as */ /* TODO(TypeReference): UnionType */
	numericStringType := getTemplateLiteralType( /* TODO(ArrayLiteralExpression): ["", ""] */ TODO /* TODO(ArrayLiteralExpression): [numberType] */, TODO)
	var restrictiveMapper TypeMapper = makeFunctionTypeMapper( /* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t */ TODO /* TODO(ArrowFunction): () => "(restrictive mapper)" */, TODO)
	var permissiveMapper TypeMapper = makeFunctionTypeMapper( /* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? wildcardType : t */ TODO /* TODO(ArrowFunction): () => "(permissive mapper)" */, TODO)
	uniqueLiteralType := createIntrinsicType( /* TODO(PropertyAccessExpression): TypeFlags.Never */ TODO, "never", nil, "unique literal")
	var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper( /* TODO(ArrowFunction): t => t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t */ TODO /* TODO(ArrowFunction): () => "(unique literal mapper)" */, TODO)
	var outofbandVarianceMarkerHandler /* TODO(ParenthesizedType): ((onlyUnreliable: boolean) => void) */ any
	reportUnreliableMapper := makeFunctionTypeMapper( /* TODO(ArrowFunction): t => {         if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {             outofbandVarianceMarkerHandler(/*onlyUnreliable* / true);         }         return t;     } */ TODO /* TODO(ArrowFunction): () => "(unmeasurable reporter)" */, TODO)
	reportUnmeasurableMapper := makeFunctionTypeMapper( /* TODO(ArrowFunction): t => {         if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {             outofbandVarianceMarkerHandler(/*onlyUnreliable* / false);         }         return t;     } */ TODO /* TODO(ArrowFunction): () => "(unreliable reporter)" */, TODO)
	emptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	/* TODO(ExpressionStatement): emptyJsxObjectType.objectFlags |= ObjectFlags.JsxAttributes; */
	emptyTypeLiteralSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.TypeLiteral */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Type */, TODO)
	/* TODO(ExpressionStatement): emptyTypeLiteralSymbol.members = createSymbolTable(); */
	emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownEmptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownUnionType := /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType */ TODO
	emptyGenericType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray) /* as */ /* TODO(TypeReference): ObjectType */ /* as */ /* TODO(TypeReference): GenericType */
	/* TODO(ExpressionStatement): emptyGenericType.instantiations = new Map<string, TypeReference>(); */
	anyFunctionType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	/* TODO(ExpressionStatement): anyFunctionType.objectFlags |= ObjectFlags.NonInferrableType; */
	noConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	circularConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	resolvingDefaultType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	markerSuperType := createTypeParameter()
	markerSubType := createTypeParameter()
	/* TODO(ExpressionStatement): markerSubType.constraint = markerSuperType; */
	markerOtherType := createTypeParameter()
	markerSuperTypeForCheck := createTypeParameter()
	markerSubTypeForCheck := createTypeParameter()
	/* TODO(ExpressionStatement): markerSubTypeForCheck.constraint = markerSuperTypeForCheck; */
	noTypePredicate := createTypePredicate( /* TODO(PropertyAccessExpression): TypePredicateKind.Identifier */ TODO, "<<unresolved>>", 0, anyType)
	anySignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0 /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	unknownSignature := createSignature(nil, nil, nil, emptyArray, errorType, nil, 0 /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	resolvingSignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0 /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	silentNeverSignature := createSignature(nil, nil, nil, emptyArray, silentNeverType, nil, 0 /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	enumNumberIndexInfo := createIndexInfo(numberType, stringType /* TODO(TrueKeyword): true */, TODO)
	iterationTypesCache := /* TODO(NewExpression): new Map<string, IterationTypes>() */ TODO
	var noIterationTypes IterationTypes = /* TODO(ObjectLiteralExpression): {         get yieldType(): Type {             return Debug.fail("Not supported");         },         get returnType(): Type {             return Debug.fail("Not supported");         },         get nextType(): Type {             return Debug.fail("Not supported");         },     } */ TODO
	anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
	var asyncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfAsyncIterable",         iteratorCacheKey: "iterationTypesOfAsyncIterator",         iteratorSymbolName: "asyncIterator",         getGlobalIteratorType: getGlobalAsyncIteratorType,         getGlobalIterableType: getGlobalAsyncIterableType,         getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,         getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType,         getGlobalGeneratorType: getGlobalAsyncGeneratorType,         getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes,         resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member),         mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,     } */ TODO
	var syncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfIterable",         iteratorCacheKey: "iterationTypesOfIterator",         iteratorSymbolName: "iterator",         getGlobalIteratorType,         getGlobalIterableType,         getGlobalIterableIteratorType,         getGlobalIteratorObjectType,         getGlobalGeneratorType,         getGlobalBuiltinIteratorTypes,         resolveIterationType: (type, _errorNode) => type,         mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,     } */ TODO
	type DuplicateInfoForSymbol struct {
		firstFileLocations  []Declaration
		secondFileLocations []Declaration
		isBlockScoped       bool
	}
	type DuplicateInfoForFiles struct {
		firstFile          SourceFile
		secondFile         SourceFile
		conflictingSymbols Map[string, DuplicateInfoForSymbol]
	}
	var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
	reverseMappedCache := /* TODO(NewExpression): new Map<string, Type | undefined>() */ TODO
	reverseHomomorphicMappedCache := /* TODO(NewExpression): new Map<string, Type | undefined>() */ TODO
	var ambientModulesCache /* TODO(ArrayType): Symbol[] */ any
	var patternAmbientModules []PatternAmbientModule
	var patternAmbientModuleAugmentations *Map[string, Symbol]
	var globalObjectType ObjectType
	var globalFunctionType ObjectType
	var globalCallableFunctionType ObjectType
	var globalNewableFunctionType ObjectType
	var globalArrayType GenericType
	var globalReadonlyArrayType GenericType
	var globalStringType ObjectType
	var globalNumberType ObjectType
	var globalBooleanType ObjectType
	var globalRegExpType ObjectType
	var globalThisType GenericType
	var anyArrayType Type
	var autoArrayType Type
	var anyReadonlyArrayType Type
	var deferredGlobalNonNullableTypeAlias Symbol
	var deferredGlobalESSymbolConstructorSymbol *Symbol
	var deferredGlobalESSymbolConstructorTypeSymbol *Symbol
	var deferredGlobalESSymbolType *ObjectType
	var deferredGlobalTypedPropertyDescriptorType GenericType
	var deferredGlobalPromiseType *GenericType
	var deferredGlobalPromiseLikeType *GenericType
	var deferredGlobalPromiseConstructorSymbol *Symbol
	var deferredGlobalPromiseConstructorLikeType *ObjectType
	var deferredGlobalIterableType *GenericType
	var deferredGlobalIteratorType *GenericType
	var deferredGlobalIterableIteratorType *GenericType
	var deferredGlobalIteratorObjectType *GenericType
	var deferredGlobalGeneratorType *GenericType
	var deferredGlobalIteratorYieldResultType *GenericType
	var deferredGlobalIteratorReturnResultType *GenericType
	var deferredGlobalAsyncIterableType *GenericType
	var deferredGlobalAsyncIteratorType *GenericType
	var deferredGlobalAsyncIterableIteratorType *GenericType
	var deferredGlobalBuiltinIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
	var deferredGlobalBuiltinAsyncIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
	var deferredGlobalAsyncIteratorObjectType *GenericType
	var deferredGlobalAsyncGeneratorType *GenericType
	var deferredGlobalTemplateStringsArrayType *ObjectType
	var deferredGlobalImportMetaType ObjectType
	var deferredGlobalImportMetaExpressionType ObjectType
	var deferredGlobalImportCallOptionsType *ObjectType
	var deferredGlobalImportAttributesType *ObjectType
	var deferredGlobalDisposableType *ObjectType
	var deferredGlobalAsyncDisposableType *ObjectType
	var deferredGlobalExtractSymbol *Symbol
	var deferredGlobalOmitSymbol *Symbol
	var deferredGlobalAwaitedSymbol *Symbol
	var deferredGlobalBigIntType *ObjectType
	var deferredGlobalNaNSymbol *Symbol
	var deferredGlobalRecordSymbol *Symbol
	var deferredGlobalClassDecoratorContextType *GenericType
	var deferredGlobalClassMethodDecoratorContextType *GenericType
	var deferredGlobalClassGetterDecoratorContextType *GenericType
	var deferredGlobalClassSetterDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorTargetType *GenericType
	var deferredGlobalClassAccessorDecoratorResultType *GenericType
	var deferredGlobalClassFieldDecoratorContextType *GenericType
	allPotentiallyUnusedIdentifiers := /* TODO(NewExpression): new Map<Path, PotentiallyUnusedIdentifier[]>() */ TODO
	flowLoopStart := 0
	flowLoopCount := 0
	sharedFlowCount := 0
	flowAnalysisDisabled := /* TODO(FalseKeyword): false */ TODO
	flowInvocationCount := 0
	var lastFlowNode *FlowNode
	var lastFlowNodeReachable bool
	var flowTypeCache /* TODO(ArrayType): Type[] */ any
	var contextualTypeNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var contextualTypes []*Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var contextualIsCache []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
	contextualTypeCount := 0
	var contextualBindingPatterns []BindingPattern = /* TODO(ArrayLiteralExpression): [] */ TODO
	var inferenceContextNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var inferenceContexts []*InferenceContext = /* TODO(ArrayLiteralExpression): [] */ TODO
	inferenceContextCount := 0
	emptyStringType := getStringLiteralType("")
	zeroType := getNumberLiteralType(0)
	zeroBigIntType := getBigIntLiteralType( /* TODO(ObjectLiteralExpression): { negative: false, base10Value: "0" } */ TODO)
	var resolutionTargets []TypeSystemEntity = /* TODO(ArrayLiteralExpression): [] */ TODO
	var resolutionResults []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
	var resolutionPropertyNames []TypeSystemPropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
	resolutionStart := 0
	inVarianceComputation := /* TODO(FalseKeyword): false */ TODO
	suggestionCount := 0
	maximumSuggestionCount := 10
	var mergedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
	var symbolLinks []SymbolLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
	var nodeLinks []NodeLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopCaches []Map[string, Type] = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopKeys []string = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopTypes [][]Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var sharedFlowNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
	var sharedFlowTypes []FlowType = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowNodeReachable [] /* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowNodePostSuper [] /* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialThisCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialNewTargetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialWeakMapSetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialReflectCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialUnusedRenamedBindingElementsInTypes []BindingElement = /* TODO(ArrayLiteralExpression): [] */ TODO
	var awaitedTypeStack []number = /* TODO(ArrayLiteralExpression): [] */ TODO
	var reverseMappedSourceStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var reverseMappedTargetStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	reverseExpandingFlags := /* TODO(PropertyAccessExpression): ExpandingFlags.None */ TODO
	diagnostics := createDiagnosticCollection()
	suggestionDiagnostics := createDiagnosticCollection()
	typeofType := createTypeofType()
	var _jsxNamespace __String
	var _jsxFactoryEntity *EntityName
	subtypeRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	strictSubtypeRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	assignableRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	comparableRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	identityRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	enumRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	var suggestedExtensions [] /* TODO(TupleType): [string, string] */ TODO = /* TODO(ArrayLiteralExpression): [         [".mts", ".mjs"],         [".ts", ".js"],         [".cts", ".cjs"],         [".mjs", ".mjs"],         [".js", ".js"],         [".cjs", ".cjs"],         [".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],         [".jsx", ".jsx"],         [".json", ".json"],     ] */ TODO
	initializeTypeChecker()
	return checker
	isDefinitelyReferenceToGlobalSymbolObject := func(node Node) bool {
		if !isPropertyAccessExpression(node) {
			/* TODO(FalseKeyword): false */
		}
		if !isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			/* TODO(FalseKeyword): false */
		}
		if !isPropertyAccessExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO) && !isIdentifier( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			/* TODO(FalseKeyword): false */
		}
		if isIdentifier( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			return idText( /* TODO(PropertyAccessExpression): node.expression */ TODO) == "Symbol" && getResolvedSymbol( /* TODO(PropertyAccessExpression): node.expression */ TODO) == /* TODO(ParenthesizedExpression): (getGlobalSymbol("Symbol" as __String, SymbolFlags.Value | SymbolFlags.ExportValue, /*diagnostic* / undefined) || unknownSymbol) */ TODO
		}
		if !isIdentifier( /* TODO(PropertyAccessExpression): node.expression.expression */ TODO) {
			/* TODO(FalseKeyword): false */
		}
		return idText( /* TODO(PropertyAccessExpression): node.expression.name */ TODO) == "Symbol" && idText( /* TODO(PropertyAccessExpression): node.expression.expression */ TODO) == "globalThis" && getResolvedSymbol( /* TODO(PropertyAccessExpression): node.expression.expression */ TODO) == globalThisSymbol
	}
	getCachedType := func(key /* TODO(StringKeyword): string */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): key ? cachedTypes.get(key) : undefined */ TODO
	}
	setCachedType := func(key /* TODO(StringKeyword): string */ any, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if key {
			/* TODO(CallExpression): cachedTypes.set(key, type) */
		}
		return type_
	}
	getJsxNamespace := func(location Node) __String {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if isJsxOpeningFragment(location) {
					if /* TODO(PropertyAccessExpression): file.localJsxFragmentNamespace */ TODO {
						return /* TODO(PropertyAccessExpression): file.localJsxFragmentNamespace */ TODO
					}
					jsxFragmentPragma := /* TODO(PropertyAccessExpression): file.pragmas.get */ TODO("jsxfrag")
					if jsxFragmentPragma {
						chosenPragma := /* TODO(ConditionalExpression): isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma */ TODO
						/* TODO(ExpressionStatement): file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion); */
						visitNode( /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO, markAsSynthetic, isEntityName)
						if /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO {
							return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText */ TODO
						}
					}
					entity := getJsxFragmentFactoryEntity(location)
					if entity {
						/* TODO(ExpressionStatement): file.localJsxFragmentFactory = entity; */
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText */ TODO
					}
				} else {
					localJsxNamespace := getLocalJsxNamespace(file)
					if localJsxNamespace {
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxNamespace = localJsxNamespace */ TODO
					}
				}
			}
		}
		if !_jsxNamespace {
			/* TODO(ExpressionStatement): _jsxNamespace = "React" as __String; */
			if /* TODO(PropertyAccessExpression): compilerOptions.jsxFactory */ TODO {
				/* TODO(ExpressionStatement): _jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion); */
				visitNode(_jsxFactoryEntity, markAsSynthetic)
				if _jsxFactoryEntity {
					/* TODO(ExpressionStatement): _jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText; */
				}
			} else if /* TODO(PropertyAccessExpression): compilerOptions.reactNamespace */ TODO {
				/* TODO(ExpressionStatement): _jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace); */
			}
		}
		if !_jsxFactoryEntity {
			/* TODO(ExpressionStatement): _jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement"); */
		}
		return _jsxNamespace
	}
	getLocalJsxNamespace := func(file SourceFile) *__String {
		if /* TODO(PropertyAccessExpression): file.localJsxNamespace */ TODO {
			return /* TODO(PropertyAccessExpression): file.localJsxNamespace */ TODO
		}
		jsxPragma := /* TODO(PropertyAccessExpression): file.pragmas.get */ TODO("jsx")
		if jsxPragma {
			chosenPragma := /* TODO(ConditionalExpression): isArray(jsxPragma) ? jsxPragma[0] : jsxPragma */ TODO
			/* TODO(ExpressionStatement): file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion); */
			visitNode( /* TODO(PropertyAccessExpression): file.localJsxFactory */ TODO, markAsSynthetic, isEntityName)
			if /* TODO(PropertyAccessExpression): file.localJsxFactory */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText */ TODO
			}
		}
	}
	markAsSynthetic := func(node T) VisitResult[T] {
		setTextRangePosEnd(node, -1, -1)
		return visitEachChildWorker(node, markAsSynthetic, nil)
	}
	getEmitResolver := func(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitResolver */ TODO {
		if !skipDiagnostics {
			/* TODO(CallExpression): getDiagnostics(sourceFile, cancellationToken) */
		}
		return emitResolver
	}
	lookupOrIssueError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
		existing := /* TODO(PropertyAccessExpression): diagnostics.lookup */ TODO(diagnostic)
		if existing {
			return existing
		} else {
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
			return diagnostic
		}
	}
	errorSkippedOn := func(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message /* TODO(SpreadElement): ...args */, TODO)
		/* TODO(ExpressionStatement): diagnostic.skippedOn = key; */
		return diagnostic
	}
	createError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		return /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
	}
	error := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := createError(location, message /* TODO(SpreadElement): ...args */, TODO)
		/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
		return diagnostic
	}
	addErrorOrSuggestion := func(isError bool, diagnostic Diagnostic) {
		if isError {
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
		} else {
			/* TODO(PropertyAccessExpression): suggestionDiagnostics.add */ TODO( /* TODO(ObjectLiteralExpression): { ...diagnostic, category: DiagnosticCategory.Suggestion } */ TODO)
		}
	}
	errorOrSuggestion := func(isError bool, location Node, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		if /* TODO(PropertyAccessExpression): location.pos */ TODO < 0 || /* TODO(PropertyAccessExpression): location.end */ TODO < 0 {
			if !isError {
				return
			}
			file := getSourceFileOfNode(location)
			addErrorOrSuggestion(isError /* TODO(ConditionalExpression): "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message) */, TODO)
			return
		}
		addErrorOrSuggestion(isError /* TODO(ConditionalExpression): "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message) */, TODO)
	}
	errorAndMaybeSuggestAwait := func(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message /* TODO(SpreadElement): ...args */, TODO)
		if maybeMissingAwait {
			related := createDiagnosticForNode(location /* TODO(PropertyAccessExpression): Diagnostics.Did_you_forget_to_use_await */, TODO)
			addRelatedInfo(diagnostic, related)
		}
		return diagnostic
	}
	addDeprecatedSuggestionWorker := func(declarations /* TODO(UnionType): Node | Node[] */ any, diagnostic DiagnosticWithLocation) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		deprecatedTag := /* TODO(ConditionalExpression): Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations) */ TODO
		if deprecatedTag {
			addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag /* TODO(PropertyAccessExpression): Diagnostics.The_declaration_was_marked_as_deprecated_here */, TODO))
		}
		/* TODO(PropertyAccessExpression): suggestionDiagnostics.add */ TODO(diagnostic)
		return diagnostic
	}
	isDeprecatedSymbol := func(symbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
		parentSymbol := getParentOfSymbol(symbol)
		if parentSymbol && length( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO) > 1 {
			return /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Interface ? some(symbol.declarations, isDeprecatedDeclaration) : every(symbol.declarations, isDeprecatedDeclaration) */ TODO
		}
		return !! /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isDeprecatedDeclaration( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) || length( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO) && every( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isDeprecatedDeclaration)
	}
	isDeprecatedDeclaration := func(declaration Declaration) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getCombinedNodeFlagsCached(declaration) & NodeFlags.Deprecated) */ TODO
	}
	addDeprecatedSuggestion := func(location Node, declarations []Node, deprecatedEntity string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		diagnostic := createDiagnosticForNode(location /* TODO(PropertyAccessExpression): Diagnostics._0_is_deprecated */, TODO, deprecatedEntity)
		return addDeprecatedSuggestionWorker(declarations, diagnostic)
	}
	addDeprecatedSuggestionWithSignature := func(location Node, declaration Node, deprecatedEntity /* TODO(StringKeyword): string */ any, signatureString string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		diagnostic := /* TODO(ConditionalExpression): deprecatedEntity             ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)             : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString) */ TODO
		return addDeprecatedSuggestionWorker(declaration, diagnostic)
	}
	createSymbol := func(flags SymbolFlags, name __String, checkFlags CheckFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		/* TODO(ExpressionStatement): symbolCount++; */
		symbol := /* TODO(NewExpression): new Symbol(flags | SymbolFlags.Transient, name) */ TODO /* as */ /* TODO(TypeReference): TransientSymbol */
		/* TODO(ExpressionStatement): symbol.links = new SymbolLinks() as TransientSymbolLinks; */
		/* TODO(ExpressionStatement): symbol.links.checkFlags = checkFlags || CheckFlags.None; */
		return symbol
	}
	createParameter := func(name __String, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, name)
		/* TODO(ExpressionStatement): symbol.links.type = type; */
		return symbol
	}
	createProperty := func(name __String, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, name)
		/* TODO(ExpressionStatement): symbol.links.type = type; */
		return symbol
	}
	getExcludedSymbolFlags := func(flags SymbolFlags) SymbolFlags {
		var result SymbolFlags = 0
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.BlockScopedVariable */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.BlockScopedVariableExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.FunctionScopedVariable */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.FunctionScopedVariableExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.Property */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.PropertyExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.EnumMember */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.EnumMemberExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.Function */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.FunctionExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.Class */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.ClassExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.Interface */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.InterfaceExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.RegularEnum */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.RegularEnumExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.ConstEnum */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.ConstEnumExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.ValueModule */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.ValueModuleExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.Method */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.MethodExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.GetAccessor */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.GetAccessorExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.SetAccessor */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.SetAccessorExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.TypeParameter */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.TypeParameterExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.TypeAlias */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.TypeAliasExcludes */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFlags.Alias */ TODO {
			/* TODO(BinaryExpression): result |= SymbolFlags.AliasExcludes */
		}
		return result
	}
	recordMergedSymbol := func(target Symbol, source Symbol) {
		if ! /* TODO(PropertyAccessExpression): source.mergeId */ TODO {
			/* TODO(ExpressionStatement): source.mergeId = nextMergeId; */
			/* TODO(ExpressionStatement): nextMergeId++; */
		}
		/* TODO(ExpressionStatement): mergedSymbols[source.mergeId] = target; */
	}
	cloneSymbol := func(symbol Symbol) TransientSymbol {
		result := createSymbol( /* TODO(PropertyAccessExpression): symbol.flags */ TODO /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO)
		/* TODO(ExpressionStatement): result.declarations = symbol.declarations ? symbol.declarations.slice() : []; */
		/* TODO(ExpressionStatement): result.parent = symbol.parent; */
		if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
			/* TODO(BinaryExpression): result.valueDeclaration = symbol.valueDeclaration */
		}
		if /* TODO(PropertyAccessExpression): symbol.constEnumOnlyModule */ TODO {
			/* TODO(BinaryExpression): result.constEnumOnlyModule = true */
		}
		if /* TODO(PropertyAccessExpression): symbol.members */ TODO {
			/* TODO(BinaryExpression): result.members = new Map(symbol.members) */
		}
		if /* TODO(PropertyAccessExpression): symbol.exports */ TODO {
			/* TODO(BinaryExpression): result.exports = new Map(symbol.exports) */
		}
		recordMergedSymbol(result, symbol)
		return result
	}
	mergeSymbol := func(target Symbol, source Symbol, unidirectional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Symbol {
		if ! /* TODO(ParenthesizedExpression): (target.flags & getExcludedSymbolFlags(source.flags)) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (source.flags | target.flags) & SymbolFlags.Assignment */ TODO {
			if source == target {
				return target
			}
			if ! /* TODO(ParenthesizedExpression): (target.flags & SymbolFlags.Transient) */ TODO {
				resolvedTarget := resolveSymbol(target)
				if resolvedTarget == unknownSymbol {
					return source
				}
				if ! /* TODO(ParenthesizedExpression): (resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (source.flags | resolvedTarget.flags) & SymbolFlags.Assignment */ TODO {
					/* TODO(ExpressionStatement): target = cloneSymbol(resolvedTarget); */
				} else {
					reportMergeSymbolError(target, source)
					return source
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & SymbolFlags.ValueModule */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & SymbolFlags.ValueModule */ TODO && /* TODO(PropertyAccessExpression): target.constEnumOnlyModule */ TODO && ! /* TODO(PropertyAccessExpression): source.constEnumOnlyModule */ TODO {
				/* TODO(ExpressionStatement): target.constEnumOnlyModule = false; */
			}
			/* TODO(ExpressionStatement): target.flags |= source.flags; */
			if /* TODO(PropertyAccessExpression): source.valueDeclaration */ TODO {
				setValueDeclaration(target /* TODO(PropertyAccessExpression): source.valueDeclaration */, TODO)
			}
			addRange( /* TODO(PropertyAccessExpression): target.declarations */ TODO /* TODO(PropertyAccessExpression): source.declarations */, TODO)
			if /* TODO(PropertyAccessExpression): source.members */ TODO {
				if ! /* TODO(PropertyAccessExpression): target.members */ TODO {
					/* TODO(BinaryExpression): target.members = createSymbolTable() */
				}
				mergeSymbolTable( /* TODO(PropertyAccessExpression): target.members */ TODO /* TODO(PropertyAccessExpression): source.members */, TODO, unidirectional)
			}
			if /* TODO(PropertyAccessExpression): source.exports */ TODO {
				if ! /* TODO(PropertyAccessExpression): target.exports */ TODO {
					/* TODO(BinaryExpression): target.exports = createSymbolTable() */
				}
				mergeSymbolTable( /* TODO(PropertyAccessExpression): target.exports */ TODO /* TODO(PropertyAccessExpression): source.exports */, TODO, unidirectional, target)
			}
			if !unidirectional {
				recordMergedSymbol(target, source)
			}
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & SymbolFlags.NamespaceModule */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== globalThisSymbol */ TODO {
				error( /* TODO(PropertyAccessExpression): source.declarations */ TODO && getNameOfDeclaration( /* TODO(ElementAccessExpression): source.declarations[0] */ TODO) /* TODO(PropertyAccessExpression): Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity */, TODO, symbolToString(target))
			}
		} else {
			reportMergeSymbolError(target, source)
		}
		return target
		reportMergeSymbolError := func(target Symbol, source Symbol) {
			isEitherEnum := !! /* TODO(ParenthesizedExpression): (target.flags & SymbolFlags.Enum || source.flags & SymbolFlags.Enum) */ TODO
			isEitherBlockScoped := !! /* TODO(ParenthesizedExpression): (target.flags & SymbolFlags.BlockScopedVariable || source.flags & SymbolFlags.BlockScopedVariable) */ TODO
			message := /* TODO(ConditionalExpression): isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations                 : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0                 : Diagnostics.Duplicate_identifier_0 */ TODO
			sourceSymbolFile := /* TODO(PropertyAccessExpression): source.declarations */ TODO && getSourceFileOfNode( /* TODO(ElementAccessExpression): source.declarations[0] */ TODO)
			targetSymbolFile := /* TODO(PropertyAccessExpression): target.declarations */ TODO && getSourceFileOfNode( /* TODO(ElementAccessExpression): target.declarations[0] */ TODO)
			isSourcePlainJs := isPlainJsFile(sourceSymbolFile /* TODO(PropertyAccessExpression): compilerOptions.checkJs */, TODO)
			isTargetPlainJs := isPlainJsFile(targetSymbolFile /* TODO(PropertyAccessExpression): compilerOptions.checkJs */, TODO)
			symbolName := symbolToString(source)
			if sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSymbolFile !== targetSymbolFile */ TODO {
				firstFile := /* TODO(ConditionalExpression): comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile */ TODO
				secondFile := /* TODO(ConditionalExpression): firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile */ TODO
				filesDuplicates := getOrUpdate(amalgamatedDuplicates /* TODO(TemplateExpression): `${firstFile.path}|${secondFile.path}` */, TODO /* TODO(ArrowFunction): (): DuplicateInfoForFiles => ({ firstFile, secondFile, conflictingSymbols: new Map() }) */, TODO)
				conflictingSymbolInfo := getOrUpdate( /* TODO(PropertyAccessExpression): filesDuplicates.conflictingSymbols */ TODO, symbolName /* TODO(ArrowFunction): (): DuplicateInfoForSymbol => ({ isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] }) */, TODO)
				if !isSourcePlainJs {
					/* TODO(CallExpression): addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source) */
				}
				if !isTargetPlainJs {
					/* TODO(CallExpression): addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target) */
				}
			} else {
				if !isSourcePlainJs {
					/* TODO(CallExpression): addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target) */
				}
				if !isTargetPlainJs {
					/* TODO(CallExpression): addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source) */
				}
			}
		}
		addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
			if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
				for _, decl := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
					pushIfUnique(locs, decl)
				}
			}
		}
	}
	addDuplicateDeclarationErrorsForSymbols := func(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
		forEach( /* TODO(PropertyAccessExpression): target.declarations */ TODO /* TODO(ArrowFunction): node => {             addDuplicateDeclarationError(node, message, symbolName, source.declarations);         } */, TODO)
	}
	addDuplicateDeclarationError := func(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes /* TODO(TypeOperator): readonly Declaration[] */ any) {
		errorNode := /* TODO(ParenthesizedExpression): (getExpandoInitializer(node, /*isPrototypeAssignment* / false) ? getNameOfExpando(node) : getNameOfDeclaration(node)) */ TODO || node
		err := lookupOrIssueError(errorNode, message, symbolName)
		for _, relatedNode := range relatedNodes || emptyArray {
			adjustedNode := /* TODO(ParenthesizedExpression): (getExpandoInitializer(relatedNode, /*isPrototypeAssignment* / false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode)) */ TODO || relatedNode
			if adjustedNode == errorNode {
			}
			/* TODO(ExpressionStatement): err.relatedInformation = err.relatedInformation || []; */
			leadingMessage := createDiagnosticForNode(adjustedNode /* TODO(PropertyAccessExpression): Diagnostics._0_was_also_declared_here */, TODO, symbolName)
			followOnMessage := createDiagnosticForNode(adjustedNode /* TODO(PropertyAccessExpression): Diagnostics.and_here */, TODO)
			if length( /* TODO(PropertyAccessExpression): err.relatedInformation */ TODO) >= 5 || some( /* TODO(PropertyAccessExpression): err.relatedInformation */ TODO /* TODO(ArrowFunction): r => compareDiagnostics(r, followOnMessage) === Comparison.EqualTo || compareDiagnostics(r, leadingMessage) === Comparison.EqualTo */, TODO) {
			}
			addRelatedInfo(err /* TODO(ConditionalExpression): !length(err.relatedInformation) ? leadingMessage : followOnMessage */, TODO)
		}
	}
	combineSymbolTables := func(first *SymbolTable, second *SymbolTable) *SymbolTable {
		if ! /* TODO(PropertyAccessExpression): first?.size */ TODO {
			/* TODO(Identifier): second */
		}
		if ! /* TODO(PropertyAccessExpression): second?.size */ TODO {
			/* TODO(Identifier): first */
		}
		combined := createSymbolTable()
		mergeSymbolTable(combined, first)
		mergeSymbolTable(combined, second)
		return combined
	}
	mergeSymbolTable := func(target SymbolTable, source SymbolTable, unidirectional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, mergedParent Symbol) {
		/* TODO(PropertyAccessExpression): source.forEach */ TODO( /* TODO(ArrowFunction): (sourceSymbol, id) => {             const targetSymbol = target.get(id);             const merged = targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol);             if (mergedParent && targetSymbol) {                 // If a merge was performed on the target symbol, set its parent to the merged parent that initiated the merge                 // of its exports. Otherwise, `merged` came only from `sourceSymbol` and can keep its parent:                 //                 // // a.ts                 // export interface A { x: number; }                 //                 // // b.ts                 // declare module "./a" {                 //   interface A { y: number; }                 //   interface B {}                 // }                 //                 // When merging the module augmentation into a.ts, the symbol for `A` will itself be merged, so its parent                 // should be the merged module symbol. But the symbol for `B` has only one declaration, so its parent should                 // be the module augmentation symbol, which contains its only declaration.                 merged.parent = mergedParent;             }             target.set(id, merged);         } */ TODO)
	}
	mergeModuleAugmentation := func(moduleName /* TODO(UnionType): StringLiteral | Identifier */ any) {
		moduleAugmentation := /* TODO(PropertyAccessExpression): moduleName.parent */ TODO /* as */ /* TODO(TypeReference): ModuleDeclaration */
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleAugmentation.symbol.declarations?.[0] !== moduleAugmentation */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): moduleAugmentation.symbol.declarations!.length */ TODO > 1)
			return
		}
		if isGlobalScopeAugmentation(moduleAugmentation) {
			mergeSymbolTable(globals /* TODO(NonNullExpression): moduleAugmentation.symbol.exports! */, TODO)
		} else {
			moduleNotFoundError := /* TODO(ConditionalExpression): !(moduleName.parent.parent.flags & NodeFlags.Ambient)                 ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found                 : undefined */ TODO
			mainModule := resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
			if !mainModule {
				return
			}
			/* TODO(ExpressionStatement): mainModule = resolveExternalModuleSymbol(mainModule); */
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): mainModule.flags & SymbolFlags.Namespace */ TODO {
				if some(patternAmbientModules /* TODO(ArrowFunction): module => mainModule === module.symbol */, TODO) {
					merged := mergeSymbol( /* TODO(PropertyAccessExpression): moduleAugmentation.symbol */ TODO, mainModule /* TODO(TrueKeyword): true */, TODO)
					if !patternAmbientModuleAugmentations {
						/* TODO(ExpressionStatement): patternAmbientModuleAugmentations = new Map(); */
					}
					/* TODO(PropertyAccessExpression): patternAmbientModuleAugmentations.set */ TODO( /* TODO(PropertyAccessExpression): (moduleName as StringLiteral).text */ TODO, merged)
				} else {
					if /* TODO(PropertyAccessExpression): mainModule.exports?.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportStar */ TODO) && /* TODO(PropertyAccessExpression): moduleAugmentation.symbol.exports?.size */ TODO {
						resolvedExports := getResolvedMembersOrExportsOfSymbol(mainModule /* TODO(PropertyAccessExpression): MembersOrExportsResolutionKind.resolvedExports */, TODO)
						for _, TODO_IDENTIFIER := range arrayFrom( /* TODO(PropertyAccessExpression): moduleAugmentation.symbol.exports.entries */ TODO()) {
							if /* TODO(PropertyAccessExpression): resolvedExports.has */ TODO(key) && ! /* TODO(PropertyAccessExpression): mainModule.exports.has */ TODO(key) {
								mergeSymbol( /* TODO(NonNullExpression): resolvedExports.get(key)! */ TODO, value)
							}
						}
					}
					mergeSymbol(mainModule /* TODO(PropertyAccessExpression): moduleAugmentation.symbol */, TODO)
				}
			} else {
				error(moduleName /* TODO(PropertyAccessExpression): Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity */, TODO /* TODO(PropertyAccessExpression): (moduleName as StringLiteral).text */, TODO)
			}
		}
	}
	addUndefinedToGlobalsOrErrorOnRedeclaration := func() {
		name := /* TODO(PropertyAccessExpression): undefinedSymbol.escapedName */ TODO
		targetSymbol := /* TODO(PropertyAccessExpression): globals.get */ TODO(name)
		if targetSymbol {
			forEach( /* TODO(PropertyAccessExpression): targetSymbol.declarations */ TODO /* TODO(ArrowFunction): declaration => {                 // checkTypeNameIsReserved will have added better diagnostics for type declarations.                 if (!isTypeDeclaration(declaration)) {                     diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)));                 }             } */, TODO)
		} else {
			/* TODO(PropertyAccessExpression): globals.set */ TODO(name, undefinedSymbol)
		}
	}
	getSymbolLinks := func(symbol Symbol) SymbolLinks {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Transient */ TODO {
			/* TODO(PropertyAccessExpression): (symbol as TransientSymbol).links */
		}
		id := getSymbolId(symbol)
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): symbolLinks[id] ??= new SymbolLinks() */ TODO
	}
	getNodeLinks := func(node Node) NodeLinks {
		nodeId := getNodeId(node)
		return /* TODO(ElementAccessExpression): nodeLinks[nodeId] */ TODO || /* TODO(ParenthesizedExpression): (nodeLinks[nodeId] = new (NodeLinks as any)()) */ TODO
	}
	getSymbol := func(symbols SymbolTable, name __String, meaning SymbolFlags) *Symbol {
		if meaning {
			symbol := getMergedSymbol( /* TODO(PropertyAccessExpression): symbols.get */ TODO(name))
			if symbol {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & meaning */ TODO {
					return symbol
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
					targetFlags := getSymbolFlags(symbol)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & meaning */ TODO {
						return symbol
					}
				}
			}
		}
	}
	getSymbolsOfParameterPropertyDeclaration := func(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TupleType): [Symbol, Symbol] */ TODO {
		constructorDeclaration := /* TODO(PropertyAccessExpression): parameter.parent */ TODO
		classDeclaration := /* TODO(PropertyAccessExpression): parameter.parent.parent */ TODO
		parameterSymbol := getSymbol( /* TODO(NonNullExpression): constructorDeclaration.locals! */ TODO, parameterName /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
		propertySymbol := getSymbol(getMembersOfSymbol( /* TODO(PropertyAccessExpression): classDeclaration.symbol */ TODO), parameterName /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
		if parameterSymbol && propertySymbol {
			return /* TODO(ArrayLiteralExpression): [parameterSymbol, propertySymbol] */ TODO
		}
		return /* TODO(PropertyAccessExpression): Debug.fail */ TODO("There should exist two symbols, one as property declaration and one as parameter declaration")
	}
	isBlockScopedNameDeclaredBeforeUse := func(declaration Declaration, usage Node) bool {
		declarationFile := getSourceFileOfNode(declaration)
		useFile := getSourceFileOfNode(usage)
		declContainer := getEnclosingBlockScopeContainer(declaration)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declarationFile !== useFile */ TODO {
			if /* TODO(ParenthesizedExpression): (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) */ TODO || /* TODO(ParenthesizedExpression): (!compilerOptions.outFile) */ TODO || isInTypeQuery(usage) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declaration.flags & NodeFlags.Ambient */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if isUsedInFunctionOrInstanceProperty(usage, declaration) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			sourceFiles := /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO()
			return /* TODO(PropertyAccessExpression): sourceFiles.indexOf */ TODO(declarationFile) <= /* TODO(PropertyAccessExpression): sourceFiles.indexOf */ TODO(useFile)
		}
		if !! /* TODO(ParenthesizedExpression): (usage.flags & NodeFlags.JSDoc) */ TODO || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(PropertyAccessExpression): declaration.pos */ TODO <= /* TODO(PropertyAccessExpression): usage.pos */ TODO && ! /* TODO(ParenthesizedExpression): (isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) */ TODO {
			if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO {
				errorBindingElement := getAncestor(usage /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */, TODO) /* as */ /* TODO(TypeReference): BindingElement */
				if errorBindingElement {
					return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): findAncestor(errorBindingElement, isBindingElement) !== findAncestor(declaration, isBindingElement) */ TODO || /* TODO(PropertyAccessExpression): declaration.pos */ TODO < /* TODO(PropertyAccessExpression): errorBindingElement.pos */ TODO
				}
				return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */, TODO) /* as */ /* TODO(TypeReference): Declaration */, usage)
			} else if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO {
				return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration /* as */ /* TODO(TypeReference): VariableDeclaration */, usage)
			} else if isClassLike(declaration) {
				container := findAncestor(usage /* TODO(ArrowFunction): n =>                     n === declaration ? "quit" :                         isComputedPropertyName(n) ? n.parent.parent === declaration :                         !legacyDecorators && isDecorator(n) && (n.parent === declaration ||                             isMethodDeclaration(n.parent) && n.parent.parent === declaration ||                             isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration ||                             isPropertyDeclaration(n.parent) && n.parent.parent === declaration ||                             isParameter(n.parent) && n.parent.parent.parent === declaration) */, TODO)
				if !container {
					return /* TODO(TrueKeyword): true */ TODO
				}
				if !legacyDecorators && isDecorator(container) {
					return !!findAncestor(usage /* TODO(ArrowFunction): n => n === container ? "quit" : isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n) */, TODO)
				}
				return /* TODO(FalseKeyword): false */ TODO
			} else if isPropertyDeclaration(declaration) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage /* TODO(FalseKeyword): false */, TODO)
			} else if isParameterPropertyDeclaration(declaration /* TODO(PropertyAccessExpression): declaration.parent */, TODO) {
				return ! /* TODO(ParenthesizedExpression): (emitStandardClassFields                     && getContainingClass(declaration) === getContainingClass(usage)                     && isUsedInFunctionOrInstanceProperty(usage, declaration)) */ TODO
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(PropertyAccessExpression): usage.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportSpecifier */ TODO || /* TODO(ParenthesizedExpression): (usage.parent.kind === SyntaxKind.ExportAssignment && (usage.parent as ExportAssignment).isExportEquals) */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(PropertyAccessExpression): usage.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO && /* TODO(PropertyAccessExpression): (usage as ExportAssignment).isExportEquals */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if isUsedInFunctionOrInstanceProperty(usage, declaration) {
			if emitStandardClassFields && getContainingClass(declaration) && /* TODO(ParenthesizedExpression): (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) */ TODO {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage /* TODO(TrueKeyword): true */, TODO)
			} else {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
		isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
			/* TODO(SwitchStatement): switch (declaration.parent.parent.kind) {                 case SyntaxKind.VariableStatement:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForOfStatement:                     // variable statement/for/for-of statement case,                     // use site should not be inside variable declaration (initializer of declaration or binding element)                     if (isSameScopeDescendentOf(usage, declaration, declContainer)) {                         return true;                     }                     break;             } */
			grandparent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
			return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage /* TODO(PropertyAccessExpression): grandparent.expression */, TODO, declContainer)
		}
		isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
			return !!findAncestor(usage /* TODO(ArrowFunction): current => {                 if (current === declContainer) {                     return "quit";                 }                 if (isFunctionLike(current)) {                     return true;                 }                 if (isClassStaticBlockDeclaration(current)) {                     return declaration.pos < usage.pos;                 }                  const propertyDeclaration = tryCast(current.parent, isPropertyDeclaration);                 if (propertyDeclaration) {                     const initializerOfProperty = propertyDeclaration.initializer === current;                     if (initializerOfProperty) {                         if (isStatic(current.parent)) {                             if (declaration.kind === SyntaxKind.MethodDeclaration) {                                 return true;                             }                             if (isPropertyDeclaration(declaration) && getContainingClass(usage) === getContainingClass(declaration)) {                                 const propName = declaration.name;                                 if (isIdentifier(propName) || isPrivateIdentifier(propName)) {                                     const type = getTypeOfSymbol(getSymbolOfDeclaration(declaration));                                     const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);                                     if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration.parent.pos, current.pos)) {                                         return true;                                     }                                 }                             }                         }                         else {                             const isDeclarationInstanceProperty = declaration.kind === SyntaxKind.PropertyDeclaration && !isStatic(declaration);                             if (!isDeclarationInstanceProperty || getContainingClass(usage) !== getContainingClass(declaration)) {                                 return true;                             }                         }                     }                 }                 return false;             } */, TODO)
		}
		isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(UnionType): PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) /* TODO(undefined): boolean */ TODO {
			if /* TODO(PropertyAccessExpression): usage.end */ TODO > /* TODO(PropertyAccessExpression): declaration.end */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
			ancestorChangingReferenceScope := findAncestor(usage /* TODO(ArrowFunction): (node: Node) => {                 if (node === declaration) {                     return "quit";                 }                  switch (node.kind) {                     case SyntaxKind.ArrowFunction:                         return true;                     case SyntaxKind.PropertyDeclaration:                         // even when stopping at any property declaration, they need to come from the same class                         return stopAtAnyPropertyDeclaration &&                                 (isPropertyDeclaration(declaration) && node.parent === declaration.parent                                     || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)                             ? "quit" : true;                     case SyntaxKind.Block:                         switch (node.parent.kind) {                             case SyntaxKind.GetAccessor:                             case SyntaxKind.MethodDeclaration:                             case SyntaxKind.SetAccessor:                                 return true;                             default:                                 return false;                         }                     default:                         return false;                 }             } */, TODO)
			return ancestorChangingReferenceScope == nil
		}
	}
	getRequiresScopeChangeCache := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		return /* TODO(PropertyAccessExpression): getNodeLinks(node).declarationRequiresScopeChange */ TODO
	}
	setRequiresScopeChangeCache := func(node FunctionLikeDeclaration, value bool) {
		/* TODO(ExpressionStatement): getNodeLinks(node).declarationRequiresScopeChange = value; */
	}
	checkAndReportErrorForInvalidInitializer := func(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result *Symbol) /* TODO(undefined): boolean */ TODO {
		if !emitStandardClassFields {
			if errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			error(errorLocation /* TODO(ConditionalExpression): errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos)                     ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor                     : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): propertyWithInvalidInitializer.name */ TODO), diagnosticName(name))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	onFailedToResolveSymbol := func(errorLocation Node, nameArg /* TODO(UnionType): __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
		name := /* TODO(ConditionalExpression): isString(nameArg) ? nameArg : (nameArg as Identifier).escapedText */ TODO
		addLazyDiagnostic( /* TODO(ArrowFunction): () => {             if (                 !errorLocation ||                 errorLocation.parent.kind !== SyntaxKind.JSDocLink &&                     !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) &&                     !checkAndReportErrorForExtendingInterface(errorLocation) &&                     !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) &&                     !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) &&                     !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) &&                     !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) &&                     !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)             ) {                 let suggestion: Symbol | undefined;                 let suggestedLib: string | undefined;                 // Report missing lib first                 if (nameArg) {                     suggestedLib = getSuggestedLibForNonExistentName(nameArg);                     if (suggestedLib) {                         error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib);                     }                 }                 // then spelling suggestions                 if (!suggestedLib && suggestionCount < maximumSuggestionCount) {                     suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning);                     const isGlobalScopeAugmentationDeclaration = suggestion?.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration);                     if (isGlobalScopeAugmentationDeclaration) {                         suggestion = undefined;                     }                     if (suggestion) {                         const suggestionName = symbolToString(suggestion);                         const isUncheckedJS = isUncheckedJSSuggestion(errorLocation, suggestion, /*excludeClasses* / false);                         const message = meaning === SymbolFlags.Namespace ||                                 nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ?                             Diagnostics.Cannot_find_namespace_0_Did_you_mean_1                             : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1                             : Diagnostics.Cannot_find_name_0_Did_you_mean_1;                         const diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);                         diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg));                         addErrorOrSuggestion(!isUncheckedJS, diagnostic);                         if (suggestion.valueDeclaration) {                             addRelatedInfo(                                 diagnostic,                                 createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName),                             );                         }                     }                 }                 // And then fall back to unspecified "not found"                 if (!suggestion && !suggestedLib && nameArg) {                     error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));                 }                 suggestionCount++;             }         } */ TODO)
	}
	onSuccessfullyResolvedSymbol := func(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(UnionType): ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
		addLazyDiagnostic( /* TODO(ArrowFunction): () => {             const name = result.escapedName;             const isInExternalModule = lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation);             // Only check for block-scoped variable if we have an error location and are looking for the             // name with variable meaning             //      For example,             //          declare module foo {             //              interface bar {}             //          }             //      const foo/*1* /: foo/*2* /.bar;             // The foo at /*1* / and /*2* / will share same symbol with two meanings:             // block-scoped variable and namespace module. However, only when we             // try to resolve name in /*1* / which is used in variable position,             // we want to check for block-scoped             if (                 errorLocation &&                 (meaning & SymbolFlags.BlockScopedVariable ||                     ((meaning & SymbolFlags.Class || meaning & SymbolFlags.Enum) && (meaning & SymbolFlags.Value) === SymbolFlags.Value))             ) {                 const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);                 if (exportOrLocalSymbol.flags & SymbolFlags.BlockScopedVariable || exportOrLocalSymbol.flags & SymbolFlags.Class || exportOrLocalSymbol.flags & SymbolFlags.Enum) {                     checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);                 }             }              // If we're in an external module, we can't reference value symbols created from UMD export declarations             if (isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value && !(errorLocation!.flags & NodeFlags.JSDoc)) {                 const merged = getMergedSymbol(result);                 if (length(merged.declarations) && every(merged.declarations, d => isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports)) {                     errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation!, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name));                 }             }              // If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right             if (associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {                 const candidate = getMergedSymbol(getLateBoundSymbol(result));                 const root = getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) as ParameterDeclaration;                 // A parameter initializer or binding pattern initializer within a parameter cannot refer to itself                 if (candidate === getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName)) {                     error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));                 }                 // And it cannot refer to any declarations which come after it                 else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) === candidate) {                     error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation as Identifier));                 }             }             if (errorLocation && meaning & SymbolFlags.Value && result.flags & SymbolFlags.Alias && !(result.flags & SymbolFlags.Value) && !isValidTypeOnlyAliasUseSite(errorLocation)) {                 const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(result, SymbolFlags.Value);                 if (typeOnlyDeclaration) {                     const message = typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                         ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type                         : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;                     const unescapedName = unescapeLeadingUnderscores(name);                     addTypeOnlyDeclarationRelatedInfo(                         error(errorLocation, message, unescapedName),                         typeOnlyDeclaration,                         unescapedName,                     );                 }             }              // Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')             // here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.             if (compilerOptions.isolatedModules && result && isInExternalModule && (meaning & SymbolFlags.Value) === SymbolFlags.Value) {                 const isGlobal = getSymbol(globals, name, meaning) === result;                 const nonValueSymbol = isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlags.Value);                 if (nonValueSymbol) {                     const importDecl = nonValueSymbol.declarations?.find(d => d.kind === SyntaxKind.ImportSpecifier || d.kind === SyntaxKind.ImportClause || d.kind === SyntaxKind.NamespaceImport || d.kind === SyntaxKind.ImportEqualsDeclaration);                     if (importDecl && !isTypeOnlyImportDeclaration(importDecl)) {                         error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name));                     }                 }             }         } */ TODO)
	}
	addTypeOnlyDeclarationRelatedInfo := func(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
		if !typeOnlyDeclaration {
			/* TODO(Identifier): diagnostic */
		}
		return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                     ? Diagnostics._0_was_exported_here                     : Diagnostics._0_was_imported_here */, TODO, unescapedName))
	}
	diagnosticName := func(nameArg /* TODO(UnionType): __String | Identifier | PrivateIdentifier */ any) /* TODO(undefined): string */ TODO {
		return /* TODO(ConditionalExpression): isString(nameArg) ? unescapeLeadingUnderscores(nameArg as __String) : declarationNameToString(nameArg as Identifier) */ TODO
	}
	checkAndReportErrorForMissingPrefix := func(errorLocation Node, name __String, nameArg /* TODO(UnionType): __String | Identifier */ any) bool {
		if !isIdentifier(errorLocation) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorLocation.escapedText !== name */ TODO || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		container := getThisContainer(errorLocation /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		var location Node = container
		/* TODO(WhileStatement): while (location) {             if (isClassLike(location.parent)) {                 const classSymbol = getSymbolOfDeclaration(location.parent);                 if (!classSymbol) {                     break;                 }                  // Check to see if a static member exists.                 const constructorType = getTypeOfSymbol(classSymbol);                 if (getPropertyOfType(constructorType, name)) {                     error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));                     return true;                 }                  // No static member is present.                 // Check if we're in an instance method and look for a relevant instance member.                 if (location === container && !isStatic(location)) {                     const instanceType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType!; // TODO: GH#18217                     if (getPropertyOfType(instanceType, name)) {                         error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));                         return true;                     }                 }             }              location = location.parent;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkAndReportErrorForExtendingInterface := func(errorLocation Node) bool {
		expression := getEntityNameForExtendingInterface(errorLocation)
		if expression && resolveEntityName(expression /* TODO(PropertyAccessExpression): SymbolFlags.Interface */, TODO /* TODO(TrueKeyword): true */, TODO) {
			error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements */, TODO, getTextOfNode(expression))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getEntityNameForExtendingInterface := func(node Node) *EntityNameExpression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.PropertyAccessExpression:                 return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;             case SyntaxKind.ExpressionWithTypeArguments:                 if (isEntityNameExpression((node as ExpressionWithTypeArguments).expression)) {                     return (node as ExpressionWithTypeArguments).expression as EntityNameExpression;                 }                 // falls through             default:                 return undefined;         } */
	}
	checkAndReportErrorForUsingTypeAsNamespace := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		namespaceMeaning := /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Namespace | (isInJSFile(errorLocation) ? SymbolFlags.Value : 0) */ TODO
		if meaning == namespaceMeaning {
			symbol := resolveSymbol(resolveName(errorLocation, name /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): SymbolFlags.Type & ~namespaceMeaning */, TODO, nil /* TODO(FalseKeyword): false */, TODO))
			parent := /* TODO(PropertyAccessExpression): errorLocation.parent */ TODO
			if symbol {
				if isQualifiedName(parent) {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): parent.left */ TODO == errorLocation, "Should only be resolving left side of qualified name as a namespace")
					propName := /* TODO(PropertyAccessExpression): parent.right.escapedText */ TODO
					propType := getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName)
					if propType {
						error(parent /* TODO(PropertyAccessExpression): Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1 */, TODO, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName))
						return /* TODO(TrueKeyword): true */ TODO
					}
				}
				error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here */, TODO, unescapeLeadingUnderscores(name))
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkAndReportErrorForUsingValueAsType := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & (SymbolFlags.Type & ~SymbolFlags.Namespace) */ TODO {
			symbol := resolveSymbol(resolveName(errorLocation, name /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): ~SymbolFlags.Type & SymbolFlags.Value */, TODO, nil /* TODO(FalseKeyword): false */, TODO))
			if symbol && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Namespace) */ TODO {
				error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0 */, TODO, unescapeLeadingUnderscores(name))
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isPrimitiveTypeName := func(name __String) /* TODO(undefined): boolean */ TODO {
		return name == "any" || name == "string" || name == "number" || name == "boolean" || name == "never" || name == "unknown"
	}
	checkAndReportErrorForExportingPrimitiveType := func(errorLocation Node, name __String) bool {
		if isPrimitiveTypeName(name) && /* TODO(PropertyAccessExpression): errorLocation.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportSpecifier */ TODO {
			error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module */, TODO, name /* as */ /* TODO(StringKeyword): string */)
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkAndReportErrorForUsingTypeAsValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & SymbolFlags.Value */ TODO {
			if isPrimitiveTypeName(name) {
				grandparent := /* TODO(PropertyAccessExpression): errorLocation.parent.parent */ TODO
				if grandparent && /* TODO(PropertyAccessExpression): grandparent.parent */ TODO && isHeritageClause(grandparent) {
					heritageKind := /* TODO(PropertyAccessExpression): grandparent.token */ TODO
					containerKind := /* TODO(PropertyAccessExpression): grandparent.parent.kind */ TODO
					if containerKind == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO && heritageKind == /* TODO(PropertyAccessExpression): SyntaxKind.ExtendsKeyword */ TODO {
						error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types */, TODO, unescapeLeadingUnderscores(name))
					} else if containerKind == /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */ TODO && heritageKind == /* TODO(PropertyAccessExpression): SyntaxKind.ExtendsKeyword */ TODO {
						error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values */, TODO, unescapeLeadingUnderscores(name))
					} else if containerKind == /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */ TODO && heritageKind == /* TODO(PropertyAccessExpression): SyntaxKind.ImplementsKeyword */ TODO {
						error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types */, TODO, unescapeLeadingUnderscores(name))
					}
				} else {
					error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here */, TODO, unescapeLeadingUnderscores(name))
				}
				return /* TODO(TrueKeyword): true */ TODO
			}
			symbol := resolveSymbol(resolveName(errorLocation, name /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): SymbolFlags.Type & ~SymbolFlags.Value */, TODO, nil /* TODO(FalseKeyword): false */, TODO))
			allFlags := symbol && getSymbolFlags(symbol)
			if symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): allFlags !== undefined */ TODO && ! /* TODO(ParenthesizedExpression): (allFlags & SymbolFlags.Value) */ TODO {
				rawName := unescapeLeadingUnderscores(name)
				if isES2015OrLaterConstructorName(name) {
					error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later */, TODO, rawName)
				} else if maybeMappedType(errorLocation, symbol) {
					error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0 */, TODO, rawName /* TODO(ConditionalExpression): rawName === "K" ? "P" : "K" */, TODO)
				} else {
					error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here */, TODO, rawName)
				}
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	maybeMappedType := func(node Node, symbol Symbol) /* TODO(undefined): boolean */ TODO {
		container := findAncestor( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): n => isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(n) || "quit" */, TODO) /* as */ /* TODO(UnionType): TypeLiteralNode | undefined */
		if container && /* TODO(PropertyAccessExpression): container.members.length */ TODO == 1 {
			type_ := getDeclaredTypeOfSymbol(symbol)
			return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union) */ TODO && allTypesAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteral */, TODO /* TODO(TrueKeyword): true */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isES2015OrLaterConstructorName := func(n __String) /* TODO(undefined): boolean */ TODO {
		/* TODO(SwitchStatement): switch (n) {             case "Promise":             case "Symbol":             case "Map":             case "WeakMap":             case "Set":             case "WeakSet":                 return true;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkAndReportErrorForUsingNamespaceAsTypeOrValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & (SymbolFlags.Value & ~SymbolFlags.Type) */ TODO {
			symbol := resolveSymbol(resolveName(errorLocation, name /* TODO(PropertyAccessExpression): SymbolFlags.NamespaceModule */, TODO, nil /* TODO(FalseKeyword): false */, TODO))
			if symbol {
				error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.Cannot_use_namespace_0_as_a_value */, TODO, unescapeLeadingUnderscores(name))
				return /* TODO(TrueKeyword): true */ TODO
			}
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & (SymbolFlags.Type & ~SymbolFlags.Value) */ TODO {
			symbol := resolveSymbol(resolveName(errorLocation, name /* TODO(PropertyAccessExpression): SymbolFlags.Module */, TODO, nil /* TODO(FalseKeyword): false */, TODO))
			if symbol {
				error(errorLocation /* TODO(PropertyAccessExpression): Diagnostics.Cannot_use_namespace_0_as_a_type */, TODO, unescapeLeadingUnderscores(name))
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkResolvedBlockScopedVariable := func(result Symbol, errorLocation Node) {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (result.flags & SymbolFlags.BlockScopedVariable || result.flags & SymbolFlags.Class || result.flags & SymbolFlags.Enum) */ TODO)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & (SymbolFlags.Function | SymbolFlags.FunctionScopedVariable | SymbolFlags.Assignment) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & SymbolFlags.Class */ TODO {
			return
		}
		declaration := /* TODO(PropertyAccessExpression): result.declarations?.find */ TODO( /* TODO(ArrowFunction): d => isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind === SyntaxKind.EnumDeclaration) */ TODO)
		if declaration == nil {
			/* TODO(CallExpression): Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration") */
		}
		if ! /* TODO(ParenthesizedExpression): (declaration.flags & NodeFlags.Ambient) */ TODO && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) {
			var diagnosticMessage TODO
			declarationName := declarationNameToString(getNameOfDeclaration(declaration))
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & SymbolFlags.BlockScopedVariable */ TODO {
				/* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName); */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & SymbolFlags.Class */ TODO {
				/* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName); */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & SymbolFlags.RegularEnum */ TODO {
				/* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName); */
			} else {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (result.flags & SymbolFlags.ConstEnum) */ TODO)
				if getIsolatedModules(compilerOptions) {
					/* TODO(ExpressionStatement): diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName); */
				}
			}
			if diagnosticMessage {
				addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_here */, TODO, declarationName))
			}
		}
	}
	isSameScopeDescendentOf := func(initial Node, parent Node, stopAt Node) bool {
		return !!parent && !!findAncestor(initial /* TODO(ArrowFunction): n =>             n === parent             || (n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false) */, TODO)
	}
	getAnyImportSyntax := func(node Node) *AnyImportOrJsDocImport {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:                 return node as ImportEqualsDeclaration;             case SyntaxKind.ImportClause:                 return (node as ImportClause).parent;             case SyntaxKind.NamespaceImport:                 return (node as NamespaceImport).parent.parent;             case SyntaxKind.ImportSpecifier:                 return (node as ImportSpecifier).parent.parent.parent;             default:                 return undefined;         } */
	}
	getDeclarationOfAliasSymbol := func(symbol Symbol) Declaration {
		return /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && findLast( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isAliasSymbolDeclaration)
	}
	isAliasSymbolDeclaration := func(node Node) bool {
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceExportDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportClause */ TODO && !! /* TODO(PropertyAccessExpression): (node as ImportClause).name */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceImport */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceExport */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportSpecifier */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportSpecifier */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO && exportAssignmentIsAlias(node /* as */ /* TODO(TypeReference): ExportAssignment */) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ModuleExports */ TODO && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(PropertyAccessExpression): node.parent.left */ TODO == node && /* TODO(PropertyAccessExpression): node.parent.operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO && isAliasableOrJsExpression( /* TODO(PropertyAccessExpression): node.parent.right */ TODO) || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO && isAliasableOrJsExpression( /* TODO(PropertyAccessExpression): (node as PropertyAssignment).initializer */ TODO) || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO && isVariableDeclarationInitializedToBareOrAccessedRequire( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
	}
	isAliasableOrJsExpression := func(e Expression) /* TODO(undefined): boolean */ TODO {
		return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e)
	}
	getTargetOfImportEqualsDeclaration := func(node /* TODO(UnionType): ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) *Symbol {
		commonJSPropertyAccess := getCommonJSPropertyAccess(node)
		if commonJSPropertyAccess {
			name := /* TODO(ElementAccessExpression): (getLeftmostAccessExpression(commonJSPropertyAccess.expression) as CallExpression).arguments[0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */
			return /* TODO(ConditionalExpression): isIdentifier(commonJSPropertyAccess.name)                 ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))                 : undefined */ TODO
		}
		if isVariableDeclaration(node) || /* TODO(PropertyAccessExpression): node.moduleReference.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExternalModuleReference */ TODO {
			immediate := resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node))
			resolved := resolveExternalModuleSymbol(immediate)
			markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /* TODO(FalseKeyword): false */, TODO)
			return resolved
		}
		resolved := getSymbolOfPartOfRightHandSideOfImportEquals( /* TODO(PropertyAccessExpression): node.moduleReference */ TODO, dontResolveAlias)
		checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved)
		return resolved
	}
	checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol := func(node ImportEqualsDeclaration, resolved *Symbol) {
		if markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved /* TODO(FalseKeyword): false */, TODO) && ! /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO {
			typeOnlyDeclaration := /* TODO(NonNullExpression): getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))! */ TODO
			isExport := /* TODO(PropertyAccessExpression): typeOnlyDeclaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportSpecifier */ TODO || /* TODO(PropertyAccessExpression): typeOnlyDeclaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportDeclaration */ TODO
			message := /* TODO(ConditionalExpression): isExport                 ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type                 : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type */ TODO
			relatedMessage := /* TODO(ConditionalExpression): isExport                 ? Diagnostics._0_was_exported_here                 : Diagnostics._0_was_imported_here */ TODO
			name := /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? "*" : moduleExportNameTextUnescaped(typeOnlyDeclaration.name) */ TODO
			addRelatedInfo(error( /* TODO(PropertyAccessExpression): node.moduleReference */ TODO, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name))
		}
	}
	resolveExportByName := func(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		exportValue := /* TODO(PropertyAccessExpression): moduleSymbol.exports!.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
		exportSymbol := /* TODO(ConditionalExpression): exportValue             ? getPropertyOfType(getTypeOfSymbol(exportValue), name, /*skipObjectFunctionPropertyAugment* / true)             : moduleSymbol.exports!.get(name) */ TODO
		resolved := resolveSymbol(exportSymbol, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved /* TODO(FalseKeyword): false */, TODO)
		return resolved
	}
	isSyntacticDefault := func(node Node) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ParenthesizedExpression): ((isExportAssignment(node) && !node.isExportEquals)             || hasSyntacticModifier(node, ModifierFlags.Default)             || isExportSpecifier(node)             || isNamespaceExport(node)) */ TODO
	}
	getEmitSyntaxForModuleSpecifierExpression := func(usage Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolutionMode */ TODO {
		return /* TODO(ConditionalExpression): isStringLiteralLike(usage) ? host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage) : undefined */ TODO
	}
	isESMFormatImportImportingCommonjsFormatFile := func(usageMode ResolutionMode, targetMode ResolutionMode) /* TODO(undefined): boolean */ TODO {
		return usageMode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && targetMode == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO
	}
	isOnlyImportableAsDefault := func(usage Expression) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): ModuleKind.Node16 */ TODO <= moduleKind && moduleKind <= /* TODO(PropertyAccessExpression): ModuleKind.NodeNext */ TODO {
			usageMode := getEmitSyntaxForModuleSpecifierExpression(usage)
			return usageMode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && endsWith( /* TODO(PropertyAccessExpression): (usage as StringLiteralLike).text */ TODO /* TODO(PropertyAccessExpression): Extension.Json */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	canHaveSyntheticDefault := func(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) /* TODO(undefined): boolean */ TODO {
		usageMode := file && getEmitSyntaxForModuleSpecifierExpression(usage)
		if file && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): usageMode !== undefined */ TODO {
			targetMode := /* TODO(PropertyAccessExpression): host.getImpliedNodeFormatForEmit */ TODO(file)
			if usageMode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && targetMode == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO && /* TODO(PropertyAccessExpression): ModuleKind.Node16 */ TODO <= moduleKind && moduleKind <= /* TODO(PropertyAccessExpression): ModuleKind.NodeNext */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if usageMode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && targetMode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		if !allowSyntheticDefaultImports {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if !file || /* TODO(PropertyAccessExpression): file.isDeclarationFile */ TODO {
			defaultExportSymbol := resolveExportByName(moduleSymbol /* TODO(PropertyAccessExpression): InternalSymbolName.Default */, TODO, nil /* TODO(TrueKeyword): true */, TODO)
			if defaultExportSymbol && some( /* TODO(PropertyAccessExpression): defaultExportSymbol.declarations */ TODO, isSyntacticDefault) {
				return /* TODO(FalseKeyword): false */ TODO
			}
			if resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias) {
				return /* TODO(FalseKeyword): false */ TODO
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		if !isSourceFileJS(file) {
			return hasExportAssignmentSymbol(moduleSymbol)
		}
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeof file.externalModuleIndicator !== "object" */ TODO && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias)
	}
	getTargetOfImportClause := func(node ImportClause, dontResolveAlias bool) *Symbol {
		moduleSymbol := resolveExternalModuleName(node /* TODO(PropertyAccessExpression): node.parent.moduleSpecifier */, TODO)
		if moduleSymbol {
			return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
		}
	}
	getTargetofModuleDefault := func(moduleSymbol Symbol, node /* TODO(UnionType): ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var exportDefaultSymbol *Symbol
		if isShorthandAmbientModuleSymbol(moduleSymbol) {
			/* TODO(ExpressionStatement): exportDefaultSymbol = moduleSymbol; */
		} else {
			/* TODO(ExpressionStatement): exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolName.Default, node, dontResolveAlias); */
		}
		file := /* TODO(PropertyAccessExpression): moduleSymbol.declarations?.find */ TODO(isSourceFile)
		specifier := getModuleSpecifierForImportOrExport(node)
		if !specifier {
			return exportDefaultSymbol
		}
		hasDefaultOnly := isOnlyImportableAsDefault(specifier)
		hasSyntheticDefault := canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
		if !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly {
			if hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports {
				compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop" */ TODO
				exportEqualsSymbol := /* TODO(PropertyAccessExpression): moduleSymbol.exports!.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
				exportAssignment := /* TODO(PropertyAccessExpression): exportEqualsSymbol!.valueDeclaration */ TODO
				err := error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag */, TODO, symbolToString(moduleSymbol), compilerOptionName)
				if exportAssignment {
					addRelatedInfo(err, createDiagnosticForNode(exportAssignment /* TODO(PropertyAccessExpression): Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag */, TODO, compilerOptionName))
				}
			} else if isImportClause(node) {
				reportNonDefaultExport(moduleSymbol, node)
			} else {
				errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO)
			}
		} else if hasSyntheticDefault || hasDefaultOnly {
			resolved := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved /* TODO(FalseKeyword): false */, TODO)
			return resolved
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, nil /* TODO(FalseKeyword): false */, TODO)
		return exportDefaultSymbol
	}
	getModuleSpecifierForImportOrExport := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) *Expression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportClause:                 return node.parent.moduleSpecifier;             case SyntaxKind.ImportEqualsDeclaration:                 return isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : undefined;             case SyntaxKind.NamespaceImport:                 return node.parent.parent.moduleSpecifier;             case SyntaxKind.ImportSpecifier:                 return node.parent.parent.parent.moduleSpecifier;             case SyntaxKind.ExportSpecifier:                 return node.parent.parent.moduleSpecifier;             default:                 return Debug.assertNever(node);         } */
	}
	reportNonDefaultExport := func(moduleSymbol Symbol, node ImportClause) {
		if /* TODO(PropertyAccessExpression): moduleSymbol.exports?.has */ TODO( /* TODO(PropertyAccessExpression): node.symbol.escapedName */ TODO) {
			error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead */, TODO, symbolToString(moduleSymbol), symbolToString( /* TODO(PropertyAccessExpression): node.symbol */ TODO))
		} else {
			diagnostic := error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Module_0_has_no_default_export */, TODO, symbolToString(moduleSymbol))
			exportStar := /* TODO(PropertyAccessExpression): moduleSymbol.exports?.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportStar */ TODO)
			if exportStar {
				defaultExport := /* TODO(PropertyAccessExpression): exportStar.declarations?.find */ TODO( /* TODO(ArrowFunction): decl =>                     !!(                         isExportDeclaration(decl) && decl.moduleSpecifier &&                         resolveExternalModuleName(decl, decl.moduleSpecifier)?.exports?.has(InternalSymbolName.Default)                     ) */ TODO)
				if defaultExport {
					addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport /* TODO(PropertyAccessExpression): Diagnostics.export_Asterisk_does_not_re_export_a_default */, TODO))
				}
			}
		}
	}
	getTargetOfNamespaceImport := func(node NamespaceImport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := /* TODO(PropertyAccessExpression): node.parent.parent.moduleSpecifier */ TODO
		immediate := resolveExternalModuleName(node, moduleSpecifier)
		resolved := resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias /* TODO(FalseKeyword): false */, TODO)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /* TODO(FalseKeyword): false */, TODO)
		return resolved
	}
	getTargetOfNamespaceExport := func(node NamespaceExport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := /* TODO(PropertyAccessExpression): node.parent.moduleSpecifier */ TODO
		immediate := moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier)
		resolved := moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias /* TODO(FalseKeyword): false */, TODO)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /* TODO(FalseKeyword): false */, TODO)
		return resolved
	}
	combineValueAndTypeSymbols := func(valueSymbol Symbol, typeSymbol Symbol) Symbol {
		if valueSymbol == unknownSymbol && typeSymbol == unknownSymbol {
			return unknownSymbol
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): valueSymbol.flags & (SymbolFlags.Type | SymbolFlags.Namespace) */ TODO {
			return valueSymbol
		}
		result := createSymbol( /* TODO(BarToken): | */ /* TODO(BinaryExpression): valueSymbol.flags | typeSymbol.flags */ TODO /* TODO(PropertyAccessExpression): valueSymbol.escapedName */, TODO)
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): valueSymbol.declarations */ TODO || /* TODO(PropertyAccessExpression): typeSymbol.declarations */ TODO)
		/* TODO(ExpressionStatement): result.declarations = deduplicate(concatenate(valueSymbol.declarations!, typeSymbol.declarations), equateValues); */
		/* TODO(ExpressionStatement): result.parent = valueSymbol.parent || typeSymbol.parent; */
		if /* TODO(PropertyAccessExpression): valueSymbol.valueDeclaration */ TODO {
			/* TODO(BinaryExpression): result.valueDeclaration = valueSymbol.valueDeclaration */
		}
		if /* TODO(PropertyAccessExpression): typeSymbol.members */ TODO {
			/* TODO(BinaryExpression): result.members = new Map(typeSymbol.members) */
		}
		if /* TODO(PropertyAccessExpression): valueSymbol.exports */ TODO {
			/* TODO(BinaryExpression): result.exports = new Map(valueSymbol.exports) */
		}
		return result
	}
	getExportOfModule := func(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) *Symbol {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Module */ TODO {
			exportSymbol := /* TODO(PropertyAccessExpression): getExportsOfSymbol(symbol).get */ TODO(nameText)
			resolved := resolveSymbol(exportSymbol, dontResolveAlias)
			exportStarDeclaration := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeOnlyExportStarMap?.get */ TODO(nameText)
			markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved /* TODO(FalseKeyword): false */, TODO, exportStarDeclaration, nameText)
			return resolved
		}
	}
	getPropertyOfVariable := func(symbol Symbol, name __String) *Symbol {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Variable */ TODO {
			typeAnnotation := /* TODO(PropertyAccessExpression): (symbol.valueDeclaration as VariableDeclaration).type */ TODO
			if typeAnnotation {
				return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name))
			}
		}
	}
	getExternalModuleMember := func(node /* TODO(UnionType): ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(UnionType): ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		moduleSpecifier := getExternalModuleRequireArgument(node) || /* TODO(NonNullExpression): (node as ImportDeclaration | ExportDeclaration | JSDocImportTag).moduleSpecifier! */ TODO
		moduleSymbol := /* TODO(NonNullExpression): resolveExternalModuleName(node, moduleSpecifier)! */ TODO
		name := !isPropertyAccessExpression(specifier) && /* TODO(PropertyAccessExpression): specifier.propertyName */ TODO || /* TODO(PropertyAccessExpression): specifier.name */ TODO
		if !isIdentifier(name) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name.kind !== SyntaxKind.StringLiteral */ TODO {
			return nil
		}
		nameText := moduleExportNameTextEscaped(name)
		suppressInteropError := nameText == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO && allowSyntheticDefaultImports
		targetSymbol := resolveESModuleSymbol(moduleSymbol, moduleSpecifier /* TODO(FalseKeyword): false */, TODO, suppressInteropError)
		if targetSymbol {
			if nameText || /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.StringLiteral */ TODO {
				if isShorthandAmbientModuleSymbol(moduleSymbol) {
					return moduleSymbol
				}
				var symbolFromVariable *Symbol
				if moduleSymbol && /* TODO(PropertyAccessExpression): moduleSymbol.exports */ TODO && /* TODO(PropertyAccessExpression): moduleSymbol.exports.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO) {
					/* TODO(ExpressionStatement): symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText, /*skipObjectFunctionPropertyAugment* / true); */
				} else {
					/* TODO(ExpressionStatement): symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText); */
				}
				/* TODO(ExpressionStatement): symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias); */
				symbolFromModule := getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
				if symbolFromModule == nil && nameText == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO {
					file := /* TODO(PropertyAccessExpression): moduleSymbol.declarations?.find */ TODO(isSourceFile)
					if isOnlyImportableAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) {
						/* TODO(ExpressionStatement): symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias); */
					}
				}
				symbol := /* TODO(ConditionalExpression): symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?                     combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :                     symbolFromModule || symbolFromVariable */ TODO
				if !symbol {
					errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name)
				}
				return symbol
			}
		}
	}
	errorNoModuleMemberSymbol := func(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
		moduleName := getFullyQualifiedName(moduleSymbol, node)
		declarationName := declarationNameToString(name)
		suggestion := /* TODO(ConditionalExpression): isIdentifier(name) ? getSuggestedSymbolForNonexistentModule(name, targetSymbol) : undefined */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
			suggestionName := symbolToString(suggestion)
			diagnostic := error(name /* TODO(PropertyAccessExpression): Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2 */, TODO, moduleName, declarationName, suggestionName)
			if /* TODO(PropertyAccessExpression): suggestion.valueDeclaration */ TODO {
				addRelatedInfo(diagnostic, createDiagnosticForNode( /* TODO(PropertyAccessExpression): suggestion.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_here */, TODO, suggestionName))
			}
		} else {
			if /* TODO(PropertyAccessExpression): moduleSymbol.exports?.has */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO) {
				error(name /* TODO(PropertyAccessExpression): Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead */, TODO, moduleName, declarationName)
			} else {
				reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName)
			}
		}
	}
	reportNonExportedMember := func(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
		localSymbol := /* TODO(PropertyAccessExpression): tryCast(moduleSymbol.valueDeclaration, canHaveLocals)?.locals?.get */ TODO(moduleExportNameTextEscaped(name))
		exports := /* TODO(PropertyAccessExpression): moduleSymbol.exports */ TODO
		if localSymbol {
			exportedEqualsSymbol := /* TODO(PropertyAccessExpression): exports?.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
			if exportedEqualsSymbol {
				/* TODO(ExpressionStatement): getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :                     error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName); */
			} else {
				exportedSymbol := /* TODO(ConditionalExpression): exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined */ TODO
				diagnostic := /* TODO(ConditionalExpression): exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :                     error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName) */ TODO
				if /* TODO(PropertyAccessExpression): localSymbol.declarations */ TODO {
					addRelatedInfo(diagnostic /* TODO(SpreadElement): ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here, declarationName)) */, TODO)
				}
			}
		} else {
			error(name /* TODO(PropertyAccessExpression): Diagnostics.Module_0_has_no_exported_member_1 */, TODO, moduleName, declarationName)
		}
	}
	reportInvalidImportEqualsExportMember := func(node Node, name ModuleExportName, declarationName string, moduleName string) {
		if moduleKind >= /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO {
			message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import :                 Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
			error(name, message, declarationName)
		} else {
			if isInJSFile(node) {
				message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName)
			} else {
				message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName, declarationName, moduleName)
			}
		}
	}
	getTargetOfImportSpecifier := func(node /* TODO(UnionType): ImportSpecifier | BindingElement */ any, dontResolveAlias bool) *Symbol {
		if isImportSpecifier(node) && moduleExportNameIsDefault( /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
			}
		}
		root := /* TODO(ConditionalExpression): isBindingElement(node) ? getRootDeclaration(node) as VariableDeclaration : node.parent.parent.parent */ TODO
		commonJSPropertyAccess := getCommonJSPropertyAccess(root)
		resolved := getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias)
		name := /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO
		if commonJSPropertyAccess && resolved && isIdentifier(name) {
			return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved) /* TODO(PropertyAccessExpression): name.escapedText */, TODO), dontResolveAlias)
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved /* TODO(FalseKeyword): false */, TODO)
		return resolved
	}
	getCommonJSPropertyAccess := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAccessExpression | undefined */ TODO {
		if isVariableDeclaration(node) && /* TODO(PropertyAccessExpression): node.initializer */ TODO && isPropertyAccessExpression( /* TODO(PropertyAccessExpression): node.initializer */ TODO) {
			return /* TODO(PropertyAccessExpression): node.initializer */ TODO
		}
	}
	getTargetOfNamespaceExportDeclaration := func(node NamespaceExportDeclaration, dontResolveAlias bool) *Symbol {
		if canHaveSymbol( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			resolved := resolveExternalModuleSymbol( /* TODO(PropertyAccessExpression): node.parent.symbol */ TODO, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved /* TODO(FalseKeyword): false */, TODO)
			return resolved
		}
	}
	getTargetOfExportSpecifier := func(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		name := /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO
		if moduleExportNameIsDefault(name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias)
			}
		}
		resolved := /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?             getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :             name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }             resolveEntityName(name, meaning, /*ignoreErrors* / false, dontResolveAlias) */ TODO
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved /* TODO(FalseKeyword): false */, TODO)
		return resolved
	}
	getTargetOfExportAssignment := func(node /* TODO(UnionType): ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) *Symbol {
		expression := /* TODO(ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
		resolved := getTargetOfAliasLikeExpression(expression, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved /* TODO(FalseKeyword): false */, TODO)
		return resolved
	}
	getTargetOfAliasLikeExpression := func(expression Expression, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isClassExpression(expression) {
			return /* TODO(PropertyAccessExpression): checkExpressionCached(expression).symbol */ TODO
		}
		if !isEntityName(expression) && !isEntityNameExpression(expression) {
			return nil
		}
		aliasLike := resolveEntityName(expression /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */, TODO /* TODO(TrueKeyword): true */, TODO, dontResolveAlias)
		if aliasLike {
			return aliasLike
		}
		checkExpressionCached(expression)
		return /* TODO(PropertyAccessExpression): getNodeLinks(expression).resolvedSymbol */ TODO
	}
	getTargetOfAccessExpression := func(node AccessExpression, dontRecursivelyResolve bool) *Symbol {
		if ! /* TODO(ParenthesizedExpression): (isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === SyntaxKind.EqualsToken) */ TODO {
			return nil
		}
		return getTargetOfAliasLikeExpression( /* TODO(PropertyAccessExpression): node.parent.right */ TODO, dontRecursivelyResolve)
	}
	getTargetOfAliasDeclaration := func(node Declaration, dontRecursivelyResolve /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:             case SyntaxKind.VariableDeclaration:                 return getTargetOfImportEqualsDeclaration(node as ImportEqualsDeclaration | VariableDeclaration, dontRecursivelyResolve);             case SyntaxKind.ImportClause:                 return getTargetOfImportClause(node as ImportClause, dontRecursivelyResolve);             case SyntaxKind.NamespaceImport:                 return getTargetOfNamespaceImport(node as NamespaceImport, dontRecursivelyResolve);             case SyntaxKind.NamespaceExport:                 return getTargetOfNamespaceExport(node as NamespaceExport, dontRecursivelyResolve);             case SyntaxKind.ImportSpecifier:             case SyntaxKind.BindingElement:                 return getTargetOfImportSpecifier(node as ImportSpecifier | BindingElement, dontRecursivelyResolve);             case SyntaxKind.ExportSpecifier:                 return getTargetOfExportSpecifier(node as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);             case SyntaxKind.ExportAssignment:             case SyntaxKind.BinaryExpression:                 return getTargetOfExportAssignment(node as ExportAssignment | BinaryExpression, dontRecursivelyResolve);             case SyntaxKind.NamespaceExportDeclaration:                 return getTargetOfNamespaceExportDeclaration(node as NamespaceExportDeclaration, dontRecursivelyResolve);             case SyntaxKind.ShorthandPropertyAssignment:                 return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors* / true, dontRecursivelyResolve);             case SyntaxKind.PropertyAssignment:                 return getTargetOfAliasLikeExpression((node as PropertyAssignment).initializer, dontRecursivelyResolve);             case SyntaxKind.ElementAccessExpression:             case SyntaxKind.PropertyAccessExpression:                 return getTargetOfAccessExpression(node as AccessExpression, dontRecursivelyResolve);             default:                 return Debug.fail();         } */
	}
	isNonLocalAlias := func(symbol *Symbol, excludes /* TODO(undefined): number */ TODO /* = */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TypePredicate): symbol is Symbol */ TODO {
		if !symbol {
			/* TODO(FalseKeyword): false */
		}
		return /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.Alias | excludes)) */ TODO == /* TODO(PropertyAccessExpression): SymbolFlags.Alias */ TODO || !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias && symbol.flags & SymbolFlags.Assignment) */ TODO
	}
	// OVERLOAD: resolveSymbol := func(symbol Symbol, dontResolveAlias bool) Symbol
	// OVERLOAD: resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol
	resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol {
		return /* TODO(ConditionalExpression): !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol */ TODO
	}
	resolveAlias := func(symbol Symbol) Symbol {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Alias) !== 0 */ TODO, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.aliasTarget */ TODO {
			/* TODO(ExpressionStatement): links.aliasTarget = resolvingSymbol; */
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				/* TODO(CallExpression): Debug.fail() */
			}
			target := getTargetOfAliasDeclaration(node)
			if /* TODO(PropertyAccessExpression): links.aliasTarget */ TODO == resolvingSymbol {
				/* TODO(ExpressionStatement): links.aliasTarget = target || unknownSymbol; */
			} else {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Circular_definition_of_import_alias_0 */, TODO, symbolToString(symbol))
			}
		} else if /* TODO(PropertyAccessExpression): links.aliasTarget */ TODO == resolvingSymbol {
			/* TODO(ExpressionStatement): links.aliasTarget = unknownSymbol; */
		}
		return /* TODO(PropertyAccessExpression): links.aliasTarget */ TODO
	}
	tryResolveAlias := func(symbol Symbol) *Symbol {
		links := getSymbolLinks(symbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): links.aliasTarget !== resolvingSymbol */ TODO {
			return resolveAlias(symbol)
		}
		return nil
	}
	getSymbolFlags := func(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
		typeOnlyDeclaration := excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol)
		typeOnlyDeclarationIsExportStar := typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration)
		typeOnlyResolution := typeOnlyDeclaration && /* TODO(ParenthesizedExpression): (             typeOnlyDeclarationIsExportStar                 ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors* / true)                 : resolveAlias(typeOnlyDeclaration.symbol)         ) */ TODO
		typeOnlyExportStarTargets := /* TODO(ConditionalExpression): typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined */ TODO
		flags := /* TODO(ConditionalExpression): excludeLocalMeanings ? SymbolFlags.None : symbol.flags */ TODO
		var seenSymbols TODO
		/* TODO(WhileStatement): while (symbol.flags & SymbolFlags.Alias) {             const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));             if (                 !typeOnlyDeclarationIsExportStar && target === typeOnlyResolution ||                 typeOnlyExportStarTargets?.get(target.escapedName) === target             ) {                 break;             }             if (target === unknownSymbol) {                 return SymbolFlags.All;             }              // Optimizations - try to avoid creating or adding to             // `seenSymbols` if possible             if (target === symbol || seenSymbols?.has(target)) {                 break;             }             if (target.flags & SymbolFlags.Alias) {                 if (seenSymbols) {                     seenSymbols.add(target);                 }                 else {                     seenSymbols = new Set([symbol, target]);                 }             }             flags |= target.flags;             symbol = target;         } */
		return flags
	}
	markSymbolOfAliasDeclarationIfTypeOnly := func(aliasDeclaration Declaration, immediateTarget *Symbol, finalTarget *Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ TODO, exportStarName __String) bool {
		if !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) {
			/* TODO(FalseKeyword): false */
		}
		sourceSymbol := getSymbolOfDeclaration(aliasDeclaration)
		if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
			links := getSymbolLinks(sourceSymbol)
			/* TODO(ExpressionStatement): links.typeOnlyDeclaration = aliasDeclaration; */
			return /* TODO(TrueKeyword): true */ TODO
		}
		if exportStarDeclaration {
			links := getSymbolLinks(sourceSymbol)
			/* TODO(ExpressionStatement): links.typeOnlyDeclaration = exportStarDeclaration; */
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSymbol.escapedName !== exportStarName */ TODO {
				/* TODO(ExpressionStatement): links.typeOnlyExportStarName = exportStarName; */
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		links := getSymbolLinks(sourceSymbol)
		return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty)
	}
	markSymbolOfAliasDeclarationIfTypeOnlyWorker := func(aliasDeclarationLinks SymbolLinks, target *Symbol, overwriteEmpty bool) bool {
		if target && /* TODO(ParenthesizedExpression): (aliasDeclarationLinks.typeOnlyDeclaration === undefined || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false) */ TODO {
			exportSymbol := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
			typeOnly := /* TODO(PropertyAccessExpression): exportSymbol.declarations */ TODO && find( /* TODO(PropertyAccessExpression): exportSymbol.declarations */ TODO, isTypeOnlyImportOrExportDeclaration)
			/* TODO(ExpressionStatement): aliasDeclarationLinks.typeOnlyDeclaration = typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false; */
		}
		return !! /* TODO(PropertyAccessExpression): aliasDeclarationLinks.typeOnlyDeclaration */ TODO
	}
	getTypeOnlyAliasDeclaration := func(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
		if ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias) */ TODO {
			return nil
		}
		links := getSymbolLinks(symbol)
		if /* TODO(PropertyAccessExpression): links.typeOnlyDeclaration */ TODO == nil {
			/* TODO(ExpressionStatement): links.typeOnlyDeclaration = false; */
			resolved := resolveSymbol(symbol)
			markSymbolOfAliasDeclarationIfTypeOnly( /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO, getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved /* TODO(TrueKeyword): true */, TODO)
		}
		if include == nil {
			return /* TODO(PropertyAccessExpression): links.typeOnlyDeclaration */ TODO || nil
		}
		if /* TODO(PropertyAccessExpression): links.typeOnlyDeclaration */ TODO {
			resolved := /* TODO(ConditionalExpression): links.typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration                 ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent!).get(links.typeOnlyExportStarName || symbol.escapedName))!                 : resolveAlias(links.typeOnlyDeclaration.symbol) */ TODO
			return /* TODO(ConditionalExpression): getSymbolFlags(resolved) & include ? links.typeOnlyDeclaration : undefined */ TODO
		}
		return nil
	}
	getSymbolOfPartOfRightHandSideOfImportEquals := func(entityName EntityName, dontResolveAlias bool) *Symbol {
		if /* TODO(PropertyAccessExpression): entityName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO && isRightSideOfQualifiedNameOrPropertyAccess(entityName) {
			/* TODO(ExpressionStatement): entityName = entityName.parent as QualifiedName; */
		}
		if /* TODO(PropertyAccessExpression): entityName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO || /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.QualifiedName */ TODO {
			return resolveEntityName(entityName /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */, TODO /* TODO(FalseKeyword): false */, TODO, dontResolveAlias)
		} else {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */ TODO)
			return resolveEntityName(entityName /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */, TODO /* TODO(FalseKeyword): false */, TODO, dontResolveAlias)
		}
	}
	getFullyQualifiedName := func(symbol Symbol, containingLocation Node) string {
		return /* TODO(ConditionalExpression): symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, /*meaning* / undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind) */ TODO
	}
	getContainingQualifiedNameNode := func(node QualifiedName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").QualifiedName */ TODO {
		/* TODO(WhileStatement): while (isQualifiedName(node.parent)) {             node = node.parent;         } */
		return node
	}
	tryGetQualifiedNameAsValue := func(node QualifiedName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var left /* TODO(UnionType): Identifier | QualifiedName */ any = getFirstIdentifier(node)
		symbol := resolveName(left, left /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO, nil /* TODO(TrueKeyword): true */, TODO)
		if !symbol {
			return nil
		}
		/* TODO(WhileStatement): while (isQualifiedName(left.parent)) {             const type = getTypeOfSymbol(symbol);             symbol = getPropertyOfType(type, left.parent.right.escapedText);             if (!symbol) {                 return undefined;             }             left = left.parent;         } */
		return symbol
	}
	resolveEntityName := func(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) *Symbol {
		if nodeIsMissing(name) {
			return nil
		}
		namespaceMeaning := /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Namespace | (isInJSFile(name) ? meaning & SymbolFlags.Value : 0) */ TODO
		var symbol *Symbol
		if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			message := /* TODO(ConditionalExpression): meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name)) */ TODO
			symbolFromJSPrototype := /* TODO(ConditionalExpression): isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined */ TODO
			/* TODO(ExpressionStatement): symbol = getMergedSymbol(resolveName(location || name, name, meaning, ignoreErrors || symbolFromJSPrototype ? undefined : message, /*isUse* / true, /*excludeGlobals* / false)); */
			if !symbol {
				return getMergedSymbol(symbolFromJSPrototype)
			}
		} else if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.QualifiedName */ TODO || /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO {
			left := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.left : name.expression */ TODO
			right := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right : name.name */ TODO
			namespace := resolveEntityName(left, namespaceMeaning, ignoreErrors /* TODO(FalseKeyword): false */, TODO, location)
			if !namespace || nodeIsMissing(right) {
				return nil
			} else if namespace == unknownSymbol {
				return namespace
			}
			if /* TODO(PropertyAccessExpression): namespace.valueDeclaration */ TODO && isInJSFile( /* TODO(PropertyAccessExpression): namespace.valueDeclaration */ TODO) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Bundler */ TODO && isVariableDeclaration( /* TODO(PropertyAccessExpression): namespace.valueDeclaration */ TODO) && /* TODO(PropertyAccessExpression): namespace.valueDeclaration.initializer */ TODO && isCommonJsRequire( /* TODO(PropertyAccessExpression): namespace.valueDeclaration.initializer */ TODO) {
				moduleName := /* TODO(ElementAccessExpression): (namespace.valueDeclaration.initializer as CallExpression).arguments[0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */
				moduleSym := resolveExternalModuleName(moduleName, moduleName)
				if moduleSym {
					resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
					if resolvedModuleSymbol {
						/* TODO(ExpressionStatement): namespace = resolvedModuleSymbol; */
					}
				}
			}
			/* TODO(ExpressionStatement): symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning)); */
			if !symbol && /* TODO(ParenthesizedExpression): (namespace.flags & SymbolFlags.Alias) */ TODO {
				/* TODO(ExpressionStatement): symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning)); */
			}
			if !symbol {
				if !ignoreErrors {
					namespaceName := getFullyQualifiedName(namespace)
					declarationName := declarationNameToString(right)
					suggestionForNonexistentModule := getSuggestedSymbolForNonexistentModule(right, namespace)
					if suggestionForNonexistentModule {
						error(right /* TODO(PropertyAccessExpression): Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2 */, TODO, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule))
						return nil
					}
					containingQualifiedName := isQualifiedName(name) && getContainingQualifiedNameNode(name)
					canSuggestTypeof := globalObjectType && /* TODO(ParenthesizedExpression): (meaning & SymbolFlags.Type) */ TODO && containingQualifiedName && !isTypeOfExpression( /* TODO(PropertyAccessExpression): containingQualifiedName.parent */ TODO) && tryGetQualifiedNameAsValue(containingQualifiedName)
					if canSuggestTypeof {
						error(containingQualifiedName /* TODO(PropertyAccessExpression): Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0 */, TODO, entityNameToString(containingQualifiedName))
						return nil
					}
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & SymbolFlags.Namespace */ TODO && isQualifiedName( /* TODO(PropertyAccessExpression): name.parent */ TODO) {
						exportedTypeSymbol := getMergedSymbol(getSymbol(getExportsOfSymbol(namespace) /* TODO(PropertyAccessExpression): right.escapedText */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO))
						if exportedTypeSymbol {
							error( /* TODO(PropertyAccessExpression): name.parent.right */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1 */, TODO, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): name.parent.right.escapedText */ TODO))
							return nil
						}
					}
					error(right /* TODO(PropertyAccessExpression): Diagnostics.Namespace_0_has_no_exported_member_1 */, TODO, namespaceName, declarationName)
				}
				return nil
			}
		} else {
			/* TODO(PropertyAccessExpression): Debug.assertNever */ TODO(name, "Unknown entity name kind.")
		}
		if !nodeIsSynthesized(name) && isEntityName(name) && /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias || name.parent.kind === SyntaxKind.ExportAssignment) */ TODO {
			markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, nil /* TODO(TrueKeyword): true */, TODO)
		}
		return /* TODO(ConditionalExpression): (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol) */ TODO
	}
	resolveEntityNameFromAssignmentDeclaration := func(name Identifier, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isJSDocTypeReference( /* TODO(PropertyAccessExpression): name.parent */ TODO) {
			secondaryLocation := getAssignmentDeclarationLocation( /* TODO(PropertyAccessExpression): name.parent */ TODO)
			if secondaryLocation {
				return resolveName(secondaryLocation, name, meaning, nil /* TODO(TrueKeyword): true */, TODO)
			}
		}
	}
	getAssignmentDeclarationLocation := func(node TypeReferenceNode) Node {
		typeAlias := findAncestor(node /* TODO(ArrowFunction): node => !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(node) */, TODO)
		if typeAlias {
			return
		}
		host := getJSDocHost(node)
		if host && isExpressionStatement(host) && isPrototypePropertyAssignment( /* TODO(PropertyAccessExpression): host.expression */ TODO) {
			symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): host.expression.left */ TODO)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && isFunctionExpression(host) && isPrototypePropertyAssignment( /* TODO(PropertyAccessExpression): host.parent */ TODO) && isExpressionStatement( /* TODO(PropertyAccessExpression): host.parent.parent */ TODO) {
			symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): host.parent.left */ TODO)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && /* TODO(ParenthesizedExpression): (isObjectLiteralMethod(host) || isPropertyAssignment(host)) */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): host.parent.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): host.parent.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.Prototype */ TODO {
			symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): host.parent.parent.left */ TODO /* as */ /* TODO(TypeReference): BindableStaticNameExpression */)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		sig := getEffectiveJSDocHost(node)
		if sig && isFunctionLike(sig) {
			symbol := getSymbolOfDeclaration(sig)
			return symbol && /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		}
	}
	getDeclarationOfJSPrototypeContainer := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
		decl := /* TODO(PropertyAccessExpression): symbol.parent!.valueDeclaration */ TODO
		if !decl {
			return nil
		}
		initializer := /* TODO(ConditionalExpression): isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) :             hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) :             undefined */ TODO
		return initializer || decl
	}
	getExpandoSymbol := func(symbol Symbol) *Symbol {
		decl := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if !decl || !isInJSFile(decl) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO || getExpandoInitializer(decl /* TODO(FalseKeyword): false */, TODO) {
			return nil
		}
		init := /* TODO(ConditionalExpression): isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl) */ TODO
		if init {
			initSymbol := getSymbolOfNode(init)
			if initSymbol {
				return mergeJSSymbols(initSymbol, symbol)
			}
		}
	}
	resolveExternalModuleName := func(location Node, moduleReferenceExpression Expression, ignoreErrors bool) *Symbol {
		isClassic := getEmitModuleResolutionKind(compilerOptions) == /* TODO(PropertyAccessExpression): ModuleResolutionKind.Classic */ TODO
		errorMessage := /* TODO(ConditionalExpression): isClassic ?             Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		return resolveExternalModuleNameWorker(location, moduleReferenceExpression /* TODO(ConditionalExpression): ignoreErrors ? undefined : errorMessage */, TODO, ignoreErrors)
	}
	resolveExternalModuleNameWorker := func(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, isForAugmentation /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		return /* TODO(ConditionalExpression): isStringLiteralLike(moduleReferenceExpression)             ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, !ignoreErrors ? moduleReferenceExpression : undefined, isForAugmentation)             : undefined */ TODO
	}
	resolveExternalModule := func(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		if errorNode && startsWith(moduleReference, "@types/") {
			diag := /* TODO(PropertyAccessExpression): Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1 */ TODO
			withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
			error(errorNode, diag, withoutAtTypePrefix, moduleReference)
		}
		ambientModule := tryFindAmbientModule(moduleReference /* TODO(TrueKeyword): true */, TODO)
		if ambientModule {
			return ambientModule
		}
		currentSourceFile := getSourceFileOfNode(location)
		contextSpecifier := /* TODO(ConditionalExpression): isStringLiteralLike(location)             ? location             : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name ||                 (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal ||                 (isInJSFile(location) && isJSDocImportTag(location) ? location.moduleSpecifier : undefined) ||                 (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument* / true) ? location.initializer.arguments[0] : undefined) ||                 findAncestor(location, isImportCall)?.arguments[0] ||                 findAncestor(location, isImportDeclaration)?.moduleSpecifier ||                 findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression ||                 findAncestor(location, isExportDeclaration)?.moduleSpecifier */ TODO
		mode := /* TODO(ConditionalExpression): contextSpecifier && isStringLiteralLike(contextSpecifier)             ? host.getModeForUsageLocation(currentSourceFile, contextSpecifier)             : host.getDefaultResolutionModeForFile(currentSourceFile) */ TODO
		moduleResolutionKind := getEmitModuleResolutionKind(compilerOptions)
		resolvedModule := /* TODO(PropertyAccessExpression): host.getResolvedModule(currentSourceFile, moduleReference, mode)?.resolvedModule */ TODO
		resolutionDiagnostic := errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile)
		sourceFile := resolvedModule && /* TODO(ParenthesizedExpression): (!resolutionDiagnostic || resolutionDiagnostic === Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) */ TODO && /* TODO(PropertyAccessExpression): host.getSourceFile */ TODO( /* TODO(PropertyAccessExpression): resolvedModule.resolvedFileName */ TODO)
		if sourceFile {
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference /* TODO(PropertyAccessExpression): resolvedModule.resolvedFileName */, TODO)
			}
			if /* TODO(PropertyAccessExpression): resolvedModule.resolvedUsingTsExtension */ TODO && isDeclarationFileName(moduleReference) {
				importOrExport := /* TODO(PropertyAccessExpression): findAncestor(location, isImportDeclaration)?.importClause */ TODO || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && importOrExport && ! /* TODO(PropertyAccessExpression): importOrExport.isTypeOnly */ TODO || findAncestor(location, isImportCall) {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead */, TODO, getSuggestedImportSource( /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(tryExtractTSExtension(moduleReference))))
				}
			} else if /* TODO(PropertyAccessExpression): resolvedModule.resolvedUsingTsExtension */ TODO && !shouldAllowImportingTsExtension(compilerOptions /* TODO(PropertyAccessExpression): currentSourceFile.fileName */, TODO) {
				importOrExport := /* TODO(PropertyAccessExpression): findAncestor(location, isImportDeclaration)?.importClause */ TODO || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && ! /* TODO(ParenthesizedExpression): (importOrExport?.isTypeOnly || findAncestor(location, isImportTypeNode)) */ TODO {
					tsExtension := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(tryExtractTSExtension(moduleReference))
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled */, TODO, tsExtension)
				}
			}
			if /* TODO(PropertyAccessExpression): sourceFile.symbol */ TODO {
				if errorNode && /* TODO(PropertyAccessExpression): resolvedModule.isExternalLibraryImport */ TODO && !resolutionExtensionIsTSOrJson( /* TODO(PropertyAccessExpression): resolvedModule.extension */ TODO) {
					errorOnImplicitAnyModule( /* TODO(FalseKeyword): false */ TODO, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
				}
				if errorNode && /* TODO(ParenthesizedExpression): (moduleResolutionKind === ModuleResolutionKind.Node16 || moduleResolutionKind === ModuleResolutionKind.NodeNext) */ TODO {
					isSyncImport := /* TODO(ParenthesizedExpression): (currentSourceFile.impliedNodeFormat === ModuleKind.CommonJS && !findAncestor(location, isImportCall)) */ TODO || !!findAncestor(location, isImportEqualsDeclaration)
					overrideHost := findAncestor(location /* TODO(ArrowFunction): l => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l) */, TODO)
					if isSyncImport && /* TODO(PropertyAccessExpression): sourceFile.impliedNodeFormat */ TODO == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && !hasResolutionModeOverride(overrideHost) {
						if findAncestor(location, isImportEqualsDeclaration) {
							error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead */, TODO, moduleReference)
						} else {
							var diagnosticDetails TODO
							ext := tryGetExtensionFromPath( /* TODO(PropertyAccessExpression): currentSourceFile.fileName */ TODO)
							if ext == /* TODO(PropertyAccessExpression): Extension.Ts */ TODO || ext == /* TODO(PropertyAccessExpression): Extension.Js */ TODO || ext == /* TODO(PropertyAccessExpression): Extension.Tsx */ TODO || ext == /* TODO(PropertyAccessExpression): Extension.Jsx */ TODO {
								/* TODO(ExpressionStatement): diagnosticDetails = createModeMismatchDetails(currentSourceFile); */
							}
							/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails /* TODO(PropertyAccessExpression): Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead */, TODO, moduleReference)))
						}
					}
				}
				return getMergedSymbol( /* TODO(PropertyAccessExpression): sourceFile.symbol */ TODO)
			}
			if errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.File_0_is_not_a_module */, TODO /* TODO(PropertyAccessExpression): sourceFile.fileName */, TODO)
			}
			return nil
		}
		if patternAmbientModules {
			pattern := findBestPatternMatch(patternAmbientModules /* TODO(ArrowFunction): _ => _.pattern */, TODO, moduleReference)
			if pattern {
				augmentation := patternAmbientModuleAugmentations && /* TODO(PropertyAccessExpression): patternAmbientModuleAugmentations.get */ TODO(moduleReference)
				if augmentation {
					return getMergedSymbol(augmentation)
				}
				return getMergedSymbol( /* TODO(PropertyAccessExpression): pattern.symbol */ TODO)
			}
		}
		if !errorNode {
			return nil
		}
		if resolvedModule && !resolutionExtensionIsTSOrJson( /* TODO(PropertyAccessExpression): resolvedModule.extension */ TODO) && resolutionDiagnostic == nil || resolutionDiagnostic == /* TODO(PropertyAccessExpression): Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type */ TODO {
			if isForAugmentation {
				diag := /* TODO(PropertyAccessExpression): Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented */ TODO
				error(errorNode, diag, moduleReference /* TODO(PropertyAccessExpression): resolvedModule!.resolvedFileName */, TODO)
			} else {
				errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode /* TODO(NonNullExpression): resolvedModule! */, TODO, moduleReference)
			}
			return nil
		}
		if moduleNotFoundError {
			if resolvedModule {
				redirect := /* TODO(PropertyAccessExpression): host.getProjectReferenceRedirect */ TODO( /* TODO(PropertyAccessExpression): resolvedModule.resolvedFileName */ TODO)
				if redirect {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Output_file_0_has_not_been_built_from_source_file_1 */, TODO, redirect /* TODO(PropertyAccessExpression): resolvedModule.resolvedFileName */, TODO)
					return nil
				}
			}
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference /* TODO(PropertyAccessExpression): resolvedModule.resolvedFileName */, TODO)
			} else {
				isExtensionlessRelativePathImport := pathIsRelative(moduleReference) && !hasExtension(moduleReference)
				resolutionIsNode16OrNext := moduleResolutionKind == /* TODO(PropertyAccessExpression): ModuleResolutionKind.Node16 */ TODO || moduleResolutionKind == /* TODO(PropertyAccessExpression): ModuleResolutionKind.NodeNext */ TODO
				if !getResolveJsonModule(compilerOptions) && fileExtensionIs(moduleReference /* TODO(PropertyAccessExpression): Extension.Json */, TODO) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleResolutionKind !== ModuleResolutionKind.Classic */ TODO && hasJsonModuleEmitEnabled(compilerOptions) {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension */, TODO, moduleReference)
				} else if mode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && resolutionIsNode16OrNext && isExtensionlessRelativePathImport {
					absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath( /* TODO(PropertyAccessExpression): currentSourceFile.path */ TODO))
					suggestedExt := /* TODO(ElementAccessExpression): suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))?.[1] */ TODO
					if suggestedExt {
						error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0 */, TODO /* TODO(PlusToken): + */ /* TODO(BinaryExpression): moduleReference + suggestedExt */, TODO)
					} else {
						error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path */, TODO)
					}
				} else {
					if /* TODO(PropertyAccessExpression): host.getResolvedModule(currentSourceFile, moduleReference, mode)?.alternateResult */ TODO {
						errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
						errorOrSuggestion( /* TODO(TrueKeyword): true */ TODO, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference))
					} else {
						error(errorNode, moduleNotFoundError, moduleReference)
					}
				}
			}
		}
		return nil
		getSuggestedImportSource := func(tsExtension string) /* TODO(undefined): string */ TODO {
			importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
			if emitModuleKindIsNonNodeESM(moduleKind) || mode == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO {
				preferTs := isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions)
				ext := /* TODO(ConditionalExpression): tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" :                     tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" :                     preferTs ? ".ts" : ".js" */ TODO
				return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): importSourceWithoutExtension + ext */ TODO
			}
			return importSourceWithoutExtension
		}
	}
	errorOnImplicitAnyModule := func(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
		if isSideEffectImport(errorNode) {
			return
		}
		var errorInfo *DiagnosticMessageChain
		if !isExternalModuleNameRelative(moduleReference) && packageId {
			/* TODO(ExpressionStatement): errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name); */
		}
		errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo /* TODO(PropertyAccessExpression): Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type */, TODO, moduleReference, resolvedFileName))
	}
	// OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol Symbol, dontResolveAlias bool) Symbol
	// OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol
	resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol {
		if /* TODO(PropertyAccessExpression): moduleSymbol?.exports */ TODO {
			exportEquals := resolveSymbol( /* TODO(PropertyAccessExpression): moduleSymbol.exports.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO), dontResolveAlias)
			exported := getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol))
			return getMergedSymbol(exported) || moduleSymbol
		}
		return nil
	}
	getCommonJsExportEquals := func(exported *Symbol, moduleSymbol Symbol) *Symbol {
		if !exported || exported == unknownSymbol || exported == moduleSymbol || /* TODO(PropertyAccessExpression): moduleSymbol.exports!.size */ TODO == 1 || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): exported.flags & SymbolFlags.Alias */ TODO {
			return exported
		}
		links := getSymbolLinks(exported)
		if /* TODO(PropertyAccessExpression): links.cjsExportMerged */ TODO {
			return /* TODO(PropertyAccessExpression): links.cjsExportMerged */ TODO
		}
		merged := /* TODO(ConditionalExpression): exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(exported) */ TODO
		/* TODO(ExpressionStatement): merged.flags = merged.flags | SymbolFlags.ValueModule; */
		if /* TODO(PropertyAccessExpression): merged.exports */ TODO == nil {
			/* TODO(ExpressionStatement): merged.exports = createSymbolTable(); */
		}
		/* TODO(PropertyAccessExpression): moduleSymbol.exports!.forEach */ TODO( /* TODO(ArrowFunction): (s, name) => {             if (name === InternalSymbolName.ExportEquals) return;             merged.exports!.set(name, merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s);         } */ TODO)
		if merged == exported {
			/* TODO(ExpressionStatement): getSymbolLinks(merged).resolvedExports = undefined; */
			/* TODO(ExpressionStatement): getSymbolLinks(merged).resolvedMembers = undefined; */
		}
		/* TODO(ExpressionStatement): getSymbolLinks(merged).cjsExportMerged = merged; */
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.cjsExportMerged = merged */ TODO
	}
	resolveESModuleSymbol := func(moduleSymbol *Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) *Symbol {
		symbol := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)
		if !dontResolveAlias && symbol {
			if !suppressInteropError && ! /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.Module | SymbolFlags.Variable)) */ TODO && !getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */, TODO) {
				compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015                     ? "allowSyntheticDefaultImports"                     : "esModuleInterop" */ TODO
				error(referencingLocation /* TODO(PropertyAccessExpression): Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export */, TODO, compilerOptionName)
				return symbol
			}
			referenceParent := /* TODO(PropertyAccessExpression): referencingLocation.parent */ TODO
			if /* TODO(ParenthesizedExpression): (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) */ TODO || isImportCall(referenceParent) {
				reference := /* TODO(ConditionalExpression): isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier */ TODO
				type_ := getTypeOfSymbol(symbol)
				defaultOnlyType := getTypeWithSyntheticDefaultOnly(type_, symbol /* TODO(NonNullExpression): moduleSymbol! */, TODO, reference)
				if defaultOnlyType {
					return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
				}
				targetFile := /* TODO(PropertyAccessExpression): moduleSymbol?.declarations?.find */ TODO(isSourceFile)
				isEsmCjsRef := targetFile && isESMFormatImportImportingCommonjsFormatFile(getEmitSyntaxForModuleSpecifierExpression(reference) /* TODO(PropertyAccessExpression): host.getImpliedNodeFormatForEmit */, TODO(targetFile))
				if getESModuleInterop(compilerOptions) || isEsmCjsRef {
					sigs := getSignaturesOfStructuredType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
					if !sigs || ! /* TODO(PropertyAccessExpression): sigs.length */ TODO {
						/* TODO(ExpressionStatement): sigs = getSignaturesOfStructuredType(type, SignatureKind.Construct); */
					}
					if /* TODO(ParenthesizedExpression): (sigs && sigs.length) */ TODO || getPropertyOfType(type_ /* TODO(PropertyAccessExpression): InternalSymbolName.Default */, TODO /* TODO(TrueKeyword): true */, TODO) || isEsmCjsRef {
						moduleType := /* TODO(ConditionalExpression): type.flags & TypeFlags.StructuredType                             ? getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!, reference)                             : createDefaultPropertyWrapperForModule(symbol, symbol.parent) */ TODO
						return cloneTypeAsModuleType(symbol, moduleType, referenceParent)
					}
				}
			}
		}
		return symbol
	}
	cloneTypeAsModuleType := func(symbol Symbol, moduleType Type, referenceParent /* TODO(UnionType): ImportDeclaration | ImportCall */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		result := createSymbol( /* TODO(PropertyAccessExpression): symbol.flags */ TODO /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO)
		/* TODO(ExpressionStatement): result.declarations = symbol.declarations ? symbol.declarations.slice() : []; */
		/* TODO(ExpressionStatement): result.parent = symbol.parent; */
		/* TODO(ExpressionStatement): result.links.target = symbol; */
		/* TODO(ExpressionStatement): result.links.originatingImport = referenceParent; */
		if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
			/* TODO(BinaryExpression): result.valueDeclaration = symbol.valueDeclaration */
		}
		if /* TODO(PropertyAccessExpression): symbol.constEnumOnlyModule */ TODO {
			/* TODO(BinaryExpression): result.constEnumOnlyModule = true */
		}
		if /* TODO(PropertyAccessExpression): symbol.members */ TODO {
			/* TODO(BinaryExpression): result.members = new Map(symbol.members) */
		}
		if /* TODO(PropertyAccessExpression): symbol.exports */ TODO {
			/* TODO(BinaryExpression): result.exports = new Map(symbol.exports) */
		}
		resolvedModuleType := resolveStructuredTypeMembers(moduleType /* as */ /* TODO(TypeReference): StructuredType */)
		/* TODO(ExpressionStatement): result.links.type = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos); */
		return result
	}
	hasExportAssignmentSymbol := func(moduleSymbol Symbol) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleSymbol.exports!.get(InternalSymbolName.ExportEquals) !== undefined */ TODO
	}
	getExportsOfModuleAsArray := func(moduleSymbol Symbol) []Symbol {
		return symbolsToArray(getExportsOfModule(moduleSymbol))
	}
	getExportsAndPropertiesOfModule := func(moduleSymbol Symbol) []Symbol {
		exports := getExportsOfModuleAsArray(moduleSymbol)
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): exportEquals !== moduleSymbol */ TODO {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				addRange(exports, getPropertiesOfType(type_))
			}
		}
		return exports
	}
	forEachExportAndPropertyOfModule := func(moduleSymbol Symbol, cb func(symbol Symbol, key __String)) {
		exports := getExportsOfModule(moduleSymbol)
		/* TODO(PropertyAccessExpression): exports.forEach */ TODO( /* TODO(ArrowFunction): (symbol, key) => {             if (!isReservedMemberName(key)) {                 cb(symbol, key);             }         } */ TODO)
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): exportEquals !== moduleSymbol */ TODO {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				forEachPropertyOfType(type_ /* TODO(ArrowFunction): (symbol, escapedName) => {                     cb(symbol, escapedName);                 } */, TODO)
			}
		}
	}
	tryGetMemberInModuleExports := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbolTable := getExportsOfModule(moduleSymbol)
		if symbolTable {
			return /* TODO(PropertyAccessExpression): symbolTable.get */ TODO(memberName)
		}
	}
	tryGetMemberInModuleExportsAndProperties := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbol := tryGetMemberInModuleExports(memberName, moduleSymbol)
		if symbol {
			return symbol
		}
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals == moduleSymbol {
			return nil
		}
		type_ := getTypeOfSymbol(exportEquals)
		return /* TODO(ConditionalExpression): shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined */ TODO
	}
	shouldTreatPropertiesOfExternalModuleAsExports := func(resolvedExternalModuleType Type) /* TODO(undefined): boolean */ TODO {
		return ! /* TODO(ParenthesizedExpression): (resolvedExternalModuleType.flags & TypeFlags.Primitive ||             getObjectFlags(resolvedExternalModuleType) & ObjectFlags.Class ||             // `isArrayOrTupleLikeType` is too expensive to use in this auto-imports hot path             isArrayType(resolvedExternalModuleType) ||             isTupleType(resolvedExternalModuleType)) */ TODO
	}
	getExportsOfSymbol := func(symbol Symbol) SymbolTable {
		return /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedExports) :             symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) :             symbol.exports || emptySymbols */ TODO
	}
	getExportsOfModule := func(moduleSymbol Symbol) SymbolTable {
		links := getSymbolLinks(moduleSymbol)
		if ! /* TODO(PropertyAccessExpression): links.resolvedExports */ TODO {
			TODO_IDENTIFIER := getExportsOfModuleWorker(moduleSymbol)
			/* TODO(ExpressionStatement): links.resolvedExports = exports; */
			/* TODO(ExpressionStatement): links.typeOnlyExportStarMap = typeOnlyExportStarMap; */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedExports */ TODO
	}
	type ExportCollisionTracker struct {
		specifierText        string
		exportsWithDuplicate []ExportDeclaration
	}
	type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]
	extendExportSymbols := func(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
		if !source {
		}
		/* TODO(PropertyAccessExpression): source.forEach */ TODO( /* TODO(ArrowFunction): (sourceSymbol, id) => {             if (id === InternalSymbolName.Default) return;              const targetSymbol = target.get(id);             if (!targetSymbol) {                 target.set(id, sourceSymbol);                 if (lookupTable && exportNode) {                     lookupTable.set(id, {                         specifierText: getTextOfNode(exportNode.moduleSpecifier!),                     });                 }             }             else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {                 const collisionTracker = lookupTable.get(id)!;                 if (!collisionTracker.exportsWithDuplicate) {                     collisionTracker.exportsWithDuplicate = [exportNode];                 }                 else {                     collisionTracker.exportsWithDuplicate.push(exportNode);                 }             }         } */ TODO)
	}
	getExportsOfModuleWorker := func(moduleSymbol Symbol) /* TODO(undefined): { exports: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable; typeOnlyExportStarMap: Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> | undefined; } */ TODO {
		var visitedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var typeOnlyExportStarMap *Map[__String /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, TODO]
		nonTypeOnlyNames := /* TODO(NewExpression): new Set<__String>() */ TODO
		/* TODO(ExpressionStatement): moduleSymbol = resolveExternalModuleSymbol(moduleSymbol); */
		exports := visit(moduleSymbol) || emptySymbols
		if typeOnlyExportStarMap {
			/* TODO(PropertyAccessExpression): nonTypeOnlyNames.forEach */ TODO( /* TODO(ArrowFunction): name => typeOnlyExportStarMap!.delete(name) */ TODO)
		}
		return /* TODO(ObjectLiteralExpression): {             exports,             typeOnlyExportStarMap,         } */ TODO
		visit := func(symbol *Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
			if !isTypeOnly && /* TODO(PropertyAccessExpression): symbol?.exports */ TODO {
				/* TODO(PropertyAccessExpression): symbol.exports.forEach */ TODO( /* TODO(ArrowFunction): (_, name) => nonTypeOnlyNames.add(name) */ TODO)
			}
			if ! /* TODO(ParenthesizedExpression): (symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) */ TODO {
				return
			}
			symbols := /* TODO(NewExpression): new Map(symbol.exports) */ TODO
			exportStars := /* TODO(PropertyAccessExpression): symbol.exports.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportStar */ TODO)
			if exportStars {
				nestedSymbols := createSymbolTable()
				var lookupTable ExportCollisionTrackerTable = /* TODO(NewExpression): new Map() */ TODO
				if /* TODO(PropertyAccessExpression): exportStars.declarations */ TODO {
					for _, node := range /* TODO(PropertyAccessExpression): exportStars.declarations */ TODO {
						resolvedModule := resolveExternalModuleName(node /* TODO(NonNullExpression): (node as ExportDeclaration).moduleSpecifier! */, TODO)
						exportedSymbols := visit(resolvedModule, node /* as */ /* TODO(TypeReference): ExportDeclaration */, isTypeOnly || /* TODO(PropertyAccessExpression): (node as ExportDeclaration).isTypeOnly */ TODO)
						extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node /* as */ /* TODO(TypeReference): ExportDeclaration */)
					}
				}
				/* TODO(PropertyAccessExpression): lookupTable.forEach */ TODO( /* TODO(ArrowFunction): ({ exportsWithDuplicate }, id) => {                     // It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself                     if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {                         return;                     }                     for (const node of exportsWithDuplicate) {                         diagnostics.add(createDiagnosticForNode(                             node,                             Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity,                             lookupTable.get(id)!.specifierText,                             unescapeLeadingUnderscores(id),                         ));                     }                 } */ TODO)
				extendExportSymbols(symbols, nestedSymbols)
			}
			if /* TODO(PropertyAccessExpression): exportStar?.isTypeOnly */ TODO {
				/* TODO(ExpressionStatement): typeOnlyExportStarMap ??= new Map(); */
				/* TODO(PropertyAccessExpression): symbols.forEach */
				TODO( /* TODO(ArrowFunction): (_, escapedName) =>                     typeOnlyExportStarMap!.set(                         escapedName,                         exportStar as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; },                     ) */ TODO)
			}
			return symbols
		}
	}
	// OVERLOAD: getMergedSymbol := func(symbol Symbol) Symbol
	// OVERLOAD: getMergedSymbol := func(symbol *Symbol) *Symbol
	getMergedSymbol := func(symbol *Symbol) *Symbol {
		var merged Symbol
		return /* TODO(ConditionalExpression): symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol */ TODO
	}
	getSymbolOfDeclaration := func(node Declaration) Symbol {
		return getMergedSymbol( /* TODO(PropertyAccessExpression): node.symbol */ TODO && getLateBoundSymbol( /* TODO(PropertyAccessExpression): node.symbol */ TODO))
	}
	getSymbolOfNode := func(node Node) *Symbol {
		return /* TODO(ConditionalExpression): canHaveSymbol(node) ? getSymbolOfDeclaration(node) : undefined */ TODO
	}
	getParentOfSymbol := func(symbol Symbol) *Symbol {
		return getMergedSymbol( /* TODO(PropertyAccessExpression): symbol.parent */ TODO && getLateBoundSymbol( /* TODO(PropertyAccessExpression): symbol.parent */ TODO))
	}
	getFunctionExpressionParentSymbolOrSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		return /* TODO(ConditionalExpression): symbol.valueDeclaration?.kind === SyntaxKind.ArrowFunction || symbol.valueDeclaration?.kind === SyntaxKind.FunctionExpression             ? getSymbolOfNode(symbol.valueDeclaration.parent) || symbol             : symbol */ TODO
	}
	getAlternativeContainingModules := func(symbol Symbol, enclosingDeclaration Node) []Symbol {
		containingFile := getSourceFileOfNode(enclosingDeclaration)
		id := getNodeId(containingFile)
		links := getSymbolLinks(symbol)
		var results /* TODO(ArrayType): Symbol[] */ any
		if /* TODO(PropertyAccessExpression): links.extendedContainersByFile */ TODO && /* TODO(ParenthesizedExpression): (results = links.extendedContainersByFile.get(id)) */ TODO {
			return results
		}
		if containingFile && /* TODO(PropertyAccessExpression): containingFile.imports */ TODO {
			for _, importRef := range /* TODO(PropertyAccessExpression): containingFile.imports */ TODO {
				if nodeIsSynthesized(importRef) {
				}
				resolvedModule := resolveExternalModuleName(enclosingDeclaration, importRef /* TODO(TrueKeyword): true */, TODO)
				if !resolvedModule {
				}
				ref := getAliasForSymbolInContainer(resolvedModule, symbol)
				if !ref {
				}
				/* TODO(ExpressionStatement): results = append(results, resolvedModule); */
			}
			if length(results) {
				/* TODO(PropertyAccessExpression): (links.extendedContainersByFile || (links.extendedContainersByFile = new Map())).set */ TODO(id /* TODO(NonNullExpression): results! */, TODO)
				return /* TODO(NonNullExpression): results! */ TODO
			}
		}
		if /* TODO(PropertyAccessExpression): links.extendedContainers */ TODO {
			return /* TODO(PropertyAccessExpression): links.extendedContainers */ TODO
		}
		otherFiles := /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO()
		for _, file := range otherFiles {
			if !isExternalModule(file) {
			}
			sym := getSymbolOfDeclaration(file)
			ref := getAliasForSymbolInContainer(sym, symbol)
			if !ref {
			}
			/* TODO(ExpressionStatement): results = append(results, sym); */
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.extendedContainers = results || emptyArray */ TODO
	}
	getContainersOfSymbol := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(ArrayType): Symbol[] */ any {
		container := getParentOfSymbol(symbol)
		if container && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.TypeParameter) */ TODO {
			return getWithAlternativeContainers(container)
		}
		candidates := mapDefined( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => {             if (!isAmbientModule(d) && d.parent) {                 // direct children of a module                 if (hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {                     return getSymbolOfDeclaration(d.parent as Declaration);                 }                 // export ='d member of an ambient module                 if (isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) === symbol) {                     return getSymbolOfDeclaration(d.parent.parent);                 }             }             if (isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind === SyntaxKind.EqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression)) {                 if (isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression)) {                     return getSymbolOfDeclaration(getSourceFileOfNode(d));                 }                 checkExpressionCached(d.parent.left.expression);                 return getNodeLinks(d.parent.left.expression).resolvedSymbol;             }         } */, TODO)
		if !length(candidates) {
			return nil
		}
		containers := mapDefined(candidates /* TODO(ArrowFunction): candidate => getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined */, TODO)
		var bestContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var alternativeContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, container := range containers {
			TODO_IDENTIFIER := getWithAlternativeContainers(container)
			/* TODO(ExpressionStatement): bestContainers = append(bestContainers, bestMatch); */
			/* TODO(ExpressionStatement): alternativeContainers = addRange(alternativeContainers, rest); */
		}
		return concatenate(bestContainers, alternativeContainers)
		getWithAlternativeContainers := func(container Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			additionalContainers := mapDefined( /* TODO(PropertyAccessExpression): container.declarations */ TODO, fileSymbolIfFileSymbolExportEqualsContainer)
			reexportContainers := enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration)
			objectLiteralContainer := getVariableDeclarationOfObjectLiteral(container, meaning)
			if enclosingDeclaration && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): container.flags & getQualifiedLeftMeaning(meaning) */ TODO && getAccessibleSymbolChain(container, enclosingDeclaration /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */, TODO /* TODO(FalseKeyword): false */, TODO) {
				return append(concatenate(concatenate( /* TODO(ArrayLiteralExpression): [container] */ TODO, additionalContainers), reexportContainers), objectLiteralContainer)
			}
			firstVariableMatch := /* TODO(ConditionalExpression): !(container.flags & getQualifiedLeftMeaning(meaning))                     && container.flags & SymbolFlags.Type                     && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object                     && meaning === SymbolFlags.Value                 ? forEachSymbolTableInScope(enclosingDeclaration, t => {                     return forEachEntry(t, s => {                         if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {                             return s;                         }                     });                 }) : undefined */ TODO
			res := /* TODO(ConditionalExpression): firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container] */ TODO
			/* TODO(ExpressionStatement): res = append(res, objectLiteralContainer); */
			/* TODO(ExpressionStatement): res = addRange(res, reexportContainers); */
			return res
		}
		fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container)
		}
	}
	getVariableDeclarationOfObjectLiteral := func(symbol Symbol, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var firstDecl /* TODO(UnionType): Node | false */ any = !!length( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO) && first( /* TODO(NonNullExpression): symbol.declarations! */ TODO)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & SymbolFlags.Value */ TODO && firstDecl && /* TODO(PropertyAccessExpression): firstDecl.parent */ TODO && isVariableDeclaration( /* TODO(PropertyAccessExpression): firstDecl.parent */ TODO) {
			if isObjectLiteralExpression(firstDecl) && firstDecl == /* TODO(PropertyAccessExpression): firstDecl.parent.initializer */ TODO || isTypeLiteralNode(firstDecl) && firstDecl == /* TODO(PropertyAccessExpression): firstDecl.parent.type */ TODO {
				return getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): firstDecl.parent */ TODO)
			}
		}
	}
	getFileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration, container Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		fileSymbol := getExternalModuleContainer(d)
		exported := fileSymbol && /* TODO(PropertyAccessExpression): fileSymbol.exports */ TODO && /* TODO(PropertyAccessExpression): fileSymbol.exports.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
		return /* TODO(ConditionalExpression): exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined */ TODO
	}
	getAliasForSymbolInContainer := func(container Symbol, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if container == getParentOfSymbol(symbol) {
			return symbol
		}
		exportEquals := /* TODO(PropertyAccessExpression): container.exports */ TODO && /* TODO(PropertyAccessExpression): container.exports.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
		if exportEquals && getSymbolIfSameReference(exportEquals, symbol) {
			return container
		}
		exports := getExportsOfSymbol(container)
		quick := /* TODO(PropertyAccessExpression): exports.get */ TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
		if quick && getSymbolIfSameReference(quick, symbol) {
			return quick
		}
		return forEachEntry(exports /* TODO(ArrowFunction): exported => {             if (getSymbolIfSameReference(exported, symbol)) {                 return exported;             }         } */, TODO)
	}
	getSymbolIfSameReference := func(s1 Symbol, s2 Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) == getMergedSymbol(resolveSymbol(getMergedSymbol(s2))) {
			return s1
		}
	}
	// OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol Symbol) Symbol
	// OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol
	getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol {
		return getMergedSymbol(symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.ExportValue) !== 0 */ TODO && /* TODO(PropertyAccessExpression): symbol.exportSymbol */ TODO || symbol)
	}
	symbolIsValue := func(symbol Symbol, includeTypeOnlyMembers bool) bool {
		return !! /* TODO(ParenthesizedExpression): (             symbol.flags & SymbolFlags.Value ||             symbol.flags & SymbolFlags.Alias && getSymbolFlags(symbol, !includeTypeOnlyMembers) & SymbolFlags.Value         ) */ TODO
	}
	createType := func(flags TypeFlags) Type {
		result := /* TODO(NewExpression): new Type(checker, flags) */ TODO
		/* TODO(ExpressionStatement): typeCount++; */
		/* TODO(ExpressionStatement): result.id = typeCount; */
		/* TODO(PropertyAccessExpression): tracing?.recordType */
		TODO(result)
		return result
	}
	createTypeWithSymbol := func(flags TypeFlags, symbol Symbol) Type {
		result := createType(flags)
		/* TODO(ExpressionStatement): result.symbol = symbol; */
		return result
	}
	createOriginType := func(flags TypeFlags) Type {
		return /* TODO(NewExpression): new Type(checker, flags) */ TODO
	}
	createIntrinsicType := func(kind TypeFlags, intrinsicName string, objectFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
		checkIntrinsicName(intrinsicName, debugIntrinsicName)
		type_ := createType(kind) /* as */ /* TODO(TypeReference): IntrinsicType */
		/* TODO(ExpressionStatement): type.intrinsicName = intrinsicName; */
		/* TODO(ExpressionStatement): type.debugIntrinsicName = debugIntrinsicName; */
		/* TODO(ExpressionStatement): type.objectFlags = objectFlags | ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.IsGenericTypeComputed | ObjectFlags.IsUnknownLikeUnionComputed | ObjectFlags.IsNeverIntersectionComputed; */
		return type_
	}
	checkIntrinsicName := func(name string, debug /* TODO(StringKeyword): string */ any) {
		key := /* TODO(TemplateExpression): `${name},${debug ?? ""}` */ TODO
		if /* TODO(PropertyAccessExpression): seenIntrinsicNames.has */ TODO(key) {
			/* TODO(PropertyAccessExpression): Debug.fail */ TODO( /* TODO(TemplateExpression): `Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.` */ TODO)
		}
		/* TODO(PropertyAccessExpression): seenIntrinsicNames.add */ TODO(key)
	}
	createObjectType := func(objectFlags ObjectFlags, symbol Symbol) ObjectType {
		type_ := createTypeWithSymbol( /* TODO(PropertyAccessExpression): TypeFlags.Object */ TODO /* TODO(NonNullExpression): symbol! */, TODO) /* as */ /* TODO(TypeReference): ObjectType */
		/* TODO(ExpressionStatement): type.objectFlags = objectFlags; */
		/* TODO(ExpressionStatement): type.members = undefined; */
		/* TODO(ExpressionStatement): type.properties = undefined; */
		/* TODO(ExpressionStatement): type.callSignatures = undefined; */
		/* TODO(ExpressionStatement): type.constructSignatures = undefined; */
		/* TODO(ExpressionStatement): type.indexInfos = undefined; */
		return type_
	}
	createTypeofType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getUnionType(arrayFrom( /* TODO(PropertyAccessExpression): typeofNEFacts.keys */ TODO(), getStringLiteralType))
	}
	createTypeParameter := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
		return createTypeWithSymbol( /* TODO(PropertyAccessExpression): TypeFlags.TypeParameter */ TODO /* TODO(NonNullExpression): symbol! */, TODO) /* as */ /* TODO(TypeReference): TypeParameter */
	}
	isReservedMemberName := func(name __String) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): (name as string).charCodeAt */ TODO(0) == /* TODO(PropertyAccessExpression): CharacterCodes._ */ TODO && /* TODO(PropertyAccessExpression): (name as string).charCodeAt */ TODO(1) == /* TODO(PropertyAccessExpression): CharacterCodes._ */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (name as string).charCodeAt(2) !== CharacterCodes._ */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (name as string).charCodeAt(2) !== CharacterCodes.at */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (name as string).charCodeAt(2) !== CharacterCodes.hash */ TODO
	}
	getNamedMembers := func(members SymbolTable) []Symbol {
		var result /* TODO(ArrayType): Symbol[] */ any
		/* TODO(PropertyAccessExpression): members.forEach */ TODO( /* TODO(ArrowFunction): (symbol, id) => {             if (isNamedMember(symbol, id)) {                 (result || (result = [])).push(symbol);             }         } */ TODO)
		return result || emptyArray
	}
	isNamedMember := func(member Symbol, escapedName __String) /* TODO(undefined): boolean */ TODO {
		return !isReservedMemberName(escapedName) && symbolIsValue(member)
	}
	getNamedOrIndexSignatureMembers := func(members SymbolTable) []Symbol {
		result := getNamedMembers(members)
		index := getIndexSymbolFromSymbolTable(members)
		return /* TODO(ConditionalExpression): index ? concatenate(result, [index]) : result */ TODO
	}
	setStructuredTypeMembers := func(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		resolved := type_ /* as */ /* TODO(TypeReference): ResolvedType */
		/* TODO(ExpressionStatement): resolved.members = members; */
		/* TODO(ExpressionStatement): resolved.properties = emptyArray; */
		/* TODO(ExpressionStatement): resolved.callSignatures = callSignatures; */
		/* TODO(ExpressionStatement): resolved.constructSignatures = constructSignatures; */
		/* TODO(ExpressionStatement): resolved.indexInfos = indexInfos; */
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): members !== emptySymbols */ TODO {
			/* TODO(BinaryExpression): resolved.properties = getNamedMembers(members) */
		}
		return resolved
	}
	createAnonymousType := func(symbol *Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		return setStructuredTypeMembers(createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO, symbol), members, callSignatures, constructSignatures, indexInfos)
	}
	getResolvedTypeWithoutAbstractConstructSignatures := func(type_ ResolvedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if /* TODO(PropertyAccessExpression): type.constructSignatures.length */ TODO == 0 {
			/* TODO(Identifier): type */
		}
		if /* TODO(PropertyAccessExpression): type.objectTypeWithoutAbstractConstructSignatures */ TODO {
			/* TODO(PropertyAccessExpression): type.objectTypeWithoutAbstractConstructSignatures */
		}
		constructSignatures := filter( /* TODO(PropertyAccessExpression): type.constructSignatures */ TODO /* TODO(ArrowFunction): signature => !(signature.flags & SignatureFlags.Abstract) */, TODO)
		if /* TODO(PropertyAccessExpression): type.constructSignatures */ TODO == constructSignatures {
			/* TODO(Identifier): type */
		}
		typeCopy := createAnonymousType( /* TODO(PropertyAccessExpression): type.symbol */ TODO /* TODO(PropertyAccessExpression): type.members */, TODO /* TODO(PropertyAccessExpression): type.callSignatures */, TODO /* TODO(ConditionalExpression): some(constructSignatures) ? constructSignatures : emptyArray */, TODO /* TODO(PropertyAccessExpression): type.indexInfos */, TODO)
		/* TODO(ExpressionStatement): type.objectTypeWithoutAbstractConstructSignatures = typeCopy; */
		/* TODO(ExpressionStatement): typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy; */
		return typeCopy
	}
	forEachSymbolTableInScope := func(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
		var result T
		/* TODO(ForStatement): for (let location = enclosingDeclaration; location; location = location.parent) {             // Locals of a source file are not in scope (because they get merged into the global symbol table)             if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                 if (result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                     return result;                 }             }             switch (location.kind) {                 case SyntaxKind.SourceFile:                     if (!isExternalOrCommonJsModule(location as SourceFile)) {                         break;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                     const sym = getSymbolOfDeclaration(location as ModuleDeclaration);                     // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten                     // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred                     // to one another anyway)                     if (result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                         return result;                     }                     break;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                     // Type parameters are bound into `members` lists so they can merge across declarations                     // This is troublesome, since in all other respects, they behave like locals :cries:                     // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol                     // lookup logic in terms of `resolveName` would be nice                     // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals                     // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would                     // trigger resolving late-bound names, which we may already be in the process of doing while we're here!                     let table: Map<__String, Symbol> | undefined;                     // TODO: Should this filtered table be cached in some way?                     (getSymbolOfDeclaration(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols).forEach((memberSymbol, key) => {                         if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) {                             (table || (table = createSymbolTable())).set(key, memberSymbol);                         }                     });                     if (table && (result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location))) {                         return result;                     }                     break;             }         } */
		return callback(globals, nil /* TODO(TrueKeyword): true */, TODO)
	}
	getQualifiedLeftMeaning := func(rightMeaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Value | import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Namespace */ TODO {
		return /* TODO(ConditionalExpression): rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace */ TODO
	}
	getAccessibleSymbolChain := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap /* TODO(undefined): Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable[]> */ TODO /* = */ /* TODO(NewExpression): new Map<SymbolId, SymbolTable[]>() */) /* TODO(ArrayType): Symbol[] */ any {
		if ! /* TODO(ParenthesizedExpression): (symbol && !isPropertyOrMethodDeclarationSymbol(symbol)) */ TODO {
			return nil
		}
		links := getSymbolLinks(symbol)
		cache := /* TODO(ParenthesizedExpression): (links.accessibleChainCache ||= new Map()) */ TODO
		firstRelevantLocation := forEachSymbolTableInScope(enclosingDeclaration /* TODO(ArrowFunction): (_, __, ___, node) => node */, TODO)
		key := /* TODO(TemplateExpression): `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}` */ TODO
		if /* TODO(PropertyAccessExpression): cache.has */ TODO(key) {
			return /* TODO(PropertyAccessExpression): cache.get */ TODO(key)
		}
		id := getSymbolId(symbol)
		visitedSymbolTables := /* TODO(PropertyAccessExpression): visitedSymbolTablesMap.get */ TODO(id)
		if !visitedSymbolTables {
			/* TODO(PropertyAccessExpression): visitedSymbolTablesMap.set */ TODO(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): visitedSymbolTables = [] */, TODO)
		}
		result := forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
		/* TODO(PropertyAccessExpression): cache.set */ TODO(key, result)
		return result
		getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) /* TODO(ArrayType): Symbol[] */ any {
			if !pushIfUnique( /* TODO(NonNullExpression): visitedSymbolTables! */ TODO, symbols) {
				return nil
			}
			result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
			/* TODO(PropertyAccessExpression): visitedSymbolTables!.pop */ TODO()
			return result
		}
		canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) /* TODO(undefined): boolean */ TODO {
			return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) || !!getAccessibleSymbolChain( /* TODO(PropertyAccessExpression): symbolFromSymbolTable.parent */ TODO, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
		}
		isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) /* TODO(undefined): boolean */ TODO {
			return /* TODO(ParenthesizedExpression): (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) */ TODO && !some( /* TODO(PropertyAccessExpression): symbolFromSymbolTable.declarations */ TODO, hasNonGlobalAugmentationExternalModuleSymbol) && /* TODO(ParenthesizedExpression): (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning)) */ TODO
		}
		trySymbolTable := func(symbols SymbolTable, ignoreQualification /* TODO(BooleanKeyword): boolean */ any, isLocalNameLookup /* TODO(BooleanKeyword): boolean */ any) /* TODO(ArrayType): Symbol[] */ any {
			if isAccessible( /* TODO(NonNullExpression): symbols.get(symbol!.escapedName)! */ TODO, nil, ignoreQualification) {
				return /* TODO(ArrayLiteralExpression): [symbol!] */ TODO
			}
			result := forEachEntry(symbols /* TODO(ArrowFunction): symbolFromSymbolTable => {                 if (                     symbolFromSymbolTable.flags & SymbolFlags.Alias                     && symbolFromSymbolTable.escapedName !== InternalSymbolName.ExportEquals                     && symbolFromSymbolTable.escapedName !== InternalSymbolName.Default                     && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration)))                     // If `!useOnlyExternalAliasing`, we can use any type of alias to get the name                     && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration))                     // If we're looking up a local name to reference directly, omit namespace reexports, otherwise when we're trawling through an export list to make a dotted name, we can keep it                     && (isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true)                     // While exports are generally considered to be in scope, export-specifier declared symbols are _not_                     // See similar comment in `resolveName` for details                     && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier))                 ) {                     const resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);                     const candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);                     if (candidate) {                         return candidate;                     }                 }                 if (symbolFromSymbolTable.escapedName === symbol!.escapedName && symbolFromSymbolTable.exportSymbol) {                     if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), /*resolvedAliasSymbol* / undefined, ignoreQualification)) {                         return [symbol!];                     }                 }             } */, TODO)
			return result || /* TODO(ParenthesizedExpression): (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined) */ TODO
		}
		getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification /* TODO(BooleanKeyword): boolean */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
			if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
				return /* TODO(ArrayLiteralExpression): [symbolFromSymbolTable] */ TODO
			}
			candidateTable := getExportsOfSymbol(resolvedImportedSymbol)
			accessibleSymbolsFromExports := candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable /* TODO(TrueKeyword): true */, TODO)
			if accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning)) {
				return /* TODO(PropertyAccessExpression): [symbolFromSymbolTable].concat */ TODO(accessibleSymbolsFromExports)
			}
		}
	}
	needsQualification := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(undefined): boolean */ TODO {
		qualify := /* TODO(FalseKeyword): false */ TODO
		forEachSymbolTableInScope(enclosingDeclaration /* TODO(ArrowFunction): symbolTable => {             // If symbol of this name is not available in the symbol table we are ok             let symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.escapedName));             if (!symbolFromSymbolTable) {                 // Continue to the next symbol table                 return false;             }             // If the symbol with this name is present it should refer to the symbol             if (symbolFromSymbolTable === symbol) {                 // No need to qualify                 return true;             }              // Qualify if the symbol from symbol table has same meaning as expected             const shouldResolveAlias = symbolFromSymbolTable.flags & SymbolFlags.Alias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKind.ExportSpecifier);             symbolFromSymbolTable = shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;             const flags = shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags;             if (flags & meaning) {                 qualify = true;                 return true;             }              // Continue to the next symbol table             return false;         } */, TODO)
		return qualify
	}
	isPropertyOrMethodDeclarationSymbol := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.length */ TODO {
			for _, declaration := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
				/* TODO(SwitchStatement): switch (declaration.kind) {                     case SyntaxKind.PropertyDeclaration:                     case SyntaxKind.MethodDeclaration:                     case SyntaxKind.GetAccessor:                     case SyntaxKind.SetAccessor:                         continue;                     default:                         return false;                 } */
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isTypeSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
		return /* TODO(PropertyAccessExpression): access.accessibility */ TODO == /* TODO(PropertyAccessExpression): SymbolAccessibility.Accessible */ TODO
	}
	isValueSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
		return /* TODO(PropertyAccessExpression): access.accessibility */ TODO == /* TODO(PropertyAccessExpression): SymbolAccessibility.Accessible */ TODO
	}
	isSymbolAccessibleByFlags := func(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		return /* TODO(PropertyAccessExpression): access.accessibility */ TODO == /* TODO(PropertyAccessExpression): SymbolAccessibility.Accessible */ TODO
	}
	isAnySymbolAccessible := func(symbols /* TODO(ArrayType): Symbol[] */ any, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
		if !length(symbols) {
		}
		var hadAccessibleChain *Symbol
		earlyModuleBail := /* TODO(FalseKeyword): false */ TODO
		for _, symbol := range /* TODO(NonNullExpression): symbols! */ TODO {
			accessibleSymbolChain := getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning /* TODO(FalseKeyword): false */, TODO)
			if accessibleSymbolChain {
				/* TODO(ExpressionStatement): hadAccessibleChain = symbol; */
				hasAccessibleDeclarations := hasVisibleDeclarations( /* TODO(ElementAccessExpression): accessibleSymbolChain[0] */ TODO, shouldComputeAliasesToMakeVisible)
				if hasAccessibleDeclarations {
					return hasAccessibleDeclarations
				}
			}
			if allowModules {
				if some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, hasNonGlobalAugmentationExternalModuleSymbol) {
					if shouldComputeAliasesToMakeVisible {
						/* TODO(ExpressionStatement): earlyModuleBail = true; */
						/* TODO(ContinueStatement): continue; */
					}
					return /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.Accessible,                     } */ TODO
				}
			}
			containers := getContainersOfSymbol(symbol, enclosingDeclaration, meaning)
			parentResult := isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol /* TODO(ConditionalExpression): initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning */, TODO, shouldComputeAliasesToMakeVisible, allowModules)
			if parentResult {
				return parentResult
			}
		}
		if earlyModuleBail {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.Accessible,             } */ TODO
		}
		if hadAccessibleChain {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),                 errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined,             } */ TODO
		}
	}
	isSymbolAccessible := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
		return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible /* TODO(TrueKeyword): true */, TODO)
	}
	isSymbolAccessibleWorker := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
		if symbol && enclosingDeclaration {
			result := isAnySymbolAccessible( /* TODO(ArrayLiteralExpression): [symbol] */ TODO, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
			if result {
				return result
			}
			symbolExternalModule := forEach( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, getExternalModuleContainer)
			if symbolExternalModule {
				enclosingExternalModule := getExternalModuleContainer(enclosingDeclaration)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbolExternalModule !== enclosingExternalModule */ TODO {
					return /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.CannotBeNamed,                         errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),                         errorModuleName: symbolToString(symbolExternalModule),                         errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,                     } */ TODO
				}
			}
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),             } */ TODO
		}
		return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
	}
	getExternalModuleContainer := func(declaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		node := findAncestor(declaration, hasExternalModuleSymbol)
		return node && getSymbolOfDeclaration(node /* as */ /* TODO(UnionType): AmbientModuleDeclaration | SourceFile */)
	}
	hasExternalModuleSymbol := func(declaration Node) /* TODO(undefined): boolean */ TODO {
		return isAmbientModule(declaration) || /* TODO(ParenthesizedExpression): (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile)) */ TODO
	}
	hasNonGlobalAugmentationExternalModuleSymbol := func(declaration Node) /* TODO(undefined): boolean */ TODO {
		return isModuleWithStringLiteralName(declaration) || /* TODO(ParenthesizedExpression): (declaration.kind === SyntaxKind.SourceFile && isExternalOrCommonJsModule(declaration as SourceFile)) */ TODO
	}
	hasVisibleDeclarations := func(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
		var aliasesToMakeVisible /* TODO(ArrayType): LateVisibilityPaintedStatement[] */ any
		if !every(filter( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => d.kind !== SyntaxKind.Identifier */, TODO), getIsDeclarationVisible) {
			return nil
		}
		return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible } */ TODO
		getIsDeclarationVisible := func(declaration Declaration) /* TODO(undefined): boolean */ TODO {
			if !isDeclarationVisible(declaration) {
				anyImportSyntax := getAnyImportSyntax(declaration)
				if anyImportSyntax && !hasSyntacticModifier(anyImportSyntax /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) && isDeclarationVisible( /* TODO(PropertyAccessExpression): anyImportSyntax.parent */ TODO) {
					return addVisibleAlias(declaration, anyImportSyntax)
				} else if isVariableDeclaration(declaration) && isVariableStatement( /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO) && !hasSyntacticModifier( /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) && isDeclarationVisible( /* TODO(PropertyAccessExpression): declaration.parent.parent.parent */ TODO) {
					return addVisibleAlias(declaration /* TODO(PropertyAccessExpression): declaration.parent.parent */, TODO)
				} else if isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) && isDeclarationVisible( /* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
					return addVisibleAlias(declaration, declaration)
				} else if isBindingElement(declaration) {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO && isInJSFile(declaration) && /* TODO(PropertyAccessExpression): declaration.parent?.parent */ TODO && isVariableDeclaration( /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO) && /* TODO(PropertyAccessExpression): declaration.parent.parent.parent?.parent */ TODO && isVariableStatement( /* TODO(PropertyAccessExpression): declaration.parent.parent.parent.parent */ TODO) && !hasSyntacticModifier( /* TODO(PropertyAccessExpression): declaration.parent.parent.parent.parent */ TODO /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) && /* TODO(PropertyAccessExpression): declaration.parent.parent.parent.parent.parent */ TODO && isDeclarationVisible( /* TODO(PropertyAccessExpression): declaration.parent.parent.parent.parent.parent */ TODO) {
						return addVisibleAlias(declaration /* TODO(PropertyAccessExpression): declaration.parent.parent.parent.parent */, TODO)
					} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.BlockScopedVariable */ TODO {
						variableStatement := /* TODO(NonNullExpression): findAncestor(declaration, isVariableStatement)! */ TODO
						if hasSyntacticModifier(variableStatement /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) {
							return /* TODO(TrueKeyword): true */ TODO
						}
						if !isDeclarationVisible( /* TODO(PropertyAccessExpression): variableStatement.parent */ TODO) {
							return /* TODO(FalseKeyword): false */ TODO
						}
						return addVisibleAlias(declaration, variableStatement)
					}
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) /* TODO(undefined): boolean */ TODO {
			if shouldComputeAliasToMakeVisible {
				/* TODO(ExpressionStatement): getNodeLinks(declaration).isVisible = true; */
				/* TODO(ExpressionStatement): aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement); */
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
	}
	getMeaningOfEntityNameReference := func(entityName EntityNameOrEntityNameExpression) SymbolFlags {
		var meaning SymbolFlags
		if /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeQuery */ TODO || /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExpressionWithTypeArguments */ TODO && !isPartOfTypeNode( /* TODO(PropertyAccessExpression): entityName.parent */ TODO) || /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO || /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypePredicate */ TODO && /* TODO(PropertyAccessExpression): (entityName.parent as TypePredicateNode).parameterName */ TODO == entityName {
			/* TODO(ExpressionStatement): meaning = SymbolFlags.Value | SymbolFlags.ExportValue; */
		} else if /* TODO(PropertyAccessExpression): entityName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.QualifiedName */ TODO || /* TODO(PropertyAccessExpression): entityName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO || /* TODO(PropertyAccessExpression): entityName.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */ TODO || /* TODO(ParenthesizedExpression): (entityName.parent.kind === SyntaxKind.QualifiedName && (entityName.parent as QualifiedName).left === entityName) */ TODO || /* TODO(ParenthesizedExpression): (entityName.parent.kind === SyntaxKind.PropertyAccessExpression && (entityName.parent as PropertyAccessExpression).expression === entityName) */ TODO || /* TODO(ParenthesizedExpression): (entityName.parent.kind === SyntaxKind.ElementAccessExpression && (entityName.parent as ElementAccessExpression).expression === entityName) */ TODO {
			/* TODO(ExpressionStatement): meaning = SymbolFlags.Namespace; */
		} else {
			/* TODO(ExpressionStatement): meaning = SymbolFlags.Type; */
		}
		return meaning
	}
	isEntityNameVisible := func(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) SymbolVisibilityResult {
		meaning := getMeaningOfEntityNameReference(entityName)
		firstIdentifier := getFirstIdentifier(entityName)
		symbol := resolveName(enclosingDeclaration /* TODO(PropertyAccessExpression): firstIdentifier.escapedText */, TODO, meaning, nil /* TODO(FalseKeyword): false */, TODO)
		if symbol && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): meaning & SymbolFlags.Type */ TODO {
			return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol && isThisIdentifier(firstIdentifier) && /* TODO(PropertyAccessExpression): isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false)), firstIdentifier, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility */ TODO == /* TODO(PropertyAccessExpression): SymbolAccessibility.Accessible */ TODO {
			return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotResolved,                 errorSymbolName: getTextOfNode(firstIdentifier),                 errorNode: firstIdentifier,             } */ TODO
		}
		return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || /* TODO(ObjectLiteralExpression): {             accessibility: SymbolAccessibility.NotAccessible,             errorSymbolName: getTextOfNode(firstIdentifier),             errorNode: firstIdentifier,         } */ TODO
	}
	symbolToString := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /* = */ /* TODO(PropertyAccessExpression): SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
		nodeFlags := /* TODO(PropertyAccessExpression): NodeBuilderFlags.IgnoreErrors */ TODO
		internalNodeFlags := /* TODO(PropertyAccessExpression): InternalNodeBuilderFlags.None */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFormatFlags.UseOnlyExternalAliasing */ TODO {
			/* TODO(ExpressionStatement): nodeFlags |= NodeBuilderFlags.UseOnlyExternalAliasing; */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFormatFlags.WriteTypeParametersOrArguments */ TODO {
			/* TODO(ExpressionStatement): nodeFlags |= NodeBuilderFlags.WriteTypeParametersInQualifiedName; */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFormatFlags.UseAliasDefinedOutsideCurrentScope */ TODO {
			/* TODO(ExpressionStatement): nodeFlags |= NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope; */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFormatFlags.DoNotIncludeSymbolChain */ TODO {
			/* TODO(ExpressionStatement): internalNodeFlags |= InternalNodeBuilderFlags.DoNotIncludeSymbolChain; */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & SymbolFormatFlags.WriteComputedProps */ TODO {
			/* TODO(ExpressionStatement): internalNodeFlags |= InternalNodeBuilderFlags.WriteComputedProps; */
		}
		builder := /* TODO(ConditionalExpression): flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName */ TODO
		return /* TODO(ConditionalExpression): writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker) */ TODO
		symbolToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			entity := /* TODO(NonNullExpression): builder(symbol, meaning!, enclosingDeclaration, nodeFlags, internalNodeFlags)! */ TODO
			printer := /* TODO(ConditionalExpression): enclosingDeclaration?.kind === SyntaxKind.SourceFile                 ? createPrinterWithRemoveCommentsNeverAsciiEscape()                 : createPrinterWithRemoveComments() */ TODO
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			/* TODO(PropertyAccessExpression): printer.writeNode */ TODO( /* TODO(PropertyAccessExpression): EmitHint.Unspecified */ TODO, entity, sourceFile, writer)
			return writer
		}
	}
	signatureToString := func(signature Signature, enclosingDeclaration Node, flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
		return /* TODO(ConditionalExpression): writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker) */ TODO
		signatureToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			var sigOutput SyntaxKind
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFormatFlags.WriteArrowStyleSignature */ TODO {
				/* TODO(ExpressionStatement): sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType; */
			} else {
				/* TODO(ExpressionStatement): sigOutput = kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature; */
			}
			sig := /* TODO(PropertyAccessExpression): nodeBuilder.signatureToSignatureDeclaration */ TODO(signature, sigOutput, enclosingDeclaration /* TODO(BarToken): | */ /* TODO(BinaryExpression): toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName */, TODO)
			printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			/* TODO(PropertyAccessExpression): printer.writeNode */ TODO( /* TODO(PropertyAccessExpression): EmitHint.Unspecified */ TODO /* TODO(NonNullExpression): sig! */, TODO, sourceFile, getTrailingSemicolonDeferringWriter(writer))
			return writer
		}
	}
	typeToString := func(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /* = */ /* TODO(BinaryExpression): TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /* = */ /* TODO(CallExpression): createTextWriter("") */) string {
		noTruncation := /* TODO(PropertyAccessExpression): compilerOptions.noErrorTruncation */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFormatFlags.NoTruncation */ TODO
		typeNode := /* TODO(PropertyAccessExpression): nodeBuilder.typeToTypeNode */ TODO(type_, enclosingDeclaration /* TODO(BarToken): | */ /* TODO(BinaryExpression): toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | (noTruncation ? NodeBuilderFlags.NoTruncation : NodeBuilderFlags.None) */, TODO, nil)
		if typeNode == nil {
			/* TODO(CallExpression): Debug.fail("should always get typenode") */
		}
		printer := /* TODO(ConditionalExpression): type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults() */ TODO
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		/* TODO(PropertyAccessExpression): printer.writeNode */ TODO( /* TODO(PropertyAccessExpression): EmitHint.Unspecified */ TODO, typeNode, sourceFile, writer)
		result := /* TODO(PropertyAccessExpression): writer.getText */ TODO()
		maxLength := /* TODO(ConditionalExpression): noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2 */ TODO
		if maxLength && result && /* TODO(PropertyAccessExpression): result.length */ TODO >= maxLength {
			return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): result.substr(0, maxLength - "...".length) + "..." */ TODO
		}
		return result
	}
	getTypeNamesForErrorDisplay := func(left Type, right Type) /* TODO(TupleType): [string, string] */ TODO {
		leftStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left) */ TODO
		rightStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right) */ TODO
		if leftStr == rightStr {
			/* TODO(ExpressionStatement): leftStr = getTypeNameForErrorDisplay(left); */
			/* TODO(ExpressionStatement): rightStr = getTypeNameForErrorDisplay(right); */
		}
		return /* TODO(ArrayLiteralExpression): [leftStr, rightStr] */ TODO
	}
	getTypeNameForErrorDisplay := func(type_ Type) /* TODO(undefined): string */ TODO {
		return typeToString(type_, nil /* TODO(PropertyAccessExpression): TypeFormatFlags.UseFullyQualifiedType */, TODO)
	}
	symbolValueDeclarationIsContextSensitive := func(symbol Symbol) bool {
		return symbol && !! /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isExpression( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) && !isContextSensitive( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
	}
	toNodeBuilderFlags := func(flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.None */) NodeBuilderFlags {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFormatFlags.NodeBuilderFlagsMask */ TODO
	}
	isClassInstanceSide := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(PropertyAccessExpression): type.symbol */ TODO && !! /* TODO(ParenthesizedExpression): (type.symbol.flags & SymbolFlags.Class) */ TODO && /* TODO(ParenthesizedExpression): (type === getDeclaredTypeOfClassOrInterface(type.symbol) || (!!(type.flags & TypeFlags.Object) && !!(getObjectFlags(type) & ObjectFlags.IsClassInstanceClone))) */ TODO
	}
	getTypeFromTypeNodeWithoutContext := func(node TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeFromTypeNode(node)
	}
	createNodeBuilder := func() /* TODO(undefined): { typeToTypeNode: (type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeValue | undefined, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, addUndefined?: boolean | undefined, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeTypeForDeclaration: (declaration: import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeReturnTypeForSignature: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, kind: import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.Constructor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.GetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.SetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.CallSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.IndexSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructorType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.JSDocFunctionType, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | undefined; symbolToEntityName: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").EntityName | undefined; symbolToExpression: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; symbolToTypeParameterDeclarations: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] | undefined; symbolToNode: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined; } */ TODO {
		return /* TODO(ObjectLiteralExpression): {             typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeToTypeNodeHelper(type, context)),             typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typePredicateToTypePredicateNodeHelper(typePredicate, context)),             expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => expressionOrTypeToTypeNode(context, expr, type, addUndefined)),             serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeTypeForDeclaration(context, declaration, type, symbol)),             serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeReturnTypeForSignature(context, signature)),             indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, /*typeNode* / undefined)),             signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)),             symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToName(symbol, context, meaning, /*expectsIdentifier* / false)),             symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToExpression(symbol, context, meaning)),             symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)),             symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToParameterDeclaration(symbol, context)),             typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParameterToDeclaration(parameter, context)),             symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolTableToDeclarationStatements(symbolTable, context)),             symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToNode(symbol, context, meaning)),         } */ TODO
		// OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): false */ TODO) Type
		// OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): true */ TODO) *Type
		getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) *Type {
			type_ := getTypeFromTypeNodeWithoutContext(node)
			if ! /* TODO(PropertyAccessExpression): context.mapper */ TODO {
				/* TODO(Identifier): type */
			}
			mappedType := instantiateType(type_ /* TODO(PropertyAccessExpression): context.mapper */, TODO)
			return /* TODO(ConditionalExpression): noMappedTypes && mappedType !== type ? undefined : mappedType */ TODO
		}
		setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
			if !nodeIsSynthesized(range_) || ! /* TODO(ParenthesizedExpression): (range.flags & NodeFlags.Synthesized) */ TODO || ! /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): context.enclosingFile !== getSourceFileOfNode(getOriginalNode(range)) */ TODO {
				/* TODO(ExpressionStatement): range = factory.cloneNode(range); */
			}
			if range_ == location {
				/* TODO(Identifier): range */
			}
			if !location {
				return range_
			}
			original := /* TODO(PropertyAccessExpression): range.original */ TODO
			/* TODO(WhileStatement): while (original && original !== location) {                 original = original.original;             } */
			if !original {
				setOriginalNode(range_, location)
			}
			if /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO && /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO == getSourceFileOfNode(getOriginalNode(location)) {
				return setTextRangeWorker(range_, location)
			}
			return range_
		}
		expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			restoreFlags := saveRestoreFlags(context)
			if expr && ! /* TODO(ParenthesizedExpression): (context.internalFlags & InternalNodeBuilderFlags.NoSyntacticPrinter) */ TODO {
				/* TODO(PropertyAccessExpression): syntacticNodeBuilder.serializeTypeOfExpression */ TODO(expr, context, addUndefined)
			}
			/* TODO(ExpressionStatement): context.internalFlags |= InternalNodeBuilderFlags.NoSyntacticPrinter; */
			result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
			restoreFlags()
			return result
		}
		expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			if expr {
				typeNode := /* TODO(ConditionalExpression): isAssertionExpression(expr) ? expr.type                     : isJSDocTypeAssertion(expr) ? getJSDocTypeAssertionType(expr)                     : undefined */ TODO
				if typeNode && !isConstTypeReference(typeNode) {
					result := tryReuseExistingTypeNode(context, typeNode, type_ /* TODO(PropertyAccessExpression): expr.parent */, TODO, addUndefined)
					if result {
						return result
					}
				}
			}
			if addUndefined {
				/* TODO(ExpressionStatement): type = getOptionalType(type); */
			}
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			originalType := type_
			if addUndefined {
				/* TODO(ExpressionStatement): type = getOptionalType(type, !isParameter(host)); */
			}
			clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
			if clone {
				if addUndefined && containsNonMissingUndefinedType(type_) && !someType(getTypeFromTypeNode(context, typeNode) /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Undefined) */, TODO) {
					return /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO( /* TODO(ArrayLiteralExpression): [clone, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
				return clone
			}
			if addUndefined && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): originalType !== type */ TODO {
				cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
				if cloneMissingUndefined {
					return /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO( /* TODO(ArrayLiteralExpression): [cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
			}
			return nil
		}
		tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO /* = */ /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, annotationType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /* = */ /* TODO(CallExpression): getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			if annotationType && typeNodeIsEquivalentToType(host, type_, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) {
				result := tryReuseExistingTypeNodeHelper(context, existing)
				if result {
					return result
				}
			}
			return nil
		}
		symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.internalFlags & InternalNodeBuilderFlags.WriteComputedProps */ TODO {
				if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
					name := getNameOfDeclaration( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
					if name && isComputedPropertyName(name) {
						/* TODO(Identifier): name */
					}
				}
				nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
				if nameType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nameType.flags & (TypeFlags.EnumLiteral | TypeFlags.UniqueESSymbol) */ TODO {
					/* TODO(ExpressionStatement): context.enclosingDeclaration = nameType.symbol.valueDeclaration; */
					return /* TODO(PropertyAccessExpression): factory.createComputedPropertyName */ TODO(symbolToExpression( /* TODO(PropertyAccessExpression): nameType.symbol */ TODO, context, meaning))
				}
			}
			return symbolToExpression(symbol, context, meaning)
		}
		withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
			moduleResolverHost := /* TODO(ConditionalExpression): tracker?.trackSymbol ? tracker.moduleResolverHost :                 (internalFlags || InternalNodeBuilderFlags.None) & InternalNodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) :                 undefined */ TODO
			var context NodeBuilderContext = /* TODO(ObjectLiteralExpression): {                 enclosingDeclaration,                 enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),                 flags: flags || NodeBuilderFlags.None,                 internalFlags: internalFlags || InternalNodeBuilderFlags.None,                 tracker: undefined!,                 encounteredError: false,                 reportedDiagnostic: false,                 visitedTypes: undefined,                 symbolDepth: undefined,                 inferTypeParameters: undefined,                 approximateLength: 0,                 trackedSymbols: undefined,                 bundled: !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),                 truncating: false,                 usedSymbolNames: undefined,                 remappedSymbolNames: undefined,                 remappedSymbolReferences: undefined,                 reverseMappedStack: undefined,                 mustCreateTypeParameterSymbolList: true,                 typeParameterSymbolList: undefined,                 mustCreateTypeParametersNamesLookups: true,                 typeParameterNames: undefined,                 typeParameterNamesByText: undefined,                 typeParameterNamesByTextNextNameCount: undefined,                 mapper: undefined,             } */ TODO
			/* TODO(ExpressionStatement): context.tracker = new SymbolTrackerImpl(context, tracker, moduleResolverHost); */
			resultingNode := cb(context)
			if /* TODO(PropertyAccessExpression): context.truncating */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.NoTruncation */ TODO {
				/* TODO(PropertyAccessExpression): context.tracker.reportTruncationError */ TODO()
			}
			return /* TODO(ConditionalExpression): context.encounteredError ? undefined : resultingNode */ TODO
		}
		saveRestoreFlags := func(context NodeBuilderContext) /* TODO(undefined): () => void */ TODO {
			flags := /* TODO(PropertyAccessExpression): context.flags */ TODO
			internalFlags := /* TODO(PropertyAccessExpression): context.internalFlags */ TODO
			return restore
			restore := func() {
				/* TODO(ExpressionStatement): context.flags = flags; */
				/* TODO(ExpressionStatement): context.internalFlags = internalFlags; */
			}
		}
		checkTruncationLength := func(context NodeBuilderContext) bool {
			if /* TODO(PropertyAccessExpression): context.truncating */ TODO {
				/* TODO(PropertyAccessExpression): context.truncating */
			}
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): context.truncating = context.approximateLength > ((context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength) */ TODO
		}
		typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
			restoreFlags := saveRestoreFlags(context)
			typeNode := typeToTypeNodeWorker(type_, context)
			restoreFlags()
			return typeNode
		}
		typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
			if cancellationToken && /* TODO(PropertyAccessExpression): cancellationToken.throwIfCancellationRequested */ TODO {
				/* TODO(PropertyAccessExpression): cancellationToken.throwIfCancellationRequested */ TODO()
			}
			inTypeAlias := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.InTypeAlias */ TODO
			/* TODO(ExpressionStatement): context.flags &= ~NodeBuilderFlags.InTypeAlias; */
			if !type_ {
				if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection) */ TODO {
					/* TODO(ExpressionStatement): context.encounteredError = true; */
					return /* TODO(NonNullExpression): undefined! */ TODO
				}
				/* TODO(ExpressionStatement): context.approximateLength += 3; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO)
			}
			if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.NoTypeReduction) */ TODO {
				/* TODO(ExpressionStatement): type = getReducedType(type); */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO {
				if /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO {
					return /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(symbolToEntityNameNode( /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO), mapToTypeNodes( /* TODO(PropertyAccessExpression): type.aliasTypeArguments */ TODO, context))
				}
				if type_ == unresolvedType {
					return addSyntheticLeadingComment( /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* TODO(PropertyAccessExpression): SyntaxKind.MultiLineCommentTrivia */, TODO, "unresolved")
				}
				/* TODO(ExpressionStatement): context.approximateLength += 3; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(ConditionalExpression): type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Unknown */ TODO {
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.UnknownKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.String */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 6; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.StringKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Number */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 6; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.NumberKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.BigInt */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 6; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.BigIntKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Boolean */ TODO && ! /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 7; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.BooleanKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.EnumLike */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.EnumMember */ TODO {
					parentSymbol := /* TODO(NonNullExpression): getParentOfSymbol(type.symbol)! */ TODO
					parentName := symbolToTypeNode(parentSymbol, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
					if getDeclaredTypeOfSymbol(parentSymbol) == type_ {
						return parentName
					}
					memberName := symbolName( /* TODO(PropertyAccessExpression): type.symbol */ TODO)
					if isIdentifierText(memberName /* TODO(PropertyAccessExpression): ScriptTarget.ES5 */, TODO) {
						return appendReferenceToType(parentName /* as */ /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */, TODO(memberName, nil))
					}
					if isImportTypeNode(parentName) {
						/* TODO(ExpressionStatement): (parentName as any).isTypeOf = true; */
						return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(parentName /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(memberName)))
					} else if isTypeReferenceNode(parentName) {
						return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO( /* TODO(PropertyAccessExpression): parentName.typeName */ TODO) /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(memberName)))
					} else {
						return /* TODO(PropertyAccessExpression): Debug.fail */ TODO("Unhandled type node kind returned from `symbolToTypeNode`.")
					}
				}
				return symbolToTypeNode( /* TODO(PropertyAccessExpression): type.symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.StringLiteral */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += (type as StringLiteralType).value.length + 2; */
				return /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO(setEmitFlags( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO( /* TODO(PropertyAccessExpression): (type as StringLiteralType).value */ TODO, !! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType) */ TODO) /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */, TODO))
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.NumberLiteral */ TODO {
				value := /* TODO(PropertyAccessExpression): (type as NumberLiteralType).value */ TODO
				/* TODO(ExpressionStatement): context.approximateLength += ("" + value).length; */
				return /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO( /* TODO(ConditionalExpression): value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value) */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.BigIntLiteral */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += (pseudoBigIntToString((type as BigIntLiteralType).value).length) + 1; */
				return /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createBigIntLiteral */ TODO( /* TODO(PropertyAccessExpression): (type as BigIntLiteralType).value */ TODO))
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.BooleanLiteral */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += (type as IntrinsicType).intrinsicName.length; */
				return /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO( /* TODO(ConditionalExpression): (type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse() */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.UniqueESSymbol */ TODO {
				if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowUniqueESSymbolType) */ TODO {
					if isValueSymbolAccessible( /* TODO(PropertyAccessExpression): type.symbol */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO) {
						/* TODO(ExpressionStatement): context.approximateLength += 6; */
						return symbolToTypeNode( /* TODO(PropertyAccessExpression): type.symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
					}
					if /* TODO(PropertyAccessExpression): context.tracker.reportInaccessibleUniqueSymbolError */ TODO {
						/* TODO(PropertyAccessExpression): context.tracker.reportInaccessibleUniqueSymbolError */ TODO()
					}
				}
				/* TODO(ExpressionStatement): context.approximateLength += 13; */
				return /* TODO(PropertyAccessExpression): factory.createTypeOperatorNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.UniqueKeyword */ TODO /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO))
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Void */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 4; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.VoidKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Undefined */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 9; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.UndefinedKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Null */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 4; */
				return /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createNull */ TODO())
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 5; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.ESSymbol */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 6; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.NonPrimitive */ TODO {
				/* TODO(ExpressionStatement): context.approximateLength += 6; */
				return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.ObjectKeyword */ TODO)
			}
			if isThisTypeParameter(type_) {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.InObjectTypeLiteral */ TODO {
					if ! /* TODO(PropertyAccessExpression): context.encounteredError */ TODO && ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowThisInObjectLiteral) */ TODO {
						/* TODO(ExpressionStatement): context.encounteredError = true; */
					}
					/* TODO(PropertyAccessExpression): context.tracker.reportInaccessibleThisError */ TODO()
				}
				/* TODO(ExpressionStatement): context.approximateLength += 4; */
				return /* TODO(PropertyAccessExpression): factory.createThisTypeNode */ TODO()
			}
			if !inTypeAlias && /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO && /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration)) */ TODO {
				typeArgumentNodes := mapToTypeNodes( /* TODO(PropertyAccessExpression): type.aliasTypeArguments */ TODO, context)
				if isReservedMemberName( /* TODO(PropertyAccessExpression): type.aliasSymbol.escapedName */ TODO) && ! /* TODO(ParenthesizedExpression): (type.aliasSymbol.flags & SymbolFlags.Class) */ TODO {
					/* TODO(CallExpression): factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes) */
				}
				if length(typeArgumentNodes) == 1 && /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO == /* TODO(PropertyAccessExpression): globalArrayType.symbol */ TODO {
					return /* TODO(PropertyAccessExpression): factory.createArrayTypeNode */ TODO( /* TODO(ElementAccessExpression): typeArgumentNodes![0] */ TODO)
				}
				return symbolToTypeNode( /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO, typeArgumentNodes)
			}
			objectFlags := getObjectFlags(type_)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & ObjectFlags.Reference */ TODO {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object) */ TODO)
				return /* TODO(ConditionalExpression): (type as TypeReference).node ? visitAndTransformType(type as TypeReference, typeReferenceToTypeNode) : typeReferenceToTypeNode(type as TypeReference) */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & ObjectFlags.ClassOrInterface */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO && contains( /* TODO(PropertyAccessExpression): context.inferTypeParameters */ TODO, type_) {
					/* TODO(ExpressionStatement): context.approximateLength += symbolName(type.symbol).length + 6; */
					var constraintNode *TypeNode
					constraint := getConstraintOfTypeParameter(type_ /* as */ /* TODO(TypeReference): TypeParameter */)
					if constraint {
						inferredConstraint := getInferredTypeParameterConstraint(type_ /* as */ /* TODO(TypeReference): TypeParameter */ /* TODO(TrueKeyword): true */, TODO)
						if ! /* TODO(ParenthesizedExpression): (inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint)) */ TODO {
							/* TODO(ExpressionStatement): context.approximateLength += 9; */
							/* TODO(ExpressionStatement): constraintNode = constraint && typeToTypeNodeHelper(constraint, context); */
						}
					}
					return /* TODO(PropertyAccessExpression): factory.createInferTypeNode */ TODO(typeParameterToDeclarationWithConstraint(type_ /* as */ /* TODO(TypeReference): TypeParameter */, context, constraintNode))
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
					name := typeParameterToName(type_, context)
					/* TODO(ExpressionStatement): context.approximateLength += idText(name).length; */
					return /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(idText(name)), nil)
				}
				if /* TODO(PropertyAccessExpression): type.symbol */ TODO {
					return symbolToTypeNode( /* TODO(PropertyAccessExpression): type.symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
				}
				name := /* TODO(ConditionalExpression): (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ?                     (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?" */ TODO
				return /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(name), nil)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO && /* TODO(PropertyAccessExpression): (type as UnionType).origin */ TODO {
				/* TODO(ExpressionStatement): type = (type as UnionType).origin!; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.Union | TypeFlags.Intersection) */ TODO {
				types := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? formatUnionTypes((type as UnionType).types) : (type as IntersectionType).types */ TODO
				if length(types) == 1 {
					return typeToTypeNodeHelper( /* TODO(ElementAccessExpression): types[0] */ TODO, context)
				}
				typeNodes := mapToTypeNodes(types, context /* TODO(TrueKeyword): true */, TODO)
				if typeNodes && /* TODO(PropertyAccessExpression): typeNodes.length */ TODO > 0 {
					return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? factory.createUnionTypeNode(typeNodes) : factory.createIntersectionTypeNode(typeNodes) */ TODO
				} else {
					if ! /* TODO(PropertyAccessExpression): context.encounteredError */ TODO && ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowEmptyUnionOrIntersection) */ TODO {
						/* TODO(ExpressionStatement): context.encounteredError = true; */
					}
					return /* TODO(NonNullExpression): undefined! */ TODO
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & (ObjectFlags.Anonymous | ObjectFlags.Mapped) */ TODO {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object) */ TODO)
				return createAnonymousTypeNode(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Index */ TODO {
				indexedType := /* TODO(PropertyAccessExpression): (type as IndexType).type */ TODO
				/* TODO(ExpressionStatement): context.approximateLength += 6; */
				indexTypeNode := typeToTypeNodeHelper(indexedType, context)
				return /* TODO(PropertyAccessExpression): factory.createTypeOperatorNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */ TODO, indexTypeNode)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TemplateLiteral */ TODO {
				texts := /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).texts */ TODO
				types := /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).types */ TODO
				templateHead := /* TODO(PropertyAccessExpression): factory.createTemplateHead */ TODO( /* TODO(ElementAccessExpression): texts[0] */ TODO)
				templateSpans := /* TODO(PropertyAccessExpression): factory.createNodeArray */ TODO(map_(types /* TODO(ArrowFunction): (t, i) =>                         factory.createTemplateLiteralTypeSpan(                             typeToTypeNodeHelper(t, context),                             (i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(texts[i + 1]),                         ) */, TODO))
				/* TODO(ExpressionStatement): context.approximateLength += 2; */
				return /* TODO(PropertyAccessExpression): factory.createTemplateLiteralType */ TODO(templateHead, templateSpans)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.StringMapping */ TODO {
				typeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): (type as StringMappingType).type */ TODO, context)
				return symbolToTypeNode( /* TODO(PropertyAccessExpression): (type as StringMappingType).symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(ArrayLiteralExpression): [typeNode] */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.IndexedAccess */ TODO {
				objectTypeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO, context)
				indexTypeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO, context)
				/* TODO(ExpressionStatement): context.approximateLength += 2; */
				return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(objectTypeNode, indexTypeNode)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
				return visitAndTransformType(type_ /* TODO(ArrowFunction): type => conditionalTypeToTypeNode(type as ConditionalType) */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
				typeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO, context)
				noInferSymbol := isNoInferType(type_) && getGlobalTypeSymbol("NoInfer" /* as */ /* TODO(TypeReference): __String */ /* TODO(FalseKeyword): false */, TODO)
				return /* TODO(ConditionalExpression): noInferSymbol ? symbolToTypeNode(noInferSymbol, context, SymbolFlags.Type, [typeNode]) : typeNode */ TODO
			}
			return /* TODO(PropertyAccessExpression): Debug.fail */ TODO("Should be unreachable.")
			conditionalTypeToTypeNode := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ TODO {
				checkTypeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): type.checkType */ TODO, context)
				/* TODO(ExpressionStatement): context.approximateLength += 15; */
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO && /* TODO(PropertyAccessExpression): type.root.isDistributive */ TODO && ! /* TODO(ParenthesizedExpression): (type.checkType.flags & TypeFlags.TypeParameter) */ TODO {
					newParam := createTypeParameter(createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, "T" /* as */ /* TODO(TypeReference): __String */))
					name := typeParameterToName(newParam, context)
					newTypeVariable := /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(name)
					/* TODO(ExpressionStatement): context.approximateLength += 37; */
					newMapper := prependTypeMapping( /* TODO(PropertyAccessExpression): type.root.checkType */ TODO, newParam /* TODO(PropertyAccessExpression): type.mapper */, TODO)
					saveInferTypeParameters := /* TODO(PropertyAccessExpression): context.inferTypeParameters */ TODO
					/* TODO(ExpressionStatement): context.inferTypeParameters = type.root.inferTypeParameters; */
					extendsTypeNode := typeToTypeNodeHelper(instantiateType( /* TODO(PropertyAccessExpression): type.root.extendsType */ TODO, newMapper), context)
					/* TODO(ExpressionStatement): context.inferTypeParameters = saveInferTypeParameters; */
					trueTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context /* TODO(PropertyAccessExpression): type.root.node.trueType */, TODO), newMapper))
					falseTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context /* TODO(PropertyAccessExpression): type.root.node.falseType */, TODO), newMapper))
					return /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(checkTypeNode /* TODO(PropertyAccessExpression): factory.createInferTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(nil /* TODO(PropertyAccessExpression): factory.cloneNode */, TODO( /* TODO(PropertyAccessExpression): newTypeVariable.typeName */ TODO) /* as */ /* TODO(TypeReference): Identifier */)) /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO( /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(name)), typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): type.checkType */ TODO, context) /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */, TODO(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode) /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO)) /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO))
				}
				saveInferTypeParameters := /* TODO(PropertyAccessExpression): context.inferTypeParameters */ TODO
				/* TODO(ExpressionStatement): context.inferTypeParameters = type.root.inferTypeParameters; */
				extendsTypeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): type.extendsType */ TODO, context)
				/* TODO(ExpressionStatement): context.inferTypeParameters = saveInferTypeParameters; */
				trueTypeNode := typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type_))
				falseTypeNode := typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type_))
				return /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
			}
			typeToTypeNodeOrCircularityElision := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
					if /* TODO(PropertyAccessExpression): context.visitedTypes?.has */ TODO(getTypeId(type_)) {
						if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) */ TODO {
							/* TODO(ExpressionStatement): context.encounteredError = true; */
							/* TODO(PropertyAccessExpression): context.tracker?.reportCyclicStructureError */
							TODO()
						}
						return createElidedInformationPlaceholder(context)
					}
					return visitAndTransformType(type_ /* TODO(ArrowFunction): type => typeToTypeNodeHelper(type, context) */, TODO)
				}
				return typeToTypeNodeHelper(type_, context)
			}
			isMappedTypeHomomorphic := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
				return !!getHomomorphicTypeVariable(type_)
			}
			isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
				return !! /* TODO(PropertyAccessExpression): type.target */ TODO && isMappedTypeHomomorphic( /* TODO(PropertyAccessExpression): type.target */ TODO /* as */ /* TODO(TypeReference): MappedType */) && !isMappedTypeHomomorphic(type_)
			}
			createMappedTypeNodeFromType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").MappedTypeNode */ TODO {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object) */ TODO)
				readonlyToken := /* TODO(ConditionalExpression): type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined */ TODO
				questionToken := /* TODO(ConditionalExpression): type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined */ TODO
				var appropriateConstraintTypeNode TypeNode
				var newTypeVariable *TypeReferenceNode
				needsModifierPreservingWrapper := !isMappedTypeWithKeyofConstraintDeclaration(type_) && ! /* TODO(ParenthesizedExpression): (getModifiersTypeFromMappedType(type).flags & TypeFlags.Unknown) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO && ! /* TODO(ParenthesizedExpression): (getConstraintTypeFromMappedType(type).flags & TypeFlags.TypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type))?.flags! & TypeFlags.Index) */ TODO
				if isMappedTypeWithKeyofConstraintDeclaration(type_) {
					if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO {
						newParam := createTypeParameter(createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, "T" /* as */ /* TODO(TypeReference): __String */))
						name := typeParameterToName(newParam, context)
						/* TODO(ExpressionStatement): newTypeVariable = factory.createTypeReferenceNode(name); */
					}
					/* TODO(ExpressionStatement): appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKind.KeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type), context)); */
				} else if needsModifierPreservingWrapper {
					newParam := createTypeParameter(createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, "T" /* as */ /* TODO(TypeReference): __String */))
					name := typeParameterToName(newParam, context)
					/* TODO(ExpressionStatement): newTypeVariable = factory.createTypeReferenceNode(name); */
					/* TODO(ExpressionStatement): appropriateConstraintTypeNode = newTypeVariable; */
				} else {
					/* TODO(ExpressionStatement): appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type), context); */
				}
				typeParameterNode := typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
				nameTypeNode := /* TODO(ConditionalExpression): type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined */ TODO
				templateTypeNode := typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type_), !! /* TODO(ParenthesizedExpression): (getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional) */ TODO), context)
				mappedTypeNode := /* TODO(PropertyAccessExpression): factory.createMappedTypeNode */ TODO(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, nil)
				/* TODO(ExpressionStatement): context.approximateLength += 10; */
				result := setEmitFlags(mappedTypeNode /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */, TODO)
				if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO {
					originalConstraint := instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context /* TODO(PropertyAccessExpression): (type.declaration.typeParameter.constraint! as TypeOperatorNode).type */, TODO) /* as */ /* TODO(TypeReference): TypeParameter */) || unknownType /* TODO(PropertyAccessExpression): type.mapper */, TODO)
					return /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context) /* TODO(PropertyAccessExpression): factory.createInferTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(nil /* TODO(PropertyAccessExpression): factory.cloneNode */, TODO( /* TODO(PropertyAccessExpression): newTypeVariable!.typeName */ TODO) /* as */ /* TODO(TypeReference): Identifier */ /* TODO(ConditionalExpression): originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context) */, TODO)), result /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO))
				} else if needsModifierPreservingWrapper {
					return /* TODO(PropertyAccessExpression): factory.createConditionalTypeNode */ TODO(typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context) /* TODO(PropertyAccessExpression): factory.createInferTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(nil /* TODO(PropertyAccessExpression): factory.cloneNode */, TODO( /* TODO(PropertyAccessExpression): newTypeVariable!.typeName */ TODO) /* as */ /* TODO(TypeReference): Identifier */ /* TODO(PropertyAccessExpression): factory.createTypeOperatorNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */ TODO, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context)))), result /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO))
				}
				return result
			}
			createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
				typeId := /* TODO(PropertyAccessExpression): type.id */ TODO
				symbol := /* TODO(PropertyAccessExpression): type.symbol */ TODO
				if symbol {
					isInstantiationExpressionType := !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.InstantiationExpressionType) */ TODO
					if isInstantiationExpressionType {
						instantiationExpressionType := type_ /* as */ /* TODO(TypeReference): InstantiationExpressionType */
						existing := /* TODO(PropertyAccessExpression): instantiationExpressionType.node */ TODO
						if isTypeQueryNode(existing) {
							typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
							if typeNode {
								return typeNode
							}
						}
						if /* TODO(PropertyAccessExpression): context.visitedTypes?.has */ TODO(typeId) {
							return createElidedInformationPlaceholder(context)
						}
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
					isInstanceType := /* TODO(ConditionalExpression): isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
					if isJSConstructor( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO && !getBaseTypeVariableOfClass(symbol) && ! /* TODO(ParenthesizedExpression): (symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible)) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Enum | SymbolFlags.ValueModule) */ TODO || shouldWriteTypeOfFunctionSymbol() {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if /* TODO(PropertyAccessExpression): context.visitedTypes?.has */ TODO(typeId) {
						typeAlias := getTypeAliasForTypeLiteral(type_)
						if typeAlias {
							return symbolToTypeNode(typeAlias, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
						} else {
							return createElidedInformationPlaceholder(context)
						}
					} else {
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
				} else {
					return createTypeNodeFromObjectType(type_)
				}
				shouldWriteTypeOfFunctionSymbol := func() /* TODO(undefined): boolean | undefined */ TODO {
					isStaticMethodSymbol := !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Method) */ TODO && some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): declaration => isStatic(declaration) */, TODO)
					isNonLocalFunctionSymbol := !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Function) */ TODO && /* TODO(ParenthesizedExpression): (symbol.parent || // is exported function symbol                             forEach(symbol.declarations, declaration => declaration.parent.kind === SyntaxKind.SourceFile || declaration.parent.kind === SyntaxKind.ModuleBlock)) */ TODO
					if isStaticMethodSymbol || isNonLocalFunctionSymbol {
						return /* TODO(ParenthesizedExpression): (!!(context.flags & NodeBuilderFlags.UseTypeOfFunction) || (context.visitedTypes?.has(typeId))) */ TODO && /* TODO(ParenthesizedExpression): (!(context.flags & NodeBuilderFlags.UseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration)) */ TODO
					}
				}
			}
			visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				typeId := /* TODO(PropertyAccessExpression): type.id */ TODO
				isConstructorObject := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Anonymous */ TODO && /* TODO(PropertyAccessExpression): type.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.Class */ TODO
				id := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) :                     type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) :                     type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :                     undefined */ TODO
				if ! /* TODO(PropertyAccessExpression): context.visitedTypes */ TODO {
					/* TODO(ExpressionStatement): context.visitedTypes = new Set(); */
				}
				if id && ! /* TODO(PropertyAccessExpression): context.symbolDepth */ TODO {
					/* TODO(ExpressionStatement): context.symbolDepth = new Map(); */
				}
				links := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO && getNodeLinks( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
				key := /* TODO(TemplateExpression): `${getTypeId(type)}|${context.flags}|${context.internalFlags}` */ TODO
				if links {
					/* TODO(ExpressionStatement): links.serializedTypes ||= new Map(); */
				}
				cachedResult := /* TODO(PropertyAccessExpression): links?.serializedTypes?.get */ TODO(key)
				if cachedResult {
					/* TODO(PropertyAccessExpression): cachedResult.trackedSymbols?.forEach */ TODO( /* TODO(ArrowFunction): ([symbol, enclosingDeclaration, meaning]) =>                             context.tracker.trackSymbol(                                 symbol,                                 enclosingDeclaration,                                 meaning,                             ) */ TODO)
					if /* TODO(PropertyAccessExpression): cachedResult.truncating */ TODO {
						/* TODO(ExpressionStatement): context.truncating = true; */
					}
					/* TODO(ExpressionStatement): context.approximateLength += cachedResult.addedLength; */
					return deepCloneOrReuseNode( /* TODO(PropertyAccessExpression): cachedResult.node */ TODO)
				}
				var depth /* TODO(NumberKeyword): number */ any
				if id {
					/* TODO(ExpressionStatement): depth = context.symbolDepth!.get(id) || 0; */
					if depth > 10 {
						return createElidedInformationPlaceholder(context)
					}
					/* TODO(PropertyAccessExpression): context.symbolDepth!.set */ TODO(id /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO)
				}
				/* TODO(PropertyAccessExpression): context.visitedTypes.add */ TODO(typeId)
				prevTrackedSymbols := /* TODO(PropertyAccessExpression): context.trackedSymbols */ TODO
				/* TODO(ExpressionStatement): context.trackedSymbols = undefined; */
				startLength := /* TODO(PropertyAccessExpression): context.approximateLength */ TODO
				result := transform(type_)
				addedLength := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): context.approximateLength - startLength */ TODO
				if ! /* TODO(PropertyAccessExpression): context.reportedDiagnostic */ TODO && ! /* TODO(PropertyAccessExpression): context.encounteredError */ TODO {
					/* TODO(PropertyAccessExpression): links?.serializedTypes?.set */ TODO(key /* TODO(ObjectLiteralExpression): {                         node: result,                         truncating: context.truncating,                         addedLength,                         trackedSymbols: context.trackedSymbols,                     } */, TODO)
				}
				/* TODO(PropertyAccessExpression): context.visitedTypes.delete */ TODO(typeId)
				if id {
					/* TODO(PropertyAccessExpression): context.symbolDepth!.set */ TODO(id /* TODO(NonNullExpression): depth! */, TODO)
				}
				/* TODO(ExpressionStatement): context.trackedSymbols = prevTrackedSymbols; */
				return result
				deepCloneOrReuseNode := func(node T) T {
					if !nodeIsSynthesized(node) && getParseTreeNode(node) == node {
						return node
					}
					return setTextRange(context /* TODO(PropertyAccessExpression): factory.cloneNode */, TODO(visitEachChildWorker(node, deepCloneOrReuseNode, nil, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
				}
				deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					if nodes && /* TODO(PropertyAccessExpression): nodes.length */ TODO == 0 {
						return setTextRangeWorker( /* TODO(PropertyAccessExpression): factory.createNodeArray */ TODO(nil /* TODO(PropertyAccessExpression): nodes.hasTrailingComma */, TODO), nodes)
					}
					return visitNodes(nodes, visitor, test, start, count)
				}
			}
			createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
				if isGenericMappedType(type_) || /* TODO(PropertyAccessExpression): (type as MappedType).containsError */ TODO {
					return createMappedTypeNodeFromType(type_ /* as */ /* TODO(TypeReference): MappedType */)
				}
				resolved := resolveStructuredTypeMembers(type_)
				if ! /* TODO(PropertyAccessExpression): resolved.properties.length */ TODO && ! /* TODO(PropertyAccessExpression): resolved.indexInfos.length */ TODO {
					if ! /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO && ! /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO {
						/* TODO(ExpressionStatement): context.approximateLength += 2; */
						return setEmitFlags( /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(nil) /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */, TODO)
					}
					if /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO == 1 && ! /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO {
						signature := /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
						signatureNode := signatureToSignatureDeclarationHelper(signature /* TODO(PropertyAccessExpression): SyntaxKind.FunctionType */, TODO, context) /* as */ /* TODO(TypeReference): FunctionTypeNode */
						return signatureNode
					}
					if /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO == 1 && ! /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO {
						signature := /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
						signatureNode := signatureToSignatureDeclarationHelper(signature /* TODO(PropertyAccessExpression): SyntaxKind.ConstructorType */, TODO, context) /* as */ /* TODO(TypeReference): ConstructorTypeNode */
						return signatureNode
					}
				}
				abstractSignatures := filter( /* TODO(PropertyAccessExpression): resolved.constructSignatures */ TODO /* TODO(ArrowFunction): signature => !!(signature.flags & SignatureFlags.Abstract) */, TODO)
				if some(abstractSignatures) {
					types := map_(abstractSignatures /* TODO(ArrowFunction): s => getOrCreateTypeFromSignature(s) */, TODO)
					typeElementCount := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): resolved.callSignatures.length +                         (resolved.constructSignatures.length - abstractSignatures.length) +                         resolved.indexInfos.length +                         // exclude `prototype` when writing a class expression as a type literal, as per                         // the logic in `createTypeNodesFromResolvedType`.                         (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ?                             countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) :                             length(resolved.properties)) */ TODO
					if typeElementCount {
						/* TODO(PropertyAccessExpression): types.push */ TODO(getResolvedTypeWithoutAbstractConstructSignatures(resolved))
					}
					return typeToTypeNodeHelper(getIntersectionType(types), context)
				}
				restoreFlags := saveRestoreFlags(context)
				/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InObjectTypeLiteral; */
				members := createTypeNodesFromResolvedType(resolved)
				restoreFlags()
				typeLiteralNode := /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(members)
				/* TODO(ExpressionStatement): context.approximateLength += 2; */
				setEmitFlags(typeLiteralNode /* TODO(ConditionalExpression): (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine */, TODO)
				return typeLiteralNode
			}
			typeReferenceToTypeNode := func(type_ TypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				var typeArguments []Type = getTypeArguments(type_)
				if /* TODO(PropertyAccessExpression): type.target */ TODO == globalArrayType || /* TODO(PropertyAccessExpression): type.target */ TODO == globalReadonlyArrayType {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteArrayAsGenericType */ TODO {
						typeArgumentNode := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
						return /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO( /* TODO(ConditionalExpression): type.target === globalArrayType ? "Array" : "ReadonlyArray" */ TODO /* TODO(ArrayLiteralExpression): [typeArgumentNode] */, TODO)
					}
					elementType := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
					arrayType := /* TODO(PropertyAccessExpression): factory.createArrayTypeNode */ TODO(elementType)
					return /* TODO(ConditionalExpression): type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, arrayType) */ TODO
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.target.objectFlags & ObjectFlags.Tuple */ TODO {
					/* TODO(ExpressionStatement): typeArguments = sameMap(typeArguments, (t, i) => removeMissingType(t, !!((type.target as TupleType).elementFlags[i] & ElementFlags.Optional))); */
					if /* TODO(PropertyAccessExpression): typeArguments.length */ TODO > 0 {
						arity := getTypeReferenceArity(type_)
						tupleConstituentNodes := mapToTypeNodes( /* TODO(PropertyAccessExpression): typeArguments.slice */ TODO(0, arity), context)
						if tupleConstituentNodes {
							TODO_IDENTIFIER := /* TODO(PropertyAccessExpression): type.target */ TODO /* as */ /* TODO(TypeReference): TupleType */
							/* TODO(ForStatement): for (let i = 0; i < tupleConstituentNodes.length; i++) {                                 const flags = (type.target as TupleType).elementFlags[i];                                 const labeledElementDeclaration = labeledElementDeclarations?.[i];                                  if (labeledElementDeclaration) {                                     tupleConstituentNodes[i] = factory.createNamedTupleMember(                                         flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined,                                         factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))),                                         flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                         flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) :                                             tupleConstituentNodes[i],                                     );                                 }                                 else {                                     tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :                                         flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) :                                         tupleConstituentNodes[i];                                 }                             } */
							tupleTypeNode := setEmitFlags( /* TODO(PropertyAccessExpression): factory.createTupleTypeNode */ TODO(tupleConstituentNodes) /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */, TODO)
							return /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
						}
					}
					if /* TODO(PropertyAccessExpression): context.encounteredError */ TODO || /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowEmptyTuple) */ TODO {
						tupleTypeNode := setEmitFlags( /* TODO(PropertyAccessExpression): factory.createTupleTypeNode */ TODO( /* TODO(ArrayLiteralExpression): [] */ TODO) /* TODO(PropertyAccessExpression): EmitFlags.SingleLine */, TODO)
						return /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
					}
					/* TODO(ExpressionStatement): context.encounteredError = true; */
					return /* TODO(NonNullExpression): undefined! */ TODO
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral */ TODO && /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO && isClassLike( /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO) && !isValueSymbolAccessible( /* TODO(PropertyAccessExpression): type.symbol */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO) {
					return createAnonymousTypeNode(type_)
				} else {
					outerTypeParameters := /* TODO(PropertyAccessExpression): type.target.outerTypeParameters */ TODO
					i := 0
					var resultType /* TODO(UnionType): TypeReferenceNode | ImportTypeNode | undefined */ any
					if outerTypeParameters {
						length := /* TODO(PropertyAccessExpression): outerTypeParameters.length */ TODO
						/* TODO(WhileStatement): while (i < length) {                             // Find group of type arguments for type parameters with the same declaring container.                             const start = i;                             const parent = getParentSymbolOfTypeParameter(outerTypeParameters[i])!;                             do {                                 i++;                             }                             while (i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);                             // When type parameters are their own type arguments for the whole group (i.e. we have                             // the default outer type arguments), we don't show the group.                             if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {                                 const typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);                                 const restoreFlags = saveRestoreFlags(context);                                 context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;                                 const ref = symbolToTypeNode(parent, context, SymbolFlags.Type, typeArgumentSlice) as TypeReferenceNode | ImportTypeNode;                                 restoreFlags();                                 resultType = !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode);                             }                         } */
					}
					var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any
					if /* TODO(PropertyAccessExpression): typeArguments.length */ TODO > 0 {
						typeParameterCount := 0
						if /* TODO(PropertyAccessExpression): type.target.typeParameters */ TODO {
							/* TODO(ExpressionStatement): typeParameterCount = Math.min(type.target.typeParameters.length, typeArguments.length); */
							if isReferenceToType(type_, getGlobalIterableType( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_, getGlobalIterableIteratorType( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_, getGlobalAsyncIterableType( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_, getGlobalAsyncIterableIteratorType( /* TODO(FalseKeyword): false */ TODO)) {
								if ! /* TODO(PropertyAccessExpression): type.node */ TODO || !isTypeReferenceNode( /* TODO(PropertyAccessExpression): type.node */ TODO) || ! /* TODO(PropertyAccessExpression): type.node.typeArguments */ TODO || /* TODO(PropertyAccessExpression): type.node.typeArguments.length */ TODO < typeParameterCount {
									/* TODO(WhileStatement): while (typeParameterCount > 0) {                                         const typeArgument = typeArguments[typeParameterCount - 1];                                         const typeParameter = type.target.typeParameters[typeParameterCount - 1];                                         const defaultType = getDefaultFromTypeParameter(typeParameter);                                         if (!defaultType || !isTypeIdenticalTo(typeArgument, defaultType)) {                                             break;                                         }                                         typeParameterCount--;                                     } */
								}
							}
						}
						/* TODO(ExpressionStatement): typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context); */
					}
					restoreFlags := saveRestoreFlags(context)
					/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences; */
					finalRef := symbolToTypeNode( /* TODO(PropertyAccessExpression): type.symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO, typeArgumentNodes)
					restoreFlags()
					return /* TODO(ConditionalExpression): !resultType ? finalRef : appendReferenceToType(resultType, finalRef as TypeReferenceNode) */ TODO
				}
			}
			appendReferenceToType := func(root /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any {
				if isImportTypeNode(root) {
					typeArguments := /* TODO(PropertyAccessExpression): root.typeArguments */ TODO
					qualifier := /* TODO(PropertyAccessExpression): root.qualifier */ TODO
					if qualifier {
						if isIdentifier(qualifier) {
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(qualifier) */ TODO {
								/* TODO(ExpressionStatement): qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments); */
							}
						} else {
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(qualifier.right) */ TODO {
								/* TODO(ExpressionStatement): qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments)); */
							}
						}
					}
					/* TODO(ExpressionStatement): typeArguments = ref.typeArguments; */
					ids := getAccessStack(ref)
					for _, id := range ids {
						/* TODO(ExpressionStatement): qualifier = qualifier ? factory.createQualifiedName(qualifier, id) : id; */
					}
					return /* TODO(PropertyAccessExpression): factory.updateImportTypeNode */ TODO(root /* TODO(PropertyAccessExpression): root.argument */, TODO /* TODO(PropertyAccessExpression): root.attributes */, TODO, qualifier, typeArguments /* TODO(PropertyAccessExpression): root.isTypeOf */, TODO)
				} else {
					typeArguments := /* TODO(PropertyAccessExpression): root.typeArguments */ TODO
					typeName := /* TODO(PropertyAccessExpression): root.typeName */ TODO
					if isIdentifier(typeName) {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(typeName) */ TODO {
							/* TODO(ExpressionStatement): typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments); */
						}
					} else {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(typeName.right) */ TODO {
							/* TODO(ExpressionStatement): typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments)); */
						}
					}
					/* TODO(ExpressionStatement): typeArguments = ref.typeArguments; */
					ids := getAccessStack(ref)
					for _, id := range ids {
						/* TODO(ExpressionStatement): typeName = factory.createQualifiedName(typeName, id); */
					}
					return /* TODO(PropertyAccessExpression): factory.updateTypeReferenceNode */ TODO(root, typeName, typeArguments)
				}
			}
			getAccessStack := func(ref TypeReferenceNode) []Identifier {
				state := /* TODO(PropertyAccessExpression): ref.typeName */ TODO
				ids := /* TODO(ArrayLiteralExpression): [] */ TODO
				/* TODO(WhileStatement): while (!isIdentifier(state)) {                     ids.unshift(state.right);                     state = state.left;                 } */
				/* TODO(PropertyAccessExpression): ids.unshift */
				TODO(state)
				return ids
			}
			createTypeNodesFromResolvedType := func(resolvedType ResolvedType) /* TODO(ArrayType): TypeElement[] */ any {
				if checkTruncationLength(context) {
					return /* TODO(ArrayLiteralExpression): [factory.createPropertySignature(/*modifiers* / undefined, "...", /*questionToken* / undefined, /*type* / undefined)] */ TODO
				}
				var typeElements []TypeElement = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, signature := range /* TODO(PropertyAccessExpression): resolvedType.callSignatures */ TODO {
					/* TODO(PropertyAccessExpression): typeElements.push */ TODO(signatureToSignatureDeclarationHelper(signature /* TODO(PropertyAccessExpression): SyntaxKind.CallSignature */, TODO, context) /* as */ /* TODO(TypeReference): CallSignatureDeclaration */)
				}
				for _, signature := range /* TODO(PropertyAccessExpression): resolvedType.constructSignatures */ TODO {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.Abstract */ TODO {
					}
					/* TODO(PropertyAccessExpression): typeElements.push */ TODO(signatureToSignatureDeclarationHelper(signature /* TODO(PropertyAccessExpression): SyntaxKind.ConstructSignature */, TODO, context) /* as */ /* TODO(TypeReference): ConstructSignatureDeclaration */)
				}
				for _, info := range /* TODO(PropertyAccessExpression): resolvedType.indexInfos */ TODO {
					/* TODO(PropertyAccessExpression): typeElements.push */ TODO(indexInfoToIndexSignatureDeclarationHelper(info, context /* TODO(ConditionalExpression): resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined */, TODO))
				}
				properties := /* TODO(PropertyAccessExpression): resolvedType.properties */ TODO
				if !properties {
					return typeElements
				}
				i := 0
				for _, propertySymbol := range properties {
					/* TODO(ExpressionStatement): i++; */
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral */ TODO {
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): propertySymbol.flags & SymbolFlags.Prototype */ TODO {
							/* TODO(ContinueStatement): continue; */
						}
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(propertySymbol) & (ModifierFlags.Private | ModifierFlags.Protected) */ TODO && /* TODO(PropertyAccessExpression): context.tracker.reportPrivateInBaseOfClassExpression */ TODO {
							/* TODO(PropertyAccessExpression): context.tracker.reportPrivateInBaseOfClassExpression */ TODO(unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): propertySymbol.escapedName */ TODO))
						}
					}
					if checkTruncationLength(context) && /* TODO(ParenthesizedExpression): (i + 2 < properties.length - 1) */ TODO {
						/* TODO(PropertyAccessExpression): typeElements.push */ TODO( /* TODO(PropertyAccessExpression): factory.createPropertySignature */ TODO(nil /* TODO(TemplateExpression): `... ${properties.length - i} more ...` */, TODO, nil, nil))
						addPropertyToElementList( /* TODO(ElementAccessExpression): properties[properties.length - 1] */ TODO, context, typeElements)
						/* TODO(BreakStatement): break; */
					}
					addPropertyToElementList(propertySymbol, context, typeElements)
				}
				return /* TODO(ConditionalExpression): typeElements.length ? typeElements : undefined */ TODO
			}
		}
		createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").KeywordTypeNode<import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.AnyKeyword> | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeReferenceNode */ TODO {
			/* TODO(ExpressionStatement): context.approximateLength += 3; */
			if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.NoTruncation) */ TODO {
				return /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO("..."), nil)
			}
			return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO)
		}
		shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) /* TODO(undefined): boolean */ TODO {
			depth := 3
			return !! /* TODO(ParenthesizedExpression): (getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped) */ TODO && /* TODO(ParenthesizedExpression): (                     contains(context.reverseMappedStack, propertySymbol as ReverseMappedSymbol)                     || (                         context.reverseMappedStack?.[0]                         && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlags.Anonymous)                     )                     || isDeeplyNestedReverseMappedTypeProperty()                 ) */ TODO
			isDeeplyNestedReverseMappedTypeProperty := func() /* TODO(undefined): boolean */ TODO {
				if /* TODO(ParenthesizedExpression): (context.reverseMappedStack?.length ?? 0) */ TODO < depth {
					return /* TODO(FalseKeyword): false */ TODO
				}
				/* TODO(ForStatement): for (let i = 0; i < depth; i++) {                     const prop = context.reverseMappedStack![context.reverseMappedStack!.length - 1 - i];                     if (prop.links.mappedType.symbol !== (propertySymbol as ReverseMappedSymbol).links.mappedType.symbol) {                         return false;                     }                 } */
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
			propertyIsReverseMapped := !! /* TODO(ParenthesizedExpression): (getCheckFlags(propertySymbol) & CheckFlags.ReverseMapped) */ TODO
			propertyType := /* TODO(ConditionalExpression): shouldUsePlaceholderForProperty(propertySymbol, context) ?                 anyType : getNonMissingTypeOfSymbol(propertySymbol) */ TODO
			saveEnclosingDeclaration := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
			/* TODO(ExpressionStatement): context.enclosingDeclaration = undefined; */
			if /* TODO(PropertyAccessExpression): context.tracker.canTrackSymbol */ TODO && isLateBoundName( /* TODO(PropertyAccessExpression): propertySymbol.escapedName */ TODO) {
				if /* TODO(PropertyAccessExpression): propertySymbol.declarations */ TODO {
					decl := first( /* TODO(PropertyAccessExpression): propertySymbol.declarations */ TODO)
					if hasLateBindableName(decl) {
						if isBinaryExpression(decl) {
							name := getNameOfDeclaration(decl)
							if name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression( /* TODO(PropertyAccessExpression): name.argumentExpression */ TODO) {
								trackComputedName( /* TODO(PropertyAccessExpression): name.argumentExpression */ TODO, saveEnclosingDeclaration, context)
							}
						} else {
							trackComputedName( /* TODO(PropertyAccessExpression): decl.name.expression */ TODO, saveEnclosingDeclaration, context)
						}
					}
				} else {
					/* TODO(PropertyAccessExpression): context.tracker.reportNonSerializableProperty */ TODO(symbolToString(propertySymbol))
				}
			}
			/* TODO(ExpressionStatement): context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations?.[0] || saveEnclosingDeclaration; */
			propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
			/* TODO(ExpressionStatement): context.enclosingDeclaration = saveEnclosingDeclaration; */
			/* TODO(ExpressionStatement): context.approximateLength += symbolName(propertySymbol).length + 1; */
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): propertySymbol.flags & SymbolFlags.Accessor */ TODO {
				writeType := getWriteTypeOfSymbol(propertySymbol)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propertyType !== writeType */ TODO && !isErrorType(propertyType) && !isErrorType(writeType) {
					getterDeclaration := /* TODO(NonNullExpression): getDeclarationOfKind<GetAccessorDeclaration>(propertySymbol, SyntaxKind.GetAccessor)! */ TODO
					getterSignature := getSignatureFromDeclaration(getterDeclaration)
					/* TODO(PropertyAccessExpression): typeElements.push */ TODO(setCommentRange(context, signatureToSignatureDeclarationHelper(getterSignature /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */, TODO, context /* TODO(ObjectLiteralExpression): { name: propertyName } */, TODO) /* as */ /* TODO(TypeReference): GetAccessorDeclaration */, getterDeclaration))
					setterDeclaration := /* TODO(NonNullExpression): getDeclarationOfKind<SetAccessorDeclaration>(propertySymbol, SyntaxKind.SetAccessor)! */ TODO
					setterSignature := getSignatureFromDeclaration(setterDeclaration)
					/* TODO(PropertyAccessExpression): typeElements.push */ TODO(setCommentRange(context, signatureToSignatureDeclarationHelper(setterSignature /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */, TODO, context /* TODO(ObjectLiteralExpression): { name: propertyName } */, TODO) /* as */ /* TODO(TypeReference): SetAccessorDeclaration */, setterDeclaration))
					return
				}
			}
			optionalToken := /* TODO(ConditionalExpression): propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): propertySymbol.flags & (SymbolFlags.Function | SymbolFlags.Method) */ TODO && ! /* TODO(PropertyAccessExpression): getPropertiesOfObjectType(propertyType).length */ TODO && !isReadonlySymbol(propertySymbol) {
				signatures := getSignaturesOfType(filterType(propertyType /* TODO(ArrowFunction): t => !(t.flags & TypeFlags.Undefined) */, TODO) /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
				for _, signature := range signatures {
					methodDeclaration := signatureToSignatureDeclarationHelper(signature /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */, TODO, context /* TODO(ObjectLiteralExpression): { name: propertyName, questionToken: optionalToken } */, TODO) /* as */ /* TODO(TypeReference): MethodSignature */
					/* TODO(PropertyAccessExpression): typeElements.push */ TODO(preserveCommentsOn(methodDeclaration))
				}
				if /* TODO(PropertyAccessExpression): signatures.length */ TODO || !optionalToken {
					return
				}
			}
			var propertyTypeNode TypeNode
			if shouldUsePlaceholderForProperty(propertySymbol, context) {
				/* TODO(ExpressionStatement): propertyTypeNode = createElidedInformationPlaceholder(context); */
			} else {
				if propertyIsReverseMapped {
					/* TODO(ExpressionStatement): context.reverseMappedStack ||= []; */
					/* TODO(PropertyAccessExpression): context.reverseMappedStack.push */
					TODO(propertySymbol /* as */ /* TODO(TypeReference): ReverseMappedSymbol */)
				}
				/* TODO(ExpressionStatement): propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, /*declaration* / undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword); */
				if propertyIsReverseMapped {
					/* TODO(PropertyAccessExpression): context.reverseMappedStack!.pop */ TODO()
				}
			}
			modifiers := /* TODO(ConditionalExpression): isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO
			if modifiers {
				/* TODO(ExpressionStatement): context.approximateLength += 9; */
			}
			propertySignature := /* TODO(PropertyAccessExpression): factory.createPropertySignature */ TODO(modifiers, propertyName, optionalToken, propertyTypeNode)
			/* TODO(PropertyAccessExpression): typeElements.push */ TODO(preserveCommentsOn(propertySignature))
			preserveCommentsOn := func(node T) /* TODO(undefined): T */ TODO {
				jsdocPropertyTag := /* TODO(PropertyAccessExpression): propertySymbol.declarations?.find */ TODO( /* TODO(ArrowFunction): (d): d is JSDocPropertyTag => d.kind === SyntaxKind.JSDocPropertyTag */ TODO)
				if jsdocPropertyTag {
					commentText := getTextOfJSDocComment( /* TODO(PropertyAccessExpression): jsdocPropertyTag.comment */ TODO)
					if commentText {
						setSyntheticLeadingComments(node /* TODO(ArrayLiteralExpression): [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO)
					}
				} else if /* TODO(PropertyAccessExpression): propertySymbol.valueDeclaration */ TODO {
					setCommentRange(context, node /* TODO(PropertyAccessExpression): propertySymbol.valueDeclaration */, TODO)
				}
				return node
			}
		}
		setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
			if /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO && /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO == getSourceFileOfNode(range_) {
				return setCommentRangeWorker(node, range_)
			}
			return node
		}
		mapToTypeNodes := func(types /* TODO(TypeOperator): readonly Type[] */ any, context NodeBuilderContext, isBareList bool) /* TODO(ArrayType): TypeNode[] */ any {
			if some(types) {
				if checkTruncationLength(context) {
					if !isBareList {
						return /* TODO(ArrayLiteralExpression): [factory.createTypeReferenceNode("...", /*typeArguments* / undefined)] */ TODO
					} else if /* TODO(PropertyAccessExpression): types.length */ TODO > 2 {
						return /* TODO(ArrayLiteralExpression): [                             typeToTypeNodeHelper(types[0], context),                             factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, /*typeArguments* / undefined),                             typeToTypeNodeHelper(types[types.length - 1], context),                         ] */ TODO
					}
				}
				mayHaveNameCollisions := ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseFullyQualifiedType) */ TODO
				seenNames := /* TODO(ConditionalExpression): mayHaveNameCollisions ? createMultiMap<__String, [Type, number]>() : undefined */ TODO
				var result []TypeNode = /* TODO(ArrayLiteralExpression): [] */ TODO
				i := 0
				for _, type_ := range types {
					/* TODO(ExpressionStatement): i++; */
					if checkTruncationLength(context) && /* TODO(ParenthesizedExpression): (i + 2 < types.length - 1) */ TODO {
						/* TODO(PropertyAccessExpression): result.push */ TODO( /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO( /* TODO(TemplateExpression): `... ${types.length - i} more ...` */ TODO, nil))
						typeNode := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO, context)
						if typeNode {
							/* TODO(PropertyAccessExpression): result.push */ TODO(typeNode)
						}
						/* TODO(BreakStatement): break; */
					}
					/* TODO(ExpressionStatement): context.approximateLength += 2; */
					typeNode := typeToTypeNodeHelper(type_, context)
					if typeNode {
						/* TODO(PropertyAccessExpression): result.push */ TODO(typeNode)
						if seenNames && isIdentifierTypeReference(typeNode) {
							/* TODO(PropertyAccessExpression): seenNames.add */ TODO( /* TODO(PropertyAccessExpression): typeNode.typeName.escapedText */ TODO /* TODO(ArrayLiteralExpression): [type, result.length - 1] */, TODO)
						}
					}
				}
				if seenNames {
					restoreFlags := saveRestoreFlags(context)
					/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.UseFullyQualifiedType; */
					/* TODO(PropertyAccessExpression): seenNames.forEach */
					TODO( /* TODO(ArrowFunction): types => {                         if (!arrayIsHomogeneous(types, ([a], [b]) => typesAreSameReference(a, b))) {                             for (const [type, resultIndex] of types) {                                 result[resultIndex] = typeToTypeNodeHelper(type, context);                             }                         }                     } */ TODO)
					restoreFlags()
				}
				return result
			}
		}
		typesAreSameReference := func(a Type, b Type) bool {
			return a == b || !! /* TODO(PropertyAccessExpression): a.symbol */ TODO && /* TODO(PropertyAccessExpression): a.symbol */ TODO == /* TODO(PropertyAccessExpression): b.symbol */ TODO || !! /* TODO(PropertyAccessExpression): a.aliasSymbol */ TODO && /* TODO(PropertyAccessExpression): a.aliasSymbol */ TODO == /* TODO(PropertyAccessExpression): b.aliasSymbol */ TODO
		}
		indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
			name := getNameFromIndexInfo(indexInfo) || "x"
			indexerTypeNode := typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): indexInfo.keyType */ TODO, context)
			indexingParameter := /* TODO(PropertyAccessExpression): factory.createParameterDeclaration */ TODO(nil, nil, name, nil, indexerTypeNode, nil)
			if !typeNode {
				/* TODO(ExpressionStatement): typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context); */
			}
			if ! /* TODO(PropertyAccessExpression): indexInfo.type */ TODO && ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowEmptyIndexInfoType) */ TODO {
				/* TODO(ExpressionStatement): context.encounteredError = true; */
			}
			/* TODO(ExpressionStatement): context.approximateLength += name.length + 4; */
			return /* TODO(PropertyAccessExpression): factory.createIndexSignature */ TODO( /* TODO(ConditionalExpression): indexInfo.isReadonly ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO /* TODO(ArrayLiteralExpression): [indexingParameter] */, TODO, typeNode)
		}
		type SignatureToSignatureDeclarationOptions struct {
			modifiers     []Modifier
			name          PropertyName
			questionToken QuestionToken
		}
		signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
			var typeParameters /* TODO(ArrayType): TypeParameterDeclaration[] */ any
			var typeArguments /* TODO(ArrayType): TypeNode[] */ any
			expandedParams := /* TODO(ElementAccessExpression): getExpandedParameters(signature, /*skipUnionExpanding* / true)[0] */ TODO
			cleanup := enterNewScope(context /* TODO(PropertyAccessExpression): signature.declaration */, TODO, expandedParams /* TODO(PropertyAccessExpression): signature.typeParameters */, TODO /* TODO(PropertyAccessExpression): signature.parameters */, TODO /* TODO(PropertyAccessExpression): signature.mapper */, TODO)
			/* TODO(ExpressionStatement): context.approximateLength += 3; */
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteTypeArgumentsOfSignature */ TODO && /* TODO(PropertyAccessExpression): signature.target */ TODO && /* TODO(PropertyAccessExpression): signature.mapper */ TODO && /* TODO(PropertyAccessExpression): signature.target.typeParameters */ TODO {
				/* TODO(ExpressionStatement): typeArguments = signature.target.typeParameters.map(parameter => typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context)); */
			} else {
				/* TODO(ExpressionStatement): typeParameters = signature.typeParameters && signature.typeParameters.map(parameter => typeParameterToDeclaration(parameter, context)); */
			}
			restoreFlags := saveRestoreFlags(context)
			/* TODO(ExpressionStatement): context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType; */
			parameters := /* TODO(PropertyAccessExpression): (some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams).map */ TODO( /* TODO(ArrowFunction): parameter => symbolToParameterDeclaration(parameter, context, kind === SyntaxKind.Constructor) */ TODO)
			thisParameter := /* TODO(ConditionalExpression): context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context) */ TODO
			if thisParameter {
				/* TODO(PropertyAccessExpression): parameters.unshift */ TODO(thisParameter)
			}
			restoreFlags()
			returnTypeNode := serializeReturnTypeForSignature(context, signature)
			modifiers := /* TODO(PropertyAccessExpression): options?.modifiers */ TODO
			if /* TODO(ParenthesizedExpression): (kind === SyntaxKind.ConstructorType) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.Abstract */ TODO {
				flags := modifiersToFlags(modifiers)
				/* TODO(ExpressionStatement): modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlags.Abstract); */
			}
			node := /* TODO(ConditionalExpression): kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ?? factory.createIdentifier(""), /*questionToken* / undefined, typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body* / undefined) :                 kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body* / undefined) :                 kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :                 kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) :                 kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) :                 kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken* / undefined, factory.createBlock([])) :                 Debug.assertNever(kind) */ TODO
			if typeArguments {
				/* TODO(ExpressionStatement): node.typeArguments = factory.createNodeArray(typeArguments); */
			}
			if /* TODO(PropertyAccessExpression): signature.declaration?.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocSignature */ TODO && /* TODO(PropertyAccessExpression): signature.declaration.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocOverloadTag */ TODO {
				comment := /* TODO(PropertyAccessExpression): getTextOfNode(signature.declaration.parent.parent, /*includeTrivia* / true).slice(2, -2).split(/\r\n|\n|\r/).map(line => line.replace(/^\s+/, " ")).join */ TODO("\n")
				addSyntheticLeadingComment(node /* TODO(PropertyAccessExpression): SyntaxKind.MultiLineCommentTrivia */, TODO, comment /* TODO(TrueKeyword): true */, TODO)
			}
			cleanup()
			return node
		}
		type IntroducesNewScopeNode /* TODO(UnionType): SignatureDeclaration | JSDocSignature | MappedTypeNode */ any
		isNewScopeNode := func(node Node) /* TODO(TypePredicate): node is IntroducesNewScopeNode */ TODO {
			return isFunctionLike(node) || isJSDocSignature(node) || isMappedTypeNode(node)
		}
		getTypeParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).typeParameters :                 isConditionalTypeNode(node) ? getInferTypeParameters(node) :                 [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))] */ TODO
		}
		getParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).parameters : undefined */ TODO
		}
		enterNewScope := func(context NodeBuilderContext, declaration /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams /* TODO(TypeOperator): readonly Symbol[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, originalParameters /* TODO(TypeOperator): readonly Symbol[] */ any, mapper TypeMapper) /* TODO(undefined): () => void */ TODO {
			cleanupContext := cloneNodeBuilderContext(context)
			var cleanupParams /* TODO(ParenthesizedType): (() => void) */ any
			var cleanupTypeParams /* TODO(ParenthesizedType): (() => void) */ any
			oldEnclosingDecl := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
			oldMapper := /* TODO(PropertyAccessExpression): context.mapper */ TODO
			if mapper {
				/* TODO(ExpressionStatement): context.mapper = mapper; */
			}
			if /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO && declaration {
				/* TODO(ExpressionStatement): cleanupParams = !some(expandedParams) ? undefined : pushFakeScope(                     "params",                     add => {                         if (!expandedParams) return;                         for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) {                             const param = expandedParams[pIndex];                             const originalParam = originalParameters?.[pIndex];                             if (originalParameters && originalParam !== param) {                                 // Can't reference parameters that come from an expansion                                 add(param.escapedName, unknownSymbol);                                 // Can't reference the original expanded parameter either                                 if (originalParam) {                                     add(originalParam.escapedName, unknownSymbol);                                 }                             }                             else if (                                 !forEach(param.declarations, d => {                                     if (isParameter(d) && isBindingPattern(d.name)) {                                         bindPattern(d.name);                                         return true;                                     }                                     return undefined;                                     function bindPattern(p: BindingPattern): void {                                         forEach(p.elements, e => {                                             switch (e.kind) {                                                 case SyntaxKind.OmittedExpression:                                                     return;                                                 case SyntaxKind.BindingElement:                                                     return bindElement(e);                                                 default:                                                     return Debug.assertNever(e);                                             }                                         });                                     }                                     function bindElement(e: BindingElement): void {                                         if (isBindingPattern(e.name)) {                                             return bindPattern(e.name);                                         }                                         const symbol = getSymbolOfDeclaration(e);                                         add(symbol.escapedName, symbol);                                     }                                 })                             ) {                                 add(param.escapedName, param);                             }                         }                     },                 ); */
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO && some(typeParameters) {
					/* TODO(ExpressionStatement): cleanupTypeParams = pushFakeScope(                         "typeParams",                         add => {                             for (const typeParam of typeParameters ?? emptyArray) {                                 const typeParamName = typeParameterToName(typeParam, context).escapedText;                                 add(typeParamName, typeParam.symbol);                             }                         },                     ); */
				}
				pushFakeScope := func(kind /* TODO(UnionType): "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol))) /* TODO(undefined): (() => void) | undefined */ TODO {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
					var existingFakeScope Node
					if /* TODO(PropertyAccessExpression): getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration */ TODO == kind {
						/* TODO(ExpressionStatement): existingFakeScope = context.enclosingDeclaration; */
					} else if /* TODO(PropertyAccessExpression): context.enclosingDeclaration.parent */ TODO && /* TODO(PropertyAccessExpression): getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration */ TODO == kind {
						/* TODO(ExpressionStatement): existingFakeScope = context.enclosingDeclaration.parent; */
					}
					/* TODO(PropertyAccessExpression): Debug.assertOptionalNode */ TODO(existingFakeScope, isBlock)
					locals := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): existingFakeScope?.locals ?? createSymbolTable() */ TODO
					var newLocals /* TODO(ArrayType): __String[] */ any
					var oldLocals /* TODO(ArrayType): { name: __String; oldSymbol: Symbol; }[] */ any
					addAll( /* TODO(ArrowFunction): (name, symbol) => {                         // Add cleanup information only if we don't own the fake scope                         if (existingFakeScope) {                             const oldSymbol = locals.get(name);                             if (!oldSymbol) {                                 newLocals = append(newLocals, name);                             }                             else {                                 oldLocals = append(oldLocals, { name, oldSymbol });                             }                         }                         locals.set(name, symbol);                     } */ TODO)
					if !existingFakeScope {
						fakeScope := /* TODO(PropertyAccessExpression): factory.createBlock */ TODO(emptyArray)
						/* TODO(ExpressionStatement): getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind; */
						/* TODO(ExpressionStatement): fakeScope.locals = locals; */
						setParent(fakeScope /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO)
						/* TODO(ExpressionStatement): context.enclosingDeclaration = fakeScope; */
					} else {
						return /* TODO(FunctionExpression): function undo() {                             forEach(newLocals, s => locals.delete(s));                             forEach(oldLocals, s => locals.set(s.name, s.oldSymbol));                         } */ TODO
					}
				}
			}
			return /* TODO(ArrowFunction): () => {                 cleanupParams?.();                 cleanupTypeParams?.();                 cleanupContext();                 context.enclosingDeclaration = oldEnclosingDecl;                 context.mapper = oldMapper;             } */ TODO
		}
		tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
			if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
				return symbolToParameterDeclaration( /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO, context)
			}
			if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && isInJSFile( /* TODO(PropertyAccessExpression): signature.declaration */ TODO) {
				thisTag := getJSDocThisTag( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
				if thisTag && /* TODO(PropertyAccessExpression): thisTag.typeExpression */ TODO {
					return /* TODO(PropertyAccessExpression): factory.createParameterDeclaration */ TODO(nil, nil, "this", nil, typeToTypeNodeHelper(getTypeFromTypeNode(context /* TODO(PropertyAccessExpression): thisTag.typeExpression */, TODO), context))
				}
			}
		}
		typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
			restoreFlags := saveRestoreFlags(context)
			/* TODO(ExpressionStatement): context.flags &= ~NodeBuilderFlags.WriteTypeParametersInQualifiedName; */
			modifiers := /* TODO(PropertyAccessExpression): factory.createModifiersFromModifierFlags */ TODO(getTypeParameterModifiers(type_))
			name := typeParameterToName(type_, context)
			defaultParameter := getDefaultFromTypeParameter(type_)
			defaultParameterNode := defaultParameter && typeToTypeNodeHelper(defaultParameter, context)
			restoreFlags()
			return /* TODO(PropertyAccessExpression): factory.createTypeParameterDeclaration */ TODO(modifiers, name, constraintNode, defaultParameterNode)
		}
		typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type_) || typeToTypeNodeHelper(type_, context)
		}
		typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /* = */ /* TODO(CallExpression): getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
			constraintNode := constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type_), context)
			return typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
		}
		typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
			assertsModifier := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 factory.createToken(SyntaxKind.AssertsKeyword) :                 undefined */ TODO
			parameterName := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) :                 factory.createThisTypeNode() */ TODO
			typeNode := /* TODO(PropertyAccessExpression): typePredicate.type */ TODO && typeToTypeNodeHelper( /* TODO(PropertyAccessExpression): typePredicate.type */ TODO, context)
			return /* TODO(PropertyAccessExpression): factory.createTypePredicateNode */ TODO(assertsModifier, parameterName, typeNode)
		}
		getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any {
			var parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */, TODO)
			if parameterDeclaration {
				return parameterDeclaration
			}
			if !isTransientSymbol(parameterSymbol) {
				return getDeclarationOfKind(parameterSymbol /* TODO(PropertyAccessExpression): SyntaxKind.JSDocParameterTag */, TODO)
			}
		}
		symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
			parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)
			parameterType := getTypeOfSymbol(parameterSymbol)
			parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)
			modifiers := /* TODO(ConditionalExpression): !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined */ TODO
			isRest := parameterDeclaration && isRestParameter(parameterDeclaration) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(parameterSymbol) & CheckFlags.RestParameter */ TODO
			dotDotDotToken := /* TODO(ConditionalExpression): isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO
			name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
			isOptional := parameterDeclaration && isOptionalParameter(parameterDeclaration) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(parameterSymbol) & CheckFlags.OptionalParameter */ TODO
			questionToken := /* TODO(ConditionalExpression): isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			parameterNode := /* TODO(PropertyAccessExpression): factory.createParameterDeclaration */ TODO(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, nil)
			/* TODO(ExpressionStatement): context.approximateLength += symbolName(parameterSymbol).length + 3; */
			return parameterNode
		}
		parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO(undefined): string | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingName */ TODO {
			return /* TODO(ConditionalExpression): parameterDeclaration ? parameterDeclaration.name ?                 parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlags.NoAsciiEscaping) :                     parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlags.NoAsciiEscaping) :                     cloneBindingName(parameterDeclaration.name) :                 symbolName(parameterSymbol) :                 symbolName(parameterSymbol) */ TODO
			cloneBindingName := func(node BindingName) BindingName {
				return elideInitializerAndSetEmitFlags(node) /* as */ /* TODO(TypeReference): BindingName */
				elideInitializerAndSetEmitFlags := func(node Node) Node {
					if /* TODO(PropertyAccessExpression): context.tracker.canTrackSymbol */ TODO && isComputedPropertyName(node) && isLateBindableName(node) {
						trackComputedName( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO, context)
					}
					visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags, nil, nil, elideInitializerAndSetEmitFlags)
					if isBindingElement(visited) {
						/* TODO(ExpressionStatement): visited = factory.updateBindingElement(                             visited,                             visited.dotDotDotToken,                             visited.propertyName,                             visited.name,                             /*initializer* / undefined,                         ); */
					}
					if !nodeIsSynthesized(visited) {
						/* TODO(ExpressionStatement): visited = factory.cloneNode(visited); */
					}
					return setEmitFlags(visited /* TODO(BarToken): | */ /* TODO(BinaryExpression): EmitFlags.SingleLine | EmitFlags.NoAsciiEscaping */, TODO)
				}
			}
		}
		trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
			if ! /* TODO(PropertyAccessExpression): context.tracker.canTrackSymbol */ TODO {
			}
			firstIdentifier := getFirstIdentifier(accessExpression)
			name := resolveName(firstIdentifier /* TODO(PropertyAccessExpression): firstIdentifier.escapedText */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.ExportValue */, TODO, nil /* TODO(TrueKeyword): true */, TODO)
			if name {
				/* TODO(PropertyAccessExpression): context.tracker.trackSymbol */ TODO(name, enclosingDeclaration /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
			}
		}
		lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			/* TODO(PropertyAccessExpression): context.tracker.trackSymbol */ TODO(symbol /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO, meaning)
			return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
		}
		lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			var chain []Symbol
			isTypeParameter := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO
			if !isTypeParameter && /* TODO(ParenthesizedExpression): (context.enclosingDeclaration || context.flags & NodeBuilderFlags.UseFullyQualifiedType) */ TODO && ! /* TODO(ParenthesizedExpression): (context.internalFlags & InternalNodeBuilderFlags.DoNotIncludeSymbolChain) */ TODO {
				/* TODO(ExpressionStatement): chain = Debug.checkDefined(getSymbolChain(symbol, meaning, /*endOfChain* / true)); */
				/* TODO(PropertyAccessExpression): Debug.assert */
				TODO(chain && /* TODO(PropertyAccessExpression): chain.length */ TODO > 0)
			} else {
				/* TODO(ExpressionStatement): chain = [symbol]; */
			}
			return chain
			getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) /* TODO(ArrayType): Symbol[] */ any {
				accessibleSymbolChain := getAccessibleSymbolChain(symbol /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO, meaning, !! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseOnlyExternalAliasing) */ TODO)
				var parentSpecifiers [] /* TODO(StringKeyword): string */ any
				if !accessibleSymbolChain || needsQualification( /* TODO(ElementAccessExpression): accessibleSymbolChain[0] */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO /* TODO(ConditionalExpression): accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning) */, TODO) {
					parents := getContainersOfSymbol( /* TODO(ConditionalExpression): accessibleSymbolChain ? accessibleSymbolChain[0] : symbol */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO, meaning)
					if length(parents) {
						/* TODO(ExpressionStatement): parentSpecifiers = parents!.map(symbol =>                             some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)                                 ? getSpecifierForModuleSymbol(symbol, context)                                 : undefined                         ); */
						indices := /* TODO(PropertyAccessExpression): parents!.map */ TODO( /* TODO(ArrowFunction): (_, i) => i */ TODO)
						/* TODO(PropertyAccessExpression): indices.sort */ TODO(sortByBestName)
						sortedParents := /* TODO(PropertyAccessExpression): indices.map */ TODO( /* TODO(ArrowFunction): i => parents![i] */ TODO)
						for _, parent := range sortedParents {
							parentChain := getSymbolChain(parent, getQualifiedLeftMeaning(meaning) /* TODO(FalseKeyword): false */, TODO)
							if parentChain {
								if /* TODO(PropertyAccessExpression): parent.exports */ TODO && /* TODO(PropertyAccessExpression): parent.exports.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO) && getSymbolIfSameReference( /* TODO(NonNullExpression): parent.exports.get(InternalSymbolName.ExportEquals)! */ TODO, symbol) {
									/* TODO(ExpressionStatement): accessibleSymbolChain = parentChain; */
									/* TODO(BreakStatement): break; */
								}
								/* TODO(ExpressionStatement): accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [getAliasForSymbolInContainer(parent, symbol) || symbol]); */
								/* TODO(BreakStatement): break; */
							}
						}
					}
				}
				if accessibleSymbolChain {
					return accessibleSymbolChain
				}
				if endOfChain || ! /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral)) */ TODO {
					if !endOfChain && !yieldModuleSymbol && !!forEach( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, hasNonGlobalAugmentationExternalModuleSymbol) {
						return
					}
					return /* TODO(ArrayLiteralExpression): [symbol] */ TODO
				}
				sortByBestName := func(a number, b number) /* TODO(undefined): number */ TODO {
					specifierA := /* TODO(ElementAccessExpression): parentSpecifiers[a] */ TODO
					specifierB := /* TODO(ElementAccessExpression): parentSpecifiers[b] */ TODO
					if specifierA && specifierB {
						isBRelative := pathIsRelative(specifierB)
						if pathIsRelative(specifierA) == isBRelative {
							return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB) */ TODO
						}
						if isBRelative {
							return -1
						}
						return 1
					}
					return 0
				}
			}
		}
		typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined */ TODO {
			var typeParameterNodes *NodeArray[TypeParameterDeclaration]
			targetSymbol := getTargetSymbol(symbol)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetSymbol.flags & (SymbolFlags.Class | SymbolFlags.Interface | SymbolFlags.TypeAlias) */ TODO {
				/* TODO(ExpressionStatement): typeParameterNodes = factory.createNodeArray(map(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), tp => typeParameterToDeclaration(tp, context))); */
			}
			return typeParameterNodes
		}
		lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode[] | readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] | undefined */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(chain && 0 <= index && index < /* TODO(PropertyAccessExpression): chain.length */ TODO)
			symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
			symbolId := getSymbolId(symbol)
			if /* TODO(PropertyAccessExpression): context.typeParameterSymbolList?.has */ TODO(symbolId) {
				return nil
			}
			if /* TODO(PropertyAccessExpression): context.mustCreateTypeParameterSymbolList */ TODO {
				/* TODO(ExpressionStatement): context.mustCreateTypeParameterSymbolList = false; */
				/* TODO(ExpressionStatement): context.typeParameterSymbolList = new Set(context.typeParameterSymbolList); */
			}
			/* TODO(PropertyAccessExpression): context.typeParameterSymbolList!.add */ TODO(symbolId)
			var typeParameterNodes /* TODO(UnionType): readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.WriteTypeParametersInQualifiedName */ TODO && index < /* TODO(ParenthesizedExpression): (chain.length - 1) */ TODO {
				parentSymbol := symbol
				nextSymbol := /* TODO(ElementAccessExpression): chain[index + 1] */ TODO
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(nextSymbol) & CheckFlags.Instantiated */ TODO {
					params := getTypeParametersOfClassOrInterface( /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol */ TODO)
					/* TODO(ExpressionStatement): typeParameterNodes = mapToTypeNodes(map(params, t => getMappedType(t, (nextSymbol as TransientSymbol).links.mapper!)), context); */
				} else {
					/* TODO(ExpressionStatement): typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context); */
				}
			}
			return typeParameterNodes
		}
		getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
			if isIndexedAccessTypeNode( /* TODO(PropertyAccessExpression): top.objectType */ TODO) {
				return getTopmostIndexedAccessType( /* TODO(PropertyAccessExpression): top.objectType */ TODO)
			}
			return top
		}
		getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) /* TODO(undefined): string */ TODO {
			file := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */, TODO)
			if !file {
				equivalentFileSymbol := firstDefined( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol) */, TODO)
				if equivalentFileSymbol {
					/* TODO(ExpressionStatement): file = getDeclarationOfKind<SourceFile>(equivalentFileSymbol, SyntaxKind.SourceFile); */
				}
			}
			if file && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): file.moduleName !== undefined */ TODO {
				return /* TODO(PropertyAccessExpression): file.moduleName */ TODO
			}
			if !file {
				if /* TODO(PropertyAccessExpression): ambientModuleSymbolRegex.test */ TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* as */ /* TODO(StringKeyword): string */) {
					return /* TODO(PropertyAccessExpression): (symbol.escapedName as string).substring */ TODO(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */, TODO)
				}
			}
			if ! /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO || ! /* TODO(PropertyAccessExpression): context.tracker.moduleResolverHost */ TODO {
				if /* TODO(PropertyAccessExpression): ambientModuleSymbolRegex.test */ TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* as */ /* TODO(StringKeyword): string */) {
					return /* TODO(PropertyAccessExpression): (symbol.escapedName as string).substring */ TODO(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */, TODO)
				}
				return /* TODO(PropertyAccessExpression): getSourceFileOfNode(getNonAugmentationDeclaration(symbol)!).fileName */ TODO
			}
			enclosingDeclaration := getOriginalNode( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
			originalModuleSpecifier := /* TODO(ConditionalExpression): canHaveModuleSpecifier(enclosingDeclaration) ? tryGetModuleSpecifierFromDeclaration(enclosingDeclaration) : undefined */ TODO
			contextFile := /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO
			resolutionMode := overrideImportMode || originalModuleSpecifier && /* TODO(PropertyAccessExpression): host.getModeForUsageLocation */ TODO(contextFile, originalModuleSpecifier) || contextFile && /* TODO(PropertyAccessExpression): host.getDefaultResolutionModeForFile */ TODO(contextFile)
			cacheKey := createModeAwareCacheKey( /* TODO(PropertyAccessExpression): contextFile.path */ TODO, resolutionMode)
			links := getSymbolLinks(symbol)
			specifier := /* TODO(PropertyAccessExpression): links.specifierCache */ TODO && /* TODO(PropertyAccessExpression): links.specifierCache.get */ TODO(cacheKey)
			if !specifier {
				isBundle := !! /* TODO(PropertyAccessExpression): compilerOptions.outFile */ TODO
				TODO_IDENTIFIER := /* TODO(PropertyAccessExpression): context.tracker */ TODO
				specifierCompilerOptions := /* TODO(ConditionalExpression): isBundle ? { ...compilerOptions, baseUrl: moduleResolverHost.getCommonSourceDirectory() } : compilerOptions */ TODO
				/* TODO(ExpressionStatement): specifier = first(moduleSpecifiers.getModuleSpecifiers(                     symbol,                     checker,                     specifierCompilerOptions,                     contextFile,                     moduleResolverHost,                     {                         importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative",                         importModuleSpecifierEnding: isBundle ? "minimal"                             : resolutionMode === ModuleKind.ESNext ? "js"                             : undefined,                     },                     { overrideImportMode },                 )); */
				/* TODO(ExpressionStatement): links.specifierCache ??= new Map(); */
				/* TODO(PropertyAccessExpression): links.specifierCache.set */
				TODO(cacheKey, specifier)
			}
			return specifier
		}
		symbolToEntityNameNode := func(symbol Symbol) EntityName {
			identifier := /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO))
			return /* TODO(ConditionalExpression): symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier */ TODO
		}
		symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
			chain := lookupSymbolChain(symbol, context, meaning, ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) */ TODO)
			isTypeOf := meaning == /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO
			if some( /* TODO(PropertyAccessExpression): chain[0].declarations */ TODO, hasNonGlobalAugmentationExternalModuleSymbol) {
				nonRootParts := /* TODO(ConditionalExpression): chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined */ TODO
				typeParameterNodes := overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context)
				contextFile := getSourceFileOfNode(getOriginalNode( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO))
				targetFile := getSourceFileOfModule( /* TODO(ElementAccessExpression): chain[0] */ TODO)
				var specifier /* TODO(StringKeyword): string */ any
				var attributes *ImportAttributes
				if getEmitModuleResolutionKind(compilerOptions) == /* TODO(PropertyAccessExpression): ModuleResolutionKind.Node16 */ TODO || getEmitModuleResolutionKind(compilerOptions) == /* TODO(PropertyAccessExpression): ModuleResolutionKind.NodeNext */ TODO {
					if /* TODO(PropertyAccessExpression): targetFile?.impliedNodeFormat */ TODO == /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetFile.impliedNodeFormat !== contextFile?.impliedNodeFormat */ TODO {
						/* TODO(ExpressionStatement): specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKind.ESNext); */
						/* TODO(ExpressionStatement): attributes = factory.createImportAttributes(                             factory.createNodeArray([                                 factory.createImportAttribute(                                     factory.createStringLiteral("resolution-mode"),                                     factory.createStringLiteral("import"),                                 ),                             ]),                         ); */
					}
				}
				if !specifier {
					/* TODO(ExpressionStatement): specifier = getSpecifierForModuleSymbol(chain[0], context); */
				}
				if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowNodeModulesRelativePaths) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Classic */ TODO && /* TODO(PropertyAccessExpression): specifier.includes */ TODO("/node_modules/") {
					oldSpecifier := specifier
					if getEmitModuleResolutionKind(compilerOptions) == /* TODO(PropertyAccessExpression): ModuleResolutionKind.Node16 */ TODO || getEmitModuleResolutionKind(compilerOptions) == /* TODO(PropertyAccessExpression): ModuleResolutionKind.NodeNext */ TODO {
						swappedMode := /* TODO(ConditionalExpression): contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext */ TODO
						/* TODO(ExpressionStatement): specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode); */
						if /* TODO(PropertyAccessExpression): specifier.includes */ TODO("/node_modules/") {
							/* TODO(ExpressionStatement): specifier = oldSpecifier; */
						} else {
							/* TODO(ExpressionStatement): attributes = factory.createImportAttributes(                                 factory.createNodeArray([                                     factory.createImportAttribute(                                         factory.createStringLiteral("resolution-mode"),                                         factory.createStringLiteral(swappedMode === ModuleKind.ESNext ? "import" : "require"),                                     ),                                 ]),                             ); */
						}
					}
					if !attributes {
						/* TODO(ExpressionStatement): context.encounteredError = true; */
						if /* TODO(PropertyAccessExpression): context.tracker.reportLikelyUnsafeImportRequiredError */ TODO {
							/* TODO(PropertyAccessExpression): context.tracker.reportLikelyUnsafeImportRequiredError */ TODO(oldSpecifier)
						}
					}
				}
				lit := /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(specifier))
				/* TODO(ExpressionStatement): context.approximateLength += specifier.length + 10; */
				if !nonRootParts || isEntityName(nonRootParts) {
					if nonRootParts {
						lastId := /* TODO(ConditionalExpression): isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right */ TODO
						setIdentifierTypeArguments(lastId, nil)
					}
					return /* TODO(PropertyAccessExpression): factory.createImportTypeNode */ TODO(lit, attributes, nonRootParts /* as */ /* TODO(TypeReference): EntityName */, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */, isTypeOf)
				} else {
					splitNode := getTopmostIndexedAccessType(nonRootParts)
					qualifier := /* TODO(PropertyAccessExpression): (splitNode.objectType as TypeReferenceNode).typeName */ TODO
					return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createImportTypeNode */ TODO(lit, attributes, qualifier, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */, isTypeOf) /* TODO(PropertyAccessExpression): splitNode.indexType */, TODO)
				}
			}
			entityName := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO, 0)
			if isIndexedAccessTypeNode(entityName) {
				return entityName
			}
			if isTypeOf {
				return /* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO(entityName)
			} else {
				lastId := /* TODO(ConditionalExpression): isIdentifier(entityName) ? entityName : entityName.right */ TODO
				lastTypeArgs := getIdentifierTypeArguments(lastId)
				setIdentifierTypeArguments(lastId, nil)
				return /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(entityName, lastTypeArgs /* as */ /* TODO(TypeReference): NodeArray<TypeNode> */)
			}
			createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(UnionType): EntityName | IndexedAccessTypeNode */ any {
				typeParameterNodes := /* TODO(ConditionalExpression): index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context) */ TODO
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				parent := /* TODO(ElementAccessExpression): chain[index - 1] */ TODO
				var symbolName /* TODO(StringKeyword): string */ any
				if index == 0 {
					/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
					/* TODO(ExpressionStatement): symbolName = getNameOfSymbolAsWritten(symbol, context); */
					/* TODO(ExpressionStatement): context.approximateLength += (symbolName ? symbolName.length : 0) + 1; */
					/* TODO(ExpressionStatement): context.flags ^= NodeBuilderFlags.InInitialEntityName; */
				} else {
					if parent && getExportsOfSymbol(parent) {
						exports := getExportsOfSymbol(parent)
						forEachEntry(exports /* TODO(ArrowFunction): (ex, name) => {                             if (getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name !== InternalSymbolName.ExportEquals) {                                 symbolName = unescapeLeadingUnderscores(name);                                 return true;                             }                         } */, TODO)
					}
				}
				if symbolName == nil {
					name := firstDefined( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, getNameOfDeclaration)
					if name && isComputedPropertyName(name) && isEntityName( /* TODO(PropertyAccessExpression): name.expression */ TODO) {
						LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
						if isEntityName(LHS) {
							return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createParenthesizedType */ TODO( /* TODO(PropertyAccessExpression): factory.createTypeQueryNode */ TODO(LHS)) /* TODO(PropertyAccessExpression): factory.createTypeQueryNode */, TODO( /* TODO(PropertyAccessExpression): name.expression */ TODO))
						}
						return LHS
					}
					/* TODO(ExpressionStatement): symbolName = getNameOfSymbolAsWritten(symbol, context); */
				}
				/* TODO(ExpressionStatement): context.approximateLength += symbolName.length + 1; */
				if ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.ForbidIndexedAccessSymbolReferences) */ TODO && parent && getMembersOfSymbol(parent) && /* TODO(PropertyAccessExpression): getMembersOfSymbol(parent).get */ TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO) && getSymbolIfSameReference( /* TODO(NonNullExpression): getMembersOfSymbol(parent).get(symbol.escapedName)! */ TODO, symbol) {
					LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
					if isIndexedAccessTypeNode(LHS) {
						return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO(LHS /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(symbolName)))
					} else {
						return /* TODO(PropertyAccessExpression): factory.createIndexedAccessTypeNode */ TODO( /* TODO(PropertyAccessExpression): factory.createTypeReferenceNode */ TODO(LHS, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */) /* TODO(PropertyAccessExpression): factory.createLiteralTypeNode */, TODO( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(symbolName)))
					}
				}
				identifier := setEmitFlags( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName) /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */, TODO)
				if typeParameterNodes {
					/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
				}
				/* TODO(ExpressionStatement): identifier.symbol = symbol; */
				if index > stopper {
					LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
					if !isEntityName(LHS) {
						return /* TODO(PropertyAccessExpression): Debug.fail */ TODO("Impossible construct - an export of an indexed access cannot be reachable")
					}
					return /* TODO(PropertyAccessExpression): factory.createQualifiedName */ TODO(LHS, identifier)
				}
				return identifier
			}
		}
		typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) /* TODO(undefined): boolean */ TODO {
			result := resolveName( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO, escapedName /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO, nil /* TODO(FalseKeyword): false */, TODO)
			if result && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & SymbolFlags.TypeParameter */ TODO {
				return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== type.symbol */ TODO
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO && /* TODO(PropertyAccessExpression): context.typeParameterNames */ TODO {
				cached := /* TODO(PropertyAccessExpression): context.typeParameterNames.get */ TODO(getTypeId(type_))
				if cached {
					return cached
				}
			}
			result := symbolToName( /* TODO(PropertyAccessExpression): type.symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(TrueKeyword): true */, TODO)
			if ! /* TODO(ParenthesizedExpression): (result.kind & SyntaxKind.Identifier) */ TODO {
				return /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO("(Missing type parameter)")
			}
			decl := /* TODO(ElementAccessExpression): type.symbol?.declarations?.[0] */ TODO
			if decl && isTypeParameterDeclaration(decl) {
				/* TODO(ExpressionStatement): result = setTextRange(context, result, decl.name); */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.GenerateNamesForShadowedTypeParams */ TODO {
				rawtext := /* TODO(PropertyAccessExpression): result.escapedText */ TODO /* as */ /* TODO(StringKeyword): string */
				i := /* TODO(PropertyAccessExpression): context.typeParameterNamesByTextNextNameCount?.get */ TODO(rawtext) || 0
				text := rawtext
				/* TODO(WhileStatement): while (context.typeParameterNamesByText?.has(text) || typeParameterShadowsOtherTypeParameterInScope(text as __String, context, type)) {                     i++;                     text = `${rawtext}_${i}`;                 } */
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): text !== rawtext */ TODO {
					typeArguments := getIdentifierTypeArguments(result)
					/* TODO(ExpressionStatement): result = factory.createIdentifier(text); */
					setIdentifierTypeArguments(result, typeArguments)
				}
				if /* TODO(PropertyAccessExpression): context.mustCreateTypeParametersNamesLookups */ TODO {
					/* TODO(ExpressionStatement): context.mustCreateTypeParametersNamesLookups = false; */
					/* TODO(ExpressionStatement): context.typeParameterNames = new Map(context.typeParameterNames); */
					/* TODO(ExpressionStatement): context.typeParameterNamesByTextNextNameCount = new Map(context.typeParameterNamesByTextNextNameCount); */
					/* TODO(ExpressionStatement): context.typeParameterNamesByText = new Set(context.typeParameterNamesByText); */
				}
				/* TODO(PropertyAccessExpression): context.typeParameterNamesByTextNextNameCount!.set */ TODO(rawtext, i)
				/* TODO(PropertyAccessExpression): context.typeParameterNames!.set */ TODO(getTypeId(type_), result)
				/* TODO(PropertyAccessExpression): context.typeParameterNamesByText!.add */ TODO(text)
			}
			return result
		}
		// OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): true */ TODO) Identifier
		// OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): false */ TODO) EntityName
		symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
			chain := lookupSymbolChain(symbol, context, meaning)
			if expectsIdentifier && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): chain.length !== 1 */ TODO && ! /* TODO(PropertyAccessExpression): context.encounteredError */ TODO && ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowQualifiedNameInPlaceOfIdentifier) */ TODO {
				/* TODO(ExpressionStatement): context.encounteredError = true; */
			}
			return createEntityNameFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO)
			createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				if index == 0 {
					/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					/* TODO(ExpressionStatement): context.flags ^= NodeBuilderFlags.InInitialEntityName; */
				}
				identifier := setEmitFlags( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName) /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */, TODO)
				if typeParameterNodes {
					/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
				}
				/* TODO(ExpressionStatement): identifier.symbol = symbol; */
				return /* TODO(ConditionalExpression): index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
			}
		}
		symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
			chain := lookupSymbolChain(symbol, context, meaning)
			return createExpressionFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO)
			createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				if index == 0 {
					/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					/* TODO(ExpressionStatement): context.flags ^= NodeBuilderFlags.InInitialEntityName; */
				}
				firstChar := /* TODO(PropertyAccessExpression): symbolName.charCodeAt */ TODO(0)
				if isSingleOrDoubleQuote(firstChar) && some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, hasNonGlobalAugmentationExternalModuleSymbol) {
					return /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(getSpecifierForModuleSymbol(symbol, context))
				}
				if index == 0 || canUsePropertyAccess(symbolName, languageVersion) {
					identifier := setEmitFlags( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName) /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */, TODO)
					if typeParameterNodes {
						/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
					}
					/* TODO(ExpressionStatement): identifier.symbol = symbol; */
					return /* TODO(ConditionalExpression): index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
				} else {
					if firstChar == /* TODO(PropertyAccessExpression): CharacterCodes.openBracket */ TODO {
						/* TODO(ExpressionStatement): symbolName = symbolName.substring(1, symbolName.length - 1); */
						/* TODO(ExpressionStatement): firstChar = symbolName.charCodeAt(0); */
					}
					var expression *Expression
					if isSingleOrDoubleQuote(firstChar) && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.EnumMember) */ TODO {
						/* TODO(ExpressionStatement): expression = factory.createStringLiteral(stripQuotes(symbolName).replace(/\\./g, s => s.substring(1)), firstChar === CharacterCodes.singleQuote); */
					} else if /* TODO(ParenthesizedExpression): ("" + +symbolName) */ TODO == symbolName {
						/* TODO(ExpressionStatement): expression = factory.createNumericLiteral(+symbolName); */
					}
					if !expression {
						identifier := setEmitFlags( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(symbolName) /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */, TODO)
						if typeParameterNodes {
							/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
						}
						/* TODO(ExpressionStatement): identifier.symbol = symbol; */
						/* TODO(ExpressionStatement): expression = identifier; */
					}
					return /* TODO(PropertyAccessExpression): factory.createElementAccessExpression */ TODO(createExpressionFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO), expression)
				}
			}
		}
		isStringNamed := func(d Declaration) /* TODO(undefined): boolean */ TODO {
			name := getNameOfDeclaration(d)
			if !name {
				return /* TODO(FalseKeyword): false */ TODO
			}
			if isComputedPropertyName(name) {
				type_ := checkExpression( /* TODO(PropertyAccessExpression): name.expression */ TODO)
				return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.StringLike) */ TODO
			}
			if isElementAccessExpression(name) {
				type_ := checkExpression( /* TODO(PropertyAccessExpression): name.argumentExpression */ TODO)
				return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.StringLike) */ TODO
			}
			return isStringLiteral(name)
		}
		isSingleQuotedStringNamed := func(d Declaration) /* TODO(undefined): boolean */ TODO {
			name := getNameOfDeclaration(d)
			return !! /* TODO(ParenthesizedExpression): (name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, /*includeTrivia* / false), "'"))) */ TODO
		}
		getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
			stringNamed := !!length( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO) && every( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isStringNamed)
			singleQuote := !!length( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO) && every( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isSingleQuotedStringNamed)
			isMethod := !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Method) */ TODO
			fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
			if fromNameType {
				return fromNameType
			}
			rawName := unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
			return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
		}
		getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined */ TODO {
			nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
			if nameType {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nameType.flags & TypeFlags.StringOrNumberLiteral */ TODO {
					name := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
					if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && /* TODO(ParenthesizedExpression): (stringNamed || !isNumericLiteralName(name)) */ TODO {
						return /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(name, !!singleQuote)
					}
					if isNumericLiteralName(name) && startsWith(name, "-") {
						return /* TODO(PropertyAccessExpression): factory.createComputedPropertyName */ TODO( /* TODO(PropertyAccessExpression): factory.createPrefixUnaryExpression */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.MinusToken */ TODO /* TODO(PropertyAccessExpression): factory.createNumericLiteral */, TODO(-name)))
					}
					return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nameType.flags & TypeFlags.UniqueESSymbol */ TODO {
					return /* TODO(PropertyAccessExpression): factory.createComputedPropertyName */ TODO(symbolToExpression( /* TODO(PropertyAccessExpression): (nameType as UniqueESSymbolType).symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO))
				}
			}
		}
		cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO(undefined): () => void */ TODO {
			oldMustCreateTypeParameterSymbolList := /* TODO(PropertyAccessExpression): context.mustCreateTypeParameterSymbolList */ TODO
			oldMustCreateTypeParametersNamesLookups := /* TODO(PropertyAccessExpression): context.mustCreateTypeParametersNamesLookups */ TODO
			/* TODO(ExpressionStatement): context.mustCreateTypeParameterSymbolList = true; */
			/* TODO(ExpressionStatement): context.mustCreateTypeParametersNamesLookups = true; */
			oldTypeParameterNames := /* TODO(PropertyAccessExpression): context.typeParameterNames */ TODO
			oldTypeParameterNamesByText := /* TODO(PropertyAccessExpression): context.typeParameterNamesByText */ TODO
			oldTypeParameterNamesByTextNextNameCount := /* TODO(PropertyAccessExpression): context.typeParameterNamesByTextNextNameCount */ TODO
			oldTypeParameterSymbolList := /* TODO(PropertyAccessExpression): context.typeParameterSymbolList */ TODO
			return /* TODO(ArrowFunction): () => {                 context.typeParameterNames = oldTypeParameterNames;                 context.typeParameterNamesByText = oldTypeParameterNamesByText;                 context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount;                 context.typeParameterSymbolList = oldTypeParameterSymbolList;                 context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList;                 context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups;             } */ TODO
		}
		getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
			return /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && find( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): s => !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, n => n === enclosingDeclaration)) */, TODO)
		}
		existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) /* TODO(undefined): boolean */ TODO {
			if ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO {
				/* TODO(TrueKeyword): true */
			}
			if !isTypeReferenceNode(existing) {
				/* TODO(TrueKeyword): true */
			}
			/* TODO(ExpressionStatement): void getTypeFromTypeReference(existing); */
			symbol := /* TODO(PropertyAccessExpression): getNodeLinks(existing).resolvedSymbol */ TODO
			existingTarget := symbol && getDeclaredTypeOfSymbol(symbol)
			if !existingTarget || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existingTarget !== (type as TypeReference).target */ TODO {
				/* TODO(TrueKeyword): true */
			}
			return length( /* TODO(PropertyAccessExpression): existing.typeArguments */ TODO) >= getMinTypeArgumentCount( /* TODO(PropertyAccessExpression): (type as TypeReference).target.typeParameters */ TODO)
		}
		getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO {
			/* TODO(WhileStatement): while (getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration) {                 enclosingDeclaration = enclosingDeclaration.parent;             } */
			return enclosingDeclaration
		}
		serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			addUndefinedForParameter := declaration && /* TODO(ParenthesizedExpression): (isParameter(declaration) || isJSDocParameterTag(declaration)) */ TODO && requiresAddingImplicitUndefined(declaration /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO)
			enclosingDeclaration := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
			restoreFlags := saveRestoreFlags(context)
			if declaration && hasInferredType(declaration) && ! /* TODO(ParenthesizedExpression): (context.internalFlags & InternalNodeBuilderFlags.NoSyntacticPrinter) */ TODO {
				/* TODO(PropertyAccessExpression): syntacticNodeBuilder.serializeTypeOfDeclaration */ TODO(declaration, context)
			}
			/* TODO(ExpressionStatement): context.internalFlags |= InternalNodeBuilderFlags.NoSyntacticPrinter; */
			if enclosingDeclaration && /* TODO(ParenthesizedExpression): (!isErrorType(type) || (context.internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames)) */ TODO {
				declWithExistingAnnotation := /* TODO(ConditionalExpression): declaration && getNonlocalEffectiveTypeAnnotationNode(declaration)                     ? declaration                     : getDeclarationWithTypeAnnotation(symbol) */ TODO
				if declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) {
					existing := /* TODO(NonNullExpression): getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)! */ TODO
					addUndefined := addUndefinedForParameter || !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Property && symbol.flags & SymbolFlags.Optional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol as MappedSymbol).links?.mappedType && containsNonMissingUndefinedType(type)) */ TODO
					result := !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type_, declWithExistingAnnotation, addUndefined)
					if result {
						restoreFlags()
						return result
					}
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.UniqueESSymbol */ TODO && /* TODO(PropertyAccessExpression): type.symbol */ TODO == symbol && /* TODO(ParenthesizedExpression): (!context.enclosingDeclaration || some(symbol.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!))) */ TODO {
				/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.AllowUniqueESSymbolType; */
			}
			decl := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
			expr := /* TODO(ConditionalExpression): decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl) ? getPossibleTypeNodeReuseExpression(decl) : undefined */ TODO
			result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
			restoreFlags()
			return result
		}
		typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) /* TODO(undefined): boolean */ TODO {
			if typeFromTypeNode == type_ {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if annotatedDeclaration && /* TODO(ParenthesizedExpression): (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) */ TODO && /* TODO(PropertyAccessExpression): annotatedDeclaration.questionToken */ TODO {
				return getTypeWithFacts(type_ /* TODO(PropertyAccessExpression): TypeFacts.NEUndefined */, TODO) == typeFromTypeNode
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			suppressAny := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & NodeBuilderFlags.SuppressAnyReturnType */ TODO
			restoreFlags := saveRestoreFlags(context)
			if suppressAny {
				/* TODO(BinaryExpression): context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType */
			}
			var returnTypeNode *TypeNode
			returnType := getReturnTypeOfSignature(signature)
			if returnType && ! /* TODO(ParenthesizedExpression): (suppressAny && isTypeAny(returnType)) */ TODO {
				if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && ! /* TODO(ParenthesizedExpression): (context.internalFlags & InternalNodeBuilderFlags.NoSyntacticPrinter) */ TODO {
					/* TODO(PropertyAccessExpression): syntacticNodeBuilder.serializeReturnTypeForSignature */ TODO( /* TODO(PropertyAccessExpression): signature.declaration */ TODO, context)
				}
				/* TODO(ExpressionStatement): context.internalFlags |= InternalNodeBuilderFlags.NoSyntacticPrinter; */
				/* TODO(ExpressionStatement): returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature); */
			} else if !suppressAny {
				/* TODO(ExpressionStatement): returnTypeNode = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword); */
			}
			restoreFlags()
			return returnTypeNode
		}
		serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			typePredicate := getTypePredicateOfSignature(signature)
			type_ := getReturnTypeOfSignature(signature)
			if /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO && /* TODO(ParenthesizedExpression): (!isErrorType(type) || (context.internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames)) */ TODO && /* TODO(PropertyAccessExpression): signature.declaration */ TODO && !nodeIsSynthesized( /* TODO(PropertyAccessExpression): signature.declaration */ TODO) {
				annotation := getNonlocalEffectiveReturnTypeAnnotationNode( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
				if annotation {
					result := tryReuseExistingTypeNode(context, annotation, type_ /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO)
					if result {
						return result
					}
				}
			}
			if typePredicate {
				return typePredicateToTypePredicateNodeHelper(typePredicate, context)
			}
			expr := /* TODO(PropertyAccessExpression): signature.declaration */ TODO && getPossibleTypeNodeReuseExpression( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
			return expressionOrTypeToTypeNode(context, expr, type_)
		}
		trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO(undefined): { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined; } */ TODO {
			introducesError := /* TODO(FalseKeyword): false */ TODO
			leftmost := getFirstIdentifier(node)
			if isInJSFile(node) && /* TODO(ParenthesizedExpression): (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) */ TODO {
				/* TODO(ExpressionStatement): introducesError = true; */
				return /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
			}
			meaning := getMeaningOfEntityNameReference(node)
			var sym *Symbol
			if isThisIdentifier(leftmost) {
				/* TODO(ExpressionStatement): sym = getSymbolOfDeclaration(getThisContainer(leftmost, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false)); */
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(sym, leftmost, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
					/* TODO(ExpressionStatement): introducesError = true; */
					/* TODO(PropertyAccessExpression): context.tracker.reportInaccessibleThisError */
					TODO()
				}
				return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			/* TODO(ExpressionStatement): sym = resolveEntityName(leftmost, meaning, /*ignoreErrors* / true, /*dontResolveAlias* / true); */
			if /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO && ! /* TODO(ParenthesizedExpression): (sym && sym.flags & SymbolFlags.TypeParameter) */ TODO {
				/* TODO(ExpressionStatement): sym = getExportSymbolOfValueSymbolIfExported(sym); */
				symAtLocation := resolveEntityName(leftmost, meaning /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO)
				if symAtLocation == unknownSymbol || /* TODO(ParenthesizedExpression): (symAtLocation === undefined && sym !== undefined) */ TODO || /* TODO(ParenthesizedExpression): (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) */ TODO {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symAtLocation !== unknownSymbol */ TODO {
						/* TODO(PropertyAccessExpression): context.tracker.reportInferenceFallback */ TODO(node)
					}
					/* TODO(ExpressionStatement): introducesError = true; */
					return /* TODO(ObjectLiteralExpression): { introducesError, node, sym } */ TODO
				} else {
					/* TODO(ExpressionStatement): sym = symAtLocation; */
				}
			}
			if sym {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sym.flags & SymbolFlags.FunctionScopedVariable */ TODO && /* TODO(PropertyAccessExpression): sym.valueDeclaration */ TODO {
					if isPartOfParameterDeclaration( /* TODO(PropertyAccessExpression): sym.valueDeclaration */ TODO) || isJSDocParameterTag( /* TODO(PropertyAccessExpression): sym.valueDeclaration */ TODO) {
						return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
					}
				}
				if ! /* TODO(ParenthesizedExpression): (sym.flags & SymbolFlags.TypeParameter) */ TODO && !isDeclarationName(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(sym, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
					/* TODO(PropertyAccessExpression): context.tracker.reportInferenceFallback */ TODO(node)
					/* TODO(ExpressionStatement): introducesError = true; */
				} else {
					/* TODO(PropertyAccessExpression): context.tracker.trackSymbol */ TODO(sym /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO, meaning)
				}
				return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			return /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
			attachSymbolToLeftmostIdentifier := func(node Node) Node {
				if node == leftmost {
					type_ := getDeclaredTypeOfSymbol( /* TODO(NonNullExpression): sym! */ TODO)
					name := /* TODO(ConditionalExpression): sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier) */ TODO
					/* TODO(ExpressionStatement): name.symbol = sym!; */
					return setTextRange(context, setEmitFlags(name /* TODO(PropertyAccessExpression): EmitFlags.NoAsciiEscaping */, TODO), node)
				}
				updated := visitEachChildWorker(node /* TODO(ArrowFunction): c => attachSymbolToLeftmostIdentifier(c) */, TODO, nil)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): updated !== node */ TODO {
					setTextRange(context, updated, node)
				}
				return updated
			}
		}
		serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			meaning := /* TODO(ConditionalExpression): isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
			symbol := resolveEntityName(node, meaning /* TODO(TrueKeyword): true */, TODO)
			if !symbol {
				/* TODO(Identifier): undefined */
			}
			resolvedSymbol := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
				/* TODO(Identifier): undefined */
			}
			return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
		}
		canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO(undefined): number | boolean */ TODO {
			if isInJSFile(existing) {
				if isLiteralImportTypeNode(existing) {
					/* TODO(ExpressionStatement): void getTypeFromImportTypeNode(existing); */
					nodeSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(existing).resolvedSymbol */ TODO
					return /* TODO(ParenthesizedExpression): (                         !nodeSymbol ||                         !(                             // The import type resolved using jsdoc fallback logic                             (!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||                             // The import type had type arguments autofilled by js fallback logic                             !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))                         )                     ) */ TODO
				}
			}
			if isThisTypeNode(existing) {
				if /* TODO(PropertyAccessExpression): context.mapper */ TODO == nil {
					/* TODO(TrueKeyword): true */
				}
				type_ := getTypeFromTypeNode(context, existing /* TODO(TrueKeyword): true */, TODO)
				return !!type_
			}
			if isTypeReferenceNode(existing) {
				if isConstTypeReference(existing) {
					/* TODO(FalseKeyword): false */
				}
				type_ := getTypeFromTypeReference(existing)
				symbol := /* TODO(PropertyAccessExpression): getNodeLinks(existing).resolvedSymbol */ TODO
				if !symbol {
					/* TODO(FalseKeyword): false */
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO {
					type_ := getDeclaredTypeOfSymbol(symbol)
					if /* TODO(PropertyAccessExpression): context.mapper */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedType(type, context.mapper) !== type */ TODO {
						return /* TODO(FalseKeyword): false */ TODO
					}
				}
				if isInJSDoc(existing) {
					return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) && !getIntendedTypeFromJSDocTypeReference(existing) && /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Type) */ TODO
				}
			}
			if isTypeOperatorNode(existing) && /* TODO(PropertyAccessExpression): existing.operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.UniqueKeyword */ TODO && /* TODO(PropertyAccessExpression): existing.type.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO {
				effectiveEnclosingContext := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO && getEnclosingDeclarationIgnoringFakeScope( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
				return !!findAncestor(existing /* TODO(ArrowFunction): n => n === effectiveEnclosingContext */, TODO)
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			type_ := getTypeFromTypeNode(context, typeNode)
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			if cancellationToken && /* TODO(PropertyAccessExpression): cancellationToken.throwIfCancellationRequested */ TODO {
				/* TODO(PropertyAccessExpression): cancellationToken.throwIfCancellationRequested */ TODO()
			}
			hadError := /* TODO(FalseKeyword): false */ TODO
			TODO_IDENTIFIER := createRecoveryBoundary()
			transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
			if !finalizeBoundary() {
				return nil
			}
			/* TODO(ExpressionStatement): context.approximateLength += existing.end - existing.pos; */
			return transformed
			visitExistingNodeTreeSymbols := func(node Node) Node {
				if hadError {
					/* TODO(Identifier): node */
				}
				recover := startRecoveryScope()
				onExitNewScope := /* TODO(ConditionalExpression): isNewScopeNode(node) ? onEnterNewScope(node) : undefined */ TODO
				result := visitExistingNodeTreeSymbolsWorker(node)
				onExitNewScope()
				if hadError {
					if isTypeNode(node) && !isTypePredicateNode(node) {
						recover()
						return serializeExistingTypeNode(context, node)
					}
					return node
				}
				return /* TODO(ConditionalExpression): result ? setTextRange(context, result, node) : undefined */ TODO
			}
			createRecoveryBoundary := func() /* TODO(undefined): { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ TODO {
				var trackedSymbols []TrackedSymbol
				var unreportedErrors []func()
				oldTracker := /* TODO(PropertyAccessExpression): context.tracker */ TODO
				oldTrackedSymbols := /* TODO(PropertyAccessExpression): context.trackedSymbols */ TODO
				/* TODO(ExpressionStatement): context.trackedSymbols = undefined; */
				oldEncounteredError := /* TODO(PropertyAccessExpression): context.encounteredError */ TODO
				/* TODO(ExpressionStatement): context.tracker = new SymbolTrackerImpl(context, {                     ...oldTracker.inner,                     reportCyclicStructureError() {                         markError(() => oldTracker.reportCyclicStructureError());                     },                     reportInaccessibleThisError() {                         markError(() => oldTracker.reportInaccessibleThisError());                     },                     reportInaccessibleUniqueSymbolError() {                         markError(() => oldTracker.reportInaccessibleUniqueSymbolError());                     },                     reportLikelyUnsafeImportRequiredError(specifier) {                         markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier));                     },                     reportNonSerializableProperty(name) {                         markError(() => oldTracker.reportNonSerializableProperty(name));                     },                     trackSymbol(sym, decl, meaning) {                         (trackedSymbols ??= []).push([sym, decl, meaning]);                         return false;                     },                     moduleResolverHost: context.tracker.moduleResolverHost,                 }, context.tracker.moduleResolverHost); */
				return /* TODO(ObjectLiteralExpression): {                     startRecoveryScope,                     finalizeBoundary,                 } */ TODO
				markError := func(unreportedError func()) {
					/* TODO(ExpressionStatement): hadError = true; */
					/* TODO(PropertyAccessExpression): (unreportedErrors ??= []).push */
					TODO(unreportedError)
				}
				startRecoveryScope := func() /* TODO(undefined): () => void */ TODO {
					trackedSymbolsTop := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): trackedSymbols?.length ?? 0 */ TODO
					unreportedErrorsTop := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): unreportedErrors?.length ?? 0 */ TODO
					return /* TODO(ArrowFunction): () => {                         hadError = false;                         // Reset the tracked symbols to before the error                         if (trackedSymbols) {                             trackedSymbols.length = trackedSymbolsTop;                         }                         if (unreportedErrors) {                             unreportedErrors.length = unreportedErrorsTop;                         }                     } */ TODO
				}
				finalizeBoundary := func() /* TODO(undefined): boolean */ TODO {
					/* TODO(ExpressionStatement): context.tracker = oldTracker; */
					/* TODO(ExpressionStatement): context.trackedSymbols = oldTrackedSymbols; */
					/* TODO(ExpressionStatement): context.encounteredError = oldEncounteredError; */
					/* TODO(PropertyAccessExpression): unreportedErrors?.forEach */
					TODO( /* TODO(ArrowFunction): fn => fn() */ TODO)
					if hadError {
						return /* TODO(FalseKeyword): false */ TODO
					}
					/* TODO(PropertyAccessExpression): trackedSymbols?.forEach */ TODO( /* TODO(ArrowFunction): ([symbol, enclosingDeclaration, meaning]) =>                             context.tracker.trackSymbol(                                 symbol,                                 enclosingDeclaration,                                 meaning,                             ) */ TODO)
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
			onEnterNewScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): () => void */ TODO {
				return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
			}
			tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
				innerNode := skipTypeParentheses(node)
				/* TODO(SwitchStatement): switch (innerNode.kind) {                     case SyntaxKind.TypeReference:                         return tryVisitTypeReference(innerNode as TypeReferenceNode);                     case SyntaxKind.TypeQuery:                         return tryVisitTypeQuery(innerNode as TypeQueryNode);                     case SyntaxKind.IndexedAccessType:                         return tryVisitIndexedAccess(innerNode as IndexedAccessTypeNode);                     case SyntaxKind.TypeOperator:                         const typeOperatorNode = innerNode as TypeOperatorNode;                         if (typeOperatorNode.operator === SyntaxKind.KeyOfKeyword) {                             return tryVisitKeyOf(typeOperatorNode);                         }                 } */
				return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
			}
			tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
				resultObjectType := tryVisitSimpleTypeNode( /* TODO(PropertyAccessExpression): node.objectType */ TODO)
				if resultObjectType == nil {
					return nil
				}
				return /* TODO(PropertyAccessExpression): factory.updateIndexedAccessTypeNode */ TODO(node, resultObjectType /* TODO(NonNullExpression): visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode)! */, TODO)
			}
			tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
				/* TODO(PropertyAccessExpression): Debug.assertEqual */ TODO( /* TODO(PropertyAccessExpression): node.operator */ TODO /* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */, TODO)
				type_ := tryVisitSimpleTypeNode( /* TODO(PropertyAccessExpression): node.type */ TODO)
				if type_ == nil {
					return nil
				}
				return /* TODO(PropertyAccessExpression): factory.updateTypeOperatorNode */ TODO(node, type_)
			}
			tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
				TODO_IDENTIFIER := trackExistingEntityName( /* TODO(PropertyAccessExpression): node.exprName */ TODO, context)
				if !introducesError {
					return /* TODO(PropertyAccessExpression): factory.updateTypeQueryNode */ TODO(node, exprName, visitNodes( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, visitExistingNodeTreeSymbols, isTypeNode))
				}
				serializedName := serializeTypeName(context /* TODO(PropertyAccessExpression): node.exprName */, TODO /* TODO(TrueKeyword): true */, TODO)
				if serializedName {
					return setTextRange(context, serializedName /* TODO(PropertyAccessExpression): node.exprName */, TODO)
				}
			}
			tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
				if canReuseTypeNode(context, node) {
					TODO_IDENTIFIER := trackExistingEntityName( /* TODO(PropertyAccessExpression): node.typeName */ TODO, context)
					typeArguments := visitNodes( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, visitExistingNodeTreeSymbols, isTypeNode)
					if !introducesError {
						updated := /* TODO(PropertyAccessExpression): factory.updateTypeReferenceNode */ TODO(node, newName, typeArguments)
						return setTextRange(context, updated, node)
					} else {
						serializedName := serializeTypeName(context /* TODO(PropertyAccessExpression): node.typeName */, TODO /* TODO(FalseKeyword): false */, TODO, typeArguments)
						if serializedName {
							return setTextRange(context, serializedName /* TODO(PropertyAccessExpression): node.typeName */, TODO)
						}
					}
				}
			}
			visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
				if isJSDocTypeExpression(node) {
					return visitNode( /* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols, isTypeNode)
				}
				if isJSDocAllType(node) || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocNamepathType */ TODO {
					return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO)
				}
				if isJSDocUnknownType(node) {
					return /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.UnknownKeyword */ TODO)
				}
				if isJSDocNullableType(node) {
					return /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO( /* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createLiteralTypeNode(factory.createNull())] */ TODO)
				}
				if isJSDocOptionalType(node) {
					return /* TODO(PropertyAccessExpression): factory.createUnionTypeNode */ TODO( /* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
				if isJSDocNonNullableType(node) {
					return visitNode( /* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols)
				}
				if isJSDocVariadicType(node) {
					return /* TODO(PropertyAccessExpression): factory.createArrayTypeNode */ TODO( /* TODO(NonNullExpression): visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO)
				}
				if isJSDocTypeLiteral(node) {
					return /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO(map_( /* TODO(PropertyAccessExpression): node.jsDocPropertyTags */ TODO /* TODO(ArrowFunction): t => {                         const name = visitNode(isIdentifier(t.name) ? t.name : t.name.right, visitExistingNodeTreeSymbols, isIdentifier)!;                         const typeViaParent = getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText);                         const overrideTypeNode = typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined;                          return factory.createPropertySignature(                             /*modifiers* / undefined,                             name,                             t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                             overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKind.AnyKeyword),                         );                     } */, TODO))
				}
				if isTypeReferenceNode(node) && isIdentifier( /* TODO(PropertyAccessExpression): node.typeName */ TODO) && /* TODO(PropertyAccessExpression): node.typeName.escapedText */ TODO == "" {
					return setOriginalNode( /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO), node)
				}
				if /* TODO(ParenthesizedExpression): (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) */ TODO && isJSDocIndexSignature(node) {
					return /* TODO(PropertyAccessExpression): factory.createTypeLiteralNode */ TODO( /* TODO(ArrayLiteralExpression): [factory.createIndexSignature(                         /*modifiers* / undefined,                         [factory.createParameterDeclaration(                             /*modifiers* / undefined,                             /*dotDotDotToken* / undefined,                             "x",                             /*questionToken* / undefined,                             visitNode(node.typeArguments![0], visitExistingNodeTreeSymbols, isTypeNode),                         )],                         visitNode(node.typeArguments![1], visitExistingNodeTreeSymbols, isTypeNode),                     )] */ TODO)
				}
				if isJSDocFunctionType(node) {
					if isJSDocConstructSignature(node) {
						var newTypeNode *TypeNode
						return /* TODO(PropertyAccessExpression): factory.createConstructorTypeNode */ TODO(nil, visitNodes( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined( /* TODO(PropertyAccessExpression): node.parameters */ TODO /* TODO(ArrowFunction): (p, i) =>                                 p.name && isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode = p.type, undefined) : factory.createParameterDeclaration(                                     /*modifiers* / undefined,                                     getEffectiveDotDotDotForParameter(p),                                     setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),                                     factory.cloneNode(p.questionToken),                                     visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),                                     /*initializer* / undefined,                                 ) */, TODO), visitNode(newTypeNode || /* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols, isTypeNode) || /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO))
					} else {
						return /* TODO(PropertyAccessExpression): factory.createFunctionTypeNode */ TODO(visitNodes( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_( /* TODO(PropertyAccessExpression): node.parameters */ TODO /* TODO(ArrowFunction): (p, i) =>                                 factory.createParameterDeclaration(                                     /*modifiers* / undefined,                                     getEffectiveDotDotDotForParameter(p),                                     setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),                                     factory.cloneNode(p.questionToken),                                     visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),                                     /*initializer* / undefined,                                 ) */, TODO), visitNode( /* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols, isTypeNode) || /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO))
					}
				}
				if isThisTypeNode(node) {
					if canReuseTypeNode(context, node) {
						return node
					}
					/* TODO(ExpressionStatement): hadError = true; */
					return node
				}
				if isTypeParameterDeclaration(node) {
					return /* TODO(PropertyAccessExpression): factory.updateTypeParameterDeclaration */ TODO(node, visitNodes( /* TODO(PropertyAccessExpression): node.modifiers */ TODO, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node), visitNode( /* TODO(PropertyAccessExpression): node.constraint */ TODO, visitExistingNodeTreeSymbols, isTypeNode), visitNode( /* TODO(PropertyAccessExpression): node.default */ TODO, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isIndexedAccessTypeNode(node) {
					result := tryVisitIndexedAccess(node)
					if !result {
						/* TODO(ExpressionStatement): hadError = true; */
						return node
					}
					return result
				}
				if isTypeReferenceNode(node) {
					result := tryVisitTypeReference(node)
					if result {
						return result
					}
					/* TODO(ExpressionStatement): hadError = true; */
					return node
				}
				if isLiteralImportTypeNode(node) {
					nodeSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
					if isInJSDoc(node) && nodeSymbol && /* TODO(ParenthesizedExpression): (                             // The import type resolved using jsdoc fallback logic                             (!node.isTypeOf && !(nodeSymbol.flags & SymbolFlags.Type)) ||                             // The import type had type arguments autofilled by js fallback logic                             !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))                         ) */ TODO {
						return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
					}
					return /* TODO(PropertyAccessExpression): factory.updateImportTypeNode */ TODO(node /* TODO(PropertyAccessExpression): factory.updateLiteralTypeNode */, TODO( /* TODO(PropertyAccessExpression): node.argument */ TODO, rewriteModuleSpecifier(node /* TODO(PropertyAccessExpression): node.argument.literal */, TODO)), visitNode( /* TODO(PropertyAccessExpression): node.attributes */ TODO, visitExistingNodeTreeSymbols, isImportAttributes), visitNode( /* TODO(PropertyAccessExpression): node.qualifier */ TODO, visitExistingNodeTreeSymbols, isEntityName), visitNodes( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, visitExistingNodeTreeSymbols, isTypeNode) /* TODO(PropertyAccessExpression): node.isTypeOf */, TODO)
				}
				if isNamedDeclaration(node) && /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO && !isLateBindableName( /* TODO(PropertyAccessExpression): node.name */ TODO) {
					if !hasDynamicName(node) {
						return visitEachChild(node, visitExistingNodeTreeSymbols)
					}
					if ! /* TODO(ParenthesizedExpression): (context.internalFlags & InternalNodeBuilderFlags.AllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags & TypeFlags.Any) */ TODO {
						return nil
					}
				}
				if /* TODO(ParenthesizedExpression): (isFunctionLike(node) && !node.type) */ TODO || /* TODO(ParenthesizedExpression): (isPropertyDeclaration(node) && !node.type && !node.initializer) */ TODO || /* TODO(ParenthesizedExpression): (isPropertySignature(node) && !node.type && !node.initializer) */ TODO || /* TODO(ParenthesizedExpression): (isParameter(node) && !node.type && !node.initializer) */ TODO {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					if visited == node {
						/* TODO(ExpressionStatement): visited = setTextRange(context, factory.cloneNode(node), node); */
					}
					/* TODO(ExpressionStatement): (visited as Mutable<typeof visited>).type = factory.createKeywordTypeNode(SyntaxKind.AnyKeyword); */
					if isParameter(node) {
						/* TODO(ExpressionStatement): (visited as Mutable<ParameterDeclaration>).modifiers = undefined; */
					}
					return visited
				}
				if isTypeQueryNode(node) {
					result := tryVisitTypeQuery(node)
					if !result {
						/* TODO(ExpressionStatement): hadError = true; */
						return node
					}
					return result
				}
				if isComputedPropertyName(node) && isEntityNameExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
					TODO_IDENTIFIER := trackExistingEntityName( /* TODO(PropertyAccessExpression): node.expression */ TODO, context)
					if !introducesError {
						return /* TODO(PropertyAccessExpression): factory.updateComputedPropertyName */ TODO(node, result)
					} else {
						type_ := getWidenedType(getRegularTypeOfExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO))
						computedPropertyNameType := typeToTypeNodeHelper(type_, context)
						var literal TODO
						if isLiteralTypeNode(computedPropertyNameType) {
							/* TODO(ExpressionStatement): literal = computedPropertyNameType.literal; */
						} else {
							evaluated := evaluateEntityNameExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
							literalNode := /* TODO(ConditionalExpression): typeof evaluated.value === "string" ? factory.createStringLiteral(evaluated.value, /*isSingleQuote* / undefined) :                                 typeof evaluated.value === "number" ? factory.createNumericLiteral(evaluated.value, /*numericLiteralFlags* / 0) :                                 undefined */ TODO
							if !literalNode {
								if isImportTypeNode(computedPropertyNameType) {
									trackComputedName( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO, context)
								}
								return node
							}
							/* TODO(ExpressionStatement): literal = literalNode; */
						}
						if /* TODO(PropertyAccessExpression): literal.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.StringLiteral */ TODO && isIdentifierText( /* TODO(PropertyAccessExpression): literal.text */ TODO, getEmitScriptTarget(compilerOptions)) {
							return /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO( /* TODO(PropertyAccessExpression): literal.text */ TODO)
						}
						if /* TODO(PropertyAccessExpression): literal.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NumericLiteral */ TODO && ! /* TODO(PropertyAccessExpression): literal.text.startsWith */ TODO("-") {
							return literal
						}
						return /* TODO(PropertyAccessExpression): factory.updateComputedPropertyName */ TODO(node, literal)
					}
				}
				if isTypePredicateNode(node) {
					var parameterName TODO
					if isIdentifier( /* TODO(PropertyAccessExpression): node.parameterName */ TODO) {
						TODO_IDENTIFIER := trackExistingEntityName( /* TODO(PropertyAccessExpression): node.parameterName */ TODO, context)
						/* TODO(ExpressionStatement): hadError = hadError || introducesError; */
						/* TODO(ExpressionStatement): parameterName = result; */
					} else {
						/* TODO(ExpressionStatement): parameterName = factory.cloneNode(node.parameterName); */
					}
					return /* TODO(PropertyAccessExpression): factory.updateTypePredicateNode */ TODO(node /* TODO(PropertyAccessExpression): factory.cloneNode */, TODO( /* TODO(PropertyAccessExpression): node.assertsModifier */ TODO), parameterName, visitNode( /* TODO(PropertyAccessExpression): node.type */ TODO, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					clone := setTextRange(context /* TODO(ConditionalExpression): visited === node ? factory.cloneNode(node) : visited */, TODO, node)
					flags := getEmitFlags(clone)
					setEmitFlags(clone /* TODO(BarToken): | */ /* TODO(BinaryExpression): flags | (context.flags & NodeBuilderFlags.MultilineObjectLiterals && isTypeLiteralNode(node) ? 0 : EmitFlags.SingleLine) */, TODO)
					return clone
				}
				if isStringLiteral(node) && !! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseSingleQuotesForStringLiteralType) */ TODO && ! /* TODO(PropertyAccessExpression): node.singleQuote */ TODO {
					clone := /* TODO(PropertyAccessExpression): factory.cloneNode */ TODO(node)
					/* TODO(ExpressionStatement): (clone as Mutable<typeof clone>).singleQuote = true; */
					return clone
				}
				if isConditionalTypeNode(node) {
					checkType := /* TODO(NonNullExpression): visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					disposeScope := onEnterNewScope(node)
					extendType := /* TODO(NonNullExpression): visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					trueType := /* TODO(NonNullExpression): visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					disposeScope()
					falseType := /* TODO(NonNullExpression): visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					return /* TODO(PropertyAccessExpression): factory.updateConditionalTypeNode */ TODO(node, checkType, extendType, trueType, falseType)
				}
				if isTypeOperatorNode(node) {
					if /* TODO(PropertyAccessExpression): node.operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.UniqueKeyword */ TODO && /* TODO(PropertyAccessExpression): node.type.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO {
						if !canReuseTypeNode(context, node) {
							/* TODO(ExpressionStatement): hadError = true; */
							return node
						}
					} else if /* TODO(PropertyAccessExpression): node.operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */ TODO {
						result := tryVisitKeyOf(node)
						if !result {
							/* TODO(ExpressionStatement): hadError = true; */
							return node
						}
						return result
					}
				}
				return visitEachChild(node, visitExistingNodeTreeSymbols)
				// OVERLOAD: visitEachChild := func(node T, visitor Visitor) T
				// OVERLOAD: visitEachChild := func(node *T, visitor Visitor) *T
				visitEachChild := func(node *T, visitor Visitor) *T {
					nonlocalNode := ! /* TODO(PropertyAccessExpression): context.enclosingFile */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): context.enclosingFile !== getSourceFileOfNode(node) */ TODO
					return visitEachChildWorker(node, visitor, nil /* TODO(ConditionalExpression): nonlocalNode ? visitNodesWithoutCopyingPositions : undefined */, TODO)
				}
				visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					result := visitNodes(nodes, visitor, test, start, count)
					if result {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result.pos !== -1 */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result.end !== -1 */ TODO {
							if result == nodes {
								/* TODO(ExpressionStatement): result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma); */
							}
							setTextRangePosEnd(result, -1, -1)
						}
					}
					return result
				}
				getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DotDotDotToken | undefined */ TODO {
					return /* TODO(PropertyAccessExpression): p.dotDotDotToken */ TODO || /* TODO(ParenthesizedExpression): (p.type && isJSDocVariadicType(p.type) ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined) */ TODO
				}
				getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) /* TODO(undefined): string */ TODO {
					return /* TODO(ConditionalExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "this" ? "this"                         : getEffectiveDotDotDotForParameter(p) ? `args`                         : `arg${index}` */ TODO
				}
				rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral */ TODO {
					if /* TODO(PropertyAccessExpression): context.bundled */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): context.enclosingFile !== getSourceFileOfNode(lit) */ TODO {
						name := /* TODO(PropertyAccessExpression): lit.text */ TODO
						nodeSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
						meaning := /* TODO(ConditionalExpression): parent.isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
						parentSymbol := nodeSymbol && /* TODO(PropertyAccessExpression): isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility */ TODO == /* TODO(PropertyAccessExpression): SymbolAccessibility.Accessible */ TODO && /* TODO(ElementAccessExpression): lookupSymbolChain(nodeSymbol, context, meaning, /*yieldModuleSymbol* / true)[0] */ TODO
						if parentSymbol && isExternalModuleSymbol(parentSymbol) {
							/* TODO(ExpressionStatement): name = getSpecifierForModuleSymbol(parentSymbol, context); */
						} else {
							targetFile := getExternalModuleFileFromDeclaration(parent)
							if targetFile {
								/* TODO(ExpressionStatement): name = getSpecifierForModuleSymbol(targetFile.symbol, context); */
							}
						}
						if /* TODO(PropertyAccessExpression): name.includes */ TODO("/node_modules/") {
							/* TODO(ExpressionStatement): context.encounteredError = true; */
							if /* TODO(PropertyAccessExpression): context.tracker.reportLikelyUnsafeImportRequiredError */ TODO {
								/* TODO(PropertyAccessExpression): context.tracker.reportLikelyUnsafeImportRequiredError */ TODO(name)
							}
						}
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== lit.text */ TODO {
							return setOriginalNode( /* TODO(PropertyAccessExpression): factory.createStringLiteral */ TODO(name), lit)
						}
					}
					return /* TODO(NonNullExpression): visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)! */ TODO
				}
			}
		}
		symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
			serializePropertySymbolForClass := makeSerializePropertySymbol( /* TODO(PropertyAccessExpression): factory.createPropertyDeclaration */ TODO /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */, TODO /* TODO(TrueKeyword): true */, TODO)
			serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol( /* TODO(ArrowFunction): (mods, name, question, type) => factory.createPropertySignature(mods, name, question, type) */ TODO /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */, TODO /* TODO(FalseKeyword): false */, TODO)
			enclosingDeclaration := /* TODO(NonNullExpression): context.enclosingDeclaration! */ TODO
			var results []Statement = /* TODO(ArrayLiteralExpression): [] */ TODO
			visitedSymbols := /* TODO(NewExpression): new Set<number>() */ TODO
			var deferredPrivatesStack []Map[SymbolId, Symbol] = /* TODO(ArrayLiteralExpression): [] */ TODO
			oldcontext := context
			/* TODO(ExpressionStatement): context = {                 ...oldcontext,                 usedSymbolNames: new Set(oldcontext.usedSymbolNames),                 remappedSymbolNames: new Map(),                 remappedSymbolReferences: new Map(oldcontext.remappedSymbolReferences?.entries()),                 tracker: undefined!,             }; */
			var tracker SymbolTracker = /* TODO(ObjectLiteralExpression): {                 ...oldcontext.tracker.inner,                 trackSymbol: (sym, decl, meaning) => {                     if (context.remappedSymbolNames?.has(getSymbolId(sym))) return false; // If the context has a remapped name for the symbol, it *should* mean it's been made visible                     const accessibleResult = isSymbolAccessible(sym, decl, meaning, /*shouldComputeAliasesToMakeVisible* / false);                     if (accessibleResult.accessibility === SymbolAccessibility.Accessible) {                         // Lookup the root symbol of the chain of refs we'll use to access it and serialize it                         const chain = lookupSymbolChainWorker(sym, context, meaning);                         if (!(sym.flags & SymbolFlags.Property)) {                             // Only include referenced privates in the same file. Weird JS aliases may expose privates                             // from other files - assume JS transforms will make those available via expected means                             const root = chain[0];                             const contextFile = getSourceFileOfNode(oldcontext.enclosingDeclaration);                             if (some(root.declarations, d => getSourceFileOfNode(d) === contextFile)) {                                 includePrivateSymbol(root);                             }                         }                     }                     else if (oldcontext.tracker.inner?.trackSymbol) {                         return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning);                     }                     return false;                 },             } */ TODO
			/* TODO(ExpressionStatement): context.tracker = new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost); */
			forEachEntry(symbolTable /* TODO(ArrowFunction): (symbol, name) => {                 const baseName = unescapeLeadingUnderscores(name);                 void getInternalSymbolName(symbol, baseName); // Called to cache values into `usedSymbolNames` and `remappedSymbolNames`             } */, TODO)
			addingDeclare := ! /* TODO(PropertyAccessExpression): context.bundled */ TODO
			exportEquals := /* TODO(PropertyAccessExpression): symbolTable.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
			if exportEquals && /* TODO(PropertyAccessExpression): symbolTable.size */ TODO > 1 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): exportEquals.flags & (SymbolFlags.Alias | SymbolFlags.Module) */ TODO {
				/* TODO(ExpressionStatement): symbolTable = createSymbolTable(); */
				/* TODO(PropertyAccessExpression): symbolTable.set */
				TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO, exportEquals)
			}
			visitSymbolTable(symbolTable)
			return mergeRedundantStatements(results)
			isIdentifierAndNotUndefined := func(node Node) /* TODO(TypePredicate): node is Identifier */ TODO {
				return !!node && /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO
			}
			getNamesOfDeclaration := func(statement Statement) []Identifier {
				if isVariableStatement(statement) {
					return filter(map_( /* TODO(PropertyAccessExpression): statement.declarationList.declarations */ TODO, getNameOfDeclaration), isIdentifierAndNotUndefined)
				}
				return filter( /* TODO(ArrayLiteralExpression): [getNameOfDeclaration(statement as DeclarationStatement)] */ TODO, isIdentifierAndNotUndefined)
			}
			flattenExportAssignedNamespace := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				exportAssignment := find(statements, isExportAssignment)
				nsIndex := findIndex(statements, isModuleDeclaration)
				ns := /* TODO(ConditionalExpression): nsIndex !== -1 ? statements[nsIndex] as ModuleDeclaration : undefined */ TODO
				if ns && exportAssignment && /* TODO(PropertyAccessExpression): exportAssignment.isExportEquals */ TODO && isIdentifier( /* TODO(PropertyAccessExpression): exportAssignment.expression */ TODO) && isIdentifier( /* TODO(PropertyAccessExpression): ns.name */ TODO) && idText( /* TODO(PropertyAccessExpression): ns.name */ TODO) == idText( /* TODO(PropertyAccessExpression): exportAssignment.expression */ TODO) && /* TODO(PropertyAccessExpression): ns.body */ TODO && isModuleBlock( /* TODO(PropertyAccessExpression): ns.body */ TODO) {
					excessExports := filter(statements /* TODO(ArrowFunction): s => !!(getEffectiveModifierFlags(s) & ModifierFlags.Export) */, TODO)
					name := /* TODO(PropertyAccessExpression): ns.name */ TODO
					body := /* TODO(PropertyAccessExpression): ns.body */ TODO
					if length(excessExports) {
						/* TODO(ExpressionStatement): ns = factory.updateModuleDeclaration(                             ns,                             ns.modifiers,                             ns.name,                             body = factory.updateModuleBlock(                                 body,                                 factory.createNodeArray([                                     ...ns.body.statements,                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))),                                         /*moduleSpecifier* / undefined,                                     ),                                 ]),                             ),                         ); */
						/* TODO(ExpressionStatement): statements = [...statements.slice(0, nsIndex), ns, ...statements.slice(nsIndex + 1)]; */
					}
					if !find(statements /* TODO(ArrowFunction): s => s !== ns && nodeHasName(s, name) */, TODO) {
						/* TODO(ExpressionStatement): results = []; */
						mixinExportFlag := !some( /* TODO(PropertyAccessExpression): body.statements */ TODO /* TODO(ArrowFunction): s => hasSyntacticModifier(s, ModifierFlags.Export) || isExportAssignment(s) || isExportDeclaration(s) */, TODO)
						forEach( /* TODO(PropertyAccessExpression): body.statements */ TODO /* TODO(ArrowFunction): s => {                             addResult(s, mixinExportFlag ? ModifierFlags.Export : ModifierFlags.None); // Recalculates the ambient (and export, if applicable from above) flag                         } */, TODO)
						/* TODO(ExpressionStatement): statements = [...filter(statements, s => s !== ns && s !== exportAssignment), ...results]; */
					}
				}
				return statements
			}
			mergeExportDeclarations := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				exports := filter(statements /* TODO(ArrowFunction): d => isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause) */, TODO) /* as */ /* TODO(ArrayType): ExportDeclaration[] */
				if length(exports) > 1 {
					nonExports := filter(statements /* TODO(ArrowFunction): d => !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause */, TODO)
					/* TODO(ExpressionStatement): statements = [                         ...nonExports,                         factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports(flatMap(exports, e => cast(e.exportClause, isNamedExports).elements)),                             /*moduleSpecifier* / undefined,                         ),                     ]; */
				}
				reexports := filter(statements /* TODO(ArrowFunction): d => isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause) */, TODO) /* as */ /* TODO(ArrayType): ExportDeclaration[] */
				if length(reexports) > 1 {
					groups := group(reexports /* TODO(ArrowFunction): decl => isStringLiteral(decl.moduleSpecifier!) ? ">" + decl.moduleSpecifier.text : ">" */, TODO)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): groups.length !== reexports.length */ TODO {
						for _, group := range groups {
							if /* TODO(PropertyAccessExpression): group.length */ TODO > 1 {
								/* TODO(ExpressionStatement): statements = [                                     ...filter(statements, s => !group.includes(s as ExportDeclaration)),                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(flatMap(group, e => cast(e.exportClause, isNamedExports).elements)),                                         group[0].moduleSpecifier,                                     ),                                 ]; */
							}
						}
					}
				}
				return statements
			}
			inlineExportModifiers := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				index := findIndex(statements /* TODO(ArrowFunction): d => isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause) */, TODO)
				if index >= 0 {
					exportDecl := /* TODO(ElementAccessExpression): statements[index] */ TODO /* as */ /* TODO(IntersectionType): ExportDeclaration & { readonly exportClause: NamedExports; } */
					replacements := mapDefined( /* TODO(PropertyAccessExpression): exportDecl.exportClause.elements */ TODO /* TODO(ArrowFunction): e => {                         if (!e.propertyName && e.name.kind !== SyntaxKind.StringLiteral) {                             // export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it                             const name = e.name;                             const indices = indicesOf(statements);                             const associatedIndices = filter(indices, i => nodeHasName(statements[i], name));                             if (length(associatedIndices) && every(associatedIndices, i => canHaveExportModifier(statements[i]))) {                                 for (const index of associatedIndices) {                                     statements[index] = addExportModifier(statements[index] as Extract<HasModifiers, Statement>);                                 }                                 return undefined;                             }                         }                         return e;                     } */, TODO)
					if !length(replacements) {
						orderedRemoveItemAt(statements, index)
					} else {
						/* TODO(ExpressionStatement): statements[index] = factory.updateExportDeclaration(                             exportDecl,                             exportDecl.modifiers,                             exportDecl.isTypeOnly,                             factory.updateNamedExports(                                 exportDecl.exportClause,                                 replacements,                             ),                             exportDecl.moduleSpecifier,                             exportDecl.attributes,                         ); */
					}
				}
				return statements
			}
			mergeRedundantStatements := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				/* TODO(ExpressionStatement): statements = flattenExportAssignedNamespace(statements); */
				/* TODO(ExpressionStatement): statements = mergeExportDeclarations(statements); */
				/* TODO(ExpressionStatement): statements = inlineExportModifiers(statements); */
				if enclosingDeclaration && /* TODO(ParenthesizedExpression): ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) */ TODO && /* TODO(ParenthesizedExpression): (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) */ TODO {
					/* TODO(PropertyAccessExpression): statements.push */ TODO(createEmptyExports(factory))
				}
				return statements
			}
			addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement */ TODO {
				flags := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (getEffectiveModifierFlags(node) | ModifierFlags.Export) & ~ModifierFlags.Ambient */ TODO
				return /* TODO(PropertyAccessExpression): factory.replaceModifiers */ TODO(node, flags)
			}
			removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement */ TODO {
				flags := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getEffectiveModifierFlags(node) & ~ModifierFlags.Export */ TODO
				return /* TODO(PropertyAccessExpression): factory.replaceModifiers */ TODO(node, flags)
			}
			visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
				if !suppressNewPrivateContext {
					/* TODO(PropertyAccessExpression): deferredPrivatesStack.push */ TODO( /* TODO(NewExpression): new Map() */ TODO)
				}
				/* TODO(PropertyAccessExpression): symbolTable.forEach */ TODO( /* TODO(ArrowFunction): (symbol: Symbol) => {                     serializeSymbol(symbol, /*isPrivate* / false, !!propertyAsAlias);                 } */ TODO)
				if !suppressNewPrivateContext {
					/* TODO(PropertyAccessExpression): deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach */ TODO( /* TODO(ArrowFunction): (symbol: Symbol) => {                         serializeSymbol(symbol, /*isPrivate* / true, !!propertyAsAlias);                     } */ TODO)
					/* TODO(PropertyAccessExpression): deferredPrivatesStack.pop */ TODO()
				}
			}
			serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
				/* TODO(ExpressionStatement): void getPropertiesOfType(getTypeOfSymbol(symbol)); */
				visitedSym := getMergedSymbol(symbol)
				if /* TODO(PropertyAccessExpression): visitedSymbols.has */ TODO(getSymbolId(visitedSym)) {
					return
				}
				/* TODO(PropertyAccessExpression): visitedSymbols.add */ TODO(getSymbolId(visitedSym))
				skipMembershipCheck := !isPrivate
				if skipMembershipCheck || /* TODO(ParenthesizedExpression): (!!length(symbol.declarations) && some(symbol.declarations, d => !!findAncestor(d, n => n === enclosingDeclaration))) */ TODO {
					scopeCleanup := cloneNodeBuilderContext(context)
					serializeSymbolWorker(symbol, isPrivate, propertyAsAlias)
					scopeCleanup()
				}
			}
			serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO /* = */ /* TODO(PropertyAccessExpression): symbol.escapedName */) {
				symbolName := unescapeLeadingUnderscores(escapedSymbolName)
				isDefault := escapedSymbolName == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO
				if isPrivate && ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.AllowAnonymousIdentifier) */ TODO && isStringANonContextualKeyword(symbolName) && !isDefault {
					/* TODO(ExpressionStatement): context.encounteredError = true; */
					return
				}
				needsPostExportDefault := isDefault && !! /* TODO(ParenthesizedExpression): (                     symbol.flags & SymbolFlags.ExportDoesNotSupportDefaultModifier                     || (symbol.flags & SymbolFlags.Function && length(getPropertiesOfType(getTypeOfSymbol(symbol))))                 ) */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias) */ TODO
				needsExportDeclaration := !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault
				if needsPostExportDefault || needsExportDeclaration {
					/* TODO(ExpressionStatement): isPrivate = true; */
				}
				modifierFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): (!isPrivate ? ModifierFlags.Export : 0) | (isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0) */ TODO
				isConstMergedWithNS := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Module */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): escapedSymbolName !== InternalSymbolName.ExportEquals */ TODO
				isConstMergedWithNSPrintableAsSignatureMerge := isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) */ TODO || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO {
					serializeTypeAlias(symbol, symbolName, modifierFlags)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.FunctionScopedVariable | SymbolFlags.Property | SymbolFlags.Accessor) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): escapedSymbolName !== InternalSymbolName.ExportEquals */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Prototype) */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Class) */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Method) */ TODO && !isConstMergedWithNSPrintableAsSignatureMerge {
					if propertyAsAlias {
						createdExport := serializeMaybeAliasAssignment(symbol)
						if createdExport {
							/* TODO(ExpressionStatement): needsExportDeclaration = false; */
							/* TODO(ExpressionStatement): needsPostExportDefault = false; */
						}
					} else {
						type_ := getTypeOfSymbol(symbol)
						localName := getInternalSymbolName(symbol, symbolName)
						if /* TODO(PropertyAccessExpression): type.symbol */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.symbol !== symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.Function */ TODO && some( /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO, isFunctionExpressionOrArrowFunction) && /* TODO(ParenthesizedExpression): (type.symbol.members?.size || type.symbol.exports?.size) */ TODO {
							if ! /* TODO(PropertyAccessExpression): context.remappedSymbolReferences */ TODO {
								/* TODO(ExpressionStatement): context.remappedSymbolReferences = new Map(); */
							}
							/* TODO(PropertyAccessExpression): context.remappedSymbolReferences.set */ TODO(getSymbolId( /* TODO(PropertyAccessExpression): type.symbol */ TODO), symbol)
							serializeSymbolWorker( /* TODO(PropertyAccessExpression): type.symbol */ TODO, isPrivate, propertyAsAlias, escapedSymbolName)
							/* TODO(PropertyAccessExpression): context.remappedSymbolReferences.delete */ TODO(getSymbolId( /* TODO(PropertyAccessExpression): type.symbol */ TODO))
						} else if ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Function) */ TODO && isTypeRepresentableAsFunctionNamespaceMerge(type_, symbol) {
							serializeAsFunctionNamespaceMerge(type_, symbol, localName, modifierFlags)
						} else {
							flags := /* TODO(ConditionalExpression): !(symbol.flags & SymbolFlags.BlockScopedVariable)                                 ? symbol.parent?.valueDeclaration && isSourceFile(symbol.parent?.valueDeclaration)                                     ? NodeFlags.Const // exports are immutable in es6, which is what we emulate and check; so it's safe to mark all exports as `const` (there's no difference to consumers, but it allows unique symbol type declarations)                                     : undefined                                 : isConstantVariable(symbol)                                 ? NodeFlags.Const                                 : NodeFlags.Let */ TODO
							name := /* TODO(ConditionalExpression): (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(localName, symbol) */ TODO
							var textRange Node = /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && find( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => isVariableDeclaration(d) */, TODO)
							if textRange && isVariableDeclarationList( /* TODO(PropertyAccessExpression): textRange.parent */ TODO) && /* TODO(PropertyAccessExpression): textRange.parent.declarations.length */ TODO == 1 {
								/* TODO(ExpressionStatement): textRange = textRange.parent.parent; */
							}
							propertyAccessRequire := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isPropertyAccessExpression)
							if propertyAccessRequire && isBinaryExpression( /* TODO(PropertyAccessExpression): propertyAccessRequire.parent */ TODO) && isIdentifier( /* TODO(PropertyAccessExpression): propertyAccessRequire.parent.right */ TODO) && /* TODO(PropertyAccessExpression): type.symbol?.valueDeclaration */ TODO && isSourceFile( /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO) {
								alias := /* TODO(ConditionalExpression): localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right */ TODO
								addResult( /* TODO(PropertyAccessExpression): factory.createExportDeclaration */ TODO(nil /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): factory.createNamedExports */, TODO( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, alias, localName)] */ TODO)) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
								/* TODO(PropertyAccessExpression): context.tracker.trackSymbol */ TODO( /* TODO(PropertyAccessExpression): type.symbol */ TODO /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
							} else {
								statement := setTextRange(context /* TODO(PropertyAccessExpression): factory.createVariableStatement */, TODO(nil /* TODO(PropertyAccessExpression): factory.createVariableDeclarationList */, TODO( /* TODO(ArrayLiteralExpression): [                                             factory.createVariableDeclaration(name, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, type, symbol)),                                         ] */ TODO, flags)), textRange)
								addResult(statement /* TODO(ConditionalExpression): name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags */, TODO)
								if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== localName */ TODO && !isPrivate {
									addResult( /* TODO(PropertyAccessExpression): factory.createExportDeclaration */ TODO(nil /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): factory.createNamedExports */, TODO( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, name, localName)] */ TODO)) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
									/* TODO(ExpressionStatement): needsExportDeclaration = false; */
									/* TODO(ExpressionStatement): needsPostExportDefault = false; */
								}
							}
						}
					}
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Enum */ TODO {
					serializeEnum(symbol, symbolName, modifierFlags)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property */ TODO && /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): symbol.valueDeclaration.parent */ TODO) && isClassExpression( /* TODO(PropertyAccessExpression): symbol.valueDeclaration.parent.right */ TODO) {
						serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					} else {
						serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					}
				}
				if /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) */ TODO || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeModule(symbol, symbolName, modifierFlags)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Interface */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Class) */ TODO {
					serializeInterface(symbol, symbolName, modifierFlags)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
					serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property */ TODO && /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO == /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO {
					serializeMaybeAliasAssignment(symbol)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ExportStar */ TODO {
					if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
						for _, node := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
							resolvedModule := resolveExternalModuleName(node /* TODO(NonNullExpression): (node as ExportDeclaration).moduleSpecifier! */, TODO)
							if !resolvedModule {
							}
							addResult( /* TODO(PropertyAccessExpression): factory.createExportDeclaration */ TODO(nil /* TODO(PropertyAccessExpression): (node as ExportDeclaration).isTypeOnly */, TODO, nil /* TODO(PropertyAccessExpression): factory.createStringLiteral */, TODO(getSpecifierForModuleSymbol(resolvedModule, context))) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
						}
					}
				}
				if needsPostExportDefault {
					addResult( /* TODO(PropertyAccessExpression): factory.createExportAssignment */ TODO(nil /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): factory.createIdentifier */, TODO(getInternalSymbolName(symbol, symbolName))) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
				} else if needsExportDeclaration {
					addResult( /* TODO(PropertyAccessExpression): factory.createExportDeclaration */ TODO(nil /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): factory.createNamedExports */, TODO( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, getInternalSymbolName(symbol, symbolName), symbolName)] */ TODO)) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
				}
			}
			includePrivateSymbol := func(symbol Symbol) {
				if some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isPartOfParameterDeclaration) {
				}
				/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(ElementAccessExpression): deferredPrivatesStack[deferredPrivatesStack.length - 1] */ TODO)
				getUnusedName(unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO), symbol)
				isExternalImportAlias := !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias) */ TODO && !some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d =>                     !!findAncestor(d, isExportDeclaration) ||                     isNamespaceExport(d) ||                     (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference)) */, TODO)
				/* TODO(PropertyAccessExpression): deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)].set */ TODO(getSymbolId(symbol), symbol)
			}
			isExportingScope := func(enclosingDeclaration Node) /* TODO(undefined): boolean */ TODO {
				return /* TODO(ParenthesizedExpression): ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) ||                     (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration))) */ TODO
			}
			addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
				if canHaveModifiers(node) {
					var newModifierFlags ModifierFlags = /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
					enclosingDeclaration := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO && /* TODO(ParenthesizedExpression): (isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration) */ TODO
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): additionalModifierFlags & ModifierFlags.Export */ TODO && enclosingDeclaration && /* TODO(ParenthesizedExpression): (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) */ TODO && canHaveExportModifier(node) {
						/* TODO(ExpressionStatement): newModifierFlags |= ModifierFlags.Export; */
					}
					if addingDeclare && ! /* TODO(ParenthesizedExpression): (newModifierFlags & ModifierFlags.Export) */ TODO && /* TODO(ParenthesizedExpression): (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlags.Ambient)) */ TODO && /* TODO(ParenthesizedExpression): (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) */ TODO {
						/* TODO(ExpressionStatement): newModifierFlags |= ModifierFlags.Ambient; */
					}
					if /* TODO(ParenthesizedExpression): (additionalModifierFlags & ModifierFlags.Default) */ TODO && /* TODO(ParenthesizedExpression): (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) */ TODO {
						/* TODO(ExpressionStatement): newModifierFlags |= ModifierFlags.Default; */
					}
					if newModifierFlags {
						/* TODO(ExpressionStatement): node = factory.replaceModifiers(node, newModifierFlags | getEffectiveModifierFlags(node)); */
					}
				}
				/* TODO(PropertyAccessExpression): results.push */ TODO(node)
			}
			serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				aliasType := getDeclaredTypeOfTypeAlias(symbol)
				typeParams := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */ TODO
				typeParamDecls := map_(typeParams /* TODO(ArrowFunction): p => typeParameterToDeclaration(p, context) */, TODO)
				jsdocAliasDecl := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isJSDocTypeAlias)
				commentText := getTextOfJSDocComment( /* TODO(ConditionalExpression): jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined */ TODO)
				restoreFlags := saveRestoreFlags(context)
				/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InTypeAlias; */
				oldEnclosingDecl := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
				/* TODO(ExpressionStatement): context.enclosingDeclaration = jsdocAliasDecl; */
				typeNode := jsdocAliasDecl && /* TODO(PropertyAccessExpression): jsdocAliasDecl.typeExpression */ TODO && isJSDocTypeExpression( /* TODO(PropertyAccessExpression): jsdocAliasDecl.typeExpression */ TODO) && tryReuseExistingNonParameterTypeNode(context /* TODO(PropertyAccessExpression): jsdocAliasDecl.typeExpression.type */, TODO, aliasType, nil) || typeToTypeNodeHelper(aliasType, context)
				addResult(setSyntheticLeadingComments( /* TODO(PropertyAccessExpression): factory.createTypeAliasDeclaration */ TODO(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode) /* TODO(ConditionalExpression): !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO), modifierFlags)
				restoreFlags()
				/* TODO(ExpressionStatement): context.enclosingDeclaration = oldEnclosingDecl; */
			}
			serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				interfaceType := getDeclaredTypeOfClassOrInterface(symbol)
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams /* TODO(ArrowFunction): p => typeParameterToDeclaration(p, context) */, TODO)
				baseTypes := getBaseTypes(interfaceType)
				baseType := /* TODO(ConditionalExpression): length(baseTypes) ? getIntersectionType(baseTypes) : undefined */ TODO
				members := flatMap(getPropertiesOfType(interfaceType) /* TODO(ArrowFunction): p => serializePropertySymbolForInterface(p, baseType) */, TODO)
				callSignatures := serializeSignatures( /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO, interfaceType, baseType /* TODO(PropertyAccessExpression): SyntaxKind.CallSignature */, TODO)                /* as */ /* TODO(ArrayType): CallSignatureDeclaration[] */
				constructSignatures := serializeSignatures( /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO, interfaceType, baseType /* TODO(PropertyAccessExpression): SyntaxKind.ConstructSignature */, TODO) /* as */ /* TODO(ArrayType): ConstructSignatureDeclaration[] */
				indexSignatures := serializeIndexSignatures(interfaceType, baseType)
				heritageClauses := /* TODO(ConditionalExpression): !length(baseTypes) ? undefined : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, SymbolFlags.Value)))] */ TODO
				addResult( /* TODO(PropertyAccessExpression): factory.createInterfaceDeclaration */ TODO(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses /* TODO(ArrayLiteralExpression): [...indexSignatures, ...constructSignatures, ...callSignatures, ...members] */, TODO), modifierFlags)
			}
			getNamespaceMembersForSerialization := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
				exports := arrayFrom( /* TODO(PropertyAccessExpression): getExportsOfSymbol(symbol).values */ TODO())
				merged := getMergedSymbol(symbol)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): merged !== symbol */ TODO {
					membersSet := /* TODO(NewExpression): new Set(exports) */ TODO
					for _, exported := range /* TODO(PropertyAccessExpression): getExportsOfSymbol(merged).values */ TODO() {
						if ! /* TODO(ParenthesizedExpression): (getSymbolFlags(resolveSymbol(exported)) & SymbolFlags.Value) */ TODO {
							/* TODO(PropertyAccessExpression): membersSet.add */ TODO(exported)
						}
					}
					/* TODO(ExpressionStatement): exports = arrayFrom(membersSet); */
				}
				return filter(exports /* TODO(ArrowFunction): m => isNamespaceMember(m) && isIdentifierText(m.escapedName as string, ScriptTarget.ESNext) */, TODO)
			}
			isTypeOnlyNamespace := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
				return every(getNamespaceMembersForSerialization(symbol) /* TODO(ArrowFunction): m => !(getSymbolFlags(resolveSymbol(m)) & SymbolFlags.Value) */, TODO)
			}
			serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				members := getNamespaceMembersForSerialization(symbol)
				locationMap := arrayToMultiMap(members /* TODO(ArrowFunction): m => m.parent && m.parent === symbol ? "real" : "merged" */, TODO)
				realMembers := /* TODO(PropertyAccessExpression): locationMap.get */ TODO("real") || emptyArray
				mergedMembers := /* TODO(PropertyAccessExpression): locationMap.get */ TODO("merged") || emptyArray
				if length(realMembers) {
					localName := getInternalSymbolName(symbol, symbolName)
					serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !! /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.Function | SymbolFlags.Assignment)) */ TODO)
				}
				if length(mergedMembers) {
					containingFile := getSourceFileOfNode( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
					localName := getInternalSymbolName(symbol, symbolName)
					nsBody := /* TODO(PropertyAccessExpression): factory.createModuleBlock */ TODO( /* TODO(ArrayLiteralExpression): [factory.createExportDeclaration(                         /*modifiers* / undefined,                         /*isTypeOnly* / false,                         factory.createNamedExports(mapDefined(filter(mergedMembers, n => n.escapedName !== InternalSymbolName.ExportEquals), s => {                             const name = unescapeLeadingUnderscores(s.escapedName);                             const localName = getInternalSymbolName(s, name);                             const aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);                             if (containingFile && (aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile))) {                                 context.tracker?.reportNonlocalAugmentation?.(containingFile, symbol, s);                                 return undefined;                             }                             const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve* / true);                             includePrivateSymbol(target || s);                             const targetName = target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName;                             return factory.createExportSpecifier(/*isTypeOnly* / false, name === targetName ? undefined : targetName, name);                         })),                     )] */ TODO)
					addResult( /* TODO(PropertyAccessExpression): factory.createModuleDeclaration */ TODO(nil /* TODO(PropertyAccessExpression): factory.createIdentifier */, TODO(localName), nsBody /* TODO(PropertyAccessExpression): NodeFlags.Namespace */, TODO) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
				}
			}
			serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				addResult( /* TODO(PropertyAccessExpression): factory.createEnumDeclaration */ TODO( /* TODO(PropertyAccessExpression): factory.createModifiersFromModifierFlags */ TODO( /* TODO(ConditionalExpression): isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0 */ TODO), getInternalSymbolName(symbol, symbolName), map_(filter(getPropertiesOfType(getTypeOfSymbol(symbol)) /* TODO(ArrowFunction): p => !!(p.flags & SymbolFlags.EnumMember) */, TODO) /* TODO(ArrowFunction): p => {                             // TODO: Handle computed names                             // I hate that to get the initialized value we need to walk back to the declarations here; but there's no                             // other way to get the possible const value of an enum member that I'm aware of, as the value is cached                             // _on the declaration_, not on the declaration's symbol...                             const initializedValue = p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined;                             return factory.createEnumMember(                                 unescapeLeadingUnderscores(p.escapedName),                                 initializedValue === undefined ? undefined :                                     typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) :                                     factory.createNumericLiteral(initializedValue),                             );                         } */, TODO)), modifierFlags)
			}
			serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
				signatures := getSignaturesOfType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig /* TODO(PropertyAccessExpression): SyntaxKind.FunctionDeclaration */, TODO, context /* TODO(ObjectLiteralExpression): { name: factory.createIdentifier(localName) } */, TODO) /* as */ /* TODO(TypeReference): FunctionDeclaration */
					addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags)
				}
				if ! /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.ValueModule | SymbolFlags.NamespaceModule) && !!symbol.exports && !!symbol.exports.size) */ TODO {
					props := filter(getPropertiesOfType(type_), isNamespaceMember)
					serializeAsNamespaceDeclaration(props, localName, modifierFlags /* TODO(TrueKeyword): true */, TODO)
				}
			}
			getSignatureTextRangeLocation := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList | import("/home/jabaile/work/TypeScript/src/compiler/types").CatchClause | undefined */ TODO {
				if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO {
					if isBinaryExpression( /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.Property */ TODO {
						return /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO
					}
					if isVariableDeclaration( /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO) && /* TODO(PropertyAccessExpression): signature.declaration.parent.parent */ TODO {
						return /* TODO(PropertyAccessExpression): signature.declaration.parent.parent */ TODO
					}
				}
				return /* TODO(PropertyAccessExpression): signature.declaration */ TODO
			}
			serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
				if length(props) {
					localVsRemoteMap := arrayToMultiMap(props /* TODO(ArrowFunction): p => !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!)) ? "local" : "remote" */, TODO)
					localProps := /* TODO(PropertyAccessExpression): localVsRemoteMap.get */ TODO("local") || emptyArray
					fakespace := /* TODO(PropertyAccessExpression): parseNodeFactory.createModuleDeclaration */ TODO(nil /* TODO(PropertyAccessExpression): factory.createIdentifier */, TODO(localName) /* TODO(PropertyAccessExpression): factory.createModuleBlock */, TODO( /* TODO(ArrayLiteralExpression): [] */ TODO) /* TODO(PropertyAccessExpression): NodeFlags.Namespace */, TODO)
					setParent(fakespace, enclosingDeclaration /* as */ /* TODO(UnionType): SourceFile | NamespaceDeclaration */)
					/* TODO(ExpressionStatement): fakespace.locals = createSymbolTable(props); */
					/* TODO(ExpressionStatement): fakespace.symbol = props[0].parent!; */
					oldResults := results
					/* TODO(ExpressionStatement): results = []; */
					oldAddingDeclare := addingDeclare
					/* TODO(ExpressionStatement): addingDeclare = false; */
					subcontext := /* TODO(ObjectLiteralExpression): { ...context, enclosingDeclaration: fakespace } */ TODO
					oldContext := context
					/* TODO(ExpressionStatement): context = subcontext; */
					visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext /* TODO(TrueKeyword): true */, TODO)
					/* TODO(ExpressionStatement): context = oldContext; */
					/* TODO(ExpressionStatement): addingDeclare = oldAddingDeclare; */
					declarations := results
					/* TODO(ExpressionStatement): results = oldResults; */
					defaultReplaced := map_(declarations /* TODO(ArrowFunction): d =>                         isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) ? factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, d.expression, factory.createIdentifier(InternalSymbolName.Default))]),                         ) : d */, TODO)
					exportModifierStripped := /* TODO(ConditionalExpression): every(defaultReplaced, d => hasSyntacticModifier(d, ModifierFlags.Export)) ? map(defaultReplaced as Extract<HasModifiers, Statement>[], removeExportModifier) : defaultReplaced */ TODO
					/* TODO(ExpressionStatement): fakespace = factory.updateModuleDeclaration(                         fakespace,                         fakespace.modifiers,                         fakespace.name,                         factory.createModuleBlock(exportModifierStripped),                     ); */
					addResult(fakespace, modifierFlags)
				}
			}
			isNamespaceMember := func(p Symbol) /* TODO(undefined): boolean */ TODO {
				return !! /* TODO(ParenthesizedExpression): (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias)) */ TODO || ! /* TODO(ParenthesizedExpression): (p.flags & SymbolFlags.Prototype || p.escapedName === "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent)) */ TODO
			}
			sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) /* TODO(ArrayType): ExpressionWithTypeArguments[] */ any {
				result := mapDefined(clauses /* TODO(ArrowFunction): e => {                     const oldEnclosing = context.enclosingDeclaration;                     context.enclosingDeclaration = e;                     let expr = e.expression;                     if (isEntityNameExpression(expr)) {                         if (isIdentifier(expr) && idText(expr) === "") {                             return cleanup(/*result* / undefined); // Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one                         }                         let introducesError: boolean;                         ({ introducesError, node: expr } = trackExistingEntityName(expr, context));                         if (introducesError) {                             return cleanup(/*result* / undefined);                         }                     }                     return cleanup(factory.createExpressionWithTypeArguments(                         expr,                         map(e.typeArguments, a =>                             tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a))                             || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)),                     ));                      function cleanup<T>(result: T): T {                         context.enclosingDeclaration = oldEnclosing;                         return result;                     }                 } */, TODO)
				if /* TODO(PropertyAccessExpression): result.length */ TODO == /* TODO(PropertyAccessExpression): clauses.length */ TODO {
					return result
				}
				return nil
			}
			serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
				originalDecl := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isClassLike)
				oldEnclosing := /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO
				/* TODO(ExpressionStatement): context.enclosingDeclaration = originalDecl || oldEnclosing; */
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams /* TODO(ArrowFunction): p => typeParameterToDeclaration(p, context) */, TODO)
				classType := getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol)) /* as */ /* TODO(TypeReference): InterfaceType */
				baseTypes := getBaseTypes(classType)
				originalImplements := originalDecl && getEffectiveImplementsTypeNodes(originalDecl)
				implementsExpressions := originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(getImplementsTypes(classType), serializeImplementedType)
				staticType := getTypeOfSymbol(symbol)
				isClass := !! /* TODO(PropertyAccessExpression): staticType.symbol?.valueDeclaration */ TODO && isClassLike( /* TODO(PropertyAccessExpression): staticType.symbol.valueDeclaration */ TODO)
				staticBaseType := /* TODO(ConditionalExpression): isClass                     ? getBaseConstructorTypeOfClass(staticType as InterfaceType)                     : anyType */ TODO
				heritageClauses := /* TODO(ArrayLiteralExpression): [                     ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))],                     ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)],                 ] */ TODO
				symbolProps := getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType))
				publicSymbolProps := filter(symbolProps /* TODO(ArrowFunction): s => {                     // `valueDeclaration` could be undefined if inherited from                     // a union/intersection base type, but inherited properties                     // don't matter here.                     const valueDecl = s.valueDeclaration;                     return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name));                 } */, TODO)
				hasPrivateIdentifier := some(symbolProps /* TODO(ArrowFunction): s => {                     // `valueDeclaration` could be undefined if inherited from                     // a union/intersection base type, but inherited properties                     // don't matter here.                     const valueDecl = s.valueDeclaration;                     return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name);                 } */, TODO)
				privateProperties := /* TODO(ConditionalExpression): hasPrivateIdentifier ?                     [factory.createPropertyDeclaration(                         /*modifiers* / undefined,                         factory.createPrivateIdentifier("#private"),                         /*questionOrExclamationToken* / undefined,                         /*type* / undefined,                         /*initializer* / undefined,                     )] :                     emptyArray */ TODO
				publicProperties := flatMap(publicSymbolProps /* TODO(ArrowFunction): p => serializePropertySymbolForClass(p, /*isStatic* / false, baseTypes[0]) */, TODO)
				staticMembers := flatMap(filter(getPropertiesOfType(staticType) /* TODO(ArrowFunction): p => !(p.flags & SymbolFlags.Prototype) && p.escapedName !== "prototype" && !isNamespaceMember(p) */, TODO) /* TODO(ArrowFunction): p => serializePropertySymbolForClass(p, /*isStatic* / true, staticBaseType) */, TODO)
				isNonConstructableClassLikeInJsFile := !isClass && !! /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isInJSFile( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) && !some(getSignaturesOfType(staticType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO))
				constructors := /* TODO(ConditionalExpression): isNonConstructableClassLikeInJsFile ?                     [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlags.Private), [], /*body* / undefined)] :                     serializeSignatures(SignatureKind.Construct, staticType, staticBaseType, SyntaxKind.Constructor) as ConstructorDeclaration[] */ TODO
				indexSignatures := serializeIndexSignatures(classType /* TODO(ElementAccessExpression): baseTypes[0] */, TODO)
				/* TODO(ExpressionStatement): context.enclosingDeclaration = oldEnclosing; */
				addResult(setTextRange(context /* TODO(PropertyAccessExpression): factory.createClassDeclaration */, TODO(nil, localName, typeParamDecls, heritageClauses /* TODO(ArrayLiteralExpression): [...indexSignatures, ...staticMembers, ...constructors, ...publicProperties, ...privateProperties] */, TODO) /* TODO(PropertyAccessExpression): symbol.declarations */, TODO && /* TODO(ElementAccessExpression): filter(symbol.declarations, d => isClassDeclaration(d) || isClassExpression(d))[0] */ TODO), modifierFlags)
			}
			getSomeTargetNameFromDeclarations := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO(undefined): string | undefined */ TODO {
				return firstDefined(declarations /* TODO(ArrowFunction): d => {                     if (isImportSpecifier(d) || isExportSpecifier(d)) {                         return moduleExportNameTextUnescaped(d.propertyName || d.name);                     }                     if (isBinaryExpression(d) || isExportAssignment(d)) {                         const expression = isExportAssignment(d) ? d.expression : d.right;                         if (isPropertyAccessExpression(expression)) {                             return idText(expression.name);                         }                     }                     if (isAliasSymbolDeclaration(d)) {                         // This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.                         const name = getNameOfDeclaration(d);                         if (name && isIdentifier(name)) {                             return idText(name);                         }                     }                     return undefined;                 } */, TODO)
			}
			serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) /* TODO(undefined): undefined */ TODO {
				node := getDeclarationOfAliasSymbol(symbol)
				if !node {
					/* TODO(CallExpression): Debug.fail() */
				}
				target := getMergedSymbol(getTargetOfAliasDeclaration(node /* TODO(TrueKeyword): true */, TODO))
				if !target {
					return
				}
				verbatimTargetName := isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO) || unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): target.escapedName */ TODO)
				if verbatimTargetName == /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO && allowSyntheticDefaultImports {
					/* TODO(ExpressionStatement): verbatimTargetName = InternalSymbolName.Default; */
				}
				targetName := getInternalSymbolName(target, verbatimTargetName)
				includePrivateSymbol(target)
				/* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.BindingElement:                         if (node.parent?.parent?.kind === SyntaxKind.VariableDeclaration) {                             // const { SomeClass } = require('./lib');                             const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // './lib'                             const { propertyName } = node as BindingElement;                             addResult(                                 factory.createImportDeclaration(                                     /*modifiers* / undefined,                                     factory.createImportClause(                                         /*isTypeOnly* / false,                                         /*name* / undefined,                                         factory.createNamedImports([factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             propertyName && isIdentifier(propertyName) ? factory.createIdentifier(idText(propertyName)) : undefined,                                             factory.createIdentifier(localName),                                         )]),                                     ),                                     factory.createStringLiteral(specifier),                                     /*attributes* / undefined,                                 ),                                 ModifierFlags.None,                             );                             break;                         }                         // We don't know how to serialize this (nested?) binding element                         Debug.failBadSyntaxKind(node.parent?.parent || node, "Unhandled binding element grandparent kind in declaration serialization");                         break;                     case SyntaxKind.ShorthandPropertyAssignment:                         if (node.parent?.parent?.kind === SyntaxKind.BinaryExpression) {                             // module.exports = { SomeClass }                             serializeExportSpecifier(                                 unescapeLeadingUnderscores(symbol.escapedName),                                 targetName,                             );                         }                         break;                     case SyntaxKind.VariableDeclaration:                         // commonjs require: const x = require('y')                         if (isPropertyAccessExpression((node as VariableDeclaration).initializer!)) {                             // const x = require('y').z                             const initializer = (node as VariableDeclaration).initializer! as PropertyAccessExpression; // require('y').z                             const uniqueName = factory.createUniqueName(localName); // _x                             const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // 'y'                             // import _x = require('y');                             addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     uniqueName,                                     factory.createExternalModuleReference(factory.createStringLiteral(specifier)),                                 ),                                 ModifierFlags.None,                             );                             // import x = _x.z                             addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     factory.createIdentifier(localName),                                     factory.createQualifiedName(uniqueName, initializer.name as Identifier),                                 ),                                 modifierFlags,                             );                             break;                         }                         // else fall through and treat commonjs require just like import=                     case SyntaxKind.ImportEqualsDeclaration:                         // This _specifically_ only exists to handle json declarations - where we make aliases, but since                         // we emit no declarations for the json document, must not refer to it in the declarations                         if (target.escapedName === InternalSymbolName.ExportEquals && some(target.declarations, d => isSourceFile(d) && isJsonSourceFile(d))) {                             serializeMaybeAliasAssignment(symbol);                             break;                         }                         // Could be a local `import localName = ns.member` or                         // an external `import localName = require("whatever")`                         const isLocalImport = !(target.flags & SymbolFlags.ValueModule) && !isVariableDeclaration(node);                         addResult(                             factory.createImportEqualsDeclaration(                                 /*modifiers* / undefined,                                 /*isTypeOnly* / false,                                 factory.createIdentifier(localName),                                 isLocalImport                                     ? symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier* / false)                                     : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))),                             ),                             isLocalImport ? modifierFlags : ModifierFlags.None,                         );                         break;                     case SyntaxKind.NamespaceExportDeclaration:                         // export as namespace foo                         // TODO: Not part of a file's local or export symbol tables                         // Is bound into file.symbol.globalExports instead, which we don't currently traverse                         addResult(factory.createNamespaceExportDeclaration(idText((node as NamespaceExportDeclaration).name)), ModifierFlags.None);                         break;                     case SyntaxKind.ImportClause: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportClause).parent.moduleSpecifier;                         const attributes = isImportDeclaration(node.parent) ? node.parent.attributes : undefined;                         const isTypeOnly = isJSDocImportTag((node as ImportClause).parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(isTypeOnly, factory.createIdentifier(localName), /*namedBindings* / undefined),                                 specifier,                                 attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.NamespaceImport: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as NamespaceImport).parent.parent.moduleSpecifier;                         const isTypeOnly = isJSDocImportTag((node as NamespaceImport).parent.parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(isTypeOnly, /*name* / undefined, factory.createNamespaceImport(factory.createIdentifier(localName))),                                 specifier,                                 (node as ImportClause).parent.attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.NamespaceExport:                         addResult(                             factory.createExportDeclaration(                                 /*modifiers* / undefined,                                 /*isTypeOnly* / false,                                 factory.createNamespaceExport(factory.createIdentifier(localName)),                                 factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)),                             ),                             ModifierFlags.None,                         );                         break;                     case SyntaxKind.ImportSpecifier: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportSpecifier).parent.parent.parent.moduleSpecifier;                         const isTypeOnly = isJSDocImportTag((node as ImportSpecifier).parent.parent.parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(                                     isTypeOnly,                                     /*name* / undefined,                                     factory.createNamedImports([                                         factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : undefined,                                             factory.createIdentifier(localName),                                         ),                                     ]),                                 ),                                 specifier,                                 (node as ImportSpecifier).parent.parent.parent.attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.ExportSpecifier:                         // does not use localName because the symbol name in this case refers to the name in the exports table,                         // which we must exactly preserve                         const specifier = (node.parent.parent as ExportDeclaration).moduleSpecifier;                         if (specifier) {                             const propertyName = (node as ExportSpecifier).propertyName;                             if (propertyName && moduleExportNameIsDefault(propertyName)) {                                 verbatimTargetName = InternalSymbolName.Default;                             }                         }                         // targetName is only used when the target is local, as otherwise the target is an alias that points at                         // another file                         serializeExportSpecifier(                             unescapeLeadingUnderscores(symbol.escapedName),                             specifier ? verbatimTargetName : targetName,                             specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : undefined,                         );                         break;                     case SyntaxKind.ExportAssignment:                         serializeMaybeAliasAssignment(symbol);                         break;                     case SyntaxKind.BinaryExpression:                     case SyntaxKind.PropertyAccessExpression:                     case SyntaxKind.ElementAccessExpression:                         // Could be best encoded as though an export specifier or as though an export assignment                         // If name is default or export=, do an export assignment                         // Otherwise do an export specifier                         if (symbol.escapedName === InternalSymbolName.Default || symbol.escapedName === InternalSymbolName.ExportEquals) {                             serializeMaybeAliasAssignment(symbol);                         }                         else {                             serializeExportSpecifier(localName, targetName);                         }                         break;                     default:                         return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");                 } */
			}
			serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
				addResult( /* TODO(PropertyAccessExpression): factory.createExportDeclaration */ TODO(nil /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): factory.createNamedExports */, TODO( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, localName !== targetName ? targetName : undefined, localName)] */ TODO), specifier) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
			}
			serializeMaybeAliasAssignment := func(symbol Symbol) bool {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Prototype */ TODO {
					return /* TODO(FalseKeyword): false */ TODO
				}
				name := unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
				isExportEquals := name == /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO
				isDefault := name == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO
				isExportAssignmentCompatibleSymbolName := isExportEquals || isDefault
				aliasDecl := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && getDeclarationOfAliasSymbol(symbol)
				target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl /* TODO(TrueKeyword): true */, TODO)
				if target && length( /* TODO(PropertyAccessExpression): target.declarations */ TODO) && some( /* TODO(PropertyAccessExpression): target.declarations */ TODO /* TODO(ArrowFunction): d => getSourceFileOfNode(d) === getSourceFileOfNode(enclosingDeclaration) */, TODO) {
					expr := aliasDecl && /* TODO(ParenthesizedExpression): ((isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression)) */ TODO
					first := /* TODO(ConditionalExpression): expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined */ TODO
					referenced := first && resolveEntityName(first /* TODO(PropertyAccessExpression): SymbolFlags.All */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, enclosingDeclaration)
					if referenced || target {
						includePrivateSymbol(referenced || target)
					}
					prevDisableTrackSymbol := /* TODO(PropertyAccessExpression): context.tracker.disableTrackSymbol */ TODO
					/* TODO(ExpressionStatement): context.tracker.disableTrackSymbol = true; */
					if isExportAssignmentCompatibleSymbolName {
						/* TODO(PropertyAccessExpression): results.push */ TODO( /* TODO(PropertyAccessExpression): factory.createExportAssignment */ TODO(nil, isExportEquals, symbolToExpression(target, context /* TODO(PropertyAccessExpression): SymbolFlags.All */, TODO)))
					} else {
						if first == expr && first {
							serializeExportSpecifier(name, idText(first))
						} else if expr && isClassExpression(expr) {
							serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)))
						} else {
							varName := getUnusedName(name, symbol)
							addResult( /* TODO(PropertyAccessExpression): factory.createImportEqualsDeclaration */ TODO(nil /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): factory.createIdentifier */, TODO(varName), symbolToName(target, context /* TODO(PropertyAccessExpression): SymbolFlags.All */, TODO /* TODO(FalseKeyword): false */, TODO)) /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
							serializeExportSpecifier(name, varName)
						}
					}
					/* TODO(ExpressionStatement): context.tracker.disableTrackSymbol = prevDisableTrackSymbol; */
					return /* TODO(TrueKeyword): true */ TODO
				} else {
					varName := getUnusedName(name, symbol)
					typeToSerialize := getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)))
					if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
						serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName /* TODO(ConditionalExpression): isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export */, TODO)
					} else {
						flags := /* TODO(ConditionalExpression): context.enclosingDeclaration?.kind === SyntaxKind.ModuleDeclaration && (!(symbol.flags & SymbolFlags.Accessor) || symbol.flags & SymbolFlags.SetAccessor) ? NodeFlags.Let : NodeFlags.Const */ TODO
						statement := /* TODO(PropertyAccessExpression): factory.createVariableStatement */ TODO(nil /* TODO(PropertyAccessExpression): factory.createVariableDeclarationList */, TODO( /* TODO(ArrayLiteralExpression): [                                 factory.createVariableDeclaration(varName, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, typeToSerialize, symbol)),                             ] */ TODO, flags))
						addResult(statement /* TODO(ConditionalExpression): target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient                                 : name === varName ? ModifierFlags.Export                                 : ModifierFlags.None */, TODO)
					}
					if isExportAssignmentCompatibleSymbolName {
						/* TODO(PropertyAccessExpression): results.push */ TODO( /* TODO(PropertyAccessExpression): factory.createExportAssignment */ TODO(nil, isExportEquals /* TODO(PropertyAccessExpression): factory.createIdentifier */, TODO(varName)))
						return /* TODO(TrueKeyword): true */ TODO
					} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== varName */ TODO {
						serializeExportSpecifier(name, varName)
						return /* TODO(TrueKeyword): true */ TODO
					}
					return /* TODO(FalseKeyword): false */ TODO
				}
			}
			isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
				ctxSrc := getSourceFileOfNode( /* TODO(PropertyAccessExpression): context.enclosingDeclaration */ TODO)
				return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(typeToSerialize) & (ObjectFlags.Anonymous | ObjectFlags.Mapped) */ TODO && !some( /* TODO(PropertyAccessExpression): typeToSerialize.symbol?.declarations */ TODO, isTypeNode) && !length(getIndexInfosOfType(typeToSerialize)) && !isClassInstanceSide(typeToSerialize) && !! /* TODO(ParenthesizedExpression): (length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKind.Call))) */ TODO && !length(getSignaturesOfType(typeToSerialize /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && ! /* TODO(ParenthesizedExpression): (typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) */ TODO && !some(getPropertiesOfType(typeToSerialize) /* TODO(ArrowFunction): p => isLateBoundName(p.escapedName) */, TODO) && !some(getPropertiesOfType(typeToSerialize) /* TODO(ArrowFunction): p => some(p.declarations, d => getSourceFileOfNode(d) !== ctxSrc) */, TODO) && every(getPropertiesOfType(typeToSerialize) /* TODO(ArrowFunction): p => {                         if (!isIdentifierText(symbolName(p), languageVersion)) {                             return false;                         }                         if (!(p.flags & SymbolFlags.Accessor)) {                             return true;                         }                         return getNonMissingTypeOfSymbol(p) === getWriteTypeOfSymbol(p);                     } */, TODO)
			}
			// OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors /* TODO(LiteralType): true */ TODO) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any
			// OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors /* TODO(LiteralType): false */ TODO) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | T[] */ any
			makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors bool) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
				return /* TODO(FunctionExpression): function serializePropertySymbol(p: Symbol, isStatic: boolean, baseType: Type | undefined): T | AccessorDeclaration | (T | AccessorDeclaration)[] {                     const modifierFlags = getDeclarationModifierFlagsFromSymbol(p);                     const isPrivate = !!(modifierFlags & ModifierFlags.Private);                     if (isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))) {                         // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols                         // need to be merged namespace members                         return [];                     }                     if (                         p.flags & SymbolFlags.Prototype || p.escapedName === "constructor" ||                         (baseType && getPropertyOfType(baseType, p.escapedName)                             && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)!) === isReadonlySymbol(p)                             && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(baseType, p.escapedName)!.flags & SymbolFlags.Optional)                             && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)!))                     ) {                         return [];                     }                     const flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0);                     const name = getPropertyNameNodeForSymbol(p, context);                     const firstPropertyLikeDecl = p.declarations?.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression));                     if (p.flags & SymbolFlags.Accessor && useAccessors) {                         const result: AccessorDeclaration[] = [];                         if (p.flags & SymbolFlags.SetAccessor) {                             const setter = p.declarations && forEach(p.declarations, d => {                                 if (d.kind === SyntaxKind.SetAccessor) {                                     return d as SetAccessorDeclaration;                                 }                                 if (isCallExpression(d) && isBindableObjectDefinePropertyCall(d)) {                                     return forEach(d.arguments[2].properties, propDecl => {                                         const id = getNameOfDeclaration(propDecl);                                         if (!!id && isIdentifier(id) && idText(id) === "set") {                                             return propDecl;                                         }                                     });                                 }                             });                              Debug.assert(!!setter);                             const paramSymbol = isFunctionLikeDeclaration(setter) ? getSignatureFromDeclaration(setter).parameters[0] : undefined;                              result.push(setTextRange(                                 context,                                 factory.createSetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [factory.createParameterDeclaration(                                         /*modifiers* / undefined,                                         /*dotDotDotToken* / undefined,                                         paramSymbol ? parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context) : "value",                                         /*questionToken* / undefined,                                         isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                     )],                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isSetAccessor) || firstPropertyLikeDecl,                             ));                         }                         if (p.flags & SymbolFlags.GetAccessor) {                             const isPrivate = modifierFlags & ModifierFlags.Private;                             result.push(setTextRange(                                 context,                                 factory.createGetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [],                                     isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getTypeOfSymbol(p), p),                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isGetAccessor) || firstPropertyLikeDecl,                             ));                         }                         return result;                     }                     // This is an else/if as accessors and properties can't merge in TS, but might in JS                     // If this happens, we assume the accessor takes priority, as it imposes more constraints                     else if (p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)) {                         return setTextRange(                             context,                             createProperty(                                 factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                 name,                                 p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                 isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                 // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357                                 // interface members can't have initializers, however class members _can_                                 /*initializer* / undefined,                             ),                             p.declarations?.find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl,                         );                     }                     if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) {                         const type = getTypeOfSymbol(p);                         const signatures = getSignaturesOfType(type, SignatureKind.Call);                         if (flag & ModifierFlags.Private) {                             return setTextRange(                                 context,                                 createProperty(                                     factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                     name,                                     p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     /*type* / undefined,                                     /*initializer* / undefined,                                 ),                                 p.declarations?.find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0],                             );                         }                          const results = [];                         for (const sig of signatures) {                             // Each overload becomes a separate method declaration, in order                             const decl = signatureToSignatureDeclarationHelper(                                 sig,                                 methodKind,                                 context,                                 {                                     name,                                     questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : undefined,                                 },                             );                             const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;                             results.push(setTextRange(context, decl, location));                         }                         return results as unknown as T[];                     }                     // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static                     return Debug.fail(`Unhandled class member kind! ${(p as any).__debugFlags || p.flags}`);                 } */ TODO
			}
			serializePropertySymbolForInterface := func(p Symbol, baseType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ TODO {
				return serializePropertySymbolForInterfaceWorker(p /* TODO(FalseKeyword): false */, TODO, baseType)
			}
			serializeSignatures := func(kind SignatureKind, input Type, baseType *Type, outputKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO) /* TODO(undefined): (import("/home/jabaile/work/TypeScript/src/compiler/types").CallSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocFunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrowFunction)[] */ TODO {
				signatures := getSignaturesOfType(input, kind)
				if kind == /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO {
					if !baseType && every(signatures /* TODO(ArrowFunction): s => length(s.parameters) === 0 */, TODO) {
						return /* TODO(ArrayLiteralExpression): [] */ TODO
					}
					if baseType {
						baseSigs := getSignaturesOfType(baseType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
						if !length(baseSigs) && every(signatures /* TODO(ArrowFunction): s => length(s.parameters) === 0 */, TODO) {
							return /* TODO(ArrayLiteralExpression): [] */ TODO
						}
						if /* TODO(PropertyAccessExpression): baseSigs.length */ TODO == /* TODO(PropertyAccessExpression): signatures.length */ TODO {
							failed := /* TODO(FalseKeyword): false */ TODO
							/* TODO(ForStatement): for (let i = 0; i < baseSigs.length; i++) {                                 if (!compareSignaturesIdentical(signatures[i], baseSigs[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true, compareTypesIdentical)) {                                     failed = true;                                     break;                                 }                             } */
							if !failed {
								return /* TODO(ArrayLiteralExpression): [] */ TODO
							}
						}
					}
					var privateProtected ModifierFlags = 0
					for _, s := range signatures {
						if /* TODO(PropertyAccessExpression): s.declaration */ TODO {
							/* TODO(ExpressionStatement): privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlags.Private | ModifierFlags.Protected); */
						}
					}
					if privateProtected {
						return /* TODO(ArrayLiteralExpression): [setTextRange(                             context,                             factory.createConstructorDeclaration(                                 factory.createModifiersFromModifierFlags(privateProtected),                                 /*parameters* / [],                                 /*body* / undefined,                             ),                             signatures[0].declaration,                         )] */ TODO
					}
				}
				results := /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, outputKind, context)
					/* TODO(PropertyAccessExpression): results.push */ TODO(setTextRange(context, decl /* TODO(PropertyAccessExpression): sig.declaration */, TODO))
				}
				return results
			}
			serializeIndexSignatures := func(input Type, baseType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[] */ TODO {
				var results []IndexSignatureDeclaration = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, info := range getIndexInfosOfType(input) {
					if baseType {
						baseInfo := getIndexInfoOfType(baseType /* TODO(PropertyAccessExpression): info.keyType */, TODO)
						if baseInfo {
							if isTypeIdenticalTo( /* TODO(PropertyAccessExpression): info.type */ TODO /* TODO(PropertyAccessExpression): baseInfo.type */, TODO) {
								/* TODO(ContinueStatement): continue; */
							}
						}
					}
					/* TODO(PropertyAccessExpression): results.push */ TODO(indexInfoToIndexSignatureDeclarationHelper(info, context, nil))
				}
				return results
			}
			serializeBaseType := func(t Type, staticType Type, rootName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO {
				ref := trySerializeAsTypeReference(t /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
				if ref {
					return ref
				}
				tempName := getUnusedName( /* TODO(TemplateExpression): `${rootName}_base` */ TODO)
				statement := /* TODO(PropertyAccessExpression): factory.createVariableStatement */ TODO(nil /* TODO(PropertyAccessExpression): factory.createVariableDeclarationList */, TODO( /* TODO(ArrayLiteralExpression): [                         factory.createVariableDeclaration(tempName, /*exclamationToken* / undefined, typeToTypeNodeHelper(staticType, context)),                     ] */ TODO /* TODO(PropertyAccessExpression): NodeFlags.Const */, TODO))
				addResult(statement /* TODO(PropertyAccessExpression): ModifierFlags.None */, TODO)
				return /* TODO(PropertyAccessExpression): factory.createExpressionWithTypeArguments */ TODO( /* TODO(PropertyAccessExpression): factory.createIdentifier */ TODO(tempName), nil)
			}
			trySerializeAsTypeReference := func(t Type, flags SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
				var typeArgs /* TODO(ArrayType): TypeNode[] */ any
				var reference *Expression
				if /* TODO(PropertyAccessExpression): (t as TypeReference).target */ TODO && isSymbolAccessibleByFlags( /* TODO(PropertyAccessExpression): (t as TypeReference).target.symbol */ TODO, enclosingDeclaration, flags) {
					/* TODO(ExpressionStatement): typeArgs = map(getTypeArguments(t as TypeReference), t => typeToTypeNodeHelper(t, context)); */
					/* TODO(ExpressionStatement): reference = symbolToExpression((t as TypeReference).target.symbol, context, SymbolFlags.Type); */
				} else if /* TODO(PropertyAccessExpression): t.symbol */ TODO && isSymbolAccessibleByFlags( /* TODO(PropertyAccessExpression): t.symbol */ TODO, enclosingDeclaration, flags) {
					/* TODO(ExpressionStatement): reference = symbolToExpression(t.symbol, context, SymbolFlags.Type); */
				}
				if reference {
					return /* TODO(PropertyAccessExpression): factory.createExpressionWithTypeArguments */ TODO(reference, typeArgs)
				}
			}
			serializeImplementedType := func(t Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
				ref := trySerializeAsTypeReference(t /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
				if ref {
					return ref
				}
				if /* TODO(PropertyAccessExpression): t.symbol */ TODO {
					return /* TODO(PropertyAccessExpression): factory.createExpressionWithTypeArguments */ TODO(symbolToExpression( /* TODO(PropertyAccessExpression): t.symbol */ TODO, context /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO), nil)
				}
			}
			getUnusedName := func(input string, symbol Symbol) string {
				id := /* TODO(ConditionalExpression): symbol ? getSymbolId(symbol) : undefined */ TODO
				if id {
					if /* TODO(PropertyAccessExpression): context.remappedSymbolNames!.has */ TODO(id) {
						return /* TODO(NonNullExpression): context.remappedSymbolNames!.get(id)! */ TODO
					}
				}
				if symbol {
					/* TODO(ExpressionStatement): input = getNameCandidateWorker(symbol, input); */
				}
				i := 0
				original := input
				/* TODO(WhileStatement): while (context.usedSymbolNames?.has(input)) {                     i++;                     input = `${original}_${i}`;                 } */
				/* TODO(PropertyAccessExpression): context.usedSymbolNames?.add */
				TODO(input)
				if id {
					/* TODO(PropertyAccessExpression): context.remappedSymbolNames!.set */ TODO(id, input)
				}
				return input
			}
			getNameCandidateWorker := func(symbol Symbol, localName string) /* TODO(undefined): string */ TODO {
				if localName == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO || localName == /* TODO(PropertyAccessExpression): InternalSymbolName.Class */ TODO || localName == /* TODO(PropertyAccessExpression): InternalSymbolName.Function */ TODO {
					restoreFlags := saveRestoreFlags(context)
					/* TODO(ExpressionStatement): context.flags |= NodeBuilderFlags.InInitialEntityName; */
					nameCandidate := getNameOfSymbolAsWritten(symbol, context)
					restoreFlags()
					/* TODO(ExpressionStatement): localName = nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate; */
				}
				if localName == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO {
					/* TODO(ExpressionStatement): localName = "_default"; */
				} else if localName == /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO {
					/* TODO(ExpressionStatement): localName = "_exports"; */
				}
				/* TODO(ExpressionStatement): localName = isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-z0-9]/gi, "_"); */
				return localName
			}
			getInternalSymbolName := func(symbol Symbol, localName string) /* TODO(undefined): string */ TODO {
				id := getSymbolId(symbol)
				if /* TODO(PropertyAccessExpression): context.remappedSymbolNames!.has */ TODO(id) {
					return /* TODO(NonNullExpression): context.remappedSymbolNames!.get(id)! */ TODO
				}
				/* TODO(ExpressionStatement): localName = getNameCandidateWorker(symbol, localName); */
				/* TODO(PropertyAccessExpression): context.remappedSymbolNames!.set */
				TODO(id, localName)
				return localName
			}
		}
	}
	typePredicateToString := func(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
		return /* TODO(ConditionalExpression): writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker) */ TODO
		typePredicateToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			nodeBuilderFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): toNodeBuilderFlags(flags) | NodeBuilderFlags.IgnoreErrors | NodeBuilderFlags.WriteTypeParametersInQualifiedName */ TODO
			predicate := /* TODO(NonNullExpression): nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)! */ TODO
			printer := createPrinterWithRemoveComments()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			/* TODO(PropertyAccessExpression): printer.writeNode */ TODO( /* TODO(PropertyAccessExpression): EmitHint.Unspecified */ TODO, predicate, sourceFile, writer)
			return writer
		}
	}
	formatUnionTypes := func(types []Type) []Type {
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := 0 /* as */ /* TODO(TypeReference): TypeFlags */
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = types[i];             flags |= t.flags;             if (!(t.flags & TypeFlags.Nullable)) {                 if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLike)) {                     const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType);                     if (baseType.flags & TypeFlags.Union) {                         const count = (baseType as UnionType).types.length;                         if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((baseType as UnionType).types[count - 1])) {                             result.push(baseType);                             i += count - 1;                             continue;                         }                     }                 }                 result.push(t);             }         } */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Null */ TODO {
			/* TODO(CallExpression): result.push(nullType) */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Undefined */ TODO {
			/* TODO(CallExpression): result.push(undefinedType) */
		}
		return result || types
	}
	visibilityToString := func(flags ModifierFlags) string {
		if flags == /* TODO(PropertyAccessExpression): ModifierFlags.Private */ TODO {
			return "private"
		}
		if flags == /* TODO(PropertyAccessExpression): ModifierFlags.Protected */ TODO {
			return "protected"
		}
		return "public"
	}
	getTypeAliasForTypeLiteral := func(type_ Type) *Symbol {
		if /* TODO(PropertyAccessExpression): type.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.TypeLiteral */ TODO && /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
			node := walkUpParenthesizedTypes( /* TODO(PropertyAccessExpression): type.symbol.declarations[0].parent */ TODO)
			if isTypeAliasDeclaration(node) {
				return getSymbolOfDeclaration(node)
			}
		}
		return nil
	}
	isTopLevelInExternalModuleAugmentation := func(node Node) bool {
		return node && /* TODO(PropertyAccessExpression): node.parent */ TODO && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleBlock */ TODO && isExternalModuleAugmentation( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
	}
	isDefaultBindingContext := func(location Node) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): location.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO || isAmbientModule(location)
	}
	getNameOfSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): string | undefined */ TODO {
		nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
		if nameType {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nameType.flags & TypeFlags.StringOrNumberLiteral */ TODO {
				name := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
				if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) {
					return /* TODO(TemplateExpression): `"${escapeString(name, CharacterCodes.doubleQuote)}"` */ TODO
				}
				if isNumericLiteralName(name) && startsWith(name, "-") {
					return /* TODO(TemplateExpression): `[${name}]` */ TODO
				}
				return name
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nameType.flags & TypeFlags.UniqueESSymbol */ TODO {
				return /* TODO(TemplateExpression): `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]` */ TODO
			}
		}
	}
	getNameOfSymbolAsWritten := func(symbol Symbol, context NodeBuilderContext) string {
		if /* TODO(PropertyAccessExpression): context?.remappedSymbolReferences?.has */ TODO(getSymbolId(symbol)) {
			/* TODO(ExpressionStatement): symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))!; */
		}
		if context && /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO == /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO && ! /* TODO(ParenthesizedExpression): (context.flags & NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope) */ TODO && /* TODO(ParenthesizedExpression): (!(context.flags & NodeBuilderFlags.InInitialEntityName) ||                 // if the symbol is synthesized, it will only be referenced externally it must print as `default`                 !symbol.declarations ||                 // if not in the same binding context (source file, module declaration), it must print as `default`                 (context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) !== findAncestor(context.enclosingDeclaration, isDefaultBindingContext))) */ TODO {
			return "default"
		}
		if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.length */ TODO {
			declaration := firstDefined( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => getNameOfDeclaration(d) ? d : undefined */, TODO)
			name := declaration && getNameOfDeclaration(declaration)
			if declaration && name {
				if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
					return symbolName(symbol)
				}
				if isComputedPropertyName(name) && ! /* TODO(ParenthesizedExpression): (getCheckFlags(symbol) & CheckFlags.Late) */ TODO {
					nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */ TODO
					if nameType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nameType.flags & TypeFlags.StringOrNumberLiteral */ TODO {
						result := getNameOfSymbolFromNameType(symbol, context)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== undefined */ TODO {
							return result
						}
					}
				}
				return declarationNameToString(name)
			}
			if !declaration {
				/* TODO(ExpressionStatement): declaration = symbol.declarations[0]; */
			}
			if /* TODO(PropertyAccessExpression): declaration.parent */ TODO && /* TODO(PropertyAccessExpression): declaration.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO {
				return declarationNameToString( /* TODO(PropertyAccessExpression): (declaration.parent as VariableDeclaration).name */ TODO)
			}
			/* TODO(SwitchStatement): switch (declaration.kind) {                 case SyntaxKind.ClassExpression:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                     if (context && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {                         context.encounteredError = true;                     }                     return declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)";             } */
		}
		name := getNameOfSymbolFromNameType(symbol, context)
		return /* TODO(ConditionalExpression): name !== undefined ? name : symbolName(symbol) */ TODO
	}
	isDeclarationVisible := func(node Node) bool {
		if node {
			links := getNodeLinks(node)
			if /* TODO(PropertyAccessExpression): links.isVisible */ TODO == nil {
				/* TODO(ExpressionStatement): links.isVisible = !!determineIfDeclarationIsVisible(); */
			}
			return /* TODO(PropertyAccessExpression): links.isVisible */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
		determineIfDeclarationIsVisible := func() /* TODO(undefined): boolean */ TODO {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocEnumTag:                     // Top-level jsdoc type aliases are considered exported                     // First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file                     return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent));                 case SyntaxKind.BindingElement:                     return isDeclarationVisible(node.parent.parent);                 case SyntaxKind.VariableDeclaration:                     if (                         isBindingPattern((node as VariableDeclaration).name) &&                         !((node as VariableDeclaration).name as BindingPattern).elements.length                     ) {                         // If the binding pattern is empty, this variable declaration is not visible                         return false;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.EnumDeclaration:                 case SyntaxKind.ImportEqualsDeclaration:                     // external module augmentation is always visible                     if (isExternalModuleAugmentation(node)) {                         return true;                     }                     const parent = getDeclarationContainer(node);                     // If the node is not exported or it is not ambient module element (except import declaration)                     if (                         !(getCombinedModifierFlagsCached(node as Declaration) & ModifierFlags.Export) &&                         !(node.kind !== SyntaxKind.ImportEqualsDeclaration && parent.kind !== SyntaxKind.SourceFile && parent.flags & NodeFlags.Ambient)                     ) {                         return isGlobalSourceFile(parent);                     }                     // Exported members/ambient module elements (exception import declaration) are visible if parent is visible                     return isDeclarationVisible(parent);                  case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.PropertySignature:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.MethodSignature:                     if (hasEffectiveModifier(node, ModifierFlags.Private | ModifierFlags.Protected)) {                         // Private/protected properties/methods are not visible                         return false;                     }                     // Public properties/methods are visible if its parents are visible, so:                     // falls through                  case SyntaxKind.Constructor:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.CallSignature:                 case SyntaxKind.IndexSignature:                 case SyntaxKind.Parameter:                 case SyntaxKind.ModuleBlock:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.TypeLiteral:                 case SyntaxKind.TypeReference:                 case SyntaxKind.ArrayType:                 case SyntaxKind.TupleType:                 case SyntaxKind.UnionType:                 case SyntaxKind.IntersectionType:                 case SyntaxKind.ParenthesizedType:                 case SyntaxKind.NamedTupleMember:                     return isDeclarationVisible(node.parent);                  // Default binding, import specifier and namespace import is visible                 // only on demand so by default it is not visible                 case SyntaxKind.ImportClause:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportSpecifier:                     return false;                  // Type parameters are always visible                 case SyntaxKind.TypeParameter:                  // Source file and namespace export are always visible                 // falls through                 case SyntaxKind.SourceFile:                 case SyntaxKind.NamespaceExportDeclaration:                     return true;                  // Export assignments do not create name bindings outside the module                 case SyntaxKind.ExportAssignment:                     return false;                  default:                     return false;             } */
		}
	}
	collectLinkedAliases := func(node ModuleExportName, setVisibility bool) /* TODO(ArrayType): Node[] */ any {
		var exportSymbol *Symbol
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.StringLiteral */ TODO && /* TODO(PropertyAccessExpression): node.parent */ TODO && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO {
			/* TODO(ExpressionStatement): exportSymbol = resolveName(node, node, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias, /*nameNotFoundMessage* / undefined, /*isUse* / false); */
		} else if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportSpecifier */ TODO {
			/* TODO(ExpressionStatement): exportSymbol = getTargetOfExportSpecifier(node.parent as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias); */
		}
		var result /* TODO(ArrayType): Node[] */ any
		var visited *Set[number]
		if exportSymbol {
			/* TODO(ExpressionStatement): visited = new Set(); */
			/* TODO(PropertyAccessExpression): visited.add */
			TODO(getSymbolId(exportSymbol))
			buildVisibleNodeList( /* TODO(PropertyAccessExpression): exportSymbol.declarations */ TODO)
		}
		return result
		buildVisibleNodeList := func(declarations /* TODO(ArrayType): Declaration[] */ any) {
			forEach(declarations /* TODO(ArrowFunction): declaration => {                 const resultNode = getAnyImportSyntax(declaration) || declaration;                 if (setVisibility) {                     getNodeLinks(declaration).isVisible = true;                 }                 else {                     result = result || [];                     pushIfUnique(result, resultNode);                 }                  if (isInternalModuleImportEqualsDeclaration(declaration)) {                     // Add the referenced top container visible                     const internalModuleReference = declaration.moduleReference as Identifier | QualifiedName;                     const firstIdentifier = getFirstIdentifier(internalModuleReference);                     const importSymbol = resolveName(declaration, firstIdentifier.escapedText, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*nameNotFoundMessage* / undefined, /*isUse* / false);                     if (importSymbol && visited) {                         if (tryAddToSet(visited, getSymbolId(importSymbol))) {                             buildVisibleNodeList(importSymbol.declarations);                         }                     }                 }             } */, TODO)
		}
	}
	pushTypeResolution := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		resolutionCycleStartIndex := findResolutionCycleStartIndex(target, propertyName)
		if resolutionCycleStartIndex >= 0 {
			TODO_IDENTIFIER := resolutionTargets
			/* TODO(ForStatement): for (let i = resolutionCycleStartIndex; i < length; i++) {                 resolutionResults[i] = false;             } */
			return /* TODO(FalseKeyword): false */ TODO
		}
		/* TODO(PropertyAccessExpression): resolutionTargets.push */ TODO(target)
		/* TODO(PropertyAccessExpression): resolutionResults.push */ TODO( /* TODO(TrueKeyword): true */ TODO)
		/* TODO(PropertyAccessExpression): resolutionPropertyNames.push */ TODO(propertyName)
		return /* TODO(TrueKeyword): true */ TODO
	}
	findResolutionCycleStartIndex := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
		/* TODO(ForStatement): for (let i = resolutionTargets.length - 1; i >= resolutionStart; i--) {             if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {                 return -1;             }             if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {                 return i;             }         } */
		return -1
	}
	resolutionTargetHasProperty := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		/* TODO(SwitchStatement): switch (propertyName) {             case TypeSystemPropertyName.Type:                 return !!getSymbolLinks(target as Symbol).type;             case TypeSystemPropertyName.DeclaredType:                 return !!getSymbolLinks(target as Symbol).declaredType;             case TypeSystemPropertyName.ResolvedBaseConstructorType:                 return !!(target as InterfaceType).resolvedBaseConstructorType;             case TypeSystemPropertyName.ResolvedReturnType:                 return !!(target as Signature).resolvedReturnType;             case TypeSystemPropertyName.ImmediateBaseConstraint:                 return !!(target as Type).immediateBaseConstraint;             case TypeSystemPropertyName.ResolvedTypeArguments:                 return !!(target as TypeReference).resolvedTypeArguments;             case TypeSystemPropertyName.ResolvedBaseTypes:                 return !!(target as InterfaceType).baseTypesResolved;             case TypeSystemPropertyName.WriteType:                 return !!getSymbolLinks(target as Symbol).writeType;             case TypeSystemPropertyName.ParameterInitializerContainsUndefined:                 return getNodeLinks(target as ParameterDeclaration).parameterInitializerContainsUndefined !== undefined;         } */
		return /* TODO(PropertyAccessExpression): Debug.assertNever */ TODO(propertyName)
	}
	popTypeResolution := func() bool {
		/* TODO(PropertyAccessExpression): resolutionTargets.pop */ TODO()
		/* TODO(PropertyAccessExpression): resolutionPropertyNames.pop */ TODO()
		return /* TODO(NonNullExpression): resolutionResults.pop()! */ TODO
	}
	getDeclarationContainer := func(node Node) Node {
		return /* TODO(PropertyAccessExpression): findAncestor(getRootDeclaration(node), node => {             switch (node.kind) {                 case SyntaxKind.VariableDeclaration:                 case SyntaxKind.VariableDeclarationList:                 case SyntaxKind.ImportSpecifier:                 case SyntaxKind.NamedImports:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportClause:                     return false;                 default:                     return true;             }         })!.parent */ TODO
	}
	getTypeOfPrototypeProperty := func(prototype Symbol) Type {
		classType := getDeclaredTypeOfSymbol( /* TODO(NonNullExpression): getParentOfSymbol(prototype)! */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
		return /* TODO(ConditionalExpression): classType.typeParameters ? createTypeReference(classType as GenericType, map(classType.typeParameters, _ => anyType)) : classType */ TODO
	}
	getTypeOfPropertyOfType := func(type_ Type, name __String) *Type {
		prop := getPropertyOfType(type_, name)
		return /* TODO(ConditionalExpression): prop ? getTypeOfSymbol(prop) : undefined */ TODO
	}
	getTypeOfPropertyOrIndexSignatureOfType := func(type_ Type, name __String) *Type {
		var propType TODO
		return getTypeOfPropertyOfType(type_, name) || /* TODO(ParenthesizedExpression): (propType = getApplicableIndexInfoForName(type, name)?.type) */ TODO && addOptionality(propType /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO)
	}
	isTypeAny := func(type_ *Type) /* TODO(undefined): boolean | undefined */ TODO {
		return type_ && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (type.flags & TypeFlags.Any) !== 0 */ TODO
	}
	isErrorType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return type_ == errorType || !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Any && type.aliasSymbol) */ TODO
	}
	getTypeForBindingElementParent := func(node BindingElementGrandparent, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): checkMode !== CheckMode.Normal */ TODO {
			return getTypeForVariableLikeDeclaration(node /* TODO(FalseKeyword): false */, TODO, checkMode)
		}
		symbol := getSymbolOfDeclaration(node)
		return symbol && /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).type */ TODO || getTypeForVariableLikeDeclaration(node /* TODO(FalseKeyword): false */, TODO, checkMode)
	}
	getRestType := func(source Type, properties []PropertyName, symbol *Symbol) Type {
		/* TODO(ExpressionStatement): source = filterType(source, t => !(t.flags & TypeFlags.Nullable)); */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Never */ TODO {
			return emptyObjectType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
			return mapType(source /* TODO(ArrowFunction): t => getRestType(t, properties, symbol) */, TODO)
		}
		omitKeyType := getUnionType(map_(properties, getLiteralTypeFromPropertyName))
		var spreadableProperties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var unspreadableToRestKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, prop := range getPropertiesOfType(source) {
			literalTypeFromProperty := getLiteralTypeFromProperty(prop /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO)
			if !isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && ! /* TODO(ParenthesizedExpression): (getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected)) */ TODO && isSpreadableProperty(prop) {
				/* TODO(PropertyAccessExpression): spreadableProperties.push */ TODO(prop)
			} else {
				/* TODO(PropertyAccessExpression): unspreadableToRestKeys.push */ TODO(literalTypeFromProperty)
			}
		}
		if isGenericObjectType(source) || isGenericIndexType(omitKeyType) {
			if /* TODO(PropertyAccessExpression): unspreadableToRestKeys.length */ TODO {
				/* TODO(ExpressionStatement): omitKeyType = getUnionType([omitKeyType, ...unspreadableToRestKeys]); */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): omitKeyType.flags & TypeFlags.Never */ TODO {
				return source
			}
			omitTypeAlias := getGlobalOmitSymbol()
			if !omitTypeAlias {
				return errorType
			}
			return getTypeAliasInstantiation(omitTypeAlias /* TODO(ArrayLiteralExpression): [source, omitKeyType] */, TODO)
		}
		members := createSymbolTable()
		for _, prop := range spreadableProperties {
			/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, getSpreadSymbol(prop /* TODO(FalseKeyword): false */, TODO))
		}
		result := createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source))
		/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ObjectRestType; */
		return result
	}
	isGenericTypeWithUndefinedConstraint := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Instantiable) */ TODO && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, TODO)
	}
	getNonUndefinedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeOrConstraint := /* TODO(ConditionalExpression): someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type */ TODO
		return getTypeWithFacts(typeOrConstraint /* TODO(PropertyAccessExpression): TypeFacts.NEUndefined */, TODO)
	}
	getFlowTypeOfDestructuring := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reference := getSyntheticElementAccess(node)
		return /* TODO(ConditionalExpression): reference ? getFlowTypeOfReference(reference, declaredType) : declaredType */ TODO
	}
	getSyntheticElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
		parentAccess := getParentElementAccess(node)
		if parentAccess && canHaveFlowNode(parentAccess) && /* TODO(PropertyAccessExpression): parentAccess.flowNode */ TODO {
			propName := getDestructuringPropertyName(node)
			if propName {
				literal := setTextRangeWorker( /* TODO(PropertyAccessExpression): parseNodeFactory.createStringLiteral */ TODO(propName), node)
				lhsExpr := /* TODO(ConditionalExpression): isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess) */ TODO
				result := setTextRangeWorker( /* TODO(PropertyAccessExpression): parseNodeFactory.createElementAccessExpression */ TODO(lhsExpr, literal), node)
				setParent(literal, result)
				setParent(result, node)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): lhsExpr !== parentAccess */ TODO {
					setParent(lhsExpr, result)
				}
				/* TODO(ExpressionStatement): result.flowNode = parentAccess.flowNode; */
				return result
			}
		}
	}
	getParentElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		ancestor := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
		/* TODO(SwitchStatement): switch (ancestor.kind) {             case SyntaxKind.BindingElement:             case SyntaxKind.PropertyAssignment:                 return getSyntheticElementAccess(ancestor as BindingElement | PropertyAssignment);             case SyntaxKind.ArrayLiteralExpression:                 return getSyntheticElementAccess(node.parent as Expression);             case SyntaxKind.VariableDeclaration:                 return (ancestor as VariableDeclaration).initializer;             case SyntaxKind.BinaryExpression:                 return (ancestor as BinaryExpression).right;         } */
	}
	getDestructuringPropertyName := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO(undefined): string | undefined */ TODO {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO && /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectBindingPattern */ TODO {
			return getLiteralPropertyNameText( /* TODO(PropertyAccessExpression): (node as BindingElement).propertyName */ TODO || /* TODO(PropertyAccessExpression): (node as BindingElement).name */ TODO /* as */ /* TODO(TypeReference): Identifier */)
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO {
			return getLiteralPropertyNameText( /* TODO(PropertyAccessExpression): (node as PropertyAssignment | ShorthandPropertyAssignment).name */ TODO)
		}
		return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + ((parent as BindingPattern | ArrayLiteralExpression).elements as NodeArray<Node>).indexOf(node) */ TODO
	}
	getLiteralPropertyNameText := func(name PropertyName) /* TODO(undefined): string | undefined */ TODO {
		type_ := getLiteralTypeFromPropertyName(name)
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? "" + (type as StringLiteralType | NumberLiteralType).value : undefined */ TODO
	}
	getTypeForBindingElement := func(declaration BindingElement) *Type {
		checkMode := /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
		parentType := getTypeForBindingElementParent( /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO, checkMode)
		return parentType && getBindingElementTypeFromParentType(declaration, parentType /* TODO(FalseKeyword): false */, TODO)
	}
	getBindingElementTypeFromParentType := func(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
		if isTypeAny(parentType) {
			return parentType
		}
		pattern := /* TODO(PropertyAccessExpression): declaration.parent */ TODO
		if strictNullChecks && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declaration.flags & NodeFlags.Ambient */ TODO && isPartOfParameterDeclaration(declaration) {
			/* TODO(ExpressionStatement): parentType = getNonNullableType(parentType); */
		} else if strictNullChecks && /* TODO(PropertyAccessExpression): pattern.parent.initializer */ TODO && ! /* TODO(ParenthesizedExpression): (hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFacts.EQUndefined)) */ TODO {
			/* TODO(ExpressionStatement): parentType = getTypeWithFacts(parentType, TypeFacts.NEUndefined); */
		}
		accessFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): AccessFlags.ExpressionPosition | (noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.AllowMissing : 0) */ TODO
		var type_ *Type
		if /* TODO(PropertyAccessExpression): pattern.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectBindingPattern */ TODO {
			if /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO {
				/* TODO(ExpressionStatement): parentType = getReducedType(parentType); */
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): parentType.flags & TypeFlags.Unknown */ TODO || !isValidSpreadType(parentType) {
					error(declaration /* TODO(PropertyAccessExpression): Diagnostics.Rest_types_may_only_be_created_from_object_types */, TODO)
					return errorType
				}
				var literalMembers []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, element := range /* TODO(PropertyAccessExpression): pattern.elements */ TODO {
					if ! /* TODO(PropertyAccessExpression): element.dotDotDotToken */ TODO {
						/* TODO(PropertyAccessExpression): literalMembers.push */ TODO( /* TODO(PropertyAccessExpression): element.propertyName */ TODO || /* TODO(PropertyAccessExpression): element.name */ TODO /* as */ /* TODO(TypeReference): Identifier */)
					}
				}
				/* TODO(ExpressionStatement): type = getRestType(parentType, literalMembers, declaration.symbol); */
			} else {
				name := /* TODO(PropertyAccessExpression): declaration.propertyName */ TODO || /* TODO(PropertyAccessExpression): declaration.name */ TODO /* as */ /* TODO(TypeReference): Identifier */
				indexType := getLiteralTypeFromPropertyName(name)
				declaredType := getIndexedAccessType(parentType, indexType, accessFlags, name)
				/* TODO(ExpressionStatement): type = getFlowTypeOfDestructuring(declaration, declaredType); */
			}
		} else {
			elementType := checkIteratedTypeOrElementType( /* TODO(BarToken): | */ /* TODO(BinaryExpression): IterationUse.Destructuring | (declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds) */ TODO, parentType, undefinedType, pattern)
			index := /* TODO(PropertyAccessExpression): pattern.elements.indexOf */ TODO(declaration)
			if /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO {
				baseConstraint := mapType(parentType /* TODO(ArrowFunction): t => t.flags & TypeFlags.InstantiableNonPrimitive ? getBaseConstraintOrType(t) : t */, TODO)
				/* TODO(ExpressionStatement): type = everyType(baseConstraint, isTupleType) ?                     mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) :                     createArrayType(elementType); */
			} else if isArrayLikeType(parentType) {
				indexType := getNumberLiteralType(index)
				declaredType := getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags /* TODO(PropertyAccessExpression): declaration.name */, TODO) || errorType
				/* TODO(ExpressionStatement): type = getFlowTypeOfDestructuring(declaration, declaredType); */
			} else {
				/* TODO(ExpressionStatement): type = elementType; */
			}
		}
		if ! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO {
			return type_
		}
		if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
			return /* TODO(ConditionalExpression): strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) ? getNonUndefinedType(type) : type */ TODO
		}
		return widenTypeInferredFromInitializer(declaration, getUnionType( /* TODO(ArrayLiteralExpression): [getNonUndefinedType(type), checkDeclarationInitializer(declaration, CheckMode.Normal)] */ TODO /* TODO(PropertyAccessExpression): UnionReduction.Subtype */, TODO))
	}
	getTypeForDeclarationFromJSDocComment := func(declaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		jsdocType := getJSDocType(declaration)
		if jsdocType {
			return getTypeFromTypeNode(jsdocType)
		}
		return nil
	}
	isNullOrUndefined := func(node Expression) /* TODO(undefined): boolean */ TODO {
		expr := skipParentheses(node /* TODO(TrueKeyword): true */, TODO)
		return /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NullKeyword */ TODO || /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO && getResolvedSymbol(expr /* as */ /* TODO(TypeReference): Identifier */) == undefinedSymbol
	}
	isEmptyArrayLiteral := func(node Expression) /* TODO(undefined): boolean */ TODO {
		expr := skipParentheses(node /* TODO(TrueKeyword): true */, TODO)
		return /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayLiteralExpression */ TODO && /* TODO(PropertyAccessExpression): (expr as ArrayLiteralExpression).elements.length */ TODO == 0
	}
	addOptionality := func(type_ Type, isProperty /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, isOptional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) Type {
		return /* TODO(ConditionalExpression): strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type */ TODO
	}
	getTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) *Type {
		if isVariableDeclaration(declaration) && /* TODO(PropertyAccessExpression): declaration.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForInStatement */ TODO {
			indexType := getIndexType(getNonNullableTypeIfNeeded(checkExpression( /* TODO(PropertyAccessExpression): declaration.parent.parent.expression */ TODO, checkMode)))
			return /* TODO(ConditionalExpression): indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType */ TODO
		}
		if isVariableDeclaration(declaration) && /* TODO(PropertyAccessExpression): declaration.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForOfStatement */ TODO {
			forOfStatement := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
			return checkRightHandSideOfForOf(forOfStatement) || anyType
		}
		if isBindingPattern( /* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
			return getTypeForBindingElement(declaration /* as */ /* TODO(TypeReference): BindingElement */)
		}
		isProperty := /* TODO(ParenthesizedExpression): (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) */ TODO || isPropertySignature(declaration) || isJSDocPropertyTag(declaration)
		isOptional := includeOptionality && isOptionalDeclaration(declaration)
		declaredType := tryGetTypeFromEffectiveTypeNode(declaration)
		if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
			if declaredType {
				return /* TODO(ConditionalExpression): isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType */ TODO
			}
			return /* TODO(ConditionalExpression): useUnknownInCatchVariables ? unknownType : anyType */ TODO
		}
		if declaredType {
			return addOptionality(declaredType, isProperty, isOptional)
		}
		if /* TODO(ParenthesizedExpression): (noImplicitAny || isInJSFile(declaration)) */ TODO && isVariableDeclaration(declaration) && !isBindingPattern( /* TODO(PropertyAccessExpression): declaration.name */ TODO) && ! /* TODO(ParenthesizedExpression): (getCombinedModifierFlagsCached(declaration) & ModifierFlags.Export) */ TODO && ! /* TODO(ParenthesizedExpression): (declaration.flags & NodeFlags.Ambient) */ TODO {
			if ! /* TODO(ParenthesizedExpression): (getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant) */ TODO && /* TODO(ParenthesizedExpression): (!declaration.initializer || isNullOrUndefined(declaration.initializer)) */ TODO {
				return autoType
			}
			if /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && isEmptyArrayLiteral( /* TODO(PropertyAccessExpression): declaration.initializer */ TODO) {
				return autoArrayType
			}
		}
		if isParameter(declaration) {
			if ! /* TODO(PropertyAccessExpression): declaration.symbol */ TODO {
				return
			}
			func_ := /* TODO(PropertyAccessExpression): declaration.parent */ TODO /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */
			if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO && hasBindableName(func_) {
				getter := getDeclarationOfKind(getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): declaration.parent */ TODO) /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */, TODO)
				if getter {
					getterSignature := getSignatureFromDeclaration(getter)
					thisParameter := getAccessorThisParameter(func_ /* as */ /* TODO(TypeReference): AccessorDeclaration */)
					if thisParameter && declaration == thisParameter {
						/* TODO(PropertyAccessExpression): Debug.assert */ TODO(! /* TODO(PropertyAccessExpression): thisParameter.type */ TODO)
						return getTypeOfSymbol( /* TODO(NonNullExpression): getterSignature.thisParameter! */ TODO)
					}
					return getReturnTypeOfSignature(getterSignature)
				}
			}
			parameterTypeOfTypeTag := getParameterTypeOfTypeTag(func_, declaration)
			if parameterTypeOfTypeTag {
				/* TODO(Identifier): parameterTypeOfTypeTag */
			}
			type_ := /* TODO(ConditionalExpression): declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration) */ TODO
			if type_ {
				return addOptionality(type_ /* TODO(FalseKeyword): false */, TODO, isOptional)
			}
		}
		if hasOnlyExpressionInitializer(declaration) && !! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO {
			if isInJSFile(declaration) && !isParameter(declaration) {
				containerObjectType := getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
				if containerObjectType {
					return containerObjectType
				}
			}
			type_ := widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode))
			return addOptionality(type_, isProperty, isOptional)
		}
		if isPropertyDeclaration(declaration) && /* TODO(ParenthesizedExpression): (noImplicitAny || isInJSFile(declaration)) */ TODO {
			if !hasStaticModifier(declaration) {
				constructor := findConstructorDeclaration( /* TODO(PropertyAccessExpression): declaration.parent */ TODO)
				type_ := /* TODO(ConditionalExpression): constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
				return type_ && addOptionality(type_ /* TODO(TrueKeyword): true */, TODO, isOptional)
			} else {
				staticBlocks := filter( /* TODO(PropertyAccessExpression): declaration.parent.members */ TODO, isClassStaticBlockDeclaration)
				type_ := /* TODO(ConditionalExpression): staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
				return type_ && addOptionality(type_ /* TODO(TrueKeyword): true */, TODO, isOptional)
			}
		}
		if isJsxAttribute(declaration) {
			return trueType
		}
		if isBindingPattern( /* TODO(PropertyAccessExpression): declaration.name */ TODO) {
			return getTypeFromBindingPattern( /* TODO(PropertyAccessExpression): declaration.name */ TODO /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
		}
		return nil
	}
	isConstructorDeclaredProperty := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) {
			links := getSymbolLinks(symbol)
			if /* TODO(PropertyAccessExpression): links.isConstructorDeclaredProperty */ TODO == nil {
				/* TODO(ExpressionStatement): links.isConstructorDeclaredProperty = false; */
				/* TODO(ExpressionStatement): links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, declaration =>                     isBinaryExpression(declaration) &&                     isPossiblyAliasedThisProperty(declaration) &&                     (declaration.left.kind !== SyntaxKind.ElementAccessExpression || isStringOrNumericLiteralLike((declaration.left as ElementAccessExpression).argumentExpression)) &&                     !getAnnotatedTypeForAssignmentDeclaration(/*declaredType* / undefined, declaration, symbol, declaration)); */
			}
			return /* TODO(PropertyAccessExpression): links.isConstructorDeclaredProperty */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isAutoTypedProperty := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && ! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && /* TODO(ParenthesizedExpression): (noImplicitAny || isInJSFile(declaration)) */ TODO
	}
	getDeclaringConstructor := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | undefined */ TODO {
		if ! /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			return
		}
		for _, declaration := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			container := getThisContainer(declaration /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
			if container && /* TODO(ParenthesizedExpression): (container.kind === SyntaxKind.Constructor || isJSConstructor(container)) */ TODO {
				return container /* as */ /* TODO(TypeReference): ConstructorDeclaration */
			}
		}
	}
	getFlowTypeFromCommonJSExport := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		file := getSourceFileOfNode( /* TODO(ElementAccessExpression): symbol.declarations![0] */ TODO)
		accessName := unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO)
		areAllModuleExports := /* TODO(PropertyAccessExpression): symbol.declarations!.every */ TODO( /* TODO(ArrowFunction): d => isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression) */ TODO)
		reference := /* TODO(ConditionalExpression): areAllModuleExports             ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)             : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName) */ TODO
		if areAllModuleExports {
			setParent( /* TODO(PropertyAccessExpression): (reference.expression as PropertyAccessExpression).expression */ TODO /* TODO(PropertyAccessExpression): reference.expression */, TODO)
		}
		setParent( /* TODO(PropertyAccessExpression): reference.expression */ TODO, reference)
		setParent(reference, file)
		/* TODO(ExpressionStatement): reference.flowNode = file.endFlowNode; */
		return getFlowTypeOfReference(reference, autoType, undefinedType)
	}
	getFlowTypeInStaticBlocks := func(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		for _, staticBlock := range staticBlocks {
			reference := /* TODO(PropertyAccessExpression): factory.createPropertyAccessExpression */ TODO( /* TODO(PropertyAccessExpression): factory.createThis */ TODO(), accessName)
			setParent( /* TODO(PropertyAccessExpression): reference.expression */ TODO, reference)
			setParent(reference, staticBlock)
			/* TODO(ExpressionStatement): reference.flowNode = staticBlock.returnFlowNode; */
			flowType := getFlowTypeOfProperty(reference, symbol)
			if noImplicitAny && /* TODO(ParenthesizedExpression): (flowType === autoType || flowType === autoArrayType) */ TODO {
				error( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Member_0_implicitly_has_an_1_type */, TODO, symbolToString(symbol), typeToString(flowType))
			}
			if everyType(flowType, isNullableType) {
				/* TODO(ContinueStatement): continue; */
			}
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeInConstructor := func(symbol Symbol, constructor ConstructorDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		reference := /* TODO(PropertyAccessExpression): factory.createPropertyAccessExpression */ TODO( /* TODO(PropertyAccessExpression): factory.createThis */ TODO(), accessName)
		setParent( /* TODO(PropertyAccessExpression): reference.expression */ TODO, reference)
		setParent(reference, constructor)
		/* TODO(ExpressionStatement): reference.flowNode = constructor.returnFlowNode; */
		flowType := getFlowTypeOfProperty(reference, symbol)
		if noImplicitAny && /* TODO(ParenthesizedExpression): (flowType === autoType || flowType === autoArrayType) */ TODO {
			error( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Member_0_implicitly_has_an_1_type */, TODO, symbolToString(symbol), typeToString(flowType))
		}
		return /* TODO(ConditionalExpression): everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType) */ TODO
	}
	getFlowTypeOfProperty := func(reference Node, prop *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		initialType := /* TODO(PropertyAccessExpression): prop?.valueDeclaration */ TODO && /* TODO(ParenthesizedExpression): (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration) & ModifierFlags.Ambient) */ TODO && getTypeOfPropertyInBaseClass(prop) || undefinedType
		return getFlowTypeOfReference(reference, autoType, initialType)
	}
	getWidenedTypeForAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		container := getAssignedExpandoInitializer( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
		if container {
			tag := /* TODO(ConditionalExpression): isInJSFile(container) ? getJSDocTypeTag(container) : undefined */ TODO
			if tag && /* TODO(PropertyAccessExpression): tag.typeExpression */ TODO {
				return getTypeFromTypeNode( /* TODO(PropertyAccessExpression): tag.typeExpression */ TODO)
			}
			containerObjectType := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && getJSContainerObjectType( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, symbol, container)
			return containerObjectType || getWidenedLiteralType(checkExpressionCached(container))
		}
		var type_ TODO
		definedInConstructor := /* TODO(FalseKeyword): false */ TODO
		definedInMethod := /* TODO(FalseKeyword): false */ TODO
		if isConstructorDeclaredProperty(symbol) {
			/* TODO(ExpressionStatement): type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol)!); */
		}
		if !type_ {
			var types /* TODO(ArrayType): Type[] */ any
			if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
				var jsdocType *Type
				for _, declaration := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
					expression := /* TODO(ConditionalExpression): (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration :                         isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration :                         undefined */ TODO
					if !expression {
						/* TODO(ContinueStatement): continue; */
					}
					kind := /* TODO(ConditionalExpression): isAccessExpression(expression)                         ? getAssignmentDeclarationPropertyAccessKind(expression)                         : getAssignmentDeclarationKind(expression) */ TODO
					if kind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ThisProperty */ TODO || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind) {
						if isDeclarationInConstructor(expression) {
							/* TODO(ExpressionStatement): definedInConstructor = true; */
						} else {
							/* TODO(ExpressionStatement): definedInMethod = true; */
						}
					}
					if !isCallExpression(expression) {
						/* TODO(ExpressionStatement): jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration); */
					}
					if !jsdocType {
						/* TODO(PropertyAccessExpression): (types || (types = [])).push */ TODO( /* TODO(ConditionalExpression): (isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType */ TODO)
					}
				}
				/* TODO(ExpressionStatement): type = jsdocType; */
			}
			if !type_ {
				if !length(types) {
					return errorType
				}
				constructorTypes := /* TODO(ConditionalExpression): definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined */ TODO
				if definedInMethod {
					propType := getTypeOfPropertyInBaseClass(symbol)
					if propType {
						/* TODO(PropertyAccessExpression): (constructorTypes || (constructorTypes = [])).push */ TODO(propType)
						/* TODO(ExpressionStatement): definedInConstructor = true; */
					}
				}
				sourceTypes := /* TODO(ConditionalExpression): some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types */ TODO
				/* TODO(ExpressionStatement): type = getUnionType(sourceTypes!); */
			}
		}
		widened := getWidenedType(addOptionality(type_ /* TODO(FalseKeyword): false */, TODO, definedInMethod && !definedInConstructor))
		if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isInJSFile( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) && filterType(widened /* TODO(ArrowFunction): t => !!(t.flags & ~TypeFlags.Nullable) */, TODO) == neverType {
			reportImplicitAny( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, anyType)
			return anyType
		}
		return widened
	}
	getJSContainerObjectType := func(decl Node, symbol Symbol, init *Expression) *Type {
		if !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || /* TODO(PropertyAccessExpression): init.properties.length */ TODO {
			return nil
		}
		exports := createSymbolTable()
		/* TODO(WhileStatement): while (isBinaryExpression(decl) || isPropertyAccessExpression(decl)) {             const s = getSymbolOfNode(decl);             if (s?.exports?.size) {                 mergeSymbolTable(exports, s.exports);             }             decl = isBinaryExpression(decl) ? decl.parent : decl.parent.parent;         } */
		s := getSymbolOfNode(decl)
		if /* TODO(PropertyAccessExpression): s?.exports?.size */ TODO {
			mergeSymbolTable(exports /* TODO(PropertyAccessExpression): s.exports */, TODO)
		}
		type_ := createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
		/* TODO(ExpressionStatement): type.objectFlags |= ObjectFlags.JSLiteral; */
		return type_
	}
	getAnnotatedTypeForAssignmentDeclaration := func(declaredType *Type, expression Expression, symbol Symbol, declaration Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		typeNode := getEffectiveTypeAnnotationNode( /* TODO(PropertyAccessExpression): expression.parent */ TODO)
		if typeNode {
			type_ := getWidenedType(getTypeFromTypeNode(typeNode))
			if !declaredType {
				return type_
			} else if !isErrorType(declaredType) && !isErrorType(type_) && !isTypeIdenticalTo(declaredType, type_) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(nil, declaredType, declaration, type_)
			}
		}
		if /* TODO(PropertyAccessExpression): symbol.parent?.valueDeclaration */ TODO {
			possiblyAnnotatedSymbol := getFunctionExpressionParentSymbolOrSymbol( /* TODO(PropertyAccessExpression): symbol.parent */ TODO)
			if /* TODO(PropertyAccessExpression): possiblyAnnotatedSymbol.valueDeclaration */ TODO {
				typeNode := getEffectiveTypeAnnotationNode( /* TODO(PropertyAccessExpression): possiblyAnnotatedSymbol.valueDeclaration */ TODO)
				if typeNode {
					annotationSymbol := getPropertyOfType(getTypeFromTypeNode(typeNode) /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO)
					if annotationSymbol {
						return getNonMissingTypeOfSymbol(annotationSymbol)
					}
				}
			}
		}
		return declaredType
	}
	getInitializerTypeFromAssignmentDeclaration := func(symbol Symbol, resolvedSymbol *Symbol, expression /* TODO(UnionType): BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isCallExpression(expression) {
			if resolvedSymbol {
				return getTypeOfSymbol(resolvedSymbol)
			}
			objectLitType := checkExpressionCached( /* TODO(ElementAccessExpression): (expression as BindableObjectDefinePropertyCall).arguments[2] */ TODO)
			valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as */ /* TODO(TypeReference): __String */)
			if valueType {
				return valueType
			}
			getFunc := getTypeOfPropertyOfType(objectLitType, "get" /* as */ /* TODO(TypeReference): __String */)
			if getFunc {
				getSig := getSingleCallSignature(getFunc)
				if getSig {
					return getReturnTypeOfSignature(getSig)
				}
			}
			setFunc := getTypeOfPropertyOfType(objectLitType, "set" /* as */ /* TODO(TypeReference): __String */)
			if setFunc {
				setSig := getSingleCallSignature(setFunc)
				if setSig {
					return getTypeOfFirstParameterOfSignature(setSig)
				}
			}
			return anyType
		}
		if containsSameNamedThisProperty( /* TODO(PropertyAccessExpression): expression.left */ TODO /* TODO(PropertyAccessExpression): expression.right */, TODO) {
			return anyType
		}
		isDirectExport := kind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ExportsProperty */ TODO && /* TODO(ParenthesizedExpression): (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) */ TODO && /* TODO(ParenthesizedExpression): (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression))) */ TODO
		type_ := /* TODO(ConditionalExpression): resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)             : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))             : getWidenedLiteralType(checkExpressionCached(expression.right)) */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO && kind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ModuleExports */ TODO && /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO == /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO {
			exportedType := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			members := createSymbolTable()
			copyEntries( /* TODO(PropertyAccessExpression): exportedType.members */ TODO, members)
			initialSize := /* TODO(PropertyAccessExpression): members.size */ TODO
			if resolvedSymbol && ! /* TODO(PropertyAccessExpression): resolvedSymbol.exports */ TODO {
				/* TODO(ExpressionStatement): resolvedSymbol.exports = createSymbolTable(); */
			}
			/* TODO(PropertyAccessExpression): (resolvedSymbol || symbol).exports!.forEach */ TODO( /* TODO(ArrowFunction): (s, name) => {                 const exportedMember = members.get(name)!;                 if (exportedMember && exportedMember !== s && !(s.flags & SymbolFlags.Alias)) {                     if (s.flags & SymbolFlags.Value && exportedMember.flags & SymbolFlags.Value) {                         // If the member has an additional value-like declaration, union the types from the two declarations,                         // but issue an error if they occurred in two different files. The purpose is to support a JS file with                         // a pattern like:                         //                         // module.exports = { a: true };                         // module.exports.a = 3;                         //                         // but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation                         // declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because                         // it's unclear what that's supposed to mean, so it's probably a mistake.                         if (s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) !== getSourceFileOfNode(exportedMember.valueDeclaration)) {                             const unescapedName = unescapeLeadingUnderscores(s.escapedName);                             const exportedMemberName = tryCast(exportedMember.valueDeclaration, isNamedDeclaration)?.name || exportedMember.valueDeclaration;                             addRelatedInfo(                                 error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName),                                 createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName),                             );                             addRelatedInfo(                                 error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName),                                 createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName),                             );                         }                         const union = createSymbol(s.flags | exportedMember.flags, name);                         union.links.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);                         union.valueDeclaration = exportedMember.valueDeclaration;                         union.declarations = concatenate(exportedMember.declarations, s.declarations);                         members.set(name, union);                     }                     else {                         members.set(name, mergeSymbol(s, exportedMember));                     }                 }                 else {                     members.set(name, s);                 }             } */ TODO)
			result := createAnonymousType( /* TODO(ConditionalExpression): initialSize !== members.size ? undefined : exportedType.symbol */ TODO, members /* TODO(PropertyAccessExpression): exportedType.callSignatures */, TODO /* TODO(PropertyAccessExpression): exportedType.constructSignatures */, TODO /* TODO(PropertyAccessExpression): exportedType.indexInfos */, TODO)
			if initialSize == /* TODO(PropertyAccessExpression): members.size */ TODO {
				if /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO {
					/* TODO(ExpressionStatement): result.aliasSymbol = type.aliasSymbol; */
					/* TODO(ExpressionStatement): result.aliasTypeArguments = type.aliasTypeArguments; */
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Reference */ TODO {
					/* TODO(ExpressionStatement): result.aliasSymbol = (type as TypeReference).symbol; */
					args := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
					/* TODO(ExpressionStatement): result.aliasTypeArguments = length(args) ? args : undefined; */
				}
			}
			/* TODO(ExpressionStatement): result.objectFlags |= getPropagatingFlagsOfTypes([type]) | getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.ArrayLiteral | ObjectFlags.ObjectLiteral); */
			if /* TODO(PropertyAccessExpression): result.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.symbol.flags & SymbolFlags.Class */ TODO && type_ == getDeclaredTypeOfClassOrInterface( /* TODO(PropertyAccessExpression): result.symbol */ TODO) {
				/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.IsClassInstanceClone; */
			}
			return result
		}
		if isEmptyArrayLiteralType(type_) {
			reportImplicitAny(expression, anyArrayType)
			return anyArrayType
		}
		return type_
	}
	containsSameNamedThisProperty := func(thisProperty Expression, expression Expression) /* TODO(undefined): boolean | undefined */ TODO {
		return isPropertyAccessExpression(thisProperty) && /* TODO(PropertyAccessExpression): thisProperty.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO && forEachChildRecursively(expression /* TODO(ArrowFunction): n => isMatchingReference(thisProperty, n) */, TODO)
	}
	isDeclarationInConstructor := func(expression Expression) /* TODO(undefined): boolean */ TODO {
		thisContainer := getThisContainer(expression /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		return /* TODO(PropertyAccessExpression): thisContainer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO || /* TODO(PropertyAccessExpression): thisContainer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionDeclaration */ TODO || /* TODO(ParenthesizedExpression): (thisContainer.kind === SyntaxKind.FunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent)) */ TODO
	}
	getConstructorDefinedThisAssignmentTypes := func(types []Type, declarations []Declaration) /* TODO(ArrayType): Type[] */ any {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): types.length */ TODO == /* TODO(PropertyAccessExpression): declarations.length */ TODO)
		return /* TODO(PropertyAccessExpression): types.filter */ TODO( /* TODO(ArrowFunction): (_, i) => {             const declaration = declarations[i];             const expression = isBinaryExpression(declaration) ? declaration :                 isBinaryExpression(declaration.parent) ? declaration.parent : undefined;             return expression && isDeclarationInConstructor(expression);         } */ TODO)
	}
	getTypeFromBindingElement := func(element BindingElement, includePatternInType bool, reportErrors bool) Type {
		if /* TODO(PropertyAccessExpression): element.initializer */ TODO {
			contextualType := /* TODO(ConditionalExpression): isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType* / true, /*reportErrors* / false) : unknownType */ TODO
			return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO, contextualType)))
		}
		if isBindingPattern( /* TODO(PropertyAccessExpression): element.name */ TODO) {
			return getTypeFromBindingPattern( /* TODO(PropertyAccessExpression): element.name */ TODO, includePatternInType, reportErrors)
		}
		if reportErrors && !declarationBelongsToPrivateAmbientMember(element) {
			reportImplicitAny(element, anyType)
		}
		return /* TODO(ConditionalExpression): includePatternInType ? nonInferrableAnyType : anyType */ TODO
	}
	getTypeFromObjectBindingPattern := func(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
		members := createSymbolTable()
		var stringIndexInfo *IndexInfo
		objectFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral */ TODO
		forEach( /* TODO(PropertyAccessExpression): pattern.elements */ TODO /* TODO(ArrowFunction): e => {             const name = e.propertyName || e.name as Identifier;             if (e.dotDotDotToken) {                 stringIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly* / false);                 return;             }              const exprType = getLiteralTypeFromPropertyName(name);             if (!isTypeUsableAsPropertyName(exprType)) {                 // do not include computed properties in the implied type                 objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties;                 return;             }             const text = getPropertyNameFromType(exprType);             const flags = SymbolFlags.Property | (e.initializer ? SymbolFlags.Optional : 0);             const symbol = createSymbol(flags, text);             symbol.links.type = getTypeFromBindingElement(e, includePatternInType, reportErrors);             symbol.links.bindingElement = e;             members.set(symbol.escapedName, symbol);         } */, TODO)
		result := createAnonymousType(nil, members, emptyArray, emptyArray /* TODO(ConditionalExpression): stringIndexInfo ? [stringIndexInfo] : emptyArray */, TODO)
		/* TODO(ExpressionStatement): result.objectFlags |= objectFlags; */
		if includePatternInType {
			/* TODO(ExpressionStatement): result.pattern = pattern; */
			/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral; */
		}
		return result
	}
	getTypeFromArrayBindingPattern := func(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
		elements := /* TODO(PropertyAccessExpression): pattern.elements */ TODO
		lastElement := lastOrUndefined(elements)
		restElement := /* TODO(ConditionalExpression): lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined */ TODO
		if /* TODO(PropertyAccessExpression): elements.length */ TODO == 0 || /* TODO(PropertyAccessExpression): elements.length */ TODO == 1 && restElement {
			return /* TODO(ConditionalExpression): languageVersion >= ScriptTarget.ES2015 ? createIterableType(anyType) : anyArrayType */ TODO
		}
		elementTypes := map_(elements /* TODO(ArrowFunction): e => isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors) */, TODO)
		minLength := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1 */ TODO
		elementFlags := map_(elements /* TODO(ArrowFunction): (e, i) => e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required */, TODO)
		result := createTupleType(elementTypes, elementFlags) /* as */ /* TODO(TypeReference): TypeReference */
		if includePatternInType {
			/* TODO(ExpressionStatement): result = cloneTypeReference(result); */
			/* TODO(ExpressionStatement): result.pattern = pattern; */
			/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ContainsObjectOrArrayLiteral; */
		}
		return result
	}
	getTypeFromBindingPattern := func(pattern BindingPattern, includePatternInType /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Type {
		if includePatternInType {
			/* TODO(CallExpression): contextualBindingPatterns.push(pattern) */
		}
		result := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern             ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)             : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) */ TODO
		if includePatternInType {
			/* TODO(CallExpression): contextualBindingPatterns.pop() */
		}
		return result
	}
	getWidenedTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
		return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration /* TODO(TrueKeyword): true */, TODO /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO), declaration, reportErrors)
	}
	getTypeFromImportAttributes := func(node ImportAttributes) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			symbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.ObjectLiteral */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.ImportAttributes */, TODO)
			members := createSymbolTable()
			forEach( /* TODO(PropertyAccessExpression): node.elements */ TODO /* TODO(ArrowFunction): attr => {                 const member = createSymbol(SymbolFlags.Property, getNameFromImportAttribute(attr));                 member.parent = symbol;                 member.links.type = checkImportAttribute(attr);                 member.links.target = member;                 members.set(member.escapedName, member);             } */, TODO)
			type_ := createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
			/* TODO(ExpressionStatement): type.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.NonInferrableType; */
			/* TODO(ExpressionStatement): links.resolvedType = type; */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	isGlobalSymbolConstructor := func(node Node) /* TODO(undefined): boolean | undefined */ TODO {
		symbol := getSymbolOfNode(node)
		globalSymbol := getGlobalESSymbolConstructorTypeSymbol( /* TODO(FalseKeyword): false */ TODO)
		return globalSymbol && symbol && symbol == globalSymbol
	}
	widenTypeForVariableLikeDeclaration := func(type_ *Type, declaration /* TODO(AnyKeyword): any */ TODO, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_ {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.ESSymbol */ TODO && isGlobalSymbolConstructor( /* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
				/* TODO(ExpressionStatement): type = getESSymbolLikeTypeForNode(declaration); */
			}
			if reportErrors {
				reportErrorsFromWidening(declaration, type_)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.UniqueESSymbol */ TODO && /* TODO(ParenthesizedExpression): (isBindingElement(declaration) || !declaration.type) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.symbol !== getSymbolOfDeclaration(declaration) */ TODO {
				/* TODO(ExpressionStatement): type = esSymbolType; */
			}
			return getWidenedType(type_)
		}
		/* TODO(ExpressionStatement): type = isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType; */
		if reportErrors {
			if !declarationBelongsToPrivateAmbientMember(declaration) {
				reportImplicitAny(declaration, type_)
			}
		}
		return type_
	}
	declarationBelongsToPrivateAmbientMember := func(declaration VariableLikeDeclaration) /* TODO(undefined): boolean */ TODO {
		root := getRootDeclaration(declaration)
		memberDeclaration := /* TODO(ConditionalExpression): root.kind === SyntaxKind.Parameter ? root.parent : root */ TODO
		return isPrivateWithinAmbient(memberDeclaration)
	}
	tryGetTypeFromEffectiveTypeNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		typeNode := getEffectiveTypeAnnotationNode(node)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
	}
	isParameterOfContextSensitiveSignature := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		decl := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if !decl {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if isBindingElement(decl) {
			/* TODO(ExpressionStatement): decl = walkUpBindingElementsAndPatterns(decl); */
		}
		if isParameter(decl) {
			return isContextSensitiveFunctionOrObjectLiteralMethod( /* TODO(PropertyAccessExpression): decl.parent */ TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getTypeOfVariableOrParameterOrProperty := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			type_ := getTypeOfVariableOrParameterOrPropertyWorker(symbol)
			if ! /* TODO(PropertyAccessExpression): links.type */ TODO && !isParameterOfContextSensitiveSignature(symbol) {
				/* TODO(ExpressionStatement): links.type = type; */
			}
			return type_
		}
		return /* TODO(PropertyAccessExpression): links.type */ TODO
	}
	getTypeOfVariableOrParameterOrPropertyWorker := func(symbol Symbol) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Prototype */ TODO {
			return getTypeOfPrototypeProperty(symbol)
		}
		if symbol == requireSymbol {
			return anyType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ModuleExports */ TODO && /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
			fileSymbol := getSymbolOfDeclaration(getSourceFileOfNode( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO))
			result := createSymbol( /* TODO(PropertyAccessExpression): fileSymbol.flags */ TODO, "exports" /* as */ /* TODO(TypeReference): __String */)
			/* TODO(ExpressionStatement): result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : []; */
			/* TODO(ExpressionStatement): result.parent = symbol; */
			/* TODO(ExpressionStatement): result.links.target = fileSymbol; */
			if /* TODO(PropertyAccessExpression): fileSymbol.valueDeclaration */ TODO {
				/* TODO(BinaryExpression): result.valueDeclaration = fileSymbol.valueDeclaration */
			}
			if /* TODO(PropertyAccessExpression): fileSymbol.members */ TODO {
				/* TODO(BinaryExpression): result.members = new Map(fileSymbol.members) */
			}
			if /* TODO(PropertyAccessExpression): fileSymbol.exports */ TODO {
				/* TODO(BinaryExpression): result.exports = new Map(fileSymbol.exports) */
			}
			members := createSymbolTable()
			/* TODO(PropertyAccessExpression): members.set */ TODO("exports" /* as */ /* TODO(TypeReference): __String */, result)
			return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if isSourceFile(declaration) && isJsonSourceFile(declaration) {
			if ! /* TODO(PropertyAccessExpression): declaration.statements.length */ TODO {
				return emptyObjectType
			}
			return getWidenedType(getWidenedLiteralType(checkExpression( /* TODO(PropertyAccessExpression): declaration.statements[0].expression */ TODO)))
		}
		if isAccessor(declaration) {
			return getTypeOfAccessors(symbol)
		}
		if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.Type */, TODO) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Assignment) */ TODO {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		var type_ Type
		if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO {
			/* TODO(ExpressionStatement): type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration as ExportAssignment).expression), declaration); */
		} else if isBinaryExpression(declaration) || /* TODO(ParenthesizedExpression): (isInJSFile(declaration) &&                 (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) */ TODO {
			/* TODO(ExpressionStatement): type = getWidenedTypeForAssignmentDeclaration(symbol); */
		} else if isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || /* TODO(ParenthesizedExpression): (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration)) */ TODO || isMethodSignature(declaration) || isSourceFile(declaration) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule) */ TODO {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			/* TODO(ExpressionStatement): type = isBinaryExpression(declaration.parent) ?                 getWidenedTypeForAssignmentDeclaration(symbol) :                 tryGetTypeFromEffectiveTypeNode(declaration) || anyType; */
		} else if isPropertyAssignment(declaration) {
			/* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration); */
		} else if isJsxAttribute(declaration) {
			/* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration); */
		} else if isShorthandPropertyAssignment(declaration) {
			/* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckMode.Normal); */
		} else if isObjectLiteralMethod(declaration) {
			/* TODO(ExpressionStatement): type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckMode.Normal); */
		} else if isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration) {
			/* TODO(ExpressionStatement): type = getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true); */
		} else if isEnumDeclaration(declaration) {
			/* TODO(ExpressionStatement): type = getTypeOfFuncClassEnumModule(symbol); */
		} else if isEnumMember(declaration) {
			/* TODO(ExpressionStatement): type = getTypeOfEnumMember(symbol); */
		} else {
			return /* TODO(PropertyAccessExpression): Debug.fail */ TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol) */ TODO)
		}
		if !popTypeResolution() {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule */ TODO && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Assignment) */ TODO {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		return type_
	}
	getAnnotatedAccessorTypeNode := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
		if accessor {
			/* TODO(SwitchStatement): switch (accessor.kind) {                 case SyntaxKind.GetAccessor:                     const getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);                     return getterTypeAnnotation;                 case SyntaxKind.SetAccessor:                     const setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(accessor);                     return setterTypeAnnotation;                 case SyntaxKind.PropertyDeclaration:                     Debug.assert(hasAccessorModifier(accessor));                     const accessorTypeAnnotation = getEffectiveTypeAnnotationNode(accessor);                     return accessorTypeAnnotation;             } */
		}
		return nil
	}
	getAnnotatedAccessorType := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *Type {
		node := getAnnotatedAccessorTypeNode(accessor)
		return node && getTypeFromTypeNode(node)
	}
	getAnnotatedAccessorThisParameter := func(accessor AccessorDeclaration) *Symbol {
		parameter := getAccessorThisParameter(accessor)
		return parameter && /* TODO(PropertyAccessExpression): parameter.symbol */ TODO
	}
	getThisTypeOfDeclaration := func(declaration SignatureDeclaration) *Type {
		return getThisTypeOfSignature(getSignatureFromDeclaration(declaration))
	}
	getTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.Type */, TODO) {
				return errorType
			}
			getter := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */, TODO)
			setter := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */, TODO)
			accessor := tryCast(getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */, TODO), isAutoAccessorPropertyDeclaration)
			type_ := getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) || getAnnotatedAccessorType(getter) || getAnnotatedAccessorType(setter) || getAnnotatedAccessorType(accessor) || getter && /* TODO(PropertyAccessExpression): getter.body */ TODO && getReturnTypeFromBody(getter) || accessor && /* TODO(PropertyAccessExpression): accessor.initializer */ TODO && getWidenedTypeForVariableLikeDeclaration(accessor /* TODO(TrueKeyword): true */, TODO)
			if !type_ {
				if setter && !isPrivateWithinAmbient(setter) {
					errorOrSuggestion(noImplicitAny, setter /* TODO(PropertyAccessExpression): Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation */, TODO, symbolToString(symbol))
				} else if getter && !isPrivateWithinAmbient(getter) {
					errorOrSuggestion(noImplicitAny, getter /* TODO(PropertyAccessExpression): Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation */, TODO, symbolToString(symbol))
				} else if accessor && !isPrivateWithinAmbient(accessor) {
					errorOrSuggestion(noImplicitAny, accessor /* TODO(PropertyAccessExpression): Diagnostics.Member_0_implicitly_has_an_1_type */, TODO, symbolToString(symbol), "any")
				}
				/* TODO(ExpressionStatement): type = anyType; */
			}
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(getter) {
					error(getter /* TODO(PropertyAccessExpression): Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation */, TODO, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(setter) {
					error(setter /* TODO(PropertyAccessExpression): Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation */, TODO, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(accessor) {
					error(setter /* TODO(PropertyAccessExpression): Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation */, TODO, symbolToString(symbol))
				} else if getter && noImplicitAny {
					error(getter /* TODO(PropertyAccessExpression): Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions */, TODO, symbolToString(symbol))
				}
				/* TODO(ExpressionStatement): type = anyType; */
			}
			/* TODO(ExpressionStatement): links.type ??= type; */
		}
		return /* TODO(PropertyAccessExpression): links.type */ TODO
	}
	getWriteTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.writeType */ TODO {
			if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.WriteType */, TODO) {
				return errorType
			}
			setter := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor)                 ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
			writeType := getAnnotatedAccessorType(setter)
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(setter) {
					error(setter /* TODO(PropertyAccessExpression): Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation */, TODO, symbolToString(symbol))
				}
				/* TODO(ExpressionStatement): writeType = anyType; */
			}
			/* TODO(ExpressionStatement): links.writeType ??= writeType || getTypeOfAccessors(symbol); */
		}
		return /* TODO(PropertyAccessExpression): links.writeType */ TODO
	}
	getBaseTypeVariableOfClass := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		baseConstructorType := getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol))
		return /* TODO(ConditionalExpression): baseConstructorType.flags & TypeFlags.TypeVariable ? baseConstructorType :             baseConstructorType.flags & TypeFlags.Intersection ? find((baseConstructorType as IntersectionType).types, t => !!(t.flags & TypeFlags.TypeVariable)) :             undefined */ TODO
	}
	getTypeOfFuncClassEnumModule := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			expando := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && getSymbolOfExpando( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(FalseKeyword): false */, TODO)
			if expando {
				merged := mergeJSSymbols(symbol, expando)
				if merged {
					/* TODO(ExpressionStatement): symbol = merged; */
					/* TODO(ExpressionStatement): links = merged.links; */
				}
			}
			/* TODO(ExpressionStatement): originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol); */
		}
		return /* TODO(PropertyAccessExpression): links.type */ TODO
	}
	getTypeOfFuncClassEnumModuleWorker := func(symbol Symbol) Type {
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Module */ TODO && isShorthandAmbientModuleSymbol(symbol) {
			return anyType
		} else if declaration && /* TODO(ParenthesizedExpression): (declaration.kind === SyntaxKind.BinaryExpression ||                 isAccessExpression(declaration) &&                     declaration.parent.kind === SyntaxKind.BinaryExpression) */ TODO {
			return getWidenedTypeForAssignmentDeclaration(symbol)
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule */ TODO && declaration && isSourceFile(declaration) && /* TODO(PropertyAccessExpression): declaration.commonJsModuleIndicator */ TODO {
			resolvedModule := resolveExternalModuleSymbol(symbol)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): resolvedModule !== symbol */ TODO {
				if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.Type */, TODO) {
					return errorType
				}
				exportEquals := getMergedSymbol( /* TODO(NonNullExpression): symbol.exports!.get(InternalSymbolName.ExportEquals)! */ TODO)
				type_ := getWidenedTypeForAssignmentDeclaration(exportEquals /* TODO(ConditionalExpression): exportEquals === resolvedModule ? undefined : resolvedModule */, TODO)
				if !popTypeResolution() {
					return reportCircularityError(symbol)
				}
				return type_
			}
		}
		type_ := createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO, symbol)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
			baseTypeVariable := getBaseTypeVariableOfClass(symbol)
			return /* TODO(ConditionalExpression): baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type */ TODO
		} else {
			return /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type, /*isProperty* / true) : type */ TODO
		}
	}
	getTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return /* TODO(PropertyAccessExpression): links.type */ TODO || /* TODO(ParenthesizedExpression): (links.type = getDeclaredTypeOfEnumMember(symbol)) */ TODO
	}
	getTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.Type */, TODO) {
				return errorType
			}
			targetSymbol := resolveAlias(symbol)
			exportSymbol := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && getTargetOfAliasDeclaration( /* TODO(NonNullExpression): getDeclarationOfAliasSymbol(symbol)! */ TODO /* TODO(TrueKeyword): true */, TODO)
			declaredType := firstDefined( /* TODO(PropertyAccessExpression): exportSymbol?.declarations */ TODO /* TODO(ArrowFunction): d => isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined */, TODO)
			/* TODO(ExpressionStatement): links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol)                 : isDuplicatedCommonJSExport(symbol.declarations) ? autoType                 : declaredType ? declaredType                 : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol)                 : errorType; */
			if !popTypeResolution() {
				reportCircularityError( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): exportSymbol ?? symbol */ TODO)
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): links.type ??= errorType */ TODO
			}
		}
		return /* TODO(PropertyAccessExpression): links.type */ TODO
	}
	getTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return /* TODO(PropertyAccessExpression): links.type */ TODO || /* TODO(ParenthesizedExpression): (links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper)) */ TODO
	}
	getWriteTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return /* TODO(PropertyAccessExpression): links.writeType */ TODO || /* TODO(ParenthesizedExpression): (links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper)) */ TODO
	}
	reportCircularityError := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if declaration {
			if getEffectiveTypeAnnotationNode(declaration) {
				error( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation */, TODO, symbolToString(symbol))
				return errorType
			}
			if noImplicitAny && /* TODO(ParenthesizedExpression): (declaration.kind !== SyntaxKind.Parameter || (declaration as HasInitializer).initializer) */ TODO {
				error( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer */, TODO, symbolToString(symbol))
			}
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
			node := getDeclarationOfAliasSymbol(symbol)
			if node {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Circular_definition_of_import_alias_0 */, TODO, symbolToString(symbol))
			}
		}
		return anyType
	}
	getTypeOfSymbolWithDeferredType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(PropertyAccessExpression): links.deferralParent */ TODO)
			/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(PropertyAccessExpression): links.deferralConstituents */ TODO)
			/* TODO(ExpressionStatement): links.type = links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents); */
		}
		return /* TODO(PropertyAccessExpression): links.type */ TODO
	}
	getWriteTypeOfSymbolWithDeferredType := func(symbol Symbol) *Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.writeType */ TODO && /* TODO(PropertyAccessExpression): links.deferralWriteConstituents */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(PropertyAccessExpression): links.deferralParent */ TODO)
			/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(PropertyAccessExpression): links.deferralConstituents */ TODO)
			/* TODO(ExpressionStatement): links.writeType = links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents); */
		}
		return /* TODO(PropertyAccessExpression): links.writeType */ TODO
	}
	getWriteTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property */ TODO {
			return /* TODO(ConditionalExpression): checkFlags & CheckFlags.SyntheticProperty ?                 checkFlags & CheckFlags.DeferredType ?                     getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :                     // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty                     (symbol as TransientSymbol).links.writeType || (symbol as TransientSymbol).links.type! :                 removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional)) */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Accessor */ TODO {
			return /* TODO(ConditionalExpression): checkFlags & CheckFlags.Instantiated ?                 getWriteTypeOfInstantiatedSymbol(symbol) :                 getWriteTypeOfAccessors(symbol) */ TODO
		}
		return getTypeOfSymbol(symbol)
	}
	getTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkFlags & CheckFlags.DeferredType */ TODO {
			return getTypeOfSymbolWithDeferredType(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkFlags & CheckFlags.Instantiated */ TODO {
			return getTypeOfInstantiatedSymbol(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkFlags & CheckFlags.Mapped */ TODO {
			return getTypeOfMappedSymbol(symbol /* as */ /* TODO(TypeReference): MappedSymbol */)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkFlags & CheckFlags.ReverseMapped */ TODO {
			return getTypeOfReverseMappedSymbol(symbol /* as */ /* TODO(TypeReference): ReverseMappedSymbol */)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property) */ TODO {
			return getTypeOfVariableOrParameterOrProperty(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.Enum | SymbolFlags.ValueModule) */ TODO {
			return getTypeOfFuncClassEnumModule(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.EnumMember */ TODO {
			return getTypeOfEnumMember(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Accessor */ TODO {
			return getTypeOfAccessors(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
			return getTypeOfAlias(symbol)
		}
		return errorType
	}
	getNonMissingTypeOfSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return removeMissingType(getTypeOfSymbol(symbol), !! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Optional) */ TODO)
	}
	isReferenceToSomeType := func(type_ Type, targets []Type) /* TODO(undefined): boolean */ TODO {
		if type_ == nil || /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO == 0 {
			return /* TODO(FalseKeyword): false */ TODO
		}
		for _, target := range targets {
			if /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO == target {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isReferenceToType := func(type_ Type, target Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== undefined */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== undefined */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getObjectFlags(type) & ObjectFlags.Reference) !== 0 */ TODO && /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO == target
	}
	getTargetType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target : type */ TODO
	}
	hasBaseType := func(type_ Type, checkBase *Type) /* TODO(undefined): boolean */ TODO {
		return check(type_)
		check := func(type_ Type) bool {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) */ TODO {
				target := getTargetType(type_) /* as */ /* TODO(TypeReference): InterfaceType */
				return target == checkBase || some(getBaseTypes(target), check)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
				return some( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, check)
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	appendTypeParameters := func(typeParameters /* TODO(ArrayType): TypeParameter[] */ any, declarations []TypeParameterDeclaration) /* TODO(ArrayType): TypeParameter[] */ any {
		for _, declaration := range declarations {
			/* TODO(ExpressionStatement): typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration))); */
		}
		return typeParameters
	}
	getOuterTypeParameters := func(node Node, includeThisTypes bool) /* TODO(ArrayType): TypeParameter[] */ any {
		/* TODO(WhileStatement): while (true) {             node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead             if (node && isBinaryExpression(node)) {                 // prototype assignments get the outer type parameters of their constructor function                 const assignmentKind = getAssignmentDeclarationKind(node);                 if (assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty) {                     const symbol = getSymbolOfDeclaration(node.left as BindableStaticNameExpression | PropertyAssignment);                     if (symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d)) {                         node = symbol.parent.valueDeclaration!;                     }                 }             }             if (!node) {                 return undefined;             }             const kind = node.kind;             switch (kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.CallSignature:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.MethodSignature:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.JSDocFunctionType:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.JSDocTemplateTag:                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocEnumTag:                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.MappedType:                 case SyntaxKind.ConditionalType: {                     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);                     if ((kind === SyntaxKind.FunctionExpression || kind === SyntaxKind.ArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node as Expression | MethodDeclaration)) {                         const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node as FunctionLikeDeclaration)), SignatureKind.Call));                         if (signature && signature.typeParameters) {                             return [...(outerTypeParameters || emptyArray), ...signature.typeParameters];                         }                     }                     if (kind === SyntaxKind.MappedType) {                         return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node as MappedTypeNode).typeParameter)));                     }                     else if (kind === SyntaxKind.ConditionalType) {                         return concatenate(outerTypeParameters, getInferTypeParameters(node as ConditionalTypeNode));                     }                     const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node as DeclarationWithTypeParameters));                     const thisType = includeThisTypes &&                         (kind === SyntaxKind.ClassDeclaration || kind === SyntaxKind.ClassExpression || kind === SyntaxKind.InterfaceDeclaration || isJSConstructor(node)) &&                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node as ClassLikeDeclaration | InterfaceDeclaration)).thisType;                     return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;                 }                 case SyntaxKind.JSDocParameterTag:                     const paramSymbol = getParameterSymbolFromJSDoc(node as JSDocParameterTag);                     if (paramSymbol) {                         node = paramSymbol.valueDeclaration!;                     }                     break;                 case SyntaxKind.JSDoc: {                     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);                     return (node as JSDoc).tags                         ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))                         : outerTypeParameters;                 }             }         } */
	}
	getOuterTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		declaration := /* TODO(ConditionalExpression): (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function)             ? symbol.valueDeclaration             : symbol.declarations?.find(decl => {                 if (decl.kind === SyntaxKind.InterfaceDeclaration) {                     return true;                 }                 if (decl.kind !== SyntaxKind.VariableDeclaration) {                     return false;                 }                 const initializer = (decl as VariableDeclaration).initializer;                 return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.ArrowFunction);             })! */ TODO
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations")
		return getOuterTypeParameters(declaration)
	}
	getLocalTypeParametersOfClassOrInterfaceOrTypeAlias := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		if ! /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			return
		}
		var result /* TODO(ArrayType): TypeParameter[] */ any
		for _, node := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ClassExpression */ TODO || isJSConstructor(node) || isTypeAlias(node) {
				declaration := node /* as */ /* TODO(UnionType): InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag */
				/* TODO(ExpressionStatement): result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration)); */
			}
		}
		return result
	}
	getTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
	}
	isMixinConstructorType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		signatures := getSignaturesOfType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		if /* TODO(PropertyAccessExpression): signatures.length */ TODO == 1 {
			s := /* TODO(ElementAccessExpression): signatures[0] */ TODO
			if ! /* TODO(PropertyAccessExpression): s.typeParameters */ TODO && /* TODO(PropertyAccessExpression): s.parameters.length */ TODO == 1 && signatureHasRestParameter(s) {
				paramType := getTypeOfParameter( /* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
				return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) == anyType
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isConstructorType := func(type_ Type) bool {
		if /* TODO(PropertyAccessExpression): getSignaturesOfType(type, SignatureKind.Construct).length */ TODO > 0 {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeVariable */ TODO {
			constraint := getBaseConstraintOfType(type_)
			return !!constraint && isMixinConstructorType(constraint)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getBaseTypeNodeOfClass := func(type_ InterfaceType) *ExpressionWithTypeArguments {
		decl := getClassLikeDeclarationOfSymbol( /* TODO(PropertyAccessExpression): type.symbol */ TODO)
		return decl && getEffectiveBaseTypeNode(decl)
	}
	getConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
		typeArgCount := length(typeArgumentNodes)
		isJavascript := isInJSFile(location)
		return filter(getSignaturesOfType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO) /* TODO(ArrowFunction): sig => (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters) */, TODO)
	}
	getInstantiatedConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
		signatures := getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
		typeArguments := map_(typeArgumentNodes, getTypeFromTypeNode)
		return sameMap(signatures /* TODO(ArrowFunction): sig => some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig */, TODO)
	}
	getBaseConstructorTypeOfClass := func(type_ InterfaceType) Type {
		if ! /* TODO(PropertyAccessExpression): type.resolvedBaseConstructorType */ TODO {
			decl := getClassLikeDeclarationOfSymbol( /* TODO(PropertyAccessExpression): type.symbol */ TODO)
			extended := decl && getEffectiveBaseTypeNode(decl)
			baseTypeNode := getBaseTypeNodeOfClass(type_)
			if !baseTypeNode {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType = undefinedType */ TODO
			}
			if !pushTypeResolution(type_ /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ResolvedBaseConstructorType */, TODO) {
				return errorType
			}
			baseConstructorType := checkExpression( /* TODO(PropertyAccessExpression): baseTypeNode.expression */ TODO)
			if extended && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseTypeNode !== extended */ TODO {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(! /* TODO(PropertyAccessExpression): extended.typeArguments */ TODO)
				checkExpression( /* TODO(PropertyAccessExpression): extended.expression */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO {
				resolveStructuredTypeMembers(baseConstructorType /* as */ /* TODO(TypeReference): ObjectType */)
			}
			if !popTypeResolution() {
				error( /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression */, TODO, symbolToString( /* TODO(PropertyAccessExpression): type.symbol */ TODO))
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			if ! /* TODO(ParenthesizedExpression): (baseConstructorType.flags & TypeFlags.Any) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseConstructorType !== nullWideningType */ TODO && !isConstructorType(baseConstructorType) {
				err := error( /* TODO(PropertyAccessExpression): baseTypeNode.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_constructor_function_type */, TODO, typeToString(baseConstructorType))
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): baseConstructorType.flags & TypeFlags.TypeParameter */ TODO {
					constraint := getConstraintFromTypeParameter(baseConstructorType)
					var ctorReturn Type = unknownType
					if constraint {
						ctorSig := getSignaturesOfType(constraint /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
						if /* TODO(ElementAccessExpression): ctorSig[0] */ TODO {
							/* TODO(ExpressionStatement): ctorReturn = getReturnTypeOfSignature(ctorSig[0]); */
						}
					}
					if /* TODO(PropertyAccessExpression): baseConstructorType.symbol.declarations */ TODO {
						addRelatedInfo(err, createDiagnosticForNode( /* TODO(ElementAccessExpression): baseConstructorType.symbol.declarations[0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1 */, TODO, symbolToString( /* TODO(PropertyAccessExpression): baseConstructorType.symbol */ TODO), typeToString(ctorReturn)))
					}
				}
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			/* TODO(ExpressionStatement): type.resolvedBaseConstructorType ??= baseConstructorType; */
		}
		return /* TODO(PropertyAccessExpression): type.resolvedBaseConstructorType */ TODO
	}
	getImplementsTypes := func(type_ InterfaceType) []BaseType {
		var resolvedImplementsTypes []BaseType = emptyArray
		if /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
			for _, declaration := range /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
				implementsTypeNodes := getEffectiveImplementsTypeNodes(declaration /* as */ /* TODO(TypeReference): ClassLikeDeclaration */)
				if !implementsTypeNodes {
				}
				for _, node := range implementsTypeNodes {
					implementsType := getTypeFromTypeNode(node)
					if !isErrorType(implementsType) {
						if resolvedImplementsTypes == emptyArray {
							/* TODO(ExpressionStatement): resolvedImplementsTypes = [implementsType as ObjectType]; */
						} else {
							/* TODO(PropertyAccessExpression): resolvedImplementsTypes.push */ TODO(implementsType)
						}
					}
				}
			}
		}
		return resolvedImplementsTypes
	}
	reportCircularBaseType := func(node Node, type_ Type) {
		error(node /* TODO(PropertyAccessExpression): Diagnostics.Type_0_recursively_references_itself_as_a_base_type */, TODO, typeToString(type_, nil /* TODO(PropertyAccessExpression): TypeFormatFlags.WriteArrayAsGenericType */, TODO))
	}
	getBaseTypes := func(type_ InterfaceType) []BaseType {
		if ! /* TODO(PropertyAccessExpression): type.baseTypesResolved */ TODO {
			if pushTypeResolution(type_ /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ResolvedBaseTypes */, TODO) {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.Tuple */ TODO {
					/* TODO(ExpressionStatement): type.resolvedBaseTypes = [getTupleBaseType(type as TupleType)]; */
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) */ TODO {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.Class */ TODO {
						resolveBaseTypesOfClass(type_)
					}
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol.flags & SymbolFlags.Interface */ TODO {
						resolveBaseTypesOfInterface(type_)
					}
				} else {
					/* TODO(PropertyAccessExpression): Debug.fail */ TODO("type must be class or interface")
				}
				if !popTypeResolution() && /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
					for _, declaration := range /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
						if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */ TODO || /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO {
							reportCircularBaseType(declaration, type_)
						}
					}
				}
			}
			/* TODO(ExpressionStatement): type.baseTypesResolved = true; */
		}
		return /* TODO(PropertyAccessExpression): type.resolvedBaseTypes */ TODO
	}
	getTupleBaseType := func(type_ TupleType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		elementTypes := sameMap( /* TODO(PropertyAccessExpression): type.typeParameters */ TODO /* TODO(ArrowFunction): (t, i) => type.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */, TODO)
		return createArrayType(getUnionType(elementTypes || emptyArray) /* TODO(PropertyAccessExpression): type.readonly */, TODO)
	}
	resolveBaseTypesOfClass := func(type_ InterfaceType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BaseType[] */ TODO {
		/* TODO(ExpressionStatement): type.resolvedBaseTypes = resolvingEmptyArray; */
		baseConstructorType := getApparentType(getBaseConstructorTypeOfClass(type_))
		if ! /* TODO(ParenthesizedExpression): (baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Any)) */ TODO {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		baseTypeNode := /* TODO(NonNullExpression): getBaseTypeNodeOfClass(type)! */ TODO
		var baseType Type
		originalBaseType := /* TODO(ConditionalExpression): baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined */ TODO
		if /* TODO(PropertyAccessExpression): baseConstructorType.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): baseConstructorType.symbol.flags & SymbolFlags.Class */ TODO && areAllOuterTypeParametersApplied( /* TODO(NonNullExpression): originalBaseType! */ TODO) {
			/* TODO(ExpressionStatement): baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol); */
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): baseConstructorType.flags & TypeFlags.Any */ TODO {
			/* TODO(ExpressionStatement): baseType = baseConstructorType; */
		} else {
			constructors := getInstantiatedConstructorsForTypeArguments(baseConstructorType /* TODO(PropertyAccessExpression): baseTypeNode.typeArguments */, TODO, baseTypeNode)
			if ! /* TODO(PropertyAccessExpression): constructors.length */ TODO {
				error( /* TODO(PropertyAccessExpression): baseTypeNode.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments */, TODO)
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
			}
			/* TODO(ExpressionStatement): baseType = getReturnTypeOfSignature(constructors[0]); */
		}
		if isErrorType(baseType) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		reducedBaseType := getReducedType(baseType)
		if !isValidBaseType(reducedBaseType) {
			elaboration := elaborateNeverIntersection(nil, baseType)
			diagnostic := chainDiagnosticMessages(elaboration /* TODO(PropertyAccessExpression): Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members */, TODO, typeToString(reducedBaseType))
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode( /* TODO(PropertyAccessExpression): baseTypeNode.expression */ TODO) /* TODO(PropertyAccessExpression): baseTypeNode.expression */, TODO, diagnostic))
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		if type_ == reducedBaseType || hasBaseType(reducedBaseType, type_) {
			error( /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_0_recursively_references_itself_as_a_base_type */, TODO, typeToString(type_, nil /* TODO(PropertyAccessExpression): TypeFormatFlags.WriteArrayAsGenericType */, TODO))
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		if /* TODO(PropertyAccessExpression): type.resolvedBaseTypes */ TODO == resolvingEmptyArray {
			/* TODO(ExpressionStatement): type.members = undefined; */
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = [reducedBaseType] */ TODO
	}
	areAllOuterTypeParametersApplied := func(type_ Type) bool {
		outerTypeParameters := /* TODO(PropertyAccessExpression): (type as InterfaceType).outerTypeParameters */ TODO
		if outerTypeParameters {
			last := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): outerTypeParameters.length - 1 */ TODO
			typeArguments := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
			return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): outerTypeParameters[last].symbol !== typeArguments[last].symbol */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	isValidBaseType := func(type_ Type) /* TODO(TypePredicate): type is BaseType */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
			constraint := getBaseConstraintOfType(type_)
			if constraint {
				return isValidBaseType(constraint)
			}
		}
		return !! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.Any) && !isGenericMappedType(type) ||             type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isValidBaseType)) */ TODO
	}
	resolveBaseTypesOfInterface := func(type_ InterfaceType) {
		/* TODO(ExpressionStatement): type.resolvedBaseTypes = type.resolvedBaseTypes || emptyArray; */
		if /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
			for _, declaration := range /* TODO(PropertyAccessExpression): type.symbol.declarations */ TODO {
				if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO && getInterfaceBaseTypeNodes(declaration /* as */ /* TODO(TypeReference): InterfaceDeclaration */) {
					for _, node := range /* TODO(NonNullExpression): getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration)! */ TODO {
						baseType := getReducedType(getTypeFromTypeNode(node))
						if !isErrorType(baseType) {
							if isValidBaseType(baseType) {
								if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== baseType */ TODO && !hasBaseType(baseType, type_) {
									if /* TODO(PropertyAccessExpression): type.resolvedBaseTypes */ TODO == emptyArray {
										/* TODO(ExpressionStatement): type.resolvedBaseTypes = [baseType as ObjectType]; */
									} else {
										/* TODO(PropertyAccessExpression): type.resolvedBaseTypes.push */ TODO(baseType)
									}
								} else {
									reportCircularBaseType(declaration, type_)
								}
							} else {
								error(node /* TODO(PropertyAccessExpression): Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members */, TODO)
							}
						}
					}
				}
			}
		}
	}
	isThislessInterface := func(symbol Symbol) bool {
		if ! /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		for _, declaration := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declaration.flags & NodeFlags.ContainsThis */ TODO {
					return /* TODO(FalseKeyword): false */ TODO
				}
				baseTypeNodes := getInterfaceBaseTypeNodes(declaration /* as */ /* TODO(TypeReference): InterfaceDeclaration */)
				if baseTypeNodes {
					for _, node := range baseTypeNodes {
						if isEntityNameExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
							baseSymbol := resolveEntityName( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(TrueKeyword): true */, TODO)
							if !baseSymbol || ! /* TODO(ParenthesizedExpression): (baseSymbol.flags & SymbolFlags.Interface) */ TODO || /* TODO(PropertyAccessExpression): getDeclaredTypeOfClassOrInterface(baseSymbol).thisType */ TODO {
								return /* TODO(FalseKeyword): false */ TODO
							}
						}
					}
				}
			}
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getDeclaredTypeOfClassOrInterface := func(symbol Symbol) InterfaceType {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if ! /* TODO(PropertyAccessExpression): links.declaredType */ TODO {
			kind := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface */ TODO
			merged := mergeJSSymbols(symbol /* TODO(PropertyAccessExpression): symbol.valueDeclaration */, TODO && getAssignedClassSymbol( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO))
			if merged {
				/* TODO(ExpressionStatement): symbol = merged; */
				/* TODO(ExpressionStatement): links = merged.links; */
			}
			type_ := /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
			outerTypeParameters := getOuterTypeParametersOfClassOrInterface(symbol)
			localTypeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			if outerTypeParameters || localTypeParameters || kind == /* TODO(PropertyAccessExpression): ObjectFlags.Class */ TODO || !isThislessInterface(symbol) {
				/* TODO(ExpressionStatement): type.objectFlags |= ObjectFlags.Reference; */
				/* TODO(ExpressionStatement): type.typeParameters = concatenate(outerTypeParameters, localTypeParameters); */
				/* TODO(ExpressionStatement): type.outerTypeParameters = outerTypeParameters; */
				/* TODO(ExpressionStatement): type.localTypeParameters = localTypeParameters; */
				/* TODO(ExpressionStatement): (type as GenericType).instantiations = new Map<string, TypeReference>(); */
				/* TODO(PropertyAccessExpression): (type as GenericType).instantiations.set */
				TODO(getTypeListId( /* TODO(PropertyAccessExpression): type.typeParameters */ TODO), type_ /* as */ /* TODO(TypeReference): GenericType */)
				/* TODO(ExpressionStatement): (type as GenericType).target = type as GenericType; */
				/* TODO(ExpressionStatement): (type as GenericType).resolvedTypeArguments = type.typeParameters; */
				/* TODO(ExpressionStatement): type.thisType = createTypeParameter(symbol); */
				/* TODO(ExpressionStatement): type.thisType.isThisType = true; */
				/* TODO(ExpressionStatement): type.thisType.constraint = type; */
			}
		}
		return /* TODO(PropertyAccessExpression): links.declaredType */ TODO /* as */ /* TODO(TypeReference): InterfaceType */
	}
	getDeclaredTypeOfTypeAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.declaredType */ TODO {
			if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.DeclaredType */, TODO) {
				return errorType
			}
			declaration := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO( /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isTypeAlias), "Type alias symbol with no valid declaration found")
			typeNode := /* TODO(ConditionalExpression): isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type */ TODO
			type_ := /* TODO(ConditionalExpression): typeNode ? getTypeFromTypeNode(typeNode) : errorType */ TODO
			if popTypeResolution() {
				typeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				if typeParameters {
					/* TODO(ExpressionStatement): links.typeParameters = typeParameters; */
					/* TODO(ExpressionStatement): links.instantiations = new Map<string, Type>(); */
					/* TODO(PropertyAccessExpression): links.instantiations.set */
					TODO(getTypeListId(typeParameters), type_)
				}
				if type_ == intrinsicMarkerType && /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO == "BuiltinIteratorReturn" {
					/* TODO(ExpressionStatement): type = getBuiltinIteratorReturnType(); */
				}
			} else {
				/* TODO(ExpressionStatement): type = errorType; */
				if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocEnumTag */ TODO {
					error( /* TODO(PropertyAccessExpression): declaration.typeExpression.type */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_alias_0_circularly_references_itself */, TODO, symbolToString(symbol))
				} else {
					error( /* TODO(ConditionalExpression): isNamedDeclaration(declaration) ? declaration.name || declaration : declaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_alias_0_circularly_references_itself */, TODO, symbolToString(symbol))
				}
			}
			/* TODO(ExpressionStatement): links.declaredType ??= type; */
		}
		return /* TODO(PropertyAccessExpression): links.declaredType */ TODO
	}
	getBaseTypeOfEnumLikeType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && type.symbol.flags & SymbolFlags.EnumMember ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)!) : type */ TODO
	}
	getDeclaredTypeOfEnum := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.declaredType */ TODO {
			var memberTypeList []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
				for _, declaration := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
					if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EnumDeclaration */ TODO {
						for _, member := range /* TODO(PropertyAccessExpression): (declaration as EnumDeclaration).members */ TODO {
							if hasBindableName(member) {
								memberSymbol := getSymbolOfDeclaration(member)
								value := /* TODO(PropertyAccessExpression): getEnumMemberValue(member).value */ TODO
								memberType := getFreshTypeOfLiteralType( /* TODO(ConditionalExpression): value !== undefined ?                                         getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) :                                         createComputedEnumType(memberSymbol) */ TODO)
								/* TODO(ExpressionStatement): getSymbolLinks(memberSymbol).declaredType = memberType; */
								/* TODO(PropertyAccessExpression): memberTypeList.push */
								TODO(getRegularTypeOfLiteralType(memberType))
							}
						}
					}
				}
			}
			enumType := /* TODO(ConditionalExpression): memberTypeList.length ?                 getUnionType(memberTypeList, UnionReduction.Literal, symbol, /*aliasTypeArguments* / undefined) :                 createComputedEnumType(symbol) */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): enumType.flags & TypeFlags.Union */ TODO {
				/* TODO(ExpressionStatement): enumType.flags |= TypeFlags.EnumLiteral; */
				/* TODO(ExpressionStatement): enumType.symbol = symbol; */
			}
			/* TODO(ExpressionStatement): links.declaredType = enumType; */
		}
		return /* TODO(PropertyAccessExpression): links.declaredType */ TODO
	}
	createComputedEnumType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EnumType */ TODO {
		regularType := createTypeWithSymbol( /* TODO(PropertyAccessExpression): TypeFlags.Enum */ TODO, symbol) /* as */ /* TODO(TypeReference): EnumType */
		freshType := createTypeWithSymbol( /* TODO(PropertyAccessExpression): TypeFlags.Enum */ TODO, symbol)   /* as */ /* TODO(TypeReference): EnumType */
		/* TODO(ExpressionStatement): regularType.regularType = regularType; */
		/* TODO(ExpressionStatement): regularType.freshType = freshType; */
		/* TODO(ExpressionStatement): freshType.regularType = regularType; */
		/* TODO(ExpressionStatement): freshType.freshType = freshType; */
		return regularType
	}
	getDeclaredTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.declaredType */ TODO {
			enumType := getDeclaredTypeOfEnum( /* TODO(NonNullExpression): getParentOfSymbol(symbol)! */ TODO)
			if ! /* TODO(PropertyAccessExpression): links.declaredType */ TODO {
				/* TODO(ExpressionStatement): links.declaredType = enumType; */
			}
		}
		return /* TODO(PropertyAccessExpression): links.declaredType */ TODO
	}
	getDeclaredTypeOfTypeParameter := func(symbol Symbol) TypeParameter {
		links := getSymbolLinks(symbol)
		return /* TODO(PropertyAccessExpression): links.declaredType */ TODO || /* TODO(ParenthesizedExpression): (links.declaredType = createTypeParameter(symbol)) */ TODO
	}
	getDeclaredTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return /* TODO(PropertyAccessExpression): links.declaredType */ TODO || /* TODO(ParenthesizedExpression): (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol))) */ TODO
	}
	getDeclaredTypeOfSymbol := func(symbol Symbol) Type {
		return tryGetDeclaredTypeOfSymbol(symbol) || errorType
	}
	tryGetDeclaredTypeOfSymbol := func(symbol Symbol) *Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) */ TODO {
			return getDeclaredTypeOfClassOrInterface(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO {
			return getDeclaredTypeOfTypeAlias(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeParameter */ TODO {
			return getDeclaredTypeOfTypeParameter(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Enum */ TODO {
			return getDeclaredTypeOfEnum(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.EnumMember */ TODO {
			return getDeclaredTypeOfEnumMember(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
			return getDeclaredTypeOfAlias(symbol)
		}
		return nil
	}
	isThislessType := func(node TypeNode) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AnyKeyword:             case SyntaxKind.UnknownKeyword:             case SyntaxKind.StringKeyword:             case SyntaxKind.NumberKeyword:             case SyntaxKind.BigIntKeyword:             case SyntaxKind.BooleanKeyword:             case SyntaxKind.SymbolKeyword:             case SyntaxKind.ObjectKeyword:             case SyntaxKind.VoidKeyword:             case SyntaxKind.UndefinedKeyword:             case SyntaxKind.NeverKeyword:             case SyntaxKind.LiteralType:                 return true;             case SyntaxKind.ArrayType:                 return isThislessType((node as ArrayTypeNode).elementType);             case SyntaxKind.TypeReference:                 return !(node as TypeReferenceNode).typeArguments || (node as TypeReferenceNode).typeArguments!.every(isThislessType);         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	isThislessTypeParameter := func(node TypeParameterDeclaration) /* TODO(undefined): boolean */ TODO {
		constraint := getEffectiveConstraintOfTypeParameter(node)
		return !constraint || isThislessType(constraint)
	}
	isThislessVariableLikeDeclaration := func(node VariableLikeDeclaration) bool {
		typeNode := getEffectiveTypeAnnotationNode(node)
		return /* TODO(ConditionalExpression): typeNode ? isThislessType(typeNode) : !hasInitializer(node) */ TODO
	}
	isThislessFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		returnType := getEffectiveReturnTypeNode(node)
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		return /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.Constructor || (!!returnType && isThislessType(returnType))) */ TODO && /* TODO(PropertyAccessExpression): node.parameters.every */ TODO(isThislessVariableLikeDeclaration) && /* TODO(PropertyAccessExpression): typeParameters.every */ TODO(isThislessTypeParameter)
	}
	isThisless := func(symbol Symbol) bool {
		if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.length */ TODO == 1 {
			declaration := /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO
			if declaration {
				/* TODO(SwitchStatement): switch (declaration.kind) {                     case SyntaxKind.PropertyDeclaration:                     case SyntaxKind.PropertySignature:                         return isThislessVariableLikeDeclaration(declaration as VariableLikeDeclaration);                     case SyntaxKind.MethodDeclaration:                     case SyntaxKind.MethodSignature:                     case SyntaxKind.Constructor:                     case SyntaxKind.GetAccessor:                     case SyntaxKind.SetAccessor:                         return isThislessFunctionLikeDeclaration(declaration as FunctionLikeDeclaration | AccessorDeclaration);                 } */
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	createInstantiatedSymbolTable := func(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
		result := createSymbolTable()
		for _, symbol := range symbols {
			/* TODO(PropertyAccessExpression): result.set */ TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* TODO(ConditionalExpression): mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper) */, TODO)
		}
		return result
	}
	addInheritedMembers := func(symbols SymbolTable, baseSymbols []Symbol) {
		for _, base := range baseSymbols {
			if isStaticPrivateIdentifierProperty(base) {
				/* TODO(ContinueStatement): continue; */
			}
			derived := /* TODO(PropertyAccessExpression): symbols.get */ TODO( /* TODO(PropertyAccessExpression): base.escapedName */ TODO)
			if !derived || /* TODO(PropertyAccessExpression): derived.valueDeclaration */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): derived.valueDeclaration */ TODO) && !isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock( /* TODO(PropertyAccessExpression): derived.valueDeclaration */ TODO) {
				/* TODO(PropertyAccessExpression): symbols.set */ TODO( /* TODO(PropertyAccessExpression): base.escapedName */ TODO, base)
				/* TODO(PropertyAccessExpression): symbols.set */ TODO( /* TODO(PropertyAccessExpression): base.escapedName */ TODO, base)
			}
		}
	}
	isStaticPrivateIdentifierProperty := func(s Symbol) bool {
		return !! /* TODO(PropertyAccessExpression): s.valueDeclaration */ TODO && isPrivateIdentifierClassElementDeclaration( /* TODO(PropertyAccessExpression): s.valueDeclaration */ TODO) && isStatic( /* TODO(PropertyAccessExpression): s.valueDeclaration */ TODO)
	}
	resolveDeclaredMembers := func(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
		if ! /* TODO(PropertyAccessExpression): (type as InterfaceTypeWithDeclaredMembers).declaredProperties */ TODO {
			symbol := /* TODO(PropertyAccessExpression): type.symbol */ TODO
			members := getMembersOfSymbol(symbol)
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredProperties = getNamedMembers(members); */
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = emptyArray; */
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = emptyArray; */
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = emptyArray; */
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.Call)); */
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolName.New)); */
			/* TODO(ExpressionStatement): (type as InterfaceTypeWithDeclaredMembers).declaredIndexInfos = getIndexInfosOfSymbol(symbol); */
		}
		return type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */
	}
	isLateBindableName := func(node DeclarationName) /* TODO(TypePredicate): node is LateBoundName */ TODO {
		if !isComputedPropertyName(node) && !isElementAccessExpression(node) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		expr := /* TODO(ConditionalExpression): isComputedPropertyName(node) ? node.expression : node.argumentExpression */ TODO
		return isEntityNameExpression(expr) && isTypeUsableAsPropertyName( /* TODO(ConditionalExpression): isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr) */ TODO)
	}
	isLateBoundName := func(name __String) bool {
		return /* TODO(PropertyAccessExpression): (name as string).charCodeAt */ TODO(0) == /* TODO(PropertyAccessExpression): CharacterCodes._ */ TODO && /* TODO(PropertyAccessExpression): (name as string).charCodeAt */ TODO(1) == /* TODO(PropertyAccessExpression): CharacterCodes._ */ TODO && /* TODO(PropertyAccessExpression): (name as string).charCodeAt */ TODO(2) == /* TODO(PropertyAccessExpression): CharacterCodes.at */ TODO
	}
	hasLateBindableName := func(node Declaration) /* TODO(TypePredicate): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ TODO {
		name := getNameOfDeclaration(node)
		return !!name && isLateBindableName(name)
	}
	hasBindableName := func(node Declaration) /* TODO(undefined): boolean */ TODO {
		return !hasDynamicName(node) || hasLateBindableName(node)
	}
	isNonBindableDynamicName := func(node DeclarationName) /* TODO(undefined): boolean */ TODO {
		return isDynamicName(node) && !isLateBindableName(node)
	}
	addDeclarationToLateBoundSymbol := func(symbol Symbol, member /* TODO(UnionType): LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (getCheckFlags(symbol) & CheckFlags.Late) */ TODO, "Expected a late-bound symbol.")
		/* TODO(ExpressionStatement): symbol.flags |= symbolFlags; */
		/* TODO(ExpressionStatement): getSymbolLinks(member.symbol).lateSymbol = symbol; */
		if ! /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			/* TODO(ExpressionStatement): symbol.declarations = [member]; */
		} else if ! /* TODO(PropertyAccessExpression): member.symbol.isReplaceableByMethod */ TODO {
			/* TODO(PropertyAccessExpression): symbol.declarations.push */ TODO(member)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbolFlags & SymbolFlags.Value */ TODO {
			if ! /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.valueDeclaration.kind !== member.kind */ TODO {
				/* TODO(ExpressionStatement): symbol.valueDeclaration = member; */
			}
		}
	}
	lateBindMember := func(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(UnionType): LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(PropertyAccessExpression): decl.symbol */ TODO, "The member is expected to have a symbol.")
		links := getNodeLinks(decl)
		if ! /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO {
			/* TODO(ExpressionStatement): links.resolvedSymbol = decl.symbol; */
			declName := /* TODO(ConditionalExpression): isBinaryExpression(decl) ? decl.left : decl.name */ TODO
			type_ := /* TODO(ConditionalExpression): isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName) */ TODO
			if isTypeUsableAsPropertyName(type_) {
				memberName := getPropertyNameFromType(type_)
				symbolFlags := /* TODO(PropertyAccessExpression): decl.symbol.flags */ TODO
				lateSymbol := /* TODO(PropertyAccessExpression): lateSymbols.get */ TODO(memberName)
				if !lateSymbol {
					/* TODO(CallExpression): lateSymbols.set(memberName, lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late)) */
				}
				earlySymbol := earlySymbols && /* TODO(PropertyAccessExpression): earlySymbols.get */ TODO(memberName)
				if ! /* TODO(ParenthesizedExpression): (parent.flags & SymbolFlags.Class) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) */ TODO {
					declarations := /* TODO(ConditionalExpression): earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations */ TODO
					name := ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.UniqueESSymbol) */ TODO && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName)
					forEach(declarations /* TODO(ArrowFunction): declaration => error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name) */, TODO)
					error(declName || decl /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_property_0 */, TODO, name)
					/* TODO(ExpressionStatement): lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late); */
				}
				/* TODO(ExpressionStatement): lateSymbol.links.nameType = type; */
				addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags)
				if /* TODO(PropertyAccessExpression): lateSymbol.parent */ TODO {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): lateSymbol.parent */ TODO == parent, "Existing symbol parent should match new one")
				} else {
					/* TODO(ExpressionStatement): lateSymbol.parent = parent; */
				}
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = lateSymbol */ TODO
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
	}
	getResolvedMembersOrExportsOfSymbol := func(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
		links := getSymbolLinks(symbol)
		if ! /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO {
			isStatic := resolutionKind == /* TODO(PropertyAccessExpression): MembersOrExportsResolutionKind.resolvedExports */ TODO
			earlySymbols := /* TODO(ConditionalExpression): !isStatic ? symbol.members :                 symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(symbol).exports :                 symbol.exports */ TODO
			/* TODO(ExpressionStatement): links[resolutionKind] = earlySymbols || emptySymbols; */
			lateSymbols := createSymbolTable() /* as */ /* TODO(TypeReference): Map<__String, TransientSymbol> */
			for _, decl := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO || emptyArray {
				members := getMembersOfDeclaration(decl)
				if members {
					for _, member := range members {
						if isStatic == hasStaticModifier(member) {
							if hasLateBindableName(member) {
								lateBindMember(symbol, earlySymbols, lateSymbols, member)
							}
						}
					}
				}
			}
			assignments := /* TODO(PropertyAccessExpression): getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers */ TODO
			if assignments {
				decls := arrayFrom( /* TODO(PropertyAccessExpression): assignments.values */ TODO())
				for _, member := range decls {
					assignmentKind := getAssignmentDeclarationKind(member /* as */ /* TODO(UnionType): BinaryExpression | CallExpression */)
					isInstanceMember := assignmentKind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.PrototypeProperty */ TODO || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ObjectDefinePrototypeProperty */ TODO || assignmentKind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.Prototype */ TODO
					if isStatic == !isInstanceMember {
						if hasLateBindableName(member) {
							lateBindMember(symbol, earlySymbols, lateSymbols, member)
						}
					}
				}
			}
			resolved := combineSymbolTables(earlySymbols, lateSymbols)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Transient */ TODO && /* TODO(PropertyAccessExpression): links.cjsExportMerged */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
				for _, decl := range /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
					original := /* TODO(ElementAccessExpression): getSymbolLinks(decl.symbol)[resolutionKind] */ TODO
					if !resolved {
						/* TODO(ExpressionStatement): resolved = original; */
						/* TODO(ContinueStatement): continue; */
					}
					if !original {
					}
					/* TODO(PropertyAccessExpression): original.forEach */ TODO( /* TODO(ArrowFunction): (s, name) => {                         const existing = resolved!.get(name);                         if (!existing) resolved!.set(name, s);                         else if (existing === s) return;                         else resolved!.set(name, mergeSymbol(existing, s));                     } */ TODO)
				}
			}
			/* TODO(ExpressionStatement): links[resolutionKind] = resolved || emptySymbols; */
		}
		return /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO
	}
	getMembersOfSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
		return /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer             ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedMembers)             : symbol.members || emptySymbols */ TODO
	}
	getLateBoundSymbol := func(symbol Symbol) Symbol {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ClassMember */ TODO && /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO == /* TODO(PropertyAccessExpression): InternalSymbolName.Computed */ TODO {
			links := getSymbolLinks(symbol)
			if ! /* TODO(PropertyAccessExpression): links.lateSymbol */ TODO && some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, hasLateBindableName) {
				parent := /* TODO(NonNullExpression): getMergedSymbol(symbol.parent)! */ TODO
				if some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, hasStaticModifier) {
					getExportsOfSymbol(parent)
				} else {
					getMembersOfSymbol(parent)
				}
			}
			return /* TODO(PropertyAccessExpression): links.lateSymbol */ TODO || /* TODO(ParenthesizedExpression): (links.lateSymbol = symbol) */ TODO
		}
		return symbol
	}
	getTypeWithThisArgument := func(type_ Type, thisArgument Type, needApparentType bool) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Reference */ TODO {
			target := /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO
			typeArguments := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
			return /* TODO(ConditionalExpression): length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!])) : type */ TODO
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			types := sameMap( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => getTypeWithThisArgument(t, thisArgument, needApparentType) */, TODO)
			return /* TODO(ConditionalExpression): types !== (type as IntersectionType).types ? getIntersectionType(types) : type */ TODO
		}
		return /* TODO(ConditionalExpression): needApparentType ? getApparentType(type) : type */ TODO
	}
	resolveObjectTypeMembers := func(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
		var mapper *TypeMapper
		var members SymbolTable
		var callSignatures []Signature
		var constructSignatures []Signature
		var indexInfos []IndexInfo
		if rangeEquals(typeParameters, typeArguments, 0 /* TODO(PropertyAccessExpression): typeParameters.length */, TODO) {
			/* TODO(ExpressionStatement): members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties); */
			/* TODO(ExpressionStatement): callSignatures = source.declaredCallSignatures; */
			/* TODO(ExpressionStatement): constructSignatures = source.declaredConstructSignatures; */
			/* TODO(ExpressionStatement): indexInfos = source.declaredIndexInfos; */
		} else {
			/* TODO(ExpressionStatement): mapper = createTypeMapper(typeParameters, typeArguments); */
			/* TODO(ExpressionStatement): members = createInstantiatedSymbolTable(source.declaredProperties, mapper, /*mappingThisOnly* / typeParameters.length === 1); */
			/* TODO(ExpressionStatement): callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper); */
			/* TODO(ExpressionStatement): constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper); */
			/* TODO(ExpressionStatement): indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper); */
		}
		baseTypes := getBaseTypes(source)
		if /* TODO(PropertyAccessExpression): baseTypes.length */ TODO {
			if /* TODO(PropertyAccessExpression): source.symbol */ TODO && members == getMembersOfSymbol( /* TODO(PropertyAccessExpression): source.symbol */ TODO) {
				symbolTable := createSymbolTable( /* TODO(PropertyAccessExpression): source.declaredProperties */ TODO)
				sourceIndex := getIndexSymbol( /* TODO(PropertyAccessExpression): source.symbol */ TODO)
				if sourceIndex {
					/* TODO(PropertyAccessExpression): symbolTable.set */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.Index */ TODO, sourceIndex)
				}
				/* TODO(ExpressionStatement): members = symbolTable; */
			}
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			thisArgument := lastOrUndefined(typeArguments)
			for _, baseType := range baseTypes {
				instantiatedBaseType := /* TODO(ConditionalExpression): thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType */ TODO
				addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType))
				/* TODO(ExpressionStatement): callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Call)); */
				/* TODO(ExpressionStatement): constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKind.Construct)); */
				inheritedIndexInfos := /* TODO(ConditionalExpression): instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly* / false)] */ TODO
				/* TODO(ExpressionStatement): indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, info => !findIndexInfo(indexInfos, info.keyType))); */
			}
		}
		setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
	}
	resolveClassOrInterfaceMembers := func(type_ InterfaceType) {
		resolveObjectTypeMembers(type_, resolveDeclaredMembers(type_), emptyArray, emptyArray)
	}
	resolveTypeReferenceMembers := func(type_ TypeReference) {
		source := resolveDeclaredMembers( /* TODO(PropertyAccessExpression): type.target */ TODO)
		typeParameters := concatenate( /* TODO(NonNullExpression): source.typeParameters! */ TODO /* TODO(ArrayLiteralExpression): [source.thisType!] */, TODO)
		typeArguments := getTypeArguments(type_)
		paddedTypeArguments := /* TODO(ConditionalExpression): typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]) */ TODO
		resolveObjectTypeMembers(type_, source, typeParameters, paddedTypeArguments)
	}
	createSignature := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, resolvedReturnType *Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
		sig := /* TODO(NewExpression): new Signature(checker, flags) */ TODO
		/* TODO(ExpressionStatement): sig.declaration = declaration; */
		/* TODO(ExpressionStatement): sig.typeParameters = typeParameters; */
		/* TODO(ExpressionStatement): sig.parameters = parameters; */
		/* TODO(ExpressionStatement): sig.thisParameter = thisParameter; */
		/* TODO(ExpressionStatement): sig.resolvedReturnType = resolvedReturnType; */
		/* TODO(ExpressionStatement): sig.resolvedTypePredicate = resolvedTypePredicate; */
		/* TODO(ExpressionStatement): sig.minArgumentCount = minArgumentCount; */
		/* TODO(ExpressionStatement): sig.resolvedMinArgumentCount = undefined; */
		/* TODO(ExpressionStatement): sig.target = undefined; */
		/* TODO(ExpressionStatement): sig.mapper = undefined; */
		/* TODO(ExpressionStatement): sig.compositeSignatures = undefined; */
		/* TODO(ExpressionStatement): sig.compositeKind = undefined; */
		return sig
	}
	cloneSignature := func(sig Signature) Signature {
		result := createSignature( /* TODO(PropertyAccessExpression): sig.declaration */ TODO /* TODO(PropertyAccessExpression): sig.typeParameters */, TODO /* TODO(PropertyAccessExpression): sig.thisParameter */, TODO /* TODO(PropertyAccessExpression): sig.parameters */, TODO, nil, nil /* TODO(PropertyAccessExpression): sig.minArgumentCount */, TODO /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sig.flags & SignatureFlags.PropagatingFlags */, TODO)
		/* TODO(ExpressionStatement): result.target = sig.target; */
		/* TODO(ExpressionStatement): result.mapper = sig.mapper; */
		/* TODO(ExpressionStatement): result.compositeSignatures = sig.compositeSignatures; */
		/* TODO(ExpressionStatement): result.compositeKind = sig.compositeKind; */
		return result
	}
	createUnionSignature := func(signature Signature, unionSignatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		result := cloneSignature(signature)
		/* TODO(ExpressionStatement): result.compositeSignatures = unionSignatures; */
		/* TODO(ExpressionStatement): result.compositeKind = TypeFlags.Union; */
		/* TODO(ExpressionStatement): result.target = undefined; */
		/* TODO(ExpressionStatement): result.mapper = undefined; */
		return result
	}
	getOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
		if /* TODO(ParenthesizedExpression): (signature.flags & SignatureFlags.CallChainFlags) */ TODO == callChainFlags {
			return signature
		}
		if ! /* TODO(PropertyAccessExpression): signature.optionalCallSignatureCache */ TODO {
			/* TODO(ExpressionStatement): signature.optionalCallSignatureCache = {}; */
		}
		key := /* TODO(ConditionalExpression): callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer" */ TODO
		return /* TODO(ElementAccessExpression): signature.optionalCallSignatureCache[key] */ TODO || /* TODO(ParenthesizedExpression): (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags)) */ TODO
	}
	createOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(callChainFlags == /* TODO(PropertyAccessExpression): SignatureFlags.IsInnerCallChain */ TODO || callChainFlags == /* TODO(PropertyAccessExpression): SignatureFlags.IsOuterCallChain */ TODO, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.")
		result := cloneSignature(signature)
		/* TODO(ExpressionStatement): result.flags |= callChainFlags; */
		return result
	}
	getExpandedParameters := func(sig Signature, skipUnionExpanding bool) [][]Symbol {
		if signatureHasRestParameter(sig) {
			restIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sig.parameters.length - 1 */ TODO
			restSymbol := /* TODO(ElementAccessExpression): sig.parameters[restIndex] */ TODO
			restType := getTypeOfSymbol(restSymbol)
			if isTupleType(restType) {
				return /* TODO(ArrayLiteralExpression): [expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)] */ TODO
			} else if !skipUnionExpanding && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): restType.flags & TypeFlags.Union */ TODO && every( /* TODO(PropertyAccessExpression): (restType as UnionType).types */ TODO, isTupleType) {
				return map_( /* TODO(PropertyAccessExpression): (restType as UnionType).types */ TODO /* TODO(ArrowFunction): t => expandSignatureParametersWithTupleMembers(t as TupleTypeReference, restIndex, restSymbol) */, TODO)
			}
		}
		return /* TODO(ArrayLiteralExpression): [sig.parameters] */ TODO
		expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			elementTypes := getTypeArguments(restType)
			associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
			restParams := map_(elementTypes /* TODO(ArrowFunction): (t, i) => {                 // Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name                 const name = associatedNames && associatedNames[i] ? associatedNames[i] :                     getParameterNameAtPosition(sig, restIndex + i, restType);                 const flags = restType.target.elementFlags[i];                 const checkFlags = flags & ElementFlags.Variable ? CheckFlags.RestParameter :                     flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0;                 const symbol = createSymbol(SymbolFlags.FunctionScopedVariable, name, checkFlags);                 symbol.links.type = flags & ElementFlags.Rest ? createArrayType(t) : t;                 return symbol;             } */, TODO)
			return concatenate( /* TODO(PropertyAccessExpression): sig.parameters.slice */ TODO(0, restIndex), restParams)
		}
		getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String[] | undefined */ TODO {
			names := map_( /* TODO(PropertyAccessExpression): type.target.labeledElementDeclarations */ TODO /* TODO(ArrowFunction): (labeledElement, i) => getTupleElementLabel(labeledElement, i, type.target.elementFlags[i], restSymbol) */, TODO)
			if names {
				var duplicates []number = /* TODO(ArrayLiteralExpression): [] */ TODO
				uniqueNames := /* TODO(NewExpression): new Set<__String>() */ TODO
				/* TODO(ForStatement): for (let i = 0; i < names.length; i++) {                     const name = names[i];                     if (!tryAddToSet(uniqueNames, name)) {                         duplicates.push(i);                     }                 } */
				counters := /* TODO(NewExpression): new Map<__String, number>() */ TODO
				for _, i := range duplicates {
					counter := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): counters.get(names[i]) ?? 1 */ TODO
					var name __String
					/* TODO(WhileStatement): while (!tryAddToSet(uniqueNames, name = `${names[i]}_${counter}` as __String)) {                         counter++;                     } */
					/* TODO(ExpressionStatement): names[i] = name; */
					/* TODO(PropertyAccessExpression): counters.set */
					TODO( /* TODO(ElementAccessExpression): names[i] */ TODO /* TODO(PlusToken): + */ /* TODO(BinaryExpression): counter + 1 */, TODO)
				}
			}
			return names
		}
	}
	getDefaultConstructSignatures := func(classType InterfaceType) []Signature {
		baseConstructorType := getBaseConstructorTypeOfClass(classType)
		baseSignatures := getSignaturesOfType(baseConstructorType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		declaration := getClassLikeDeclarationOfSymbol( /* TODO(PropertyAccessExpression): classType.symbol */ TODO)
		isAbstract := !!declaration && hasSyntacticModifier(declaration /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO)
		if /* TODO(PropertyAccessExpression): baseSignatures.length */ TODO == 0 {
			return /* TODO(ArrayLiteralExpression): [createSignature(/*declaration* / undefined, classType.localTypeParameters, /*thisParameter* / undefined, emptyArray, classType, /*resolvedTypePredicate* / undefined, 0, isAbstract ? SignatureFlags.Abstract : SignatureFlags.None)] */ TODO
		}
		baseTypeNode := /* TODO(NonNullExpression): getBaseTypeNodeOfClass(classType)! */ TODO
		isJavaScript := isInJSFile(baseTypeNode)
		typeArguments := typeArgumentsFromTypeReferenceNode(baseTypeNode)
		typeArgCount := length(typeArguments)
		var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, baseSig := range baseSignatures {
			minTypeArgumentCount := getMinTypeArgumentCount( /* TODO(PropertyAccessExpression): baseSig.typeParameters */ TODO)
			typeParamCount := length( /* TODO(PropertyAccessExpression): baseSig.typeParameters */ TODO)
			if isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount {
				sig := /* TODO(ConditionalExpression): typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig) */ TODO
				/* TODO(ExpressionStatement): sig.typeParameters = classType.localTypeParameters; */
				/* TODO(ExpressionStatement): sig.resolvedReturnType = classType; */
				/* TODO(ExpressionStatement): sig.flags = isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract; */
				/* TODO(PropertyAccessExpression): result.push */
				TODO(sig)
			}
		}
		return result
	}
	findMatchingSignature := func(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
		for _, s := range signatureList {
			if compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes /* TODO(ConditionalExpression): partialMatch ? compareTypesSubtypeOf : compareTypesIdentical */, TODO) {
				return s
			}
		}
	}
	findMatchingSignatures := func(signatureLists [][]Signature, signature Signature, listIndex number) /* TODO(ArrayType): Signature[] */ any {
		if /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO {
			if listIndex > 0 {
				return nil
			}
			/* TODO(ForStatement): for (let i = 1; i < signatureLists.length; i++) {                 if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false)) {                     return undefined;                 }             } */
			return /* TODO(ArrayLiteralExpression): [signature] */ TODO
		}
		var result /* TODO(ArrayType): Signature[] */ any
		/* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             // Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.             // Prefer matching this types if possible.             const match = i === listIndex                 ? signature                 : findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)                     || findMatchingSignature(signatureLists[i], signature, /*partialMatch* / true, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true);             if (!match) {                 return undefined;             }             result = appendIfUnique(result, match);         } */
		return result
	}
	getUnionSignatures := func(signatureLists [][]Signature) []Signature {
		var result /* TODO(ArrayType): Signature[] */ any
		var indexWithLengthOverOne /* TODO(NumberKeyword): number */ any
		/* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             if (signatureLists[i].length === 0) return emptyArray;             if (signatureLists[i].length > 1) {                 indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets             }             for (const signature of signatureLists[i]) {                 // Only process signatures with parameter lists that aren't already in the result list                 if (!result || !findMatchingSignature(result, signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)) {                     const unionSignatures = findMatchingSignatures(signatureLists, signature, i);                     if (unionSignatures) {                         let s = signature;                         // Union the result types when more than one signature matches                         if (unionSignatures.length > 1) {                             let thisParameter = signature.thisParameter;                             const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);                             if (firstThisParameterOfUnionSignatures) {                                 const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));                                 thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);                             }                             s = createUnionSignature(signature, unionSignatures);                             s.thisParameter = thisParameter;                         }                         (result || (result = [])).push(s);                     }                 }             }         } */
		if !length(result) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexWithLengthOverOne !== -1 */ TODO {
			masterList := /* TODO(ElementAccessExpression): signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0] */ TODO
			var results /* TODO(ArrayType): Signature[] */ any = /* TODO(PropertyAccessExpression): masterList.slice */ TODO()
			for _, signatures := range signatureLists {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signatures !== masterList */ TODO {
					signature := /* TODO(ElementAccessExpression): signatures[0] */ TODO
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass")
					/* TODO(ExpressionStatement): results = !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature)); */
					if !results {
						/* TODO(BreakStatement): break; */
					}
				}
			}
			/* TODO(ExpressionStatement): result = results; */
		}
		return result || emptyArray
	}
	compareTypeParametersIdentical := func(sourceParams /* TODO(TypeOperator): readonly TypeParameter[] */ any, targetParams /* TODO(TypeOperator): readonly TypeParameter[] */ any) bool {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(sourceParams) !== length(targetParams) */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if !sourceParams || !targetParams {
			return /* TODO(TrueKeyword): true */ TODO
		}
		mapper := createTypeMapper(targetParams, sourceParams)
		/* TODO(ForStatement): for (let i = 0; i < sourceParams.length; i++) {             const source = sourceParams[i];             const target = targetParams[i];             if (source === target) continue;             // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`             if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;             // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.             // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing             // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)             // and, since it's just an inference _default_, just picking one arbitrarily works OK.         } */
		return /* TODO(TrueKeyword): true */ TODO
	}
	combineUnionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getIntersectionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
		return createSymbolWithType(left, thisType)
	}
	combineUnionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getIntersectionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,                 isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
		if needsExtraRestElement {
			restParamSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, "args" /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): CheckFlags.RestParameter */, TODO)
			/* TODO(ExpressionStatement): restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount)); */
			if shorter == right {
				/* TODO(ExpressionStatement): restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper); */
			}
			/* TODO(ExpressionStatement): params[longestCount] = restParamSymbol; */
		}
		return params
	}
	combineSignaturesOfUnionMembers := func(left Signature, right Signature) Signature {
		typeParams := /* TODO(PropertyAccessExpression): left.typeParameters */ TODO || /* TODO(PropertyAccessExpression): right.typeParameters */ TODO
		var paramMapper *TypeMapper
		if /* TODO(PropertyAccessExpression): left.typeParameters */ TODO && /* TODO(PropertyAccessExpression): right.typeParameters */ TODO {
			/* TODO(ExpressionStatement): paramMapper = createTypeMapper(right.typeParameters, left.typeParameters); */
		}
		declaration := /* TODO(PropertyAccessExpression): left.declaration */ TODO
		params := combineUnionParameters(left, right, paramMapper)
		thisParam := combineUnionThisParam( /* TODO(PropertyAccessExpression): left.thisParameter */ TODO /* TODO(PropertyAccessExpression): right.thisParameter */, TODO, paramMapper)
		minArgCount := /* TODO(PropertyAccessExpression): Math.max */ TODO( /* TODO(PropertyAccessExpression): left.minArgumentCount */ TODO /* TODO(PropertyAccessExpression): right.minArgumentCount */, TODO)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (left.flags | right.flags) & SignatureFlags.PropagatingFlags */, TODO)
		/* TODO(ExpressionStatement): result.compositeKind = TypeFlags.Union; */
		/* TODO(ExpressionStatement): result.compositeSignatures = concatenate(left.compositeKind !== TypeFlags.Intersection && left.compositeSignatures || [left], [right]); */
		if paramMapper {
			/* TODO(ExpressionStatement): result.mapper = left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper; */
		} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): left.compositeKind !== TypeFlags.Intersection */ TODO && /* TODO(PropertyAccessExpression): left.mapper */ TODO && /* TODO(PropertyAccessExpression): left.compositeSignatures */ TODO {
			/* TODO(ExpressionStatement): result.mapper = left.mapper; */
		}
		return result
	}
	getUnionIndexInfos := func(types []Type) []IndexInfo {
		sourceInfos := getIndexInfosOfType( /* TODO(ElementAccessExpression): types[0] */ TODO)
		if sourceInfos {
			result := /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, info := range sourceInfos {
				indexType := /* TODO(PropertyAccessExpression): info.keyType */ TODO
				if every(types /* TODO(ArrowFunction): t => !!getIndexInfoOfType(t, indexType) */, TODO) {
					/* TODO(PropertyAccessExpression): result.push */ TODO(createIndexInfo(indexType, getUnionType(map_(types /* TODO(ArrowFunction): t => getIndexTypeOfType(t, indexType)! */, TODO)), some(types /* TODO(ArrowFunction): t => getIndexInfoOfType(t, indexType)!.isReadonly */, TODO)))
				}
			}
			return result
		}
		return emptyArray
	}
	resolveUnionTypeMembers := func(type_ UnionType) {
		callSignatures := getUnionSignatures(map_( /* TODO(PropertyAccessExpression): type.types */ TODO /* TODO(ArrowFunction): t => t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call) */, TODO))
		constructSignatures := getUnionSignatures(map_( /* TODO(PropertyAccessExpression): type.types */ TODO /* TODO(ArrowFunction): t => getSignaturesOfType(t, SignatureKind.Construct) */, TODO))
		indexInfos := getUnionIndexInfos( /* TODO(PropertyAccessExpression): type.types */ TODO)
		setStructuredTypeMembers(type_, emptySymbols, callSignatures, constructSignatures, indexInfos)
	}
	// OVERLOAD: intersectTypes := func(type1 Type, type2 Type) Type
	// OVERLOAD: intersectTypes := func(type1 *Type, type2 *Type) *Type
	intersectTypes := func(type1 *Type, type2 *Type) *Type {
		return /* TODO(ConditionalExpression): !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]) */ TODO
	}
	findMixins := func(types []Type) []bool {
		constructorTypeCount := countWhere(types /* TODO(ArrowFunction): t => getSignaturesOfType(t, SignatureKind.Construct).length > 0 */, TODO)
		mixinFlags := map_(types, isMixinConstructorType)
		if constructorTypeCount > 0 && constructorTypeCount == countWhere(mixinFlags /* TODO(ArrowFunction): b => b */, TODO) {
			firstMixinIndex := /* TODO(PropertyAccessExpression): mixinFlags.indexOf */ TODO( /* TODO(TrueKeyword): true */ TODO)
			/* TODO(ExpressionStatement): mixinFlags[firstMixinIndex] = false; */
		}
		return mixinFlags
	}
	includeMixinType := func(type_ Type, types []Type, mixinFlags []bool, index number) Type {
		var mixedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             if (i === index) {                 mixedTypes.push(type);             }             else if (mixinFlags[i]) {                 mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));             }         } */
		return getIntersectionType(mixedTypes)
	}
	resolveIntersectionTypeMembers := func(type_ IntersectionType) {
		var callSignatures /* TODO(ArrayType): Signature[] */ any
		var constructSignatures /* TODO(ArrayType): Signature[] */ any
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		types := /* TODO(PropertyAccessExpression): type.types */ TODO
		mixinFlags := findMixins(types)
		mixinCount := countWhere(mixinFlags /* TODO(ArrowFunction): b => b */, TODO)
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = type.types[i];             // When an intersection type contains mixin constructor types, the construct signatures from             // those types are discarded and their return types are mixed into the return types of all             // other construct signatures in the intersection type. For example, the intersection type             // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature             // 'new(s: string) => A & B'.             if (!mixinFlags[i]) {                 let signatures = getSignaturesOfType(t, SignatureKind.Construct);                 if (signatures.length && mixinCount > 0) {                     signatures = map(signatures, s => {                         const clone = cloneSignature(s);                         clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);                         return clone;                     });                 }                 constructSignatures = appendSignatures(constructSignatures, signatures);             }             callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));             indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, /*union* / false), indexInfos);         } */
		setStructuredTypeMembers(type_, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray)
	}
	appendSignatures := func(signatures /* TODO(ArrayType): Signature[] */ any, newSignatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] | undefined */ TODO {
		for _, sig := range newSignatures {
			if !signatures || every(signatures /* TODO(ArrowFunction): s => !compareSignaturesIdentical(s, sig, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, compareTypesIdentical) */, TODO) {
				/* TODO(ExpressionStatement): signatures = append(signatures, sig); */
			}
		}
		return signatures
	}
	appendIndexInfo := func(indexInfos /* TODO(ArrayType): IndexInfo[] */ any, newInfo IndexInfo, union bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ TODO {
		if indexInfos {
			/* TODO(ForStatement): for (let i = 0; i < indexInfos.length; i++) {                 const info = indexInfos[i];                 if (info.keyType === newInfo.keyType) {                     indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);                     return indexInfos;                 }             } */
		}
		return append(indexInfos, newInfo)
	}
	resolveAnonymousTypeMembers := func(type_ AnonymousType) {
		if /* TODO(PropertyAccessExpression): type.target */ TODO {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := createInstantiatedSymbolTable(getPropertiesOfObjectType( /* TODO(PropertyAccessExpression): type.target */ TODO) /* TODO(NonNullExpression): type.mapper! */, TODO /* TODO(FalseKeyword): false */, TODO)
			callSignatures := instantiateSignatures(getSignaturesOfType( /* TODO(PropertyAccessExpression): type.target */ TODO /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO) /* TODO(NonNullExpression): type.mapper! */, TODO)
			constructSignatures := instantiateSignatures(getSignaturesOfType( /* TODO(PropertyAccessExpression): type.target */ TODO /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO) /* TODO(NonNullExpression): type.mapper! */, TODO)
			indexInfos := instantiateIndexInfos(getIndexInfosOfType( /* TODO(PropertyAccessExpression): type.target */ TODO) /* TODO(NonNullExpression): type.mapper! */, TODO)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		symbol := getMergedSymbol( /* TODO(PropertyAccessExpression): type.symbol */ TODO)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeLiteral */ TODO {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := getMembersOfSymbol(symbol)
			callSignatures := getSignaturesOfSymbol( /* TODO(PropertyAccessExpression): members.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.Call */ TODO))
			constructSignatures := getSignaturesOfSymbol( /* TODO(PropertyAccessExpression): members.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.New */ TODO))
			indexInfos := getIndexInfosOfSymbol(symbol)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		members := getExportsOfSymbol(symbol)
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		if symbol == globalThisSymbol {
			varsOnly := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
			/* TODO(PropertyAccessExpression): members.forEach */ TODO( /* TODO(ArrowFunction): p => {                 if (!(p.flags & SymbolFlags.BlockScoped) && !(p.flags & SymbolFlags.ValueModule && p.declarations?.length && every(p.declarations, isAmbientModule))) {                     varsOnly.set(p.escapedName, p);                 }             } */ TODO)
			/* TODO(ExpressionStatement): members = varsOnly; */
		}
		var baseConstructorIndexInfo *IndexInfo
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, emptyArray)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			baseConstructorType := getBaseConstructorTypeOfClass(classType)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): baseConstructorType.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.TypeVariable) */ TODO {
				/* TODO(ExpressionStatement): members = createSymbolTable(getNamedOrIndexSignatureMembers(members)); */
				addInheritedMembers(members, getPropertiesOfType(baseConstructorType))
			} else if baseConstructorType == anyType {
				/* TODO(ExpressionStatement): baseConstructorIndexInfo = createIndexInfo(stringType, anyType, /*isReadonly* / false); */
			}
		}
		indexSymbol := getIndexSymbolFromSymbolTable(members)
		if indexSymbol {
			/* TODO(ExpressionStatement): indexInfos = getIndexInfosOfIndexSymbol(indexSymbol); */
		} else {
			if baseConstructorIndexInfo {
				/* TODO(ExpressionStatement): indexInfos = append(indexInfos, baseConstructorIndexInfo); */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Enum */ TODO && /* TODO(ParenthesizedExpression): (getDeclaredTypeOfSymbol(symbol).flags & TypeFlags.Enum ||                     some(type.properties, prop => !!(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike))) */ TODO {
				/* TODO(ExpressionStatement): indexInfos = append(indexInfos, enumNumberIndexInfo); */
			}
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) */ TODO {
			/* TODO(ExpressionStatement): type.callSignatures = getSignaturesOfSymbol(symbol); */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Class */ TODO {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			constructSignatures := /* TODO(ConditionalExpression): symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Function */ TODO {
				/* TODO(ExpressionStatement): constructSignatures = addRange(                     constructSignatures.slice(),                     mapDefined(                         type.callSignatures,                         sig =>                             isJSConstructor(sig.declaration) ?                                 createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate* / undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) :                                 undefined,                     ),                 ); */
			}
			if ! /* TODO(PropertyAccessExpression): constructSignatures.length */ TODO {
				/* TODO(ExpressionStatement): constructSignatures = getDefaultConstructSignatures(classType); */
			}
			/* TODO(ExpressionStatement): type.constructSignatures = constructSignatures; */
		}
	}
	type ReplaceableIndexedAccessType /* TODO(IntersectionType): IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ TODO
	replaceIndexedAccess := func(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return instantiateType(instantiable, createTypeMapper( /* TODO(ArrayLiteralExpression): [type.indexType, type.objectType] */ TODO /* TODO(ArrayLiteralExpression): [getNumberLiteralType(0), createTupleType([replacement])] */, TODO))
	}
	getLimitedConstraint := func(type_ ReverseMappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		constraint := getConstraintTypeFromMappedType( /* TODO(PropertyAccessExpression): type.mappedType */ TODO)
		if ! /* TODO(ParenthesizedExpression): (constraint.flags & TypeFlags.Union || constraint.flags & TypeFlags.Intersection) */ TODO {
			return
		}
		origin := /* TODO(ConditionalExpression): (constraint.flags & TypeFlags.Union) ? (constraint as UnionType).origin : (constraint as IntersectionType) */ TODO
		if !origin || ! /* TODO(ParenthesizedExpression): (origin.flags & TypeFlags.Intersection) */ TODO {
			return
		}
		limitedConstraint := getIntersectionType( /* TODO(PropertyAccessExpression): (origin as IntersectionType).types.filter */ TODO( /* TODO(ArrowFunction): t => t !== type.constraintType */ TODO))
		return /* TODO(ConditionalExpression): limitedConstraint !== neverType ? limitedConstraint : undefined */ TODO
	}
	resolveReverseMappedTypeMembers := func(type_ ReverseMappedType) {
		indexInfo := getIndexInfoOfType( /* TODO(PropertyAccessExpression): type.source */ TODO, stringType)
		modifiers := getMappedTypeModifiers( /* TODO(PropertyAccessExpression): type.mappedType */ TODO)
		readonlyMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? false : true */ TODO
		optionalMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional */ TODO
		indexInfos := /* TODO(ConditionalExpression): indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray */ TODO
		members := createSymbolTable()
		limitedConstraint := getLimitedConstraint(type_)
		for _, prop := range getPropertiesOfType( /* TODO(PropertyAccessExpression): type.source */ TODO) {
			if limitedConstraint {
				propertyNameType := getLiteralTypeFromProperty(prop /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO)
				if !isTypeAssignableTo(propertyNameType, limitedConstraint) {
					/* TODO(ContinueStatement): continue; */
				}
			}
			checkFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): CheckFlags.ReverseMapped | (readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0) */ TODO
			inferredProp := createSymbol( /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | prop.flags & optionalMask */ TODO /* TODO(PropertyAccessExpression): prop.escapedName */, TODO, checkFlags) /* as */ /* TODO(TypeReference): ReverseMappedSymbol */
			/* TODO(ExpressionStatement): inferredProp.declarations = prop.declarations; */
			/* TODO(ExpressionStatement): inferredProp.links.nameType = getSymbolLinks(prop).nameType; */
			/* TODO(ExpressionStatement): inferredProp.links.propertyType = getTypeOfSymbol(prop); */
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.constraintType.type.flags & TypeFlags.IndexedAccess */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type.constraintType.type as IndexedAccessType).objectType.flags & TypeFlags.TypeParameter */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type.constraintType.type as IndexedAccessType).indexType.flags & TypeFlags.TypeParameter */ TODO {
				newTypeParam := /* TODO(PropertyAccessExpression): (type.constraintType.type as IndexedAccessType).objectType */ TODO
				newMappedType := replaceIndexedAccess( /* TODO(PropertyAccessExpression): type.mappedType */ TODO /* TODO(PropertyAccessExpression): type.constraintType.type */, TODO /* as */ /* TODO(TypeReference): ReplaceableIndexedAccessType */, newTypeParam)
				/* TODO(ExpressionStatement): inferredProp.links.mappedType = newMappedType as MappedType; */
				/* TODO(ExpressionStatement): inferredProp.links.constraintType = getIndexType(newTypeParam) as IndexType; */
			} else {
				/* TODO(ExpressionStatement): inferredProp.links.mappedType = type.mappedType; */
				/* TODO(ExpressionStatement): inferredProp.links.constraintType = type.constraintType; */
			}
			/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, inferredProp)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos)
	}
	getLowerBoundOfKeyType := func(type_ Type) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Index */ TODO {
			t := getApparentType( /* TODO(PropertyAccessExpression): (type as IndexType).type */ TODO)
			return /* TODO(ConditionalExpression): isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t) */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
			if /* TODO(PropertyAccessExpression): (type as ConditionalType).root.isDistributive */ TODO {
				checkType := /* TODO(PropertyAccessExpression): (type as ConditionalType).checkType */ TODO
				constraint := getLowerBoundOfKeyType(checkType)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== checkType */ TODO {
					return getConditionalTypeInstantiation(type_ /* as */ /* TODO(TypeReference): ConditionalType */, prependTypeMapping( /* TODO(PropertyAccessExpression): (type as ConditionalType).root.checkType */ TODO, constraint /* TODO(PropertyAccessExpression): (type as ConditionalType).mapper */, TODO) /* TODO(FalseKeyword): false */, TODO)
				}
			}
			return type_
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			return mapType(type_ /* as */ /* TODO(TypeReference): UnionType */, getLowerBoundOfKeyType /* TODO(TrueKeyword): true */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			types := /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO
			if /* TODO(PropertyAccessExpression): types.length */ TODO == 2 && !! /* TODO(ParenthesizedExpression): (types[0].flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt)) */ TODO && /* TODO(ElementAccessExpression): types[1] */ TODO == emptyTypeLiteralType {
				return type_
			}
			return getIntersectionType(sameMap( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, getLowerBoundOfKeyType))
		}
		return type_
	}
	getIsLateCheckFlag := func(s Symbol) CheckFlags {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(s) & CheckFlags.Late */ TODO
	}
	forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType := func(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type)) {
		for _, prop := range getPropertiesOfType(type_) {
			cb(getLiteralTypeFromProperty(prop, include))
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO {
			cb(stringType)
		} else {
			for _, info := range getIndexInfosOfType(type_) {
				if !stringsOnly || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): info.keyType.flags & (TypeFlags.String | TypeFlags.TemplateLiteral) */ TODO {
					cb( /* TODO(PropertyAccessExpression): info.keyType */ TODO)
				}
			}
		}
	}
	resolveMappedTypeMembers := func(type_ MappedType) {
		var members SymbolTable = createSymbolTable()
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		mappedType := /* TODO(ParenthesizedExpression): (type.target as MappedType) */ TODO || type_
		nameType := getNameTypeFromMappedType(mappedType)
		shouldLinkPropDeclarations := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedTypeNameTypeKind(mappedType) !== MappedTypeNameTypeKind.Remapping */ TODO
		templateType := getTemplateTypeFromMappedType(mappedType)
		modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
		templateModifiers := getMappedTypeModifiers(type_)
		include := /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */ TODO
		if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include /* TODO(FalseKeyword): false */, TODO, addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			forEachType(propNameType /* TODO(ArrowFunction): t => addMemberForKeyTypeWorker(keyType, t) */, TODO)
		}
		addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
			if isTypeUsableAsPropertyName(propNameType) {
				propName := getPropertyNameFromType(propNameType)
				existingProp := /* TODO(PropertyAccessExpression): members.get */ TODO(propName) /* as */ /* TODO(UnionType): MappedSymbol | undefined */
				if existingProp {
					/* TODO(ExpressionStatement): existingProp.links.nameType = getUnionType([existingProp.links.nameType!, propNameType]); */
					/* TODO(ExpressionStatement): existingProp.links.keyType = getUnionType([existingProp.links.keyType, keyType]); */
				} else {
					modifiersProp := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined */ TODO
					isOptional := !! /* TODO(ParenthesizedExpression): (templateModifiers & MappedTypeModifiers.IncludeOptional ||                         !(templateModifiers & MappedTypeModifiers.ExcludeOptional) && modifiersProp && modifiersProp.flags & SymbolFlags.Optional) */ TODO
					isReadonly := !! /* TODO(ParenthesizedExpression): (templateModifiers & MappedTypeModifiers.IncludeReadonly ||                         !(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp)) */ TODO
					stripOptional := strictNullChecks && !isOptional && modifiersProp && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): modifiersProp.flags & SymbolFlags.Optional */ TODO
					var lateFlag CheckFlags = /* TODO(ConditionalExpression): modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0 */ TODO
					prop := createSymbol( /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | (isOptional ? SymbolFlags.Optional : 0) */ TODO, propName /* TODO(BarToken): | */ /* TODO(BinaryExpression): lateFlag | CheckFlags.Mapped | (isReadonly ? CheckFlags.Readonly : 0) | (stripOptional ? CheckFlags.StripOptional : 0) */, TODO) /* as */ /* TODO(TypeReference): MappedSymbol */
					/* TODO(ExpressionStatement): prop.links.mappedType = type; */
					/* TODO(ExpressionStatement): prop.links.nameType = propNameType; */
					/* TODO(ExpressionStatement): prop.links.keyType = keyType; */
					if modifiersProp {
						/* TODO(ExpressionStatement): prop.links.syntheticOrigin = modifiersProp; */
						/* TODO(ExpressionStatement): prop.declarations = shouldLinkPropDeclarations ? modifiersProp.declarations : undefined; */
					}
					/* TODO(PropertyAccessExpression): members.set */ TODO(propName, prop)
				}
			} else if isValidIndexKeyType(propNameType) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): propNameType.flags & (TypeFlags.Any | TypeFlags.Enum) */ TODO {
				indexKeyType := /* TODO(ConditionalExpression): propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType :                     propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType :                     propNameType */ TODO
				propType := instantiateType(templateType, appendTypeMapping( /* TODO(PropertyAccessExpression): type.mapper */ TODO, typeParameter, keyType))
				modifiersIndexInfo := getApplicableIndexInfo(modifiersType, propNameType)
				isReadonly := !! /* TODO(ParenthesizedExpression): (templateModifiers & MappedTypeModifiers.IncludeReadonly ||                     !(templateModifiers & MappedTypeModifiers.ExcludeReadonly) && modifiersIndexInfo?.isReadonly) */ TODO
				indexInfo := createIndexInfo(indexKeyType, propType, isReadonly)
				/* TODO(ExpressionStatement): indexInfos = appendIndexInfo(indexInfos, indexInfo, /*union* / true); */
			}
		}
	}
	getTypeOfMappedSymbol := func(symbol MappedSymbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if ! /* TODO(PropertyAccessExpression): symbol.links.type */ TODO {
			mappedType := /* TODO(PropertyAccessExpression): symbol.links.mappedType */ TODO
			if !pushTypeResolution(symbol /* TODO(PropertyAccessExpression): TypeSystemPropertyName.Type */, TODO) {
				/* TODO(ExpressionStatement): mappedType.containsError = true; */
				return errorType
			}
			templateType := getTemplateTypeFromMappedType( /* TODO(PropertyAccessExpression): mappedType.target */ TODO /* as */ /* TODO(TypeReference): MappedType */ || mappedType)
			mapper := appendTypeMapping( /* TODO(PropertyAccessExpression): mappedType.mapper */ TODO, getTypeParameterFromMappedType(mappedType) /* TODO(PropertyAccessExpression): symbol.links.keyType */, TODO)
			propType := instantiateType(templateType, mapper)
			type_ := /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :                 symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) :                 propType */ TODO
			if !popTypeResolution() {
				error(currentNode /* TODO(PropertyAccessExpression): Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1 */, TODO, symbolToString(symbol), typeToString(mappedType))
				/* TODO(ExpressionStatement): type = errorType; */
			}
			/* TODO(ExpressionStatement): symbol.links.type ??= type; */
		}
		return /* TODO(PropertyAccessExpression): symbol.links.type */ TODO
	}
	getTypeParameterFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
		return /* TODO(PropertyAccessExpression): type.typeParameter */ TODO || /* TODO(ParenthesizedExpression): (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter))) */ TODO
	}
	getConstraintTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(PropertyAccessExpression): type.constraintType */ TODO || /* TODO(ParenthesizedExpression): (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType) */ TODO
	}
	getNameTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.declaration.nameType ?             type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :             undefined */ TODO
	}
	getTemplateTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(PropertyAccessExpression): type.templateType */ TODO || /* TODO(ParenthesizedExpression): (type.templateType = type.declaration.type ?                 instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :                 errorType) */ TODO
	}
	getConstraintDeclarationForMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		return getEffectiveConstraintOfTypeParameter( /* TODO(PropertyAccessExpression): type.declaration.typeParameter */ TODO)
	}
	isMappedTypeWithKeyofConstraintDeclaration := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
		constraintDeclaration := /* TODO(NonNullExpression): getConstraintDeclarationForMappedType(type)! */ TODO
		return /* TODO(PropertyAccessExpression): constraintDeclaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeOperator */ TODO && /* TODO(PropertyAccessExpression): (constraintDeclaration as TypeOperatorNode).operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.KeyOfKeyword */ TODO
	}
	getModifiersTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if ! /* TODO(PropertyAccessExpression): type.modifiersType */ TODO {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				/* TODO(ExpressionStatement): type.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type) as TypeOperatorNode).type), type.mapper); */
			} else {
				declaredType := getTypeFromMappedTypeNode( /* TODO(PropertyAccessExpression): type.declaration */ TODO) /* as */ /* TODO(TypeReference): MappedType */
				constraint := getConstraintTypeFromMappedType(declaredType)
				extendedConstraint := /* TODO(ConditionalExpression): constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint */ TODO
				/* TODO(ExpressionStatement): type.modifiersType = extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType; */
			}
		}
		return /* TODO(PropertyAccessExpression): type.modifiersType */ TODO
	}
	getMappedTypeModifiers := func(type_ MappedType) MappedTypeModifiers {
		declaration := /* TODO(PropertyAccessExpression): type.declaration */ TODO
		return /* TODO(BarToken): | */ /* TODO(BinaryExpression): (declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0) |             (declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional : 0) */ TODO
	}
	getMappedTypeOptionality := func(type_ MappedType) number {
		modifiers := getMappedTypeModifiers(type_)
		return /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0 */ TODO
	}
	getCombinedMappedTypeOptionality := func(type_ Type) number {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Mapped */ TODO {
			return getMappedTypeOptionality(type_ /* as */ /* TODO(TypeReference): MappedType */) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */))
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			optionality := getCombinedMappedTypeOptionality( /* TODO(ElementAccessExpression): (type as IntersectionType).types[0] */ TODO)
			return /* TODO(ConditionalExpression): every((type as IntersectionType).types, (t, i) => i === 0 || getCombinedMappedTypeOptionality(t) === optionality) ? optionality : 0 */ TODO
		}
		return 0
	}
	isPartialMappedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Mapped && getMappedTypeModifiers(type as MappedType) & MappedTypeModifiers.IncludeOptional) */ TODO
	}
	isGenericMappedType := func(type_ Type) /* TODO(TypePredicate): type is MappedType */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Mapped */ TODO {
			constraint := getConstraintTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
			if isGenericIndexType(constraint) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			nameType := getNameTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
			if nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */), constraint))) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getMappedTypeNameTypeKind := func(type_ MappedType) MappedTypeNameTypeKind {
		nameType := getNameTypeFromMappedType(type_)
		if !nameType {
			return /* TODO(PropertyAccessExpression): MappedTypeNameTypeKind.None */ TODO
		}
		return /* TODO(ConditionalExpression): isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type)) ? MappedTypeNameTypeKind.Filtering : MappedTypeNameTypeKind.Remapping */ TODO
	}
	resolveStructuredTypeMembers := func(type_ StructuredType) ResolvedType {
		if ! /* TODO(PropertyAccessExpression): (type as ResolvedType).members */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as ObjectType).objectFlags & ObjectFlags.Reference */ TODO {
					resolveTypeReferenceMembers(type_ /* as */ /* TODO(TypeReference): TypeReference */)
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as ObjectType).objectFlags & ObjectFlags.ClassOrInterface */ TODO {
					resolveClassOrInterfaceMembers(type_ /* as */ /* TODO(TypeReference): InterfaceType */)
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as ReverseMappedType).objectFlags & ObjectFlags.ReverseMapped */ TODO {
					resolveReverseMappedTypeMembers(type_ /* as */ /* TODO(TypeReference): ReverseMappedType */)
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as ObjectType).objectFlags & ObjectFlags.Anonymous */ TODO {
					resolveAnonymousTypeMembers(type_ /* as */ /* TODO(TypeReference): AnonymousType */)
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as MappedType).objectFlags & ObjectFlags.Mapped */ TODO {
					resolveMappedTypeMembers(type_ /* as */ /* TODO(TypeReference): MappedType */)
				} else {
					/* TODO(PropertyAccessExpression): Debug.fail */ TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled object type " + Debug.formatObjectFlags(type.objectFlags) */ TODO)
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
				resolveUnionTypeMembers(type_ /* as */ /* TODO(TypeReference): UnionType */)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
				resolveIntersectionTypeMembers(type_ /* as */ /* TODO(TypeReference): IntersectionType */)
			} else {
				/* TODO(PropertyAccessExpression): Debug.fail */ TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled type " + Debug.formatTypeFlags(type.flags) */ TODO)
			}
		}
		return type_ /* as */ /* TODO(TypeReference): ResolvedType */
	}
	getPropertiesOfObjectType := func(type_ Type) []Symbol {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
			return /* TODO(PropertyAccessExpression): resolveStructuredTypeMembers(type as ObjectType).properties */ TODO
		}
		return emptyArray
	}
	getPropertyOfObjectType := func(type_ Type, name __String) *Symbol {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			symbol := /* TODO(PropertyAccessExpression): resolved.members.get */ TODO(name)
			if symbol && symbolIsValue(symbol) {
				return symbol
			}
		}
	}
	getPropertiesOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType) []Symbol {
		if ! /* TODO(PropertyAccessExpression): type.resolvedProperties */ TODO {
			members := createSymbolTable()
			for _, current := range /* TODO(PropertyAccessExpression): type.types */ TODO {
				for _, prop := range getPropertiesOfType(current) {
					if ! /* TODO(PropertyAccessExpression): members.has */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO) {
						combinedProp := getPropertyOfUnionOrIntersectionType(type_ /* TODO(PropertyAccessExpression): prop.escapedName */, TODO, !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Intersection) */ TODO)
						if combinedProp {
							/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, combinedProp)
						}
					}
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO && /* TODO(PropertyAccessExpression): getIndexInfosOfType(current).length */ TODO == 0 {
					/* TODO(BreakStatement): break; */
				}
			}
			/* TODO(ExpressionStatement): type.resolvedProperties = getNamedMembers(members); */
		}
		return /* TODO(PropertyAccessExpression): type.resolvedProperties */ TODO
	}
	getPropertiesOfType := func(type_ Type) []Symbol {
		/* TODO(ExpressionStatement): type = getReducedApparentType(type); */
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ?             getPropertiesOfUnionOrIntersectionType(type as UnionType) :             getPropertiesOfObjectType(type) */ TODO
	}
	forEachPropertyOfType := func(type_ Type, action func(symbol Symbol, escapedName __String)) {
		/* TODO(ExpressionStatement): type = getReducedApparentType(type); */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.StructuredType */ TODO {
			/* TODO(PropertyAccessExpression): resolveStructuredTypeMembers(type as StructuredType).members.forEach */ TODO( /* TODO(ArrowFunction): (symbol, escapedName) => {                 if (isNamedMember(symbol, escapedName)) {                     action(symbol, escapedName);                 }             } */ TODO)
		}
	}
	isTypeInvalidDueToUnionDiscriminant := func(contextualType Type, obj /* TODO(UnionType): ObjectLiteralExpression | JsxAttributes */ any) bool {
		list := /* TODO(PropertyAccessExpression): obj.properties */ TODO /* as */ /* TODO(TypeReference): NodeArray<ObjectLiteralElementLike | JsxAttributeLike> */
		return /* TODO(PropertyAccessExpression): list.some */ TODO( /* TODO(ArrowFunction): property => {             const nameType = property.name && (isJsxNamespacedName(property.name) ? getStringLiteralType(getTextOfJsxAttributeName(property.name)) : getLiteralTypeFromPropertyName(property.name));             const name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined;             const expected = name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name);             return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);         } */ TODO)
	}
	getAllPossiblePropertiesOfTypes := func(types []Type) []Symbol {
		unionType := getUnionType(types)
		if ! /* TODO(ParenthesizedExpression): (unionType.flags & TypeFlags.Union) */ TODO {
			return getAugmentedPropertiesOfType(unionType)
		}
		props := createSymbolTable()
		for _, memberType := range types {
			for _, TODO_IDENTIFIER := range getAugmentedPropertiesOfType(memberType) {
				if ! /* TODO(PropertyAccessExpression): props.has */ TODO(escapedName) {
					prop := createUnionOrIntersectionProperty(unionType /* as */ /* TODO(TypeReference): UnionType */, escapedName)
					if prop {
						/* TODO(CallExpression): props.set(escapedName, prop) */
					}
				}
			}
		}
		return arrayFrom( /* TODO(PropertyAccessExpression): props.values */ TODO())
	}
	getConstraintOfType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) *Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(type as TypeParameter) :             type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(type as IndexedAccessType) :             type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(type as ConditionalType) :             getBaseConstraintOfType(type) */ TODO
	}
	getConstraintOfTypeParameter := func(typeParameter TypeParameter) *Type {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined */ TODO
	}
	isConstMappedType := func(type_ MappedType, depth number) bool {
		typeVariable := getHomomorphicTypeVariable(type_)
		return !!typeVariable && isConstTypeVariable(typeVariable, depth)
	}
	isConstTypeVariable := func(type_ *Type, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) bool {
		return depth < 5 && !! /* TODO(ParenthesizedExpression): (type && (             type.flags & TypeFlags.TypeParameter && some((type as TypeParameter).symbol?.declarations, d => hasSyntacticModifier(d, ModifierFlags.Const)) ||             type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isConstTypeVariable(t, depth)) ||             type.flags & TypeFlags.IndexedAccess && isConstTypeVariable((type as IndexedAccessType).objectType, depth + 1) ||             type.flags & TypeFlags.Conditional && isConstTypeVariable(getConstraintOfConditionalType(type as ConditionalType), depth + 1) ||             type.flags & TypeFlags.Substitution && isConstTypeVariable((type as SubstitutionType).baseType, depth) ||             getObjectFlags(type) & ObjectFlags.Mapped && isConstMappedType(type as MappedType, depth) ||             isGenericTupleType(type) && findIndex(getElementTypes(type), (t, i) => !!(type.target.elementFlags[i] & ElementFlags.Variadic) && isConstTypeVariable(t, depth)) >= 0         )) */ TODO
	}
	getConstraintOfIndexedAccess := func(type_ IndexedAccessType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined */ TODO
	}
	getSimplifiedTypeOrConstraint := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		simplified := getSimplifiedType(type_ /* TODO(FalseKeyword): false */, TODO)
		return /* TODO(ConditionalExpression): simplified !== type ? simplified : getConstraintOfType(type) */ TODO
	}
	getConstraintFromIndexedAccess := func(type_ IndexedAccessType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isMappedTypeGenericIndexedAccess(type_) {
			return substituteIndexedMappedType( /* TODO(PropertyAccessExpression): type.objectType */ TODO /* as */ /* TODO(TypeReference): MappedType */ /* TODO(PropertyAccessExpression): type.indexType */, TODO)
		}
		indexConstraint := getSimplifiedTypeOrConstraint( /* TODO(PropertyAccessExpression): type.indexType */ TODO)
		if indexConstraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexConstraint !== type.indexType */ TODO {
			indexedAccess := getIndexedAccessTypeOrUndefined( /* TODO(PropertyAccessExpression): type.objectType */ TODO, indexConstraint /* TODO(PropertyAccessExpression): type.accessFlags */, TODO)
			if indexedAccess {
				return indexedAccess
			}
		}
		objectConstraint := getSimplifiedTypeOrConstraint( /* TODO(PropertyAccessExpression): type.objectType */ TODO)
		if objectConstraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): objectConstraint !== type.objectType */ TODO {
			return getIndexedAccessTypeOrUndefined(objectConstraint /* TODO(PropertyAccessExpression): type.indexType */, TODO /* TODO(PropertyAccessExpression): type.accessFlags */, TODO)
		}
		return nil
	}
	getDefaultConstraintOfConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if ! /* TODO(PropertyAccessExpression): type.resolvedDefaultConstraint */ TODO {
			trueConstraint := getInferredTrueTypeFromConditionalType(type_)
			falseConstraint := getFalseTypeFromConditionalType(type_)
			/* TODO(ExpressionStatement): type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]); */
		}
		return /* TODO(PropertyAccessExpression): type.resolvedDefaultConstraint */ TODO
	}
	getConstraintOfDistributiveConditionalType := func(type_ ConditionalType) *Type {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.resolvedConstraintOfDistributive !== undefined */ TODO {
			return /* TODO(PropertyAccessExpression): type.resolvedConstraintOfDistributive */ TODO || nil
		}
		if /* TODO(PropertyAccessExpression): type.root.isDistributive */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.restrictiveInstantiation !== type */ TODO {
			simplified := getSimplifiedType( /* TODO(PropertyAccessExpression): type.checkType */ TODO /* TODO(FalseKeyword): false */, TODO)
			constraint := /* TODO(ConditionalExpression): simplified === type.checkType ? getConstraintOfType(simplified) : simplified */ TODO
			if constraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== type.checkType */ TODO {
				instantiated := getConditionalTypeInstantiation(type_, prependTypeMapping( /* TODO(PropertyAccessExpression): type.root.checkType */ TODO, constraint /* TODO(PropertyAccessExpression): type.mapper */, TODO) /* TODO(TrueKeyword): true */, TODO)
				if ! /* TODO(ParenthesizedExpression): (instantiated.flags & TypeFlags.Never) */ TODO {
					/* TODO(ExpressionStatement): type.resolvedConstraintOfDistributive = instantiated; */
					return instantiated
				}
			}
		}
		/* TODO(ExpressionStatement): type.resolvedConstraintOfDistributive = false; */
		return nil
	}
	getConstraintFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getConstraintOfDistributiveConditionalType(type_) || getDefaultConstraintOfConditionalType(type_)
	}
	getConstraintOfConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined */ TODO
	}
	getEffectiveConstraintOfIntersection := func(types []Type, targetIsUnion bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var constraints /* TODO(ArrayType): Type[] */ any
		hasDisjointDomainType := /* TODO(FalseKeyword): false */ TODO
		for _, t := range types {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Instantiable */ TODO {
				constraint := getConstraintOfType(t)
				/* TODO(WhileStatement): while (constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)) {                     constraint = getConstraintOfType(constraint);                 } */
				if constraint {
					/* TODO(ExpressionStatement): constraints = append(constraints, constraint); */
					if targetIsUnion {
						/* TODO(ExpressionStatement): constraints = append(constraints, t); */
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.DisjointDomains */ TODO || isEmptyAnonymousObjectType(t) {
				/* TODO(ExpressionStatement): hasDisjointDomainType = true; */
			}
		}
		if constraints && /* TODO(ParenthesizedExpression): (targetIsUnion || hasDisjointDomainType) */ TODO {
			if hasDisjointDomainType {
				for _, t := range types {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.DisjointDomains */ TODO || isEmptyAnonymousObjectType(t) {
						/* TODO(ExpressionStatement): constraints = append(constraints, t); */
					}
				}
			}
			return getNormalizedType(getIntersectionType(constraints /* TODO(PropertyAccessExpression): IntersectionFlags.NoConstraintReduction */, TODO) /* TODO(FalseKeyword): false */, TODO)
		}
		return nil
	}
	getBaseConstraintOfType := func(type_ Type) *Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO || isGenericTupleType(type_) {
			constraint := getResolvedBaseConstraint(type_ /* as */ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */)
			return /* TODO(ConditionalExpression): constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined */ TODO
		}
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Index ? stringNumberSymbolType : undefined */ TODO
	}
	getBaseConstraintOrType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getBaseConstraintOfType(type_) || type_
	}
	hasNonCircularBaseConstraint := func(type_ InstantiableType) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getResolvedBaseConstraint(type) !== circularConstraintType */ TODO
	}
	getResolvedBaseConstraint := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) Type {
		if /* TODO(PropertyAccessExpression): type.resolvedBaseConstraint */ TODO {
			return /* TODO(PropertyAccessExpression): type.resolvedBaseConstraint */ TODO
		}
		var stack [] /* TODO(ObjectKeyword): object */ TODO = /* TODO(ArrayLiteralExpression): [] */ TODO
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseConstraint = getImmediateBaseConstraint(type) */ TODO
		getImmediateBaseConstraint := func(t Type) Type {
			if ! /* TODO(PropertyAccessExpression): t.immediateBaseConstraint */ TODO {
				if !pushTypeResolution(t /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ImmediateBaseConstraint */, TODO) {
					return circularConstraintType
				}
				var result TODO
				identity := getRecursionIdentity(t)
				if /* TODO(PropertyAccessExpression): stack.length */ TODO < 10 || /* TODO(PropertyAccessExpression): stack.length */ TODO < 50 && !contains(stack, identity) {
					/* TODO(PropertyAccessExpression): stack.push */ TODO(identity)
					/* TODO(ExpressionStatement): result = computeBaseConstraint(getSimplifiedType(t, /*writing* / false)); */
					/* TODO(PropertyAccessExpression): stack.pop */
					TODO()
				}
				if !popTypeResolution() {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */ TODO {
						errorNode := getConstraintDeclaration(t /* as */ /* TODO(TypeReference): TypeParameter */)
						if errorNode {
							diagnostic := error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Type_parameter_0_has_a_circular_constraint */, TODO, typeToString(t))
							if currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode) {
								addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode /* TODO(PropertyAccessExpression): Diagnostics.Circularity_originates_in_type_at_this_location */, TODO))
							}
						}
					}
					/* TODO(ExpressionStatement): result = circularConstraintType; */
				}
				/* TODO(ExpressionStatement): t.immediateBaseConstraint ??= result || noConstraintType; */
			}
			return /* TODO(PropertyAccessExpression): t.immediateBaseConstraint */ TODO
		}
		getBaseConstraint := func(t Type) *Type {
			c := getImmediateBaseConstraint(t)
			return /* TODO(ConditionalExpression): c !== noConstraintType && c !== circularConstraintType ? c : undefined */ TODO
		}
		computeBaseConstraint := func(t Type) *Type {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */ TODO {
				constraint := getConstraintFromTypeParameter(t /* as */ /* TODO(TypeReference): TypeParameter */)
				return /* TODO(ConditionalExpression): (t as TypeParameter).isThisType || !constraint ?                     constraint :                     getBaseConstraint(constraint) */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.UnionOrIntersection */ TODO {
				types := /* TODO(PropertyAccessExpression): (t as UnionOrIntersectionType).types */ TODO
				var baseTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
				different := /* TODO(FalseKeyword): false */ TODO
				for _, type_ := range types {
					baseType := getBaseConstraint(type_)
					if baseType {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseType !== type */ TODO {
							/* TODO(ExpressionStatement): different = true; */
						}
						/* TODO(PropertyAccessExpression): baseTypes.push */ TODO(baseType)
					} else {
						/* TODO(ExpressionStatement): different = true; */
					}
				}
				if !different {
					return t
				}
				return /* TODO(ConditionalExpression): t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(baseTypes) :                     t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(baseTypes) :                     undefined */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Index */ TODO {
				return stringNumberSymbolType
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.TemplateLiteral */ TODO {
				types := /* TODO(PropertyAccessExpression): (t as TemplateLiteralType).types */ TODO
				constraints := mapDefined(types, getBaseConstraint)
				return /* TODO(ConditionalExpression): constraints.length === types.length ? getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) : stringType */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.StringMapping */ TODO {
				constraint := getBaseConstraint( /* TODO(PropertyAccessExpression): (t as StringMappingType).type */ TODO)
				return /* TODO(ConditionalExpression): constraint && constraint !== (t as StringMappingType).type ? getStringMappingType((t as StringMappingType).symbol, constraint) : stringType */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.IndexedAccess */ TODO {
				if isMappedTypeGenericIndexedAccess(t) {
					return getBaseConstraint(substituteIndexedMappedType( /* TODO(PropertyAccessExpression): (t as IndexedAccessType).objectType */ TODO /* as */ /* TODO(TypeReference): MappedType */ /* TODO(PropertyAccessExpression): (t as IndexedAccessType).indexType */, TODO))
				}
				baseObjectType := getBaseConstraint( /* TODO(PropertyAccessExpression): (t as IndexedAccessType).objectType */ TODO)
				baseIndexType := getBaseConstraint( /* TODO(PropertyAccessExpression): (t as IndexedAccessType).indexType */ TODO)
				baseIndexedAccess := baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType /* TODO(PropertyAccessExpression): (t as IndexedAccessType).accessFlags */, TODO)
				return baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Conditional */ TODO {
				constraint := getConstraintFromConditionalType(t /* as */ /* TODO(TypeReference): ConditionalType */)
				return constraint && getBaseConstraint(constraint)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Substitution */ TODO {
				return getBaseConstraint(getSubstitutionIntersection(t /* as */ /* TODO(TypeReference): SubstitutionType */))
			}
			if isGenericTupleType(t) {
				newElements := map_(getElementTypes(t) /* TODO(ArrowFunction): (v, i) => {                     const constraint = v.flags & TypeFlags.TypeParameter && t.target.elementFlags[i] & ElementFlags.Variadic && getBaseConstraint(v) || v;                     return constraint !== v && everyType(constraint, c => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v;                 } */, TODO)
				return createTupleType(newElements /* TODO(PropertyAccessExpression): t.target.elementFlags */, TODO /* TODO(PropertyAccessExpression): t.target.readonly */, TODO /* TODO(PropertyAccessExpression): t.target.labeledElementDeclarations */, TODO)
			}
			return t
		}
	}
	getApparentTypeOfIntersectionType := func(type_ IntersectionType, thisArgument Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_ == thisArgument {
			return /* TODO(PropertyAccessExpression): type.resolvedApparentType */ TODO || /* TODO(ParenthesizedExpression): (type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
		}
		key := /* TODO(TemplateExpression): `I${getTypeId(type)},${getTypeId(thisArgument)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
	}
	getResolvedTypeParameterDefault := func(typeParameter TypeParameter) *Type {
		if ! /* TODO(PropertyAccessExpression): typeParameter.default */ TODO {
			if /* TODO(PropertyAccessExpression): typeParameter.target */ TODO {
				targetDefault := getResolvedTypeParameterDefault( /* TODO(PropertyAccessExpression): typeParameter.target */ TODO)
				/* TODO(ExpressionStatement): typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType; */
			} else {
				/* TODO(ExpressionStatement): typeParameter.default = resolvingDefaultType; */
				defaultDeclaration := /* TODO(PropertyAccessExpression): typeParameter.symbol */ TODO && forEach( /* TODO(PropertyAccessExpression): typeParameter.symbol.declarations */ TODO /* TODO(ArrowFunction): decl => isTypeParameterDeclaration(decl) && decl.default */, TODO)
				defaultType := /* TODO(ConditionalExpression): defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType */ TODO
				if /* TODO(PropertyAccessExpression): typeParameter.default */ TODO == resolvingDefaultType {
					/* TODO(ExpressionStatement): typeParameter.default = defaultType; */
				}
			}
		} else if /* TODO(PropertyAccessExpression): typeParameter.default */ TODO == resolvingDefaultType {
			/* TODO(ExpressionStatement): typeParameter.default = circularConstraintType; */
		}
		return /* TODO(PropertyAccessExpression): typeParameter.default */ TODO
	}
	getDefaultFromTypeParameter := func(typeParameter TypeParameter) *Type {
		defaultType := getResolvedTypeParameterDefault(typeParameter)
		return /* TODO(ConditionalExpression): defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined */ TODO
	}
	hasNonCircularTypeParameterDefault := func(typeParameter TypeParameter) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType */ TODO
	}
	hasTypeParameterDefault := func(typeParameter TypeParameter) bool {
		return !! /* TODO(ParenthesizedExpression): (typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default)) */ TODO
	}
	getApparentTypeOfMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(PropertyAccessExpression): type.resolvedApparentType */ TODO || /* TODO(ParenthesizedExpression): (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type)) */ TODO
	}
	getResolvedApparentTypeOfMappedType := func(type_ MappedType) Type {
		target := /* TODO(ParenthesizedExpression): (type.target ?? type) */ TODO /* as */ /* TODO(TypeReference): MappedType */
		typeVariable := getHomomorphicTypeVariable(target)
		if typeVariable && ! /* TODO(PropertyAccessExpression): target.declaration.nameType */ TODO {
			modifiersType := getModifiersTypeFromMappedType(type_)
			baseConstraint := /* TODO(ConditionalExpression): isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType) */ TODO
			if baseConstraint && everyType(baseConstraint /* TODO(ArrowFunction): t => isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t) */, TODO) {
				return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint /* TODO(PropertyAccessExpression): type.mapper */, TODO))
			}
		}
		return type_
	}
	isArrayOrTupleOrIntersection := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Intersection) */ TODO && every( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, isArrayOrTupleType)
	}
	isMappedTypeGenericIndexedAccess := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		var objectType TODO
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.IndexedAccess && getObjectFlags(objectType = (type as IndexedAccessType).objectType) & ObjectFlags.Mapped &&             !isGenericMappedType(objectType) && isGenericIndexType((type as IndexedAccessType).indexType) &&             !(getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.ExcludeOptional) && !(objectType as MappedType).declaration.nameType) */ TODO
	}
	getApparentType := func(type_ Type) Type {
		t := /* TODO(ConditionalExpression): type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type */ TODO
		objectFlags := getObjectFlags(t)
		return /* TODO(ConditionalExpression): objectFlags & ObjectFlags.Mapped ? getApparentTypeOfMappedType(t as MappedType) :             objectFlags & ObjectFlags.Reference && t !== type ? getTypeWithThisArgument(t, type) :             t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(t as IntersectionType, type) :             t.flags & TypeFlags.StringLike ? globalStringType :             t.flags & TypeFlags.NumberLike ? globalNumberType :             t.flags & TypeFlags.BigIntLike ? getGlobalBigIntType() :             t.flags & TypeFlags.BooleanLike ? globalBooleanType :             t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType() :             t.flags & TypeFlags.NonPrimitive ? emptyObjectType :             t.flags & TypeFlags.Index ? stringNumberSymbolType :             t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType :             t */ TODO
	}
	getReducedApparentType := func(type_ Type) Type {
		return getReducedType(getApparentType(getReducedType(type_)))
	}
	createUnionOrIntersectionProperty := func(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		var singleProp *Symbol
		var propSet *Map[SymbolId, Symbol]
		var indexTypes /* TODO(ArrayType): Type[] */ any
		isUnion := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): containingType.flags & TypeFlags.Union */ TODO
		var optionalFlag *SymbolFlags
		syntheticFlag := /* TODO(PropertyAccessExpression): CheckFlags.SyntheticMethod */ TODO
		checkFlags := /* TODO(ConditionalExpression): isUnion ? 0 : CheckFlags.Readonly */ TODO
		mergedInstantiations := /* TODO(FalseKeyword): false */ TODO
		for _, current := range /* TODO(PropertyAccessExpression): containingType.types */ TODO {
			type_ := getApparentType(current)
			if ! /* TODO(ParenthesizedExpression): (isErrorType(type) || type.flags & TypeFlags.Never) */ TODO {
				prop := getPropertyOfType(type_, name, skipObjectFunctionPropertyAugment)
				modifiers := /* TODO(ConditionalExpression): prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0 */ TODO
				if prop {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): prop.flags & SymbolFlags.ClassMember */ TODO {
						/* TODO(ExpressionStatement): optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional; */
						if isUnion {
							/* TODO(ExpressionStatement): optionalFlag |= prop.flags & SymbolFlags.Optional; */
						} else {
							/* TODO(ExpressionStatement): optionalFlag &= prop.flags; */
						}
					}
					if !singleProp {
						/* TODO(ExpressionStatement): singleProp = prop; */
					} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop !== singleProp */ TODO {
						isInstantiation := /* TODO(ParenthesizedExpression): (getTargetSymbol(prop) || prop) */ TODO == /* TODO(ParenthesizedExpression): (getTargetSymbol(singleProp) || singleProp) */ TODO
						if isInstantiation && compareProperties(singleProp, prop /* TODO(ArrowFunction): (a, b) => a === b ? Ternary.True : Ternary.False */, TODO) == /* TODO(PropertyAccessExpression): Ternary.True */ TODO {
							/* TODO(ExpressionStatement): mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent)); */
						} else {
							if !propSet {
								/* TODO(ExpressionStatement): propSet = new Map<SymbolId, Symbol>(); */
								/* TODO(PropertyAccessExpression): propSet.set */
								TODO(getSymbolId(singleProp), singleProp)
							}
							id := getSymbolId(prop)
							if ! /* TODO(PropertyAccessExpression): propSet.has */ TODO(id) {
								/* TODO(PropertyAccessExpression): propSet.set */ TODO(id, prop)
							}
						}
					}
					if isUnion && isReadonlySymbol(prop) {
						/* TODO(ExpressionStatement): checkFlags |= CheckFlags.Readonly; */
					} else if !isUnion && !isReadonlySymbol(prop) {
						/* TODO(ExpressionStatement): checkFlags &= ~CheckFlags.Readonly; */
					}
					/* TODO(ExpressionStatement): checkFlags |= (!(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0) |                         (modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0) |                         (modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0) |                         (modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0); */
					if !isPrototypeProperty(prop) {
						/* TODO(ExpressionStatement): syntheticFlag = CheckFlags.SyntheticProperty; */
					}
				} else if isUnion {
					indexInfo := !isLateBoundName(name) && getApplicableIndexInfoForName(type_, name)
					if indexInfo {
						/* TODO(ExpressionStatement): checkFlags |= CheckFlags.WritePartial | (indexInfo.isReadonly ? CheckFlags.Readonly : 0); */
						/* TODO(ExpressionStatement): indexTypes = append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type); */
					} else if isObjectLiteralType(type_) && ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.ContainsSpread) */ TODO {
						/* TODO(ExpressionStatement): checkFlags |= CheckFlags.WritePartial; */
						/* TODO(ExpressionStatement): indexTypes = append(indexTypes, undefinedType); */
					} else {
						/* TODO(ExpressionStatement): checkFlags |= CheckFlags.ReadPartial; */
					}
				}
			}
		}
		if !singleProp || isUnion && /* TODO(ParenthesizedExpression): (propSet || checkFlags & CheckFlags.Partial) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkFlags & (CheckFlags.ContainsPrivate | CheckFlags.ContainsProtected) */ TODO && ! /* TODO(ParenthesizedExpression): (propSet && getCommonDeclarationsOfSymbols(propSet.values())) */ TODO {
			return nil
		}
		if !propSet && ! /* TODO(ParenthesizedExpression): (checkFlags & CheckFlags.ReadPartial) */ TODO && !indexTypes {
			if mergedInstantiations {
				links := /* TODO(PropertyAccessExpression): tryCast(singleProp, isTransientSymbol)?.links */ TODO
				clone := createSymbolWithType(singleProp /* TODO(PropertyAccessExpression): links?.type */, TODO)
				/* TODO(ExpressionStatement): clone.parent = singleProp.valueDeclaration?.symbol?.parent; */
				/* TODO(ExpressionStatement): clone.links.containingType = containingType; */
				/* TODO(ExpressionStatement): clone.links.mapper = links?.mapper; */
				/* TODO(ExpressionStatement): clone.links.writeType = getWriteTypeOfSymbol(singleProp); */
				return clone
			} else {
				return singleProp
			}
		}
		props := /* TODO(ConditionalExpression): propSet ? arrayFrom(propSet.values()) : [singleProp] */ TODO
		var declarations /* TODO(ArrayType): Declaration[] */ any
		var firstType *Type
		var nameType *Type
		var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var writeTypes /* TODO(ArrayType): Type[] */ any
		var firstValueDeclaration Declaration
		hasNonUniformValueDeclaration := /* TODO(FalseKeyword): false */ TODO
		for _, prop := range props {
			if !firstValueDeclaration {
				/* TODO(ExpressionStatement): firstValueDeclaration = prop.valueDeclaration; */
			} else if /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop.valueDeclaration !== firstValueDeclaration */ TODO {
				/* TODO(ExpressionStatement): hasNonUniformValueDeclaration = true; */
			}
			/* TODO(ExpressionStatement): declarations = addRange(declarations, prop.declarations); */
			type_ := getTypeOfSymbol(prop)
			if !firstType {
				/* TODO(ExpressionStatement): firstType = type; */
				/* TODO(ExpressionStatement): nameType = getSymbolLinks(prop).nameType; */
			}
			writeType := getWriteTypeOfSymbol(prop)
			if writeTypes || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): writeType !== type */ TODO {
				/* TODO(ExpressionStatement): writeTypes = append(!writeTypes ? propTypes.slice() : writeTypes, writeType); */
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== firstType */ TODO {
				/* TODO(ExpressionStatement): checkFlags |= CheckFlags.HasNonUniformType; */
			}
			if isLiteralType(type_) || isPatternLiteralType(type_) {
				/* TODO(ExpressionStatement): checkFlags |= CheckFlags.HasLiteralType; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== uniqueLiteralType */ TODO {
				/* TODO(ExpressionStatement): checkFlags |= CheckFlags.HasNeverType; */
			}
			/* TODO(PropertyAccessExpression): propTypes.push */ TODO(type_)
		}
		addRange(propTypes, indexTypes)
		result := createSymbol( /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | (optionalFlag ?? 0) */ TODO, name /* TODO(BarToken): | */ /* TODO(BinaryExpression): syntheticFlag | checkFlags */, TODO)
		/* TODO(ExpressionStatement): result.links.containingType = containingType; */
		if !hasNonUniformValueDeclaration && firstValueDeclaration {
			/* TODO(ExpressionStatement): result.valueDeclaration = firstValueDeclaration; */
			if /* TODO(PropertyAccessExpression): firstValueDeclaration.symbol.parent */ TODO {
				/* TODO(ExpressionStatement): result.parent = firstValueDeclaration.symbol.parent; */
			}
		}
		/* TODO(ExpressionStatement): result.declarations = declarations; */
		/* TODO(ExpressionStatement): result.links.nameType = nameType; */
		if /* TODO(PropertyAccessExpression): propTypes.length */ TODO > 2 {
			/* TODO(ExpressionStatement): result.links.checkFlags |= CheckFlags.DeferredType; */
			/* TODO(ExpressionStatement): result.links.deferralParent = containingType; */
			/* TODO(ExpressionStatement): result.links.deferralConstituents = propTypes; */
			/* TODO(ExpressionStatement): result.links.deferralWriteConstituents = writeTypes; */
		} else {
			/* TODO(ExpressionStatement): result.links.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes); */
			if writeTypes {
				/* TODO(ExpressionStatement): result.links.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes); */
			}
		}
		return result
	}
	getUnionOrIntersectionProperty := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?             type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) :             type.propertyCache?.get(name) */ TODO
		if !property {
			/* TODO(ExpressionStatement): property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment); */
			if property {
				properties := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?                     type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() :                     type.propertyCache ||= createSymbolTable() */ TODO
				/* TODO(PropertyAccessExpression): properties.set */ TODO(name, property)
				if skipObjectFunctionPropertyAugment && ! /* TODO(ParenthesizedExpression): (getCheckFlags(property) & CheckFlags.Partial) */ TODO && ! /* TODO(PropertyAccessExpression): type.propertyCache?.get */ TODO(name) {
					properties := /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): type.propertyCache ||= createSymbolTable() */ TODO
					/* TODO(PropertyAccessExpression): properties.set */ TODO(name, property)
				}
			}
		}
		return property
	}
	getCommonDeclarationsOfSymbols := func(symbols Iterable[Symbol]) /* TODO(undefined): Set<import("/home/jabaile/work/TypeScript/src/compiler/types").Node> | undefined */ TODO {
		var commonDeclarations *Set[Node]
		for _, symbol := range symbols {
			if ! /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
				return nil
			}
			if !commonDeclarations {
				/* TODO(ExpressionStatement): commonDeclarations = new Set(symbol.declarations); */
				/* TODO(ContinueStatement): continue; */
			}
			/* TODO(PropertyAccessExpression): commonDeclarations.forEach */ TODO( /* TODO(ArrowFunction): declaration => {                 if (!contains(symbol.declarations, declaration)) {                     commonDeclarations!.delete(declaration);                 }             } */ TODO)
			if /* TODO(PropertyAccessExpression): commonDeclarations.size */ TODO == 0 {
				return nil
			}
		}
		return commonDeclarations
	}
	getPropertyOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
		return /* TODO(ConditionalExpression): property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined */ TODO
	}
	getReducedType := func(type_ Type) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections */ TODO {
			return /* TODO(PropertyAccessExpression): (type as UnionType).resolvedReducedType */ TODO || /* TODO(ParenthesizedExpression): ((type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType)) */ TODO
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			if ! /* TODO(ParenthesizedExpression): ((type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersectionComputed) */ TODO {
				/* TODO(ExpressionStatement): (type as IntersectionType).objectFlags |= ObjectFlags.IsNeverIntersectionComputed |                     (some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0); */
			}
			return /* TODO(ConditionalExpression): (type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type */ TODO
		}
		return type_
	}
	getReducedUnionType := func(unionType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reducedTypes := sameMap( /* TODO(PropertyAccessExpression): unionType.types */ TODO, getReducedType)
		if reducedTypes == /* TODO(PropertyAccessExpression): unionType.types */ TODO {
			return unionType
		}
		reduced := getUnionType(reducedTypes)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): reduced.flags & TypeFlags.Union */ TODO {
			/* TODO(ExpressionStatement): (reduced as UnionType).resolvedReducedType = reduced; */
		}
		return reduced
	}
	isNeverReducedProperty := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
		return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop)
	}
	isDiscriminantWithNeverType := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
		return ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.Optional) */ TODO && /* TODO(ParenthesizedExpression): (getCheckFlags(prop) & (CheckFlags.Discriminant | CheckFlags.HasNeverType)) */ TODO == /* TODO(PropertyAccessExpression): CheckFlags.Discriminant */ TODO && !! /* TODO(ParenthesizedExpression): (getTypeOfSymbol(prop).flags & TypeFlags.Never) */ TODO
	}
	isConflictingPrivateProperty := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
		return ! /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && !! /* TODO(ParenthesizedExpression): (getCheckFlags(prop) & CheckFlags.ContainsPrivate) */ TODO
	}
	isGenericReducibleType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union && (type as UnionType).objectFlags & ObjectFlags.ContainsIntersections && some((type as UnionType).types, isGenericReducibleType) ||             type.flags & TypeFlags.Intersection && isReducibleIntersection(type as IntersectionType)) */ TODO
	}
	isReducibleIntersection := func(type_ IntersectionType) /* TODO(undefined): boolean */ TODO {
		uniqueFilled := /* TODO(PropertyAccessExpression): type.uniqueLiteralFilledInstantiation */ TODO || /* TODO(ParenthesizedExpression): (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper)) */ TODO
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getReducedType(uniqueFilled) !== uniqueFilled */ TODO
	}
	elaborateNeverIntersection := func(errorInfo *DiagnosticMessageChain, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.IsNeverIntersection */ TODO {
			neverProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): IntersectionType */), isDiscriminantWithNeverType)
			if neverProp {
				return chainDiagnosticMessages(errorInfo /* TODO(PropertyAccessExpression): Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents */, TODO, typeToString(type_, nil /* TODO(PropertyAccessExpression): TypeFormatFlags.NoTypeReduction */, TODO), symbolToString(neverProp))
			}
			privateProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): IntersectionType */), isConflictingPrivateProperty)
			if privateProp {
				return chainDiagnosticMessages(errorInfo /* TODO(PropertyAccessExpression): Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some */, TODO, typeToString(type_, nil /* TODO(PropertyAccessExpression): TypeFormatFlags.NoTypeReduction */, TODO), symbolToString(privateProp))
			}
		}
		return errorInfo
	}
	getPropertyOfType := func(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) *Symbol {
		/* TODO(ExpressionStatement): type = getReducedApparentType(type); */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			symbol := /* TODO(PropertyAccessExpression): resolved.members.get */ TODO(name)
			if symbol && !includeTypeOnlyMembers && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.symbol?.flags & SymbolFlags.ValueModule */ TODO && /* TODO(PropertyAccessExpression): getSymbolLinks(type.symbol).typeOnlyExportStarMap?.has */ TODO(name) {
				return nil
			}
			if symbol && symbolIsValue(symbol, includeTypeOnlyMembers) {
				return symbol
			}
			if skipObjectFunctionPropertyAugment {
				/* TODO(Identifier): undefined */
			}
			functionType := /* TODO(ConditionalExpression): resolved === anyFunctionType ? globalFunctionType :                 resolved.callSignatures.length ? globalCallableFunctionType :                 resolved.constructSignatures.length ? globalNewableFunctionType :                 undefined */ TODO
			if functionType {
				symbol := getPropertyOfObjectType(functionType, name)
				if symbol {
					return symbol
				}
			}
			return getPropertyOfObjectType(globalObjectType, name)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			prop := getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name /* TODO(TrueKeyword): true */, TODO)
			if prop {
				return prop
			}
			if !skipObjectFunctionPropertyAugment {
				return getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
			}
			return nil
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			return getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
		}
		return nil
	}
	getSignaturesOfStructuredType := func(type_ Type, kind SignatureKind) []Signature {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.StructuredType */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			return /* TODO(ConditionalExpression): kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures */ TODO
		}
		return emptyArray
	}
	getSignaturesOfType := func(type_ Type, kind SignatureKind) []Signature {
		result := getSignaturesOfStructuredType(getReducedApparentType(type_), kind)
		if kind == /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO && !length(result) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			if /* TODO(PropertyAccessExpression): (type as UnionType).arrayFallbackSignatures */ TODO {
				return /* TODO(NonNullExpression): (type as UnionType).arrayFallbackSignatures! */ TODO
			}
			var memberName __String
			if everyType(type_ /* TODO(ArrowFunction): t => !!t.symbol?.parent && isArrayOrTupleSymbol(t.symbol.parent) && (!memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName) */, TODO) {
				arrayArg := mapType(type_ /* TODO(ArrowFunction): t => getMappedType((isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters![0], (t as AnonymousType).mapper!) */, TODO)
				arrayType := createArrayType(arrayArg, someType(type_ /* TODO(ArrowFunction): t => isReadonlyArraySymbol(t.symbol.parent) */, TODO))
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as UnionType).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName!)!, kind) */ TODO
			}
			/* TODO(ExpressionStatement): (type as UnionType).arrayFallbackSignatures = result; */
		}
		return result
	}
	isArrayOrTupleSymbol := func(symbol *Symbol) /* TODO(undefined): boolean */ TODO {
		if !symbol || ! /* TODO(PropertyAccessExpression): globalArrayType.symbol */ TODO || ! /* TODO(PropertyAccessExpression): globalReadonlyArrayType.symbol */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return !!getSymbolIfSameReference(symbol /* TODO(PropertyAccessExpression): globalArrayType.symbol */, TODO) || !!getSymbolIfSameReference(symbol /* TODO(PropertyAccessExpression): globalReadonlyArrayType.symbol */, TODO)
	}
	isReadonlyArraySymbol := func(symbol *Symbol) /* TODO(undefined): boolean */ TODO {
		if !symbol || ! /* TODO(PropertyAccessExpression): globalReadonlyArrayType.symbol */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return !!getSymbolIfSameReference(symbol /* TODO(PropertyAccessExpression): globalReadonlyArrayType.symbol */, TODO)
	}
	findIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
		return find(indexInfos /* TODO(ArrowFunction): info => info.keyType === keyType */, TODO)
	}
	findApplicableIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
		var stringIndexInfo *IndexInfo
		var applicableInfo *IndexInfo
		var applicableInfos /* TODO(ArrayType): IndexInfo[] */ any
		for _, info := range indexInfos {
			if /* TODO(PropertyAccessExpression): info.keyType */ TODO == stringType {
				/* TODO(ExpressionStatement): stringIndexInfo = info; */
			} else if isApplicableIndexType(keyType /* TODO(PropertyAccessExpression): info.keyType */, TODO) {
				if !applicableInfo {
					/* TODO(ExpressionStatement): applicableInfo = info; */
				} else {
					/* TODO(PropertyAccessExpression): (applicableInfos || (applicableInfos = [applicableInfo])).push */ TODO(info)
				}
			}
		}
		return /* TODO(ConditionalExpression): applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)), reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, /*initial* / true)) :             applicableInfo ? applicableInfo :             stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :             undefined */ TODO
	}
	isApplicableIndexType := func(source Type, target Type) bool {
		return isTypeAssignableTo(source, target) || target == stringType && isTypeAssignableTo(source, numberType) || target == numberType && /* TODO(ParenthesizedExpression): (source === numericStringType || !!(source.flags & TypeFlags.StringLiteral) && isNumericLiteralName((source as StringLiteralType).value)) */ TODO
	}
	getIndexInfosOfStructuredType := func(type_ Type) []IndexInfo {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.StructuredType */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			return /* TODO(PropertyAccessExpression): resolved.indexInfos */ TODO
		}
		return emptyArray
	}
	getIndexInfosOfType := func(type_ Type) []IndexInfo {
		return getIndexInfosOfStructuredType(getReducedApparentType(type_))
	}
	getIndexInfoOfType := func(type_ Type, keyType Type) *IndexInfo {
		return findIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getIndexTypeOfType := func(type_ Type, keyType Type) *Type {
		return /* TODO(PropertyAccessExpression): getIndexInfoOfType(type, keyType)?.type */ TODO
	}
	getApplicableIndexInfos := func(type_ Type, keyType Type) []IndexInfo {
		return /* TODO(PropertyAccessExpression): getIndexInfosOfType(type).filter */ TODO( /* TODO(ArrowFunction): info => isApplicableIndexType(keyType, info.keyType) */ TODO)
	}
	getApplicableIndexInfo := func(type_ Type, keyType Type) *IndexInfo {
		return findApplicableIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getApplicableIndexInfoForName := func(type_ Type, name __String) *IndexInfo {
		return getApplicableIndexInfo(type_ /* TODO(ConditionalExpression): isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)) */, TODO)
	}
	getTypeParametersFromDeclaration := func(declaration DeclarationWithTypeParameters) /* TODO(TypeOperator): readonly TypeParameter[] */ any {
		var result /* TODO(ArrayType): TypeParameter[] */ any
		for _, node := range getEffectiveTypeParameterDeclarations(declaration) {
			/* TODO(ExpressionStatement): result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol)); */
		}
		return /* TODO(ConditionalExpression): result?.length ? result             : isFunctionDeclaration(declaration) ? getSignatureOfTypeTag(declaration)?.typeParameters             : undefined */ TODO
	}
	symbolsToArray := func(symbols SymbolTable) []Symbol {
		var result []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(PropertyAccessExpression): symbols.forEach */ TODO( /* TODO(ArrowFunction): (symbol, id) => {             if (!isReservedMemberName(id)) {                 result.push(symbol);             }         } */ TODO)
		return result
	}
	tryFindAmbientModule := func(moduleName string, withAugmentations bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isExternalModuleNameRelative(moduleName) {
			return nil
		}
		symbol := getSymbol(globals /* TODO(PlusToken): + */ /* TODO(BinaryExpression): '"' + moduleName + '"' */, TODO /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): SymbolFlags.ValueModule */, TODO)
		return /* TODO(ConditionalExpression): symbol && withAugmentations ? getMergedSymbol(symbol) : symbol */ TODO
	}
	hasEffectiveQuestionToken := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO(undefined): boolean */ TODO {
		return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node)
	}
	isOptionalParameter := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO(undefined): boolean */ TODO {
		if hasEffectiveQuestionToken(node) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if !isParameter(node) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
			signature := getSignatureFromDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO)
			parameterIndex := /* TODO(PropertyAccessExpression): node.parent.parameters.indexOf */ TODO(node)
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(parameterIndex >= 0)
			return parameterIndex >= getMinArgumentCount(signature /* TODO(BarToken): | */ /* TODO(BinaryExpression): MinArgumentCountFlags.StrongArityForUntypedJS | MinArgumentCountFlags.VoidIsNonOptional */, TODO)
		}
		iife := getImmediatelyInvokedFunctionExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO)
		if iife {
			return ! /* TODO(PropertyAccessExpression): node.type */ TODO && ! /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO && /* TODO(PropertyAccessExpression): node.parent.parameters.indexOf */ TODO(node) >= /* TODO(PropertyAccessExpression): getEffectiveCallArguments(iife).length */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isOptionalPropertyDeclaration := func(node Declaration) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ TODO {
		return isPropertyDeclaration(node) && !hasAccessorModifier(node) && /* TODO(PropertyAccessExpression): node.questionToken */ TODO
	}
	createTypePredicate := func(kind TypePredicateKind, parameterName /* TODO(StringKeyword): string */ any, parameterIndex /* TODO(NumberKeyword): number */ any, type_ *Type) TypePredicate {
		return /* TODO(ObjectLiteralExpression): { kind, parameterName, parameterIndex, type } */ TODO /* as */ /* TODO(TypeReference): TypePredicate */
	}
	getMinTypeArgumentCount := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any) number {
		minTypeArgumentCount := 0
		if typeParameters {
			/* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {                 if (!hasTypeParameterDefault(typeParameters[i])) {                     minTypeArgumentCount = i + 1;                 }             } */
		}
		return minTypeArgumentCount
	}
	// OVERLOAD: fillMissingTypeArguments := func(typeArguments []Type, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) []Type
	// OVERLOAD: fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(ArrayType): Type[] */ any
	fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		numTypeParameters := length(typeParameters)
		if !numTypeParameters {
			return /* TODO(ArrayLiteralExpression): [] */ TODO
		}
		numTypeArguments := length(typeArguments)
		if isJavaScriptImplicitAny || /* TODO(ParenthesizedExpression): (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) */ TODO {
			result := /* TODO(ConditionalExpression): typeArguments ? typeArguments.slice() : [] */ TODO
			/* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 result[i] = errorType;             } */
			baseDefaultType := getDefaultTypeArgumentType(isJavaScriptImplicitAny)
			/* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 let defaultType = getDefaultFromTypeParameter(typeParameters![i]);                 if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {                     defaultType = anyType;                 }                 result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;             } */
			/* TODO(ExpressionStatement): result.length = typeParameters!.length; */
			return result
		}
		return typeArguments && /* TODO(PropertyAccessExpression): typeArguments.slice */ TODO()
	}
	getSignatureFromDeclaration := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) Signature {
		links := getNodeLinks(declaration)
		if ! /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO {
			var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
			flags := /* TODO(PropertyAccessExpression): SignatureFlags.None */ TODO
			minArgumentCount := 0
			var thisParameter *Symbol
			var thisTag *JSDocThisTag = /* TODO(ConditionalExpression): isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined */ TODO
			hasThisParameter := /* TODO(FalseKeyword): false */ TODO
			iife := getImmediatelyInvokedFunctionExpression(declaration)
			isJSConstructSignature := isJSDocConstructSignature(declaration)
			isUntypedSignatureInJSFile := !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration)
			if isUntypedSignatureInJSFile {
				/* TODO(ExpressionStatement): flags |= SignatureFlags.IsUntypedSignatureInJSFile; */
			}
			/* TODO(ForStatement): for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {                 const param = declaration.parameters[i];                 if (isInJSFile(param) && isJSDocThisTag(param)) {                     thisTag = param;                     continue;                 }                  let paramSymbol = param.symbol;                 const type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;                 // Include parameter symbol instead of property symbol in the signature                 if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(param.name)) {                     const resolvedSymbol = resolveName(param, paramSymbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / false);                     paramSymbol = resolvedSymbol!;                 }                 if (i === 0 && paramSymbol.escapedName === InternalSymbolName.This) {                     hasThisParameter = true;                     thisParameter = param.symbol;                 }                 else {                     parameters.push(paramSymbol);                 }                  if (type && type.kind === SyntaxKind.LiteralType) {                     flags |= SignatureFlags.HasLiteralTypes;                 }                  // Record a new minimum argument count if this is not an optional parameter                 const isOptionalParameter = hasEffectiveQuestionToken(param) ||                     isParameter(param) && param.initializer || isRestParameter(param) ||                     iife && parameters.length > iife.arguments.length && !type;                 if (!isOptionalParameter) {                     minArgumentCount = parameters.length;                 }             } */
			if /* TODO(ParenthesizedExpression): (declaration.kind === SyntaxKind.GetAccessor || declaration.kind === SyntaxKind.SetAccessor) */ TODO && hasBindableName(declaration) && /* TODO(ParenthesizedExpression): (!hasThisParameter || !thisParameter) */ TODO {
				otherKind := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
				other := getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind)
				if other {
					/* TODO(ExpressionStatement): thisParameter = getAnnotatedAccessorThisParameter(other); */
				}
			}
			if thisTag && /* TODO(PropertyAccessExpression): thisTag.typeExpression */ TODO {
				/* TODO(ExpressionStatement): thisParameter = createSymbolWithType(createSymbol(SymbolFlags.FunctionScopedVariable, InternalSymbolName.This), getTypeFromTypeNode(thisTag.typeExpression)); */
			}
			hostDeclaration := /* TODO(ConditionalExpression): isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration */ TODO
			classType := /* TODO(ConditionalExpression): hostDeclaration && isConstructorDeclaration(hostDeclaration) ?                 getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol))                 : undefined */ TODO
			typeParameters := /* TODO(ConditionalExpression): classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration) */ TODO
			if hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters) {
				/* TODO(ExpressionStatement): flags |= SignatureFlags.HasRestParameter; */
			}
			if isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) || isConstructorDeclaration(declaration) && hasSyntacticModifier( /* TODO(PropertyAccessExpression): declaration.parent */ TODO /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) {
				/* TODO(ExpressionStatement): flags |= SignatureFlags.Abstract; */
			}
			/* TODO(ExpressionStatement): links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, /*resolvedReturnType* / undefined, /*resolvedTypePredicate* / undefined, minArgumentCount, flags); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO
	}
	maybeAddJsSyntheticRestParameter := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
		if isJSDocSignature(declaration) || !containsArgumentsReference(declaration) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		lastParam := lastOrUndefined( /* TODO(PropertyAccessExpression): declaration.parameters */ TODO)
		lastParamTags := /* TODO(ConditionalExpression): lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag) */ TODO
		lastParamVariadicType := firstDefined(lastParamTags /* TODO(ArrowFunction): p => p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined */, TODO)
		syntheticArgsSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Variable */ TODO, "args" /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): CheckFlags.RestParameter */, TODO)
		if lastParamVariadicType {
			/* TODO(ExpressionStatement): syntheticArgsSymbol.links.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type)); */
		} else {
			/* TODO(ExpressionStatement): syntheticArgsSymbol.links.checkFlags |= CheckFlags.DeferredType; */
			/* TODO(ExpressionStatement): syntheticArgsSymbol.links.deferralParent = neverType; */
			/* TODO(ExpressionStatement): syntheticArgsSymbol.links.deferralConstituents = [anyArrayType]; */
			/* TODO(ExpressionStatement): syntheticArgsSymbol.links.deferralWriteConstituents = [anyArrayType]; */
		}
		if lastParamVariadicType {
			/* TODO(PropertyAccessExpression): parameters.pop */ TODO()
		}
		/* TODO(PropertyAccessExpression): parameters.push */ TODO(syntheticArgsSymbol)
		return /* TODO(TrueKeyword): true */ TODO
	}
	getSignatureOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		if ! /* TODO(ParenthesizedExpression): (isInJSFile(node) && isFunctionLikeDeclaration(node)) */ TODO {
			/* TODO(Identifier): undefined */
		}
		typeTag := getJSDocTypeTag(node)
		return /* TODO(PropertyAccessExpression): typeTag?.typeExpression */ TODO && getSingleCallSignature(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): typeTag.typeExpression */ TODO))
	}
	getParameterTypeOfTypeTag := func(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSignatureOfTypeTag(func_)
		if !signature {
			/* TODO(Identifier): undefined */
		}
		pos := /* TODO(PropertyAccessExpression): func.parameters.indexOf */ TODO(parameter)
		return /* TODO(ConditionalExpression): parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos) */ TODO
	}
	getReturnTypeOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSignatureOfTypeTag(node)
		return signature && getReturnTypeOfSignature(signature)
	}
	containsArgumentsReference := func(declaration SignatureDeclaration) bool {
		links := getNodeLinks(declaration)
		if /* TODO(PropertyAccessExpression): links.containsArgumentsReference */ TODO == nil {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.flags & NodeCheckFlags.CaptureArguments */ TODO {
				/* TODO(ExpressionStatement): links.containsArgumentsReference = true; */
			} else {
				/* TODO(ExpressionStatement): links.containsArgumentsReference = traverse((declaration as FunctionLikeDeclaration).body!); */
			}
		}
		return /* TODO(PropertyAccessExpression): links.containsArgumentsReference */ TODO
		traverse := func(node Node) bool {
			if !node {
				/* TODO(FalseKeyword): false */
			}
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.Identifier:                     return (node as Identifier).escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node as Identifier) === argumentsSymbol;                  case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     return (node as NamedDeclaration).name!.kind === SyntaxKind.ComputedPropertyName                         && traverse((node as NamedDeclaration).name!);                  case SyntaxKind.PropertyAccessExpression:                 case SyntaxKind.ElementAccessExpression:                     return traverse((node as PropertyAccessExpression | ElementAccessExpression).expression);                  case SyntaxKind.PropertyAssignment:                     return traverse((node as PropertyAssignment).initializer);                  default:                     return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);             } */
		}
	}
	getSignaturesOfSymbol := func(symbol *Symbol) []Signature {
		if !symbol || ! /* TODO(PropertyAccessExpression): symbol.declarations */ TODO {
			/* TODO(Identifier): emptyArray */
		}
		var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < symbol.declarations.length; i++) {             const decl = symbol.declarations[i];             if (!isFunctionLike(decl)) continue;             // Don't include signature if node is the implementation of an overloaded function. A node is considered             // an implementation node if it has a body and the previous node is of the same kind and immediately             // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).             if (i > 0 && (decl as FunctionLikeDeclaration).body) {                 const previous = symbol.declarations[i - 1];                 if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {                     continue;                 }             }             if (isInJSFile(decl) && decl.jsDoc) {                 const tags = getJSDocOverloadTags(decl);                 if (length(tags)) {                     for (const tag of tags) {                         const jsDocSignature = tag.typeExpression;                         if (jsDocSignature.type === undefined && !isConstructorDeclaration(decl)) {                             reportImplicitAny(jsDocSignature, anyType);                         }                         result.push(getSignatureFromDeclaration(jsDocSignature));                     }                     continue;                 }             }             // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.             // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.             result.push(                 (!isFunctionExpressionOrArrowFunction(decl) &&                     !isObjectLiteralMethod(decl) &&                     getSignatureOfTypeTag(decl)) ||                     getSignatureFromDeclaration(decl),             );         } */
		return result
	}
	resolveExternalModuleTypeByLiteral := func(name StringLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		moduleSym := resolveExternalModuleName(name, name)
		if moduleSym {
			resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
			if resolvedModuleSymbol {
				return getTypeOfSymbol(resolvedModuleSymbol)
			}
		}
		return anyType
	}
	getThisTypeOfSignature := func(signature Signature) *Type {
		if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
			return getTypeOfSymbol( /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO)
		}
	}
	getTypePredicateOfSignature := func(signature Signature) *TypePredicate {
		if ! /* TODO(PropertyAccessExpression): signature.resolvedTypePredicate */ TODO {
			if /* TODO(PropertyAccessExpression): signature.target */ TODO {
				targetTypePredicate := getTypePredicateOfSignature( /* TODO(PropertyAccessExpression): signature.target */ TODO)
				/* TODO(ExpressionStatement): signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate; */
			} else if /* TODO(PropertyAccessExpression): signature.compositeSignatures */ TODO {
				/* TODO(ExpressionStatement): signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate; */
			} else {
				type_ := /* TODO(PropertyAccessExpression): signature.declaration */ TODO && getEffectiveReturnTypeNode( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
				var jsdocPredicate *TypePredicate
				if !type_ {
					jsdocSignature := getSignatureOfTypeTag( /* TODO(NonNullExpression): signature.declaration! */ TODO)
					if jsdocSignature && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signature !== jsdocSignature */ TODO {
						/* TODO(ExpressionStatement): jsdocPredicate = getTypePredicateOfSignature(jsdocSignature); */
					}
				}
				if type_ || jsdocPredicate {
					/* TODO(ExpressionStatement): signature.resolvedTypePredicate = type && isTypePredicateNode(type) ?                         createTypePredicateFromTypePredicateNode(type, signature) :                         jsdocPredicate || noTypePredicate; */
				} else if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && isFunctionLikeDeclaration( /* TODO(PropertyAccessExpression): signature.declaration */ TODO) && /* TODO(ParenthesizedExpression): (!signature.resolvedReturnType || signature.resolvedReturnType.flags & TypeFlags.Boolean) */ TODO && getParameterCount(signature) > 0 {
					TODO_IDENTIFIER := signature
					/* TODO(ExpressionStatement): signature.resolvedTypePredicate = noTypePredicate; */
					/* TODO(ExpressionStatement): signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate; */
				} else {
					/* TODO(ExpressionStatement): signature.resolvedTypePredicate = noTypePredicate; */
				}
			}
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(PropertyAccessExpression): signature.resolvedTypePredicate */ TODO)
		}
		return /* TODO(ConditionalExpression): signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate */ TODO
	}
	createTypePredicateFromTypePredicateNode := func(node TypePredicateNode, signature Signature) TypePredicate {
		parameterName := /* TODO(PropertyAccessExpression): node.parameterName */ TODO
		type_ := /* TODO(PropertyAccessExpression): node.type */ TODO && getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.type */ TODO)
		return /* TODO(ConditionalExpression): parameterName.kind === SyntaxKind.ThisType ?             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, /*parameterName* / undefined, /*parameterIndex* / undefined, type) :             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier, parameterName.escapedText as string, findIndex(signature.parameters, p => p.escapedName === parameterName.escapedText), type) */ TODO
	}
	getUnionOrIntersectionType := func(types []Type, kind *TypeFlags, unionReduction UnionReduction) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getUnionType(types, unionReduction) : getIntersectionType(types) */ TODO
	}
	getReturnTypeOfSignature := func(signature Signature) Type {
		if ! /* TODO(PropertyAccessExpression): signature.resolvedReturnType */ TODO {
			if !pushTypeResolution(signature /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ResolvedReturnType */, TODO) {
				return errorType
			}
			type_ := /* TODO(ConditionalExpression): signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :                 signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) :                 getReturnTypeFromAnnotation(signature.declaration!) ||                 (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration)) */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsInnerCallChain */ TODO {
				/* TODO(ExpressionStatement): type = addOptionalTypeMarker(type); */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsOuterCallChain */ TODO {
				/* TODO(ExpressionStatement): type = getOptionalType(type); */
			}
			if !popTypeResolution() {
				if /* TODO(PropertyAccessExpression): signature.declaration */ TODO {
					typeNode := getEffectiveReturnTypeNode( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
					if typeNode {
						error(typeNode /* TODO(PropertyAccessExpression): Diagnostics.Return_type_annotation_circularly_references_itself */, TODO)
					} else if noImplicitAny {
						declaration := /* TODO(PropertyAccessExpression): signature.declaration */ TODO /* as */ /* TODO(TypeReference): Declaration */
						name := getNameOfDeclaration(declaration)
						if name {
							error(name /* TODO(PropertyAccessExpression): Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions */, TODO, declarationNameToString(name))
						} else {
							error(declaration /* TODO(PropertyAccessExpression): Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions */, TODO)
						}
					}
				}
				/* TODO(ExpressionStatement): type = anyType; */
			}
			/* TODO(ExpressionStatement): signature.resolvedReturnType ??= type; */
		}
		return /* TODO(PropertyAccessExpression): signature.resolvedReturnType */ TODO
	}
	getReturnTypeFromAnnotation := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
			return getDeclaredTypeOfClassOrInterface(getMergedSymbol( /* TODO(PropertyAccessExpression): (declaration.parent as ClassDeclaration).symbol */ TODO))
		}
		typeNode := getEffectiveReturnTypeNode(declaration)
		if isJSDocSignature(declaration) {
			root := getJSDocRoot(declaration)
			if root && isConstructorDeclaration( /* TODO(PropertyAccessExpression): root.parent */ TODO) && !typeNode {
				return getDeclaredTypeOfClassOrInterface(getMergedSymbol( /* TODO(PropertyAccessExpression): (root.parent.parent as ClassDeclaration).symbol */ TODO))
			}
		}
		if isJSDocConstructSignature(declaration) {
			return getTypeFromTypeNode( /* TODO(NonNullExpression): (declaration.parameters[0] as ParameterDeclaration).type! */ TODO)
		}
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		if /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO && hasBindableName(declaration) {
			jsDocType := isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration)
			if jsDocType {
				return jsDocType
			}
			setter := getDeclarationOfKind(getSymbolOfDeclaration(declaration) /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */, TODO)
			setterType := getAnnotatedAccessorType(setter)
			if setterType {
				return setterType
			}
		}
		return getReturnTypeOfTypeTag(declaration)
	}
	isResolvingReturnTypeOfSignature := func(signature Signature) bool {
		return /* TODO(PropertyAccessExpression): signature.compositeSignatures */ TODO && some( /* TODO(PropertyAccessExpression): signature.compositeSignatures */ TODO, isResolvingReturnTypeOfSignature) || ! /* TODO(PropertyAccessExpression): signature.resolvedReturnType */ TODO && findResolutionCycleStartIndex(signature /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ResolvedReturnType */, TODO) >= 0
	}
	getRestTypeOfSignature := func(signature Signature) Type {
		return tryGetRestTypeOfSignature(signature) || anyType
	}
	tryGetRestTypeOfSignature := func(signature Signature) *Type {
		if signatureHasRestParameter(signature) {
			sigRestType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			restType := /* TODO(ConditionalExpression): isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType */ TODO
			return restType && getIndexTypeOfType(restType, numberType)
		}
		return nil
	}
	getSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
		instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments /* TODO(PropertyAccessExpression): signature.typeParameters */, TODO, getMinTypeArgumentCount( /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO), isJavascript))
		if inferredTypeParameters {
			returnSignature := getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature))
			if returnSignature {
				newReturnSignature := cloneSignature(returnSignature)
				/* TODO(ExpressionStatement): newReturnSignature.typeParameters = inferredTypeParameters; */
				newInstantiatedSignature := cloneSignature(instantiatedSignature)
				/* TODO(ExpressionStatement): newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature); */
				return newInstantiatedSignature
			}
		}
		return instantiatedSignature
	}
	getSignatureInstantiationWithoutFillingInTypeArguments := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
		instantiations := /* TODO(PropertyAccessExpression): signature.instantiations */ TODO || /* TODO(ParenthesizedExpression): (signature.instantiations = new Map<string, Signature>()) */ TODO
		id := getTypeListId(typeArguments)
		instantiation := /* TODO(PropertyAccessExpression): instantiations.get */ TODO(id)
		if !instantiation {
			/* TODO(PropertyAccessExpression): instantiations.set */ TODO(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): instantiation = createSignatureInstantiation(signature, typeArguments) */, TODO)
		}
		return instantiation
	}
	createSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
		return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments) /* TODO(TrueKeyword): true */, TODO)
	}
	getTypeParametersForMapper := func(signature Signature) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		return sameMap( /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO /* TODO(ArrowFunction): tp => tp.mapper ? instantiateType(tp, tp.mapper) : tp */, TODO)
	}
	createSignatureTypeMapper := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return createTypeMapper( /* TODO(NonNullExpression): getTypeParametersForMapper(signature)! */ TODO, typeArguments)
	}
	getErasedSignature := func(signature Signature) Signature {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :             signature */ TODO
	}
	createErasedSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return instantiateSignature(signature, createTypeEraser( /* TODO(NonNullExpression): signature.typeParameters! */ TODO) /* TODO(TrueKeyword): true */, TODO)
	}
	getCanonicalSignature := func(signature Signature) Signature {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :             signature */ TODO
	}
	createCanonicalSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return getSignatureInstantiation(signature, map_( /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO /* TODO(ArrowFunction): tp => tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp */, TODO), isInJSFile( /* TODO(PropertyAccessExpression): signature.declaration */ TODO))
	}
	getImplementationSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.implementationSignatureCache ||= createImplementationSignature(signature) :             signature */ TODO
	}
	createImplementationSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return /* TODO(ConditionalExpression): signature.typeParameters ? instantiateSignature(signature, createTypeMapper([], [])) : signature */ TODO
	}
	getBaseSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		typeParameters := /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO
		if typeParameters {
			if /* TODO(PropertyAccessExpression): signature.baseSignatureCache */ TODO {
				return /* TODO(PropertyAccessExpression): signature.baseSignatureCache */ TODO
			}
			typeEraser := createTypeEraser(typeParameters)
			baseConstraintMapper := createTypeMapper(typeParameters, map_(typeParameters /* TODO(ArrowFunction): tp => getConstraintOfTypeParameter(tp) || unknownType */, TODO))
			var baseConstraints []Type = map_(typeParameters /* TODO(ArrowFunction): tp => instantiateType(tp, baseConstraintMapper) || unknownType */, TODO)
			/* TODO(ForStatement): for (let i = 0; i < typeParameters.length - 1; i++) {                 baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);             } */
			/* TODO(ExpressionStatement): baseConstraints = instantiateTypes(baseConstraints, typeEraser); */
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters* / true) */ TODO
		}
		return signature
	}
	getOrCreateTypeFromSignature := func(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
		if ! /* TODO(PropertyAccessExpression): signature.isolatedSignatureType */ TODO {
			kind := /* TODO(PropertyAccessExpression): signature.declaration?.kind */ TODO
			isConstructor := kind == nil || kind == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO || kind == /* TODO(PropertyAccessExpression): SyntaxKind.ConstructSignature */ TODO || kind == /* TODO(PropertyAccessExpression): SyntaxKind.ConstructorType */ TODO
			type_ := createObjectType( /* TODO(BarToken): | */ /* TODO(BinaryExpression): ObjectFlags.Anonymous | ObjectFlags.SingleSignatureType */ TODO, createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Function */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Function */, TODO)) /* as */ /* TODO(TypeReference): SingleSignatureType */
			if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && !nodeIsSynthesized( /* TODO(PropertyAccessExpression): signature.declaration */ TODO) {
				/* TODO(ExpressionStatement): type.symbol.declarations = [signature.declaration]; */
				/* TODO(ExpressionStatement): type.symbol.valueDeclaration = signature.declaration; */
			}
			/* TODO(ExpressionStatement): outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes* / true); */
			/* TODO(ExpressionStatement): type.outerTypeParameters = outerTypeParameters; */
			/* TODO(ExpressionStatement): type.members = emptySymbols; */
			/* TODO(ExpressionStatement): type.properties = emptyArray; */
			/* TODO(ExpressionStatement): type.callSignatures = !isConstructor ? [signature] : emptyArray; */
			/* TODO(ExpressionStatement): type.constructSignatures = isConstructor ? [signature] : emptyArray; */
			/* TODO(ExpressionStatement): type.indexInfos = emptyArray; */
			/* TODO(ExpressionStatement): signature.isolatedSignatureType = type; */
		}
		return /* TODO(PropertyAccessExpression): signature.isolatedSignatureType */ TODO
	}
	getIndexSymbol := func(symbol Symbol) *Symbol {
		return /* TODO(ConditionalExpression): symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined */ TODO
	}
	getIndexSymbolFromSymbolTable := func(symbolTable SymbolTable) *Symbol {
		return /* TODO(PropertyAccessExpression): symbolTable.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.Index */ TODO)
	}
	createIndexInfo := func(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
		return /* TODO(ObjectLiteralExpression): { keyType, type, isReadonly, declaration } */ TODO
	}
	getIndexInfosOfSymbol := func(symbol Symbol) []IndexInfo {
		indexSymbol := getIndexSymbol(symbol)
		return /* TODO(ConditionalExpression): indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray */ TODO
	}
	getIndexInfosOfIndexSymbol := func(indexSymbol Symbol) []IndexInfo {
		if /* TODO(PropertyAccessExpression): indexSymbol.declarations */ TODO {
			var indexInfos []IndexInfo = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, declaration := range /* TODO(ParenthesizedExpression): (indexSymbol.declarations as IndexSignatureDeclaration[]) */ TODO {
				if /* TODO(PropertyAccessExpression): declaration.parameters.length */ TODO == 1 {
					parameter := /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO
					if /* TODO(PropertyAccessExpression): parameter.type */ TODO {
						forEachType(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): parameter.type */ TODO) /* TODO(ArrowFunction): keyType => {                             if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType)) {                                 indexInfos.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, hasEffectiveModifier(declaration, ModifierFlags.Readonly), declaration));                             }                         } */, TODO)
					}
				}
			}
			return indexInfos
		}
		return emptyArray
	}
	isValidIndexKeyType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.ESSymbol)) */ TODO || isPatternLiteralType(type_) || !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Intersection) */ TODO && !isGenericType(type_) && some( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, isValidIndexKeyType)
	}
	getConstraintDeclaration := func(type_ TypeParameter) *TypeNode {
		return /* TODO(ElementAccessExpression): mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0] */ TODO
	}
	getInferredTypeParameterConstraint := func(typeParameter TypeParameter, omitTypeReferences bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var inferences /* TODO(ArrayType): Type[] */ any
		if /* TODO(PropertyAccessExpression): typeParameter.symbol?.declarations */ TODO {
			for _, declaration := range /* TODO(PropertyAccessExpression): typeParameter.symbol.declarations */ TODO {
				if /* TODO(PropertyAccessExpression): declaration.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InferType */ TODO {
					TODO_IDENTIFIER := walkUpParenthesizedTypesAndGetParentAndChild( /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO)
					if /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeReference */ TODO && !omitTypeReferences {
						typeReference := grandParent /* as */ /* TODO(TypeReference): TypeReferenceNode */
						typeParameters := getTypeParametersForTypeReferenceOrImport(typeReference)
						if typeParameters {
							index := /* TODO(PropertyAccessExpression): typeReference.typeArguments!.indexOf */ TODO(childTypeParameter /* as */ /* TODO(TypeReference): TypeNode */)
							if index < /* TODO(PropertyAccessExpression): typeParameters.length */ TODO {
								declaredConstraint := getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[index] */ TODO)
								if declaredConstraint {
									mapper := makeDeferredTypeMapper(typeParameters /* TODO(PropertyAccessExpression): typeParameters.map */, TODO( /* TODO(ArrowFunction): (_, index) => () => {                                             return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index);                                         } */ TODO))
									constraint := instantiateType(declaredConstraint, mapper)
									if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== typeParameter */ TODO {
										/* TODO(ExpressionStatement): inferences = append(inferences, constraint); */
									}
								}
							}
						}
					} else if /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO && /* TODO(PropertyAccessExpression): (grandParent as ParameterDeclaration).dotDotDotToken */ TODO || /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.RestType */ TODO || /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamedTupleMember */ TODO && /* TODO(PropertyAccessExpression): (grandParent as NamedTupleMember).dotDotDotToken */ TODO {
						/* TODO(ExpressionStatement): inferences = append(inferences, createArrayType(unknownType)); */
					} else if /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TemplateLiteralTypeSpan */ TODO {
						/* TODO(ExpressionStatement): inferences = append(inferences, stringType); */
					} else if /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeParameter */ TODO && /* TODO(PropertyAccessExpression): grandParent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MappedType */ TODO {
						/* TODO(ExpressionStatement): inferences = append(inferences, stringNumberSymbolType); */
					} else if /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MappedType */ TODO && /* TODO(PropertyAccessExpression): (grandParent as MappedTypeNode).type */ TODO && skipParentheses( /* TODO(NonNullExpression): (grandParent as MappedTypeNode).type! */ TODO) == /* TODO(PropertyAccessExpression): declaration.parent */ TODO && /* TODO(PropertyAccessExpression): grandParent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ConditionalType */ TODO && /* TODO(PropertyAccessExpression): (grandParent.parent as ConditionalTypeNode).extendsType */ TODO == grandParent && /* TODO(PropertyAccessExpression): (grandParent.parent as ConditionalTypeNode).checkType.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MappedType */ TODO && /* TODO(PropertyAccessExpression): ((grandParent.parent as ConditionalTypeNode).checkType as MappedTypeNode).type */ TODO {
						checkMappedType := /* TODO(PropertyAccessExpression): (grandParent.parent as ConditionalTypeNode).checkType */ TODO /* as */ /* TODO(TypeReference): MappedTypeNode */
						nodeType := getTypeFromTypeNode( /* TODO(NonNullExpression): checkMappedType.type! */ TODO)
						/* TODO(ExpressionStatement): inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)), checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType))); */
					}
				}
			}
		}
		return inferences && getIntersectionType(inferences)
	}
	getConstraintFromTypeParameter := func(typeParameter TypeParameter) *Type {
		if ! /* TODO(PropertyAccessExpression): typeParameter.constraint */ TODO {
			if /* TODO(PropertyAccessExpression): typeParameter.target */ TODO {
				targetConstraint := getConstraintOfTypeParameter( /* TODO(PropertyAccessExpression): typeParameter.target */ TODO)
				/* TODO(ExpressionStatement): typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType; */
			} else {
				constraintDeclaration := getConstraintDeclaration(typeParameter)
				if !constraintDeclaration {
					/* TODO(ExpressionStatement): typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType; */
				} else {
					type_ := getTypeFromTypeNode(constraintDeclaration)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO && !isErrorType(type_) {
						/* TODO(ExpressionStatement): type = constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType; */
					}
					/* TODO(ExpressionStatement): typeParameter.constraint = type; */
				}
			}
		}
		return /* TODO(ConditionalExpression): typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint */ TODO
	}
	getParentSymbolOfTypeParameter := func(typeParameter TypeParameter) *Symbol {
		tp := /* TODO(NonNullExpression): getDeclarationOfKind<TypeParameterDeclaration>(typeParameter.symbol, SyntaxKind.TypeParameter)! */ TODO
		host := /* TODO(ConditionalExpression): isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent */ TODO
		return host && getSymbolOfNode(host)
	}
	getTypeListId := func(types /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): string */ TODO {
		result := ""
		if types {
			length := /* TODO(PropertyAccessExpression): types.length */ TODO
			i := 0
			/* TODO(WhileStatement): while (i < length) {                 const startId = types[i].id;                 let count = 1;                 while (i + count < length && types[i + count].id === startId + count) {                     count++;                 }                 if (result.length) {                     result += ",";                 }                 result += startId;                 if (count > 1) {                     result += ":" + count;                 }                 i += count;             } */
		}
		return result
	}
	getAliasId := func(aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): string */ TODO {
		return /* TODO(ConditionalExpression): aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "" */ TODO
	}
	getPropagatingFlagsOfTypes := func(types []Type, excludeKinds TypeFlags) ObjectFlags {
		var result ObjectFlags = 0
		for _, type_ := range types {
			if excludeKinds == nil || ! /* TODO(ParenthesizedExpression): (type.flags & excludeKinds) */ TODO {
				/* TODO(ExpressionStatement): result |= getObjectFlags(type); */
			}
		}
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result & ObjectFlags.PropagatingFlags */ TODO
	}
	tryCreateTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		if some(typeArguments) && target == emptyGenericType {
			return unknownType
		}
		return createTypeReference(target, typeArguments)
	}
	createTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeReference {
		id := getTypeListId(typeArguments)
		type_ := /* TODO(PropertyAccessExpression): target.instantiations.get */ TODO(id)
		if !type_ {
			/* TODO(ExpressionStatement): type = createObjectType(ObjectFlags.Reference, target.symbol) as TypeReference; */
			/* TODO(PropertyAccessExpression): target.instantiations.set */
			TODO(id, type_)
			/* TODO(ExpressionStatement): type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0; */
			/* TODO(ExpressionStatement): type.target = target; */
			/* TODO(ExpressionStatement): type.resolvedTypeArguments = typeArguments; */
		}
		return type_
	}
	cloneTypeReference := func(source TypeReference) TypeReference {
		type_ := createTypeWithSymbol( /* TODO(PropertyAccessExpression): source.flags */ TODO /* TODO(PropertyAccessExpression): source.symbol */, TODO) /* as */ /* TODO(TypeReference): TypeReference */
		/* TODO(ExpressionStatement): type.objectFlags = source.objectFlags; */
		/* TODO(ExpressionStatement): type.target = source.target; */
		/* TODO(ExpressionStatement): type.resolvedTypeArguments = source.resolvedTypeArguments; */
		return type_
	}
	createDeferredTypeReference := func(target GenericType, node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
		if !aliasSymbol {
			/* TODO(ExpressionStatement): aliasSymbol = getAliasSymbolForTypeNode(node); */
			localAliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			/* TODO(ExpressionStatement): aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments; */
		}
		type_ := createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.Reference */ TODO /* TODO(PropertyAccessExpression): target.symbol */, TODO) /* as */ /* TODO(TypeReference): DeferredTypeReference */
		/* TODO(ExpressionStatement): type.target = target; */
		/* TODO(ExpressionStatement): type.node = node; */
		/* TODO(ExpressionStatement): type.mapper = mapper; */
		/* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
		/* TODO(ExpressionStatement): type.aliasTypeArguments = aliasTypeArguments; */
		return type_
	}
	getTypeArguments := func(type_ TypeReference) []Type {
		if ! /* TODO(PropertyAccessExpression): type.resolvedTypeArguments */ TODO {
			if !pushTypeResolution(type_ /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ResolvedTypeArguments */, TODO) {
				return concatenate( /* TODO(PropertyAccessExpression): type.target.outerTypeParameters */ TODO /* TODO(PropertyAccessExpression): type.target.localTypeParameters?.map */, TODO( /* TODO(ArrowFunction): () => errorType */ TODO)) || emptyArray
			}
			node := /* TODO(PropertyAccessExpression): type.node */ TODO
			typeArguments := /* TODO(ConditionalExpression): !node ? emptyArray :                 node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) :                 node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] :                 map(node.elements, getTypeFromTypeNode) */ TODO
			if popTypeResolution() {
				/* TODO(ExpressionStatement): type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments; */
			} else {
				/* TODO(ExpressionStatement): type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray); */
				error( /* TODO(PropertyAccessExpression): type.node */ TODO || currentNode /* TODO(ConditionalExpression): type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves */, TODO /* TODO(PropertyAccessExpression): type.target.symbol */, TODO && symbolToString( /* TODO(PropertyAccessExpression): type.target.symbol */ TODO))
			}
		}
		return /* TODO(PropertyAccessExpression): type.resolvedTypeArguments */ TODO
	}
	getTypeReferenceArity := func(type_ TypeReference) number {
		return length( /* TODO(PropertyAccessExpression): type.target.typeParameters */ TODO)
	}
	getTypeFromClassOrInterfaceReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		type_ := getDeclaredTypeOfSymbol(getMergedSymbol(symbol)) /* as */ /* TODO(TypeReference): InterfaceType */
		typeParameters := /* TODO(PropertyAccessExpression): type.localTypeParameters */ TODO
		if typeParameters {
			numTypeArguments := length( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			isJs := isInJSFile(node)
			isJsImplicitAny := !noImplicitAny && isJs
			if !isJsImplicitAny && /* TODO(ParenthesizedExpression): (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) */ TODO {
				missingAugmentsTag := isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag( /* TODO(PropertyAccessExpression): node.parent */ TODO)
				diag := /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                     missingAugmentsTag ?                         Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                     missingAugmentsTag ?                     Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :                     Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */ TODO
				typeStr := typeToString(type_, nil /* TODO(PropertyAccessExpression): TypeFormatFlags.WriteArrayAsGenericType */, TODO)
				error(node, diag, typeStr, minTypeArgumentCount /* TODO(PropertyAccessExpression): typeParameters.length */, TODO)
				if !isJs {
					return errorType
				}
			}
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeReference */ TODO && isDeferredTypeReferenceNode(node /* as */ /* TODO(TypeReference): TypeReferenceNode */ /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(node.typeArguments) !== typeParameters.length */, TODO) {
				return createDeferredTypeReference(type_ /* as */ /* TODO(TypeReference): GenericType */, node /* as */ /* TODO(TypeReference): TypeReferenceNode */, nil)
			}
			typeArguments := concatenate( /* TODO(PropertyAccessExpression): type.outerTypeParameters */ TODO, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
			return createTypeReference(type_ /* as */ /* TODO(TypeReference): GenericType */, typeArguments)
		}
		return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
	}
	getTypeAliasInstantiation := func(symbol Symbol, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		type_ := getDeclaredTypeOfSymbol(symbol)
		if type_ == intrinsicMarkerType {
			typeKind := /* TODO(PropertyAccessExpression): intrinsicTypeKinds.get */ TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO /* as */ /* TODO(StringKeyword): string */)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeKind !== undefined */ TODO && typeArguments && /* TODO(PropertyAccessExpression): typeArguments.length */ TODO == 1 {
				return /* TODO(ConditionalExpression): typeKind === IntrinsicTypeKind.NoInfer ? getNoInferType(typeArguments[0]) : getStringMappingType(symbol, typeArguments[0]) */ TODO
			}
		}
		links := getSymbolLinks(symbol)
		typeParameters := /* TODO(NonNullExpression): links.typeParameters! */ TODO
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
		instantiation := /* TODO(PropertyAccessExpression): links.instantiations!.get */ TODO(id)
		if !instantiation {
			/* TODO(PropertyAccessExpression): links.instantiations!.set */ TODO(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments) */, TODO)
		}
		return instantiation
	}
	getTypeFromTypeAliasReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Unresolved */ TODO {
			typeArguments := typeArgumentsFromTypeReferenceNode(node)
			id := getAliasId(symbol, typeArguments)
			errorType := /* TODO(PropertyAccessExpression): errorTypes.get */ TODO(id)
			if !errorType {
				/* TODO(ExpressionStatement): errorType = createIntrinsicType(TypeFlags.Any, "error", /*objectFlags* / undefined, `alias ${id}`); */
				/* TODO(ExpressionStatement): errorType.aliasSymbol = symbol; */
				/* TODO(ExpressionStatement): errorType.aliasTypeArguments = typeArguments; */
				/* TODO(PropertyAccessExpression): errorTypes.set */
				TODO(id, errorType)
			}
			return errorType
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeParameters := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */ TODO
		if typeParameters {
			numTypeArguments := length( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			if numTypeArguments < minTypeArgumentCount || numTypeArguments > /* TODO(PropertyAccessExpression): typeParameters.length */ TODO {
				error(node /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */, TODO, symbolToString(symbol), minTypeArgumentCount /* TODO(PropertyAccessExpression): typeParameters.length */, TODO)
				return errorType
			}
			aliasSymbol := getAliasSymbolForTypeNode(node)
			newAliasSymbol := /* TODO(ConditionalExpression): aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined */ TODO
			var aliasTypeArguments /* TODO(ArrayType): Type[] */ any
			if newAliasSymbol {
				/* TODO(ExpressionStatement): aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol); */
			} else if isTypeReferenceType(node) {
				aliasSymbol := resolveTypeReferenceName(node /* TODO(PropertyAccessExpression): SymbolFlags.Alias */, TODO /* TODO(TrueKeyword): true */, TODO)
				if aliasSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): aliasSymbol !== unknownSymbol */ TODO {
					resolved := resolveAlias(aliasSymbol)
					if resolved && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): resolved.flags & SymbolFlags.TypeAlias */ TODO {
						/* TODO(ExpressionStatement): newAliasSymbol = resolved; */
						/* TODO(ExpressionStatement): aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || (typeParameters ? [] : undefined); */
					}
				}
			}
			return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
		}
		return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
	}
	isLocalTypeAlias := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		declaration := /* TODO(PropertyAccessExpression): symbol.declarations?.find */ TODO(isTypeAlias)
		return !! /* TODO(ParenthesizedExpression): (declaration && getContainingFunction(declaration)) */ TODO
	}
	getTypeReferenceName := func(node TypeReferenceType) *EntityNameOrEntityNameExpression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.TypeReference:                 return node.typeName;             case SyntaxKind.ExpressionWithTypeArguments:                 // We only support expressions that are simple qualified names. For other                 // expressions this produces undefined.                 const expr = node.expression;                 if (isEntityNameExpression(expr)) {                     return expr;                 }                 // fall through;         } */
		return nil
	}
	getSymbolPath := func(symbol Symbol) string {
		return /* TODO(ConditionalExpression): symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` : symbol.escapedName as string */ TODO
	}
	getUnresolvedSymbolForEntityName := func(name EntityNameOrEntityNameExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		identifier := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right :             name.kind === SyntaxKind.PropertyAccessExpression ? name.name :             name */ TODO
		text := /* TODO(PropertyAccessExpression): identifier.escapedText */ TODO
		if text {
			parentSymbol := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :                 name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :                 undefined */ TODO
			path := /* TODO(ConditionalExpression): parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string */ TODO
			result := /* TODO(PropertyAccessExpression): unresolvedSymbols.get */ TODO(path)
			if !result {
				/* TODO(PropertyAccessExpression): unresolvedSymbols.set */ TODO(path /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved) */, TODO)
				/* TODO(ExpressionStatement): result.parent = parentSymbol; */
				/* TODO(ExpressionStatement): result.links.declaredType = unresolvedType; */
			}
			return result
		}
		return unknownSymbol
	}
	resolveTypeReferenceName := func(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		name := getTypeReferenceName(typeReference)
		if !name {
			return unknownSymbol
		}
		symbol := resolveEntityName(name, meaning, ignoreErrors)
		return /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol :             ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name) */ TODO
	}
	getTypeReferenceType := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if symbol == unknownSymbol {
			return errorType
		}
		/* TODO(ExpressionStatement): symbol = getExpandoSymbol(symbol) || symbol; */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Class | SymbolFlags.Interface) */ TODO {
			return getTypeFromClassOrInterfaceReference(node, symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO {
			return getTypeFromTypeAliasReference(node, symbol)
		}
		res := tryGetDeclaredTypeOfSymbol(symbol)
		if res {
			return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Value */ TODO && isJSDocTypeReference(node) {
			jsdocType := getTypeFromJSDocValueReference(node, symbol)
			if jsdocType {
				return jsdocType
			} else {
				resolveTypeReferenceName(node /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
				return getTypeOfSymbol(symbol)
			}
		}
		return errorType
	}
	getTypeFromJSDocValueReference := func(node NodeWithTypeArguments, symbol Symbol) *Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedJSDocType */ TODO {
			valueType := getTypeOfSymbol(symbol)
			typeType := valueType
			if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
				isImportTypeWithQualifier := /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportType */ TODO && /* TODO(PropertyAccessExpression): (node as ImportTypeNode).qualifier */ TODO
				if /* TODO(PropertyAccessExpression): valueType.symbol */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): valueType.symbol !== symbol */ TODO && isImportTypeWithQualifier {
					/* TODO(ExpressionStatement): typeType = getTypeReferenceType(node, valueType.symbol); */
				}
			}
			/* TODO(ExpressionStatement): links.resolvedJSDocType = typeType; */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedJSDocType */ TODO
	}
	getNoInferType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNoInferTargetType(type) ? getOrCreateSubstitutionType(type, unknownType) : type */ TODO
	}
	isNoInferTargetType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, isNoInferTargetType) ||             type.flags & TypeFlags.Substitution && !isNoInferType(type) && isNoInferTargetType((type as SubstitutionType).baseType) ||             type.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(type) ||             type.flags & (TypeFlags.Instantiable & ~TypeFlags.Substitution) && !isPatternLiteralType(type)) */ TODO
	}
	isNoInferType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Substitution && (type as SubstitutionType).constraint.flags & TypeFlags.Unknown) */ TODO
	}
	getSubstitutionType := func(baseType Type, constraint Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): constraint.flags & TypeFlags.AnyOrUnknown || constraint === baseType || baseType.flags & TypeFlags.Any ?             baseType :             getOrCreateSubstitutionType(baseType, constraint) */ TODO
	}
	getOrCreateSubstitutionType := func(baseType Type, constraint Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SubstitutionType */ TODO {
		id := /* TODO(TemplateExpression): `${getTypeId(baseType)}>${getTypeId(constraint)}` */ TODO
		cached := /* TODO(PropertyAccessExpression): substitutionTypes.get */ TODO(id)
		if cached {
			return cached
		}
		result := createType( /* TODO(PropertyAccessExpression): TypeFlags.Substitution */ TODO) /* as */ /* TODO(TypeReference): SubstitutionType */
		/* TODO(ExpressionStatement): result.baseType = baseType; */
		/* TODO(ExpressionStatement): result.constraint = constraint; */
		/* TODO(PropertyAccessExpression): substitutionTypes.set */
		TODO(id, result)
		return result
	}
	getSubstitutionIntersection := func(substitutionType SubstitutionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNoInferType(substitutionType) ? substitutionType.baseType : getIntersectionType([substitutionType.constraint, substitutionType.baseType]) */ TODO
	}
	isUnaryTupleTypeNode := func(node TypeNode) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TupleType */ TODO && /* TODO(PropertyAccessExpression): (node as TupleTypeNode).elements.length */ TODO == 1
	}
	getImpliedConstraint := func(type_ Type, checkNode TypeNode, extendsNode TypeNode) *Type {
		return /* TODO(ConditionalExpression): isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, (checkNode as TupleTypeNode).elements[0], (extendsNode as TupleTypeNode).elements[0]) :             getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :             undefined */ TODO
	}
	getConditionalFlowTypeOfType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var constraints /* TODO(ArrayType): Type[] */ any
		covariant := /* TODO(TrueKeyword): true */ TODO
		/* TODO(WhileStatement): while (node && !isStatement(node) && node.kind !== SyntaxKind.JSDoc) {             const parent = node.parent;             // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but             // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax             if (parent.kind === SyntaxKind.Parameter) {                 covariant = !covariant;             }             // Always substitute on type parameters, regardless of variance, since even             // in contravariant positions, they may rely on substituted constraints to be valid             if ((covariant || type.flags & TypeFlags.TypeVariable) && parent.kind === SyntaxKind.ConditionalType && node === (parent as ConditionalTypeNode).trueType) {                 const constraint = getImpliedConstraint(type, (parent as ConditionalTypeNode).checkType, (parent as ConditionalTypeNode).extendsType);                 if (constraint) {                     constraints = append(constraints, constraint);                 }             }             // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the             // template type XXX, K has an added constraint of number | `${number}`.             else if (type.flags & TypeFlags.TypeParameter && parent.kind === SyntaxKind.MappedType && !(parent as MappedTypeNode).nameType && node === (parent as MappedTypeNode).type) {                 const mappedType = getTypeFromTypeNode(parent as TypeNode) as MappedType;                 if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {                     const typeParameter = getHomomorphicTypeVariable(mappedType);                     if (typeParameter) {                         const constraint = getConstraintOfTypeParameter(typeParameter);                         if (constraint && everyType(constraint, isArrayOrTupleType)) {                             constraints = append(constraints, getUnionType([numberType, numericStringType]));                         }                     }                 }             }             node = parent;         } */
		return /* TODO(ConditionalExpression): constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type */ TODO
	}
	isJSDocTypeReference := func(node Node) /* TODO(TypePredicate): node is TypeReferenceNode */ TODO {
		return !! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.JSDoc) */ TODO && /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.TypeReference || node.kind === SyntaxKind.ImportType) */ TODO
	}
	checkNoTypeArguments := func(node NodeWithTypeArguments, symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_generic */, TODO /* TODO(ConditionalExpression): symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon */, TODO)
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getIntendedTypeFromJSDocTypeReference := func(node TypeReferenceNode) *Type {
		if isIdentifier( /* TODO(PropertyAccessExpression): node.typeName */ TODO) {
			typeArgs := /* TODO(PropertyAccessExpression): node.typeArguments */ TODO
			/* TODO(SwitchStatement): switch (node.typeName.escapedText) {                 case "String":                     checkNoTypeArguments(node);                     return stringType;                 case "Number":                     checkNoTypeArguments(node);                     return numberType;                 case "Boolean":                     checkNoTypeArguments(node);                     return booleanType;                 case "Void":                     checkNoTypeArguments(node);                     return voidType;                 case "Undefined":                     checkNoTypeArguments(node);                     return undefinedType;                 case "Null":                     checkNoTypeArguments(node);                     return nullType;                 case "Function":                 case "function":                     checkNoTypeArguments(node);                     return globalFunctionType;                 case "array":                     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;                 case "promise":                     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;                 case "Object":                     if (typeArgs && typeArgs.length === 2) {                         if (isJSDocIndexSignature(node)) {                             const indexed = getTypeFromTypeNode(typeArgs[0]);                             const target = getTypeFromTypeNode(typeArgs[1]);                             const indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly* / false)] : emptyArray;                             return createAnonymousType(/*symbol* / undefined, emptySymbols, emptyArray, emptyArray, indexInfo);                         }                         return anyType;                     }                     checkNoTypeArguments(node);                     return !noImplicitAny ? anyType : undefined;             } */
		}
	}
	getTypeFromJSDocNullableTypeNode := func(node JSDocNullableType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type_ := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.type */ TODO)
		return /* TODO(ConditionalExpression): strictNullChecks ? getNullableType(type, TypeFlags.Null) : type */ TODO
	}
	getTypeFromTypeReference := func(node TypeReferenceType) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			if isConstTypeReference(node) && isAssertionExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
				/* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = checkExpressionCached(node.parent.expression) */ TODO
			}
			var symbol *Symbol
			var type_ *Type
			meaning := /* TODO(PropertyAccessExpression): SymbolFlags.Type */ TODO
			if isJSDocTypeReference(node) {
				/* TODO(ExpressionStatement): type = getIntendedTypeFromJSDocTypeReference(node); */
				if !type_ {
					/* TODO(ExpressionStatement): symbol = resolveTypeReferenceName(node, meaning, /*ignoreErrors* / true); */
					if symbol == unknownSymbol {
						/* TODO(ExpressionStatement): symbol = resolveTypeReferenceName(node, meaning | SymbolFlags.Value); */
					} else {
						resolveTypeReferenceName(node, meaning)
					}
					/* TODO(ExpressionStatement): type = getTypeReferenceType(node, symbol); */
				}
			}
			if !type_ {
				/* TODO(ExpressionStatement): symbol = resolveTypeReferenceName(node, meaning); */
				/* TODO(ExpressionStatement): type = getTypeReferenceType(node, symbol); */
			}
			/* TODO(ExpressionStatement): links.resolvedSymbol = symbol; */
			/* TODO(ExpressionStatement): links.resolvedType = type; */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	typeArgumentsFromTypeReferenceNode := func(node NodeWithTypeArguments) /* TODO(ArrayType): Type[] */ any {
		return map_( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, getTypeFromTypeNode)
	}
	getTypeFromTypeQueryNode := func(node TypeQueryNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			type_ := checkExpressionWithTypeArguments(node)
			/* TODO(ExpressionStatement): links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type)); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getTypeOfGlobalSymbol := func(symbol *Symbol, arity number) ObjectType {
		getTypeDeclaration := func(symbol Symbol) Declaration {
			declarations := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO
			if declarations {
				for _, declaration := range declarations {
					/* TODO(SwitchStatement): switch (declaration.kind) {                         case SyntaxKind.ClassDeclaration:                         case SyntaxKind.InterfaceDeclaration:                         case SyntaxKind.EnumDeclaration:                             return declaration;                     } */
				}
			}
		}
		if !symbol {
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object) */ TODO {
			error(getTypeDeclaration(symbol) /* TODO(PropertyAccessExpression): Diagnostics.Global_type_0_must_be_a_class_or_interface_type */, TODO, symbolName(symbol))
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length((type as InterfaceType).typeParameters) !== arity */ TODO {
			error(getTypeDeclaration(symbol) /* TODO(PropertyAccessExpression): Diagnostics.Global_type_0_must_have_1_type_parameter_s */, TODO, symbolName(symbol), arity)
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		return type_ /* as */ /* TODO(TypeReference): ObjectType */
	}
	getGlobalValueSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined */, TODO)
	}
	getGlobalTypeSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
	}
	getGlobalTypeAliasSymbol := func(name __String, arity number, reportErrors bool) *Symbol {
		symbol := getGlobalSymbol(name /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
		if symbol {
			getDeclaredTypeOfSymbol(symbol)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(getSymbolLinks(symbol).typeParameters) !== arity */ TODO {
				decl := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && find( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO, isTypeAliasDeclaration)
				error(decl /* TODO(PropertyAccessExpression): Diagnostics.Global_type_0_must_have_1_type_parameter_s */, TODO, symbolName(symbol), arity)
				return nil
			}
		}
		return symbol
	}
	getGlobalSymbol := func(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) *Symbol {
		return resolveName(nil, name, meaning, diagnostic /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
	}
	// OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ TODO, reportErrors /* TODO(LiteralType): true */ TODO) ObjectType
	// OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ TODO, reportErrors bool) *ObjectType
	// OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors /* TODO(LiteralType): true */ TODO) GenericType
	// OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors bool) *GenericType
	getGlobalType := func(name __String, arity number, reportErrors bool) *ObjectType {
		symbol := getGlobalTypeSymbol(name, reportErrors)
		return /* TODO(ConditionalExpression): symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined */ TODO
	}
	// OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity /* TODO(LiteralType): 0 */ TODO) []ObjectType
	// OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity number) []GenericType
	getGlobalBuiltinTypes := func(typeNames []string, arity number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		var types /* TODO(ArrayType): Type[] */ any
		for _, typeName := range typeNames {
			/* TODO(ExpressionStatement): types = append(types, getGlobalType(typeName as __String, arity, /*reportErrors* / false)); */
		}
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): types ?? emptyArray */ TODO
	}
	getGlobalTypedPropertyDescriptorType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity* / 1, /*reportErrors* / true) || emptyGenericType */ TODO
	}
	getGlobalTemplateStringsArrayType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaExpressionType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if !deferredGlobalImportMetaExpressionType {
			symbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO, "ImportMetaExpression" /* as */ /* TODO(TypeReference): __String */)
			importMetaType := getGlobalImportMetaType()
			metaPropertySymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "meta" /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): CheckFlags.Readonly */, TODO)
			/* TODO(ExpressionStatement): metaPropertySymbol.parent = symbol; */
			/* TODO(ExpressionStatement): metaPropertySymbol.links.type = importMetaType; */
			members := createSymbolTable( /* TODO(ArrayLiteralExpression): [metaPropertySymbol] */ TODO)
			/* TODO(ExpressionStatement): symbol.members = members; */
			/* TODO(ExpressionStatement): deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray); */
		}
		return deferredGlobalImportMetaExpressionType
	}
	getGlobalImportCallOptionsType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors)) */ TODO || emptyObjectType
	}
	getGlobalImportAttributesType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors)) */ TODO || emptyObjectType
	}
	getGlobalESSymbolConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolConstructorTypeSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false)) */ TODO || emptyObjectType
	}
	getGlobalPromiseType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalPromiseLikeType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalPromiseConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors) */ TODO
	}
	getGlobalPromiseConstructorLikeType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors)) */ TODO || emptyObjectType
	}
	getGlobalAsyncIterableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalAsyncIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalAsyncIterableIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalBuiltinAsyncIteratorTypes := func() /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
	}
	getGlobalAsyncIteratorObjectType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalAsyncGeneratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalIterableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalIterableIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getBuiltinIteratorReturnType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		return /* TODO(ConditionalExpression): strictBuiltinIteratorReturn ? undefinedType : anyType */ TODO
	}
	getGlobalBuiltinIteratorTypes := func() /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
	}
	getGlobalIteratorObjectType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalGeneratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalIteratorYieldResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalIteratorReturnResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors)) */ TODO || emptyGenericType
	}
	getGlobalDisposableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors)) */ TODO || emptyObjectType
	}
	getGlobalAsyncDisposableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors)) */ TODO || emptyObjectType
	}
	getGlobalTypeOrUndefined := func(name __String, arity /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) *ObjectType {
		symbol := getGlobalSymbol(name /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO, nil)
		return symbol && getTypeOfGlobalSymbol(symbol, arity) /* as */ /* TODO(TypeReference): GenericType */
	}
	getGlobalExtractSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol */ TODO
	}
	getGlobalOmitSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol */ TODO
	}
	getGlobalAwaitedSymbol := func(reportErrors bool) *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity* / 1, reportErrors) || (reportErrors ? unknownSymbol : undefined); */
		return /* TODO(ConditionalExpression): deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol */ TODO
	}
	getGlobalBigIntType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(ParenthesizedExpression): (deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false)) */ TODO || emptyObjectType
	}
	getGlobalClassDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassMethodDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassGetterDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassSetterDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorTargetType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassFieldDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalNaNSymbol := func() *Symbol {
		return /* TODO(ParenthesizedExpression): (deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false)) */ TODO
	}
	getGlobalRecordSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalRecordSymbol === unknownSymbol ? undefined : deferredGlobalRecordSymbol */ TODO
	}
	createTypeFromGenericGlobalType := func(genericGlobalType GenericType, typeArguments []Type) ObjectType {
		return /* TODO(ConditionalExpression): genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType */ TODO
	}
	createTypedPropertyDescriptorType := func(propertyType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType() /* TODO(ArrayLiteralExpression): [propertyType] */, TODO)
	}
	createIterableType := func(iteratedType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalIterableType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [iteratedType, voidType, undefinedType] */, TODO)
	}
	createArrayType := func(elementType Type, readonly bool) ObjectType {
		return createTypeFromGenericGlobalType( /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO /* TODO(ArrayLiteralExpression): [elementType] */, TODO)
	}
	getTupleElementFlags := func(node TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.OptionalType:                 return ElementFlags.Optional;             case SyntaxKind.RestType:                 return getRestTypeElementFlags(node as RestTypeNode);             case SyntaxKind.NamedTupleMember:                 return (node as NamedTupleMember).questionToken ? ElementFlags.Optional :                     (node as NamedTupleMember).dotDotDotToken ? getRestTypeElementFlags(node as NamedTupleMember) :                     ElementFlags.Required;             default:                 return ElementFlags.Required;         } */
	}
	getRestTypeElementFlags := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
		return /* TODO(ConditionalExpression): getArrayElementTypeNode(node.type) ? ElementFlags.Rest : ElementFlags.Variadic */ TODO
	}
	getArrayOrTupleTargetType := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) GenericType {
		readonly := isReadonlyTypeOperator( /* TODO(PropertyAccessExpression): node.parent */ TODO)
		elementType := getArrayElementTypeNode(node)
		if elementType {
			return /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
		}
		elementFlags := map_( /* TODO(PropertyAccessExpression): (node as TupleTypeNode).elements */ TODO, getTupleElementFlags)
		return getTupleTargetType(elementFlags, readonly, map_( /* TODO(PropertyAccessExpression): (node as TupleTypeNode).elements */ TODO, memberIfLabeledElementDeclaration))
	}
	memberIfLabeledElementDeclaration := func(member Node) /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any {
		return /* TODO(ConditionalExpression): isNamedTupleMember(member) || isParameter(member) ? member : undefined */ TODO
	}
	isDeferredTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) /* TODO(undefined): boolean */ TODO {
		return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && /* TODO(ParenthesizedExpression): (                     node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) :                         node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) :                         hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias)                 ) */ TODO
	}
	isResolvedByTypeAlias := func(node Node) bool {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.ParenthesizedType:             case SyntaxKind.NamedTupleMember:             case SyntaxKind.TypeReference:             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:             case SyntaxKind.IndexedAccessType:             case SyntaxKind.ConditionalType:             case SyntaxKind.TypeOperator:             case SyntaxKind.ArrayType:             case SyntaxKind.TupleType:                 return isResolvedByTypeAlias(parent);             case SyntaxKind.TypeAliasDeclaration:                 return true;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	mayResolveTypeAlias := func(node Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.TypeReference:                 return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node as TypeReferenceNode, SymbolFlags.Type).flags & SymbolFlags.TypeAlias);             case SyntaxKind.TypeQuery:                 return true;             case SyntaxKind.TypeOperator:                 return (node as TypeOperatorNode).operator !== SyntaxKind.UniqueKeyword && mayResolveTypeAlias((node as TypeOperatorNode).type);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.OptionalType:             case SyntaxKind.NamedTupleMember:             case SyntaxKind.JSDocOptionalType:             case SyntaxKind.JSDocNullableType:             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocTypeExpression:                 return mayResolveTypeAlias((node as ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember).type);             case SyntaxKind.RestType:                 return (node as RestTypeNode).type.kind !== SyntaxKind.ArrayType || mayResolveTypeAlias(((node as RestTypeNode).type as ArrayTypeNode).elementType);             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:                 return some((node as UnionOrIntersectionTypeNode).types, mayResolveTypeAlias);             case SyntaxKind.IndexedAccessType:                 return mayResolveTypeAlias((node as IndexedAccessTypeNode).objectType) || mayResolveTypeAlias((node as IndexedAccessTypeNode).indexType);             case SyntaxKind.ConditionalType:                 return mayResolveTypeAlias((node as ConditionalTypeNode).checkType) || mayResolveTypeAlias((node as ConditionalTypeNode).extendsType) ||                     mayResolveTypeAlias((node as ConditionalTypeNode).trueType) || mayResolveTypeAlias((node as ConditionalTypeNode).falseType);         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	getTypeFromArrayOrTupleTypeNode := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			target := getArrayOrTupleTargetType(node)
			if target == emptyGenericType {
				/* TODO(ExpressionStatement): links.resolvedType = emptyObjectType; */
			} else if ! /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.TupleType && some(node.elements, e => !!(getTupleElementFlags(e) & ElementFlags.Variadic))) */ TODO && isDeferredTypeReferenceNode(node) {
				/* TODO(ExpressionStatement): links.resolvedType = node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target :                     createDeferredTypeReference(target, node, /*mapper* / undefined); */
			} else {
				elementTypes := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode) */ TODO
				/* TODO(ExpressionStatement): links.resolvedType = createNormalizedTypeReference(target, elementTypes); */
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	isReadonlyTypeOperator := func(node Node) /* TODO(undefined): boolean */ TODO {
		return isTypeOperatorNode(node) && /* TODO(PropertyAccessExpression): node.operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ReadonlyKeyword */ TODO
	}
	createTupleType := func(elementTypes []Type, elementFlags []ElementFlags, readonly /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any /* = */ /* TODO(ArrayLiteralExpression): [] */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		tupleTarget := getTupleTargetType(elementFlags || map_(elementTypes /* TODO(ArrowFunction): _ => ElementFlags.Required */, TODO), readonly, namedMemberDeclarations)
		return /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :             tupleTarget */ TODO
	}
	getTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
		if /* TODO(PropertyAccessExpression): elementFlags.length */ TODO == 1 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[0] & ElementFlags.Rest */ TODO {
			return /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
		}
		key := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): map(elementFlags, f => f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*").join() +             (readonly ? "R" : "") +             (some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "") */ TODO
		type_ := /* TODO(PropertyAccessExpression): tupleTypes.get */ TODO(key)
		if !type_ {
			/* TODO(PropertyAccessExpression): tupleTypes.set */ TODO(key /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) */, TODO)
		}
		return type_
	}
	createTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
		arity := /* TODO(PropertyAccessExpression): elementFlags.length */ TODO
		minLength := countWhere(elementFlags /* TODO(ArrowFunction): f => !!(f & (ElementFlags.Required | ElementFlags.Variadic)) */, TODO)
		var typeParameters /* TODO(ArrayType): TypeParameter[] */ any
		var properties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		combinedFlags := 0 /* as */ /* TODO(TypeReference): ElementFlags */
		if arity {
			/* TODO(ExpressionStatement): typeParameters = new Array(arity); */
			/* TODO(ForStatement): for (let i = 0; i < arity; i++) {                 const typeParameter = typeParameters[i] = createTypeParameter();                 const flags = elementFlags[i];                 combinedFlags |= flags;                 if (!(combinedFlags & ElementFlags.Variable)) {                     const property = createSymbol(SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0), "" + i as __String, readonly ? CheckFlags.Readonly : 0);                     property.links.tupleLabelDeclaration = namedMemberDeclarations?.[i];                     property.links.type = typeParameter;                     properties.push(property);                 }             } */
		}
		fixedLength := /* TODO(PropertyAccessExpression): properties.length */ TODO
		lengthSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "length" /* as */ /* TODO(TypeReference): __String */ /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */, TODO)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): combinedFlags & ElementFlags.Variable */ TODO {
			/* TODO(ExpressionStatement): lengthSymbol.links.type = numberType; */
		} else {
			literalTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ForStatement): for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i)); */
			/* TODO(ExpressionStatement): lengthSymbol.links.type = getUnionType(literalTypes); */
		}
		/* TODO(PropertyAccessExpression): properties.push */ TODO(lengthSymbol)
		type_ := createObjectType( /* TODO(BarToken): | */ /* TODO(BinaryExpression): ObjectFlags.Tuple | ObjectFlags.Reference */ TODO) /* as */ /* TODO(IntersectionType): TupleType & InterfaceTypeWithDeclaredMembers */
		/* TODO(ExpressionStatement): type.typeParameters = typeParameters; */
		/* TODO(ExpressionStatement): type.outerTypeParameters = undefined; */
		/* TODO(ExpressionStatement): type.localTypeParameters = typeParameters; */
		/* TODO(ExpressionStatement): type.instantiations = new Map<string, TypeReference>(); */
		/* TODO(PropertyAccessExpression): type.instantiations.set */
		TODO(getTypeListId( /* TODO(PropertyAccessExpression): type.typeParameters */ TODO), type_ /* as */ /* TODO(TypeReference): GenericType */)
		/* TODO(ExpressionStatement): type.target = type as GenericType; */
		/* TODO(ExpressionStatement): type.resolvedTypeArguments = type.typeParameters; */
		/* TODO(ExpressionStatement): type.thisType = createTypeParameter(); */
		/* TODO(ExpressionStatement): type.thisType.isThisType = true; */
		/* TODO(ExpressionStatement): type.thisType.constraint = type; */
		/* TODO(ExpressionStatement): type.declaredProperties = properties; */
		/* TODO(ExpressionStatement): type.declaredCallSignatures = emptyArray; */
		/* TODO(ExpressionStatement): type.declaredConstructSignatures = emptyArray; */
		/* TODO(ExpressionStatement): type.declaredIndexInfos = emptyArray; */
		/* TODO(ExpressionStatement): type.elementFlags = elementFlags; */
		/* TODO(ExpressionStatement): type.minLength = minLength; */
		/* TODO(ExpressionStatement): type.fixedLength = fixedLength; */
		/* TODO(ExpressionStatement): type.hasRestElement = !!(combinedFlags & ElementFlags.Variable); */
		/* TODO(ExpressionStatement): type.combinedFlags = combinedFlags; */
		/* TODO(ExpressionStatement): type.readonly = readonly; */
		/* TODO(ExpressionStatement): type.labeledElementDeclarations = namedMemberDeclarations; */
		return type_
	}
	createNormalizedTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(target as TupleType, typeArguments!) : createTypeReference(target, typeArguments) */ TODO
	}
	createNormalizedTupleType := func(target TupleType, elementTypes []Type) Type {
		if ! /* TODO(ParenthesizedExpression): (target.combinedFlags & ElementFlags.NonRequired) */ TODO {
			return createTypeReference(target, elementTypes)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.combinedFlags & ElementFlags.Variadic */ TODO {
			unionIndex := findIndex(elementTypes /* TODO(ArrowFunction): (t, i) => !!(target.elementFlags[i] & ElementFlags.Variadic && t.flags & (TypeFlags.Never | TypeFlags.Union)) */, TODO)
			if unionIndex >= 0 {
				return /* TODO(ConditionalExpression): checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType)) ?                     mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) :                     errorType */ TODO
			}
		}
		var expandedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var expandedFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
		var expandedDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		lastRequiredIndex := -1
		firstRestIndex := -1
		lastOptionalOrRestIndex := -1
		/* TODO(ForStatement): for (let i = 0; i < elementTypes.length; i++) {             const type = elementTypes[i];             const flags = target.elementFlags[i];             if (flags & ElementFlags.Variadic) {                 if (type.flags & TypeFlags.Any) {                     addElement(type, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }                 else if (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type)) {                     // Generic variadic elements stay as they are.                     addElement(type, ElementFlags.Variadic, target.labeledElementDeclarations?.[i]);                 }                 else if (isTupleType(type)) {                     const elements = getElementTypes(type);                     if (elements.length + expandedTypes.length >= 10_000) {                         error(                             currentNode,                             isPartOfTypeNode(currentNode!)                                 ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent                                 : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,                         );                         return errorType;                     }                     // Spread variadic elements with tuple types into the resulting tuple.                     forEach(elements, (t, n) => addElement(t, type.target.elementFlags[n], type.target.labeledElementDeclarations?.[n]));                 }                 else {                     // Treat everything else as an array type and create a rest element.                     addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }             }             else {                 // Copy other element kinds with no change.                 addElement(type, flags, target.labeledElementDeclarations?.[i]);             }         } */
		/* TODO(ForStatement): for (let i = 0; i < lastRequiredIndex; i++) {             if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;         } */
		if firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex {
			/* TODO(ExpressionStatement): expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), (t, i) => expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t)); */
			/* TODO(PropertyAccessExpression): expandedTypes.splice */
			TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
			/* TODO(PropertyAccessExpression): expandedFlags.splice */ TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
			/* TODO(PropertyAccessExpression): expandedDeclarations.splice */ TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
		}
		tupleTarget := getTupleTargetType(expandedFlags /* TODO(PropertyAccessExpression): target.readonly */, TODO, expandedDeclarations)
		return /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :             tupleTarget */ TODO
		addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ElementFlags.Required */ TODO {
				/* TODO(ExpressionStatement): lastRequiredIndex = expandedFlags.length; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ElementFlags.Rest */ TODO && firstRestIndex < 0 {
				/* TODO(ExpressionStatement): firstRestIndex = expandedFlags.length; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & (ElementFlags.Optional | ElementFlags.Rest) */ TODO {
				/* TODO(ExpressionStatement): lastOptionalOrRestIndex = expandedFlags.length; */
			}
			/* TODO(PropertyAccessExpression): expandedTypes.push */ TODO( /* TODO(ConditionalExpression): flags & ElementFlags.Optional ? addOptionality(type, /*isProperty* / true) : type */ TODO)
			/* TODO(PropertyAccessExpression): expandedFlags.push */ TODO(flags)
			/* TODO(PropertyAccessExpression): expandedDeclarations.push */ TODO(declaration)
		}
	}
	sliceTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		target := /* TODO(PropertyAccessExpression): type.target */ TODO
		endIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
		return /* TODO(ConditionalExpression): index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) :             createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), /*readonly* / false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex)) */ TODO
	}
	getKnownKeysOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getUnionType(append(arrayOf( /* TODO(PropertyAccessExpression): type.target.fixedLength */ TODO /* TODO(ArrowFunction): i => getStringLiteralType("" + i) */, TODO), getIndexType( /* TODO(ConditionalExpression): type.target.readonly ? globalReadonlyArrayType : globalArrayType */ TODO)))
	}
	getStartElementCount := func(type_ TupleType, flags ElementFlags) /* TODO(undefined): number */ TODO {
		index := findIndex( /* TODO(PropertyAccessExpression): type.elementFlags */ TODO /* TODO(ArrowFunction): f => !(f & flags) */, TODO)
		return /* TODO(ConditionalExpression): index >= 0 ? index : type.elementFlags.length */ TODO
	}
	getEndElementCount := func(type_ TupleType, flags ElementFlags) /* TODO(undefined): number */ TODO {
		return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1 */ TODO
	}
	getTotalFixedElementCount := func(type_ TupleType) /* TODO(undefined): number */ TODO {
		return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): type.fixedLength + getEndElementCount(type, ElementFlags.Fixed) */ TODO
	}
	getElementTypes := func(type_ TupleTypeReference) []Type {
		typeArguments := getTypeArguments(type_)
		arity := getTypeReferenceArity(type_)
		return /* TODO(ConditionalExpression): typeArguments.length === arity ? typeArguments : typeArguments.slice(0, arity) */ TODO
	}
	getTypeFromOptionalTypeNode := func(node OptionalTypeNode) Type {
		return addOptionality(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.type */ TODO) /* TODO(TrueKeyword): true */, TODO)
	}
	getTypeId := func(type_ Type) TypeId {
		return /* TODO(PropertyAccessExpression): type.id */ TODO
	}
	containsType := func(types []Type, type_ Type) bool {
		return binarySearch(types, type_, getTypeId, compareValues) >= 0
	}
	insertType := func(types []Type, type_ Type) bool {
		index := binarySearch(types, type_, getTypeId, compareValues)
		if index < 0 {
			/* TODO(PropertyAccessExpression): types.splice */ TODO(~index, 0, type_)
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	addTypeToUnion := func(typeSet []Type, includes TypeFlags, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
		if ! /* TODO(ParenthesizedExpression): (flags & TypeFlags.Never) */ TODO {
			/* TODO(ExpressionStatement): includes |= flags & TypeFlags.IncludesMask; */
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Instantiable */ TODO {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesInstantiable */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Intersection */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable */ TODO {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesConstrainedTypeVariable */
			}
			if type_ == wildcardType {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesWildcard */
			}
			if isErrorType(type_) {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesError */
			}
			if !strictNullChecks && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Nullable */ TODO {
				if ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.ContainsWideningType) */ TODO {
					/* TODO(BinaryExpression): includes |= TypeFlags.IncludesNonWideningType */
				}
			} else {
				len := /* TODO(PropertyAccessExpression): typeSet.length */ TODO
				index := /* TODO(ConditionalExpression): len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues) */ TODO
				if index < 0 {
					/* TODO(PropertyAccessExpression): typeSet.splice */ TODO(~index, 0, type_)
				}
			}
		}
		return includes
	}
	addTypesToUnion := func(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
		var lastType *Type
		for _, type_ := range types {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== lastType */ TODO {
				/* TODO(ExpressionStatement): includes = type.flags & TypeFlags.Union ?                     addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) :                     addTypeToUnion(typeSet, includes, type); */
				/* TODO(ExpressionStatement): lastType = type; */
			}
		}
		return includes
	}
	removeSubtypes := func(types []Type, hasObjectTypes bool) /* TODO(ArrayType): Type[] */ any {
		if /* TODO(PropertyAccessExpression): types.length */ TODO < 2 {
			return types
		}
		id := getTypeListId(types)
		match := /* TODO(PropertyAccessExpression): subtypeReductionCache.get */ TODO(id)
		if match {
			return match
		}
		hasEmptyObject := hasObjectTypes && some(types /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Object) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t as ObjectType)) */, TODO)
		len := /* TODO(PropertyAccessExpression): types.length */ TODO
		i := len
		count := 0
		/* TODO(WhileStatement): while (i > 0) {             i--;             const source = types[i];             if (hasEmptyObject || source.flags & TypeFlags.StructuredOrInstantiable) {                 // A type parameter with a union constraint may be a subtype of some union, but not a subtype of the                 // individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not                 // a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the                 // type parameter is a subtype of a union of all the other types.                 if (source.flags & TypeFlags.TypeParameter && getBaseConstraintOrType(source).flags & TypeFlags.Union) {                     if (isTypeRelatedTo(source, getUnionType(map(types, t => t === source ? neverType : t)), strictSubtypeRelation)) {                         orderedRemoveItemAt(types, i);                     }                     continue;                 }                 // Find the first property with a unit type, if any. When constituents have a property by the same name                 // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype                 // reduction of large discriminated union types.                 const keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?                     find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :                     undefined;                 const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));                 for (const target of types) {                     if (source !== target) {                         if (count === 100000) {                             // After 100000 subtype checks we estimate the remaining amount of work by assuming the                             // same ratio of checks per element. If the estimated number of remaining type checks is                             // greater than 1M we deem the union type too complex to represent. This for example                             // caps union types at 1000 unique object types.                             const estimatedCount = (count / (len - i)) * len;                             if (estimatedCount > 1000000) {                                 tracing?.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", { typeIds: types.map(t => t.id) });                                 error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);                                 return undefined;                             }                         }                         count++;                         if (keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {                             const t = getTypeOfPropertyOfType(target, keyProperty.escapedName);                             if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {                                 continue;                             }                         }                         if (                             isTypeRelatedTo(source, target, strictSubtypeRelation) && (                                 !(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) ||                                 !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) ||                                 isTypeDerivedFrom(source, target)                             )                         ) {                             orderedRemoveItemAt(types, i);                             break;                         }                     }                 }             }         } */
		/* TODO(PropertyAccessExpression): subtypeReductionCache.set */
		TODO(id, types)
		return types
	}
	removeRedundantLiteralTypes := func(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
		i := /* TODO(PropertyAccessExpression): types.length */ TODO
		/* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             const flags = t.flags;             const remove = flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.String ||                 flags & TypeFlags.NumberLiteral && includes & TypeFlags.Number ||                 flags & TypeFlags.BigIntLiteral && includes & TypeFlags.BigInt ||                 flags & TypeFlags.UniqueESSymbol && includes & TypeFlags.ESSymbol ||                 reduceVoidUndefined && flags & TypeFlags.Undefined && includes & TypeFlags.Void ||                 isFreshLiteralType(t) && containsType(types, (t as LiteralType).regularType);             if (remove) {                 orderedRemoveItemAt(types, i);             }         } */
	}
	removeStringLiteralsMatchedByTemplateLiterals := func(types []Type) {
		patterns := filter(types, isPatternLiteralType)                                                                    /* as */ /* TODO(ArrayType): (TemplateLiteralType | StringMappingType)[] */
		templateLiterals := filter(patterns /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.TemplateLiteral) */, TODO) /* as */ /* TODO(ArrayType): TemplateLiteralType[] */
		estimatedCount := /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): templateLiterals.length * countWhere(types, t => !!(t.flags & TypeFlags.StringLiteral)) */ TODO
		if estimatedCount > 0 {
			trie := createPrefixSuffixTrie()
			forEach(templateLiterals /* TODO(ArrowFunction): t => {                 const prefix = t.texts[0];                 const suffix = t.texts[t.texts.length - 1];                 trie.set(prefix, suffix, templates => append(templates, t));             } */, TODO)
			i := /* TODO(PropertyAccessExpression): types.length */ TODO
			/* TODO(LabeledStatement): outer: while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 const text = (t as StringLiteralType).value;                  for (const templates of trie.iterateAllMatches(text)) {                     if (some(templates, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                         orderedRemoveItemAt(types, i);                         continue outer;                     }                 }             } */
			/* TODO(ExpressionStatement): patterns = filter(patterns, t => !!(t.flags & TypeFlags.StringMapping)) as StringMappingType[]; */
		}
		if /* TODO(PropertyAccessExpression): patterns.length */ TODO {
			i := /* TODO(PropertyAccessExpression): types.length */ TODO
			/* TODO(WhileStatement): while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 if (some(patterns, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                     orderedRemoveItemAt(types, i);                 }             } */
		}
	}
	isTypeMatchedByTemplateLiteralOrStringMapping := func(type_ Type, template /* TODO(UnionType): TemplateLiteralType | StringMappingType */ any) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): template.flags & TypeFlags.TemplateLiteral ?             isTypeMatchedByTemplateLiteralType(type, template as TemplateLiteralType) :             isMemberOfStringMapping(type, template) */ TODO
	}
	removeConstrainedTypeVariables := func(types []Type) {
		var typeVariables []TypeVariable = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, type_ := range types {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable */ TODO {
				index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
				pushIfUnique(typeVariables /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */, TODO)
			}
		}
		for _, typeVariable := range typeVariables {
			var primitives []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, type_ := range types {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable */ TODO {
					index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
					if /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */ TODO == typeVariable {
						insertType(primitives /* TODO(ElementAccessExpression): (type as IntersectionType).types[1 - index] */, TODO)
					}
				}
			}
			constraint := /* TODO(NonNullExpression): getBaseConstraintOfType(typeVariable)! */ TODO
			if everyType(constraint /* TODO(ArrowFunction): t => containsType(primitives, t) */, TODO) {
				i := /* TODO(PropertyAccessExpression): types.length */ TODO
				/* TODO(WhileStatement): while (i > 0) {                     i--;                     const type = types[i];                     if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {                         const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;                         if ((type as IntersectionType).types[index] === typeVariable && containsType(primitives, (type as IntersectionType).types[1 - index])) {                             orderedRemoveItemAt(types, i);                         }                     }                 } */
				insertType(types, typeVariable)
			}
		}
	}
	isNamedUnionType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union && (type.aliasSymbol || (type as UnionType).origin)) */ TODO
	}
	addNamedUnions := func(namedUnions []Type, types []Type) {
		for _, t := range types {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Union */ TODO {
				origin := /* TODO(PropertyAccessExpression): (t as UnionType).origin */ TODO
				if /* TODO(PropertyAccessExpression): t.aliasSymbol */ TODO || origin && ! /* TODO(ParenthesizedExpression): (origin.flags & TypeFlags.Union) */ TODO {
					pushIfUnique(namedUnions, t)
				} else if origin && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): origin.flags & TypeFlags.Union */ TODO {
					addNamedUnions(namedUnions /* TODO(PropertyAccessExpression): (origin as UnionType).types */, TODO)
				}
			}
		}
	}
	createOriginUnionOrIntersectionType := func(flags TypeFlags, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").UnionOrIntersectionType */ TODO {
		result := createOriginType(flags) /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
		/* TODO(ExpressionStatement): result.types = types; */
		return result
	}
	getUnionType := func(types []Type, unionReduction UnionReduction /* = */ /* TODO(PropertyAccessExpression): UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if /* TODO(PropertyAccessExpression): types.length */ TODO == 0 {
			return neverType
		}
		if /* TODO(PropertyAccessExpression): types.length */ TODO == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		if /* TODO(PropertyAccessExpression): types.length */ TODO == 2 && !origin && /* TODO(ParenthesizedExpression): (types[0].flags & TypeFlags.Union || types[1].flags & TypeFlags.Union) */ TODO {
			infix := /* TODO(ConditionalExpression): unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L" */ TODO
			index := /* TODO(ConditionalExpression): types[0].id < types[1].id ? 0 : 1 */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): types[index].id + infix + types[1 - index].id + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			type_ := /* TODO(PropertyAccessExpression): unionOfUnionTypes.get */ TODO(id)
			if !type_ {
				/* TODO(ExpressionStatement): type = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, /*origin* / undefined); */
				/* TODO(PropertyAccessExpression): unionOfUnionTypes.set */
				TODO(id, type_)
			}
			return type_
		}
		return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionTypeWorker := func(types []Type, unionReduction UnionReduction, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, origin *Type) Type {
		var typeSet /* TODO(ArrayType): Type[] */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		includes := addTypesToUnion(typeSet, 0 /* as */ /* TODO(TypeReference): TypeFlags */, types)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): unionReduction !== UnionReduction.None */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.AnyOrUnknown */ TODO {
				return /* TODO(ConditionalExpression): includes & TypeFlags.Any ?                     includes & TypeFlags.IncludesWildcard ? wildcardType :                         includes & TypeFlags.IncludesError ? errorType : anyType :                     unknownType */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Undefined */ TODO {
				if /* TODO(PropertyAccessExpression): typeSet.length */ TODO >= 2 && /* TODO(ElementAccessExpression): typeSet[0] */ TODO == undefinedType && /* TODO(ElementAccessExpression): typeSet[1] */ TODO == missingType {
					orderedRemoveItemAt(typeSet, 1)
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.Enum | TypeFlags.Literal | TypeFlags.UniqueESSymbol | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Void */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Undefined */ TODO {
				removeRedundantLiteralTypes(typeSet, includes, !! /* TODO(ParenthesizedExpression): (unionReduction & UnionReduction.Subtype) */ TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.StringLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO {
				removeStringLiteralsMatchedByTemplateLiterals(typeSet)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.IncludesConstrainedTypeVariable */ TODO {
				removeConstrainedTypeVariables(typeSet)
			}
			if unionReduction == /* TODO(PropertyAccessExpression): UnionReduction.Subtype */ TODO {
				/* TODO(ExpressionStatement): typeSet = removeSubtypes(typeSet, !!(includes & TypeFlags.Object)); */
				if !typeSet {
					return errorType
				}
			}
			if /* TODO(PropertyAccessExpression): typeSet.length */ TODO == 0 {
				return /* TODO(ConditionalExpression): includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType :                     includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType :                     neverType */ TODO
			}
		}
		if !origin && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Union */ TODO {
			var namedUnions []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			addNamedUnions(namedUnions, types)
			var reducedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, t := range typeSet {
				if !some(namedUnions /* TODO(ArrowFunction): union => containsType((union as UnionType).types, t) */, TODO) {
					/* TODO(PropertyAccessExpression): reducedTypes.push */ TODO(t)
				}
			}
			if !aliasSymbol && /* TODO(PropertyAccessExpression): namedUnions.length */ TODO == 1 && /* TODO(PropertyAccessExpression): reducedTypes.length */ TODO == 0 {
				return /* TODO(ElementAccessExpression): namedUnions[0] */ TODO
			}
			namedTypesCount := reduceLeft(namedUnions /* TODO(ArrowFunction): (sum, union) => sum + (union as UnionType).types.length */, TODO, 0)
			if /* TODO(PlusToken): + */ /* TODO(BinaryExpression): namedTypesCount + reducedTypes.length */ TODO == /* TODO(PropertyAccessExpression): typeSet.length */ TODO {
				for _, t := range namedUnions {
					insertType(reducedTypes, t)
				}
				/* TODO(ExpressionStatement): origin = createOriginUnionOrIntersectionType(TypeFlags.Union, reducedTypes); */
			}
		}
		objectFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): (includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion) |             (includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0) */ TODO
		return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionOrIntersectionTypePredicate := func(signatures []Signature, kind *TypeFlags) *TypePredicate {
		var last *TypePredicate
		var types []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, sig := range signatures {
			pred := getTypePredicateOfSignature(sig)
			if pred {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): pred.kind !== TypePredicateKind.This */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): pred.kind !== TypePredicateKind.Identifier */ TODO || last && !typePredicateKindsMatch(last, pred) {
					return nil
				}
				/* TODO(ExpressionStatement): last = pred; */
				/* TODO(PropertyAccessExpression): types.push */
				TODO( /* TODO(PropertyAccessExpression): pred.type */ TODO)
			} else {
				returnType := /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined */ TODO
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): returnType !== falseType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): returnType !== regularFalseType */ TODO {
					return nil
				}
			}
		}
		if !last {
			return nil
		}
		compositeType := getUnionOrIntersectionType(types, kind)
		return createTypePredicate( /* TODO(PropertyAccessExpression): last.kind */ TODO /* TODO(PropertyAccessExpression): last.parameterName */, TODO /* TODO(PropertyAccessExpression): last.parameterIndex */, TODO, compositeType)
	}
	typePredicateKindsMatch := func(a TypePredicate, b TypePredicate) bool {
		return /* TODO(PropertyAccessExpression): a.kind */ TODO == /* TODO(PropertyAccessExpression): b.kind */ TODO && /* TODO(PropertyAccessExpression): a.parameterIndex */ TODO == /* TODO(PropertyAccessExpression): b.parameterIndex */ TODO
	}
	getUnionTypeFromSortedList := func(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if /* TODO(PropertyAccessExpression): types.length */ TODO == 0 {
			return neverType
		}
		if /* TODO(PropertyAccessExpression): types.length */ TODO == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		typeKey := /* TODO(ConditionalExpression): !origin ? getTypeListId(types) :             origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` :             origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` :             `#${(origin as IndexType).type.id}|${getTypeListId(types)}` */ TODO
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeKey + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
		type_ := /* TODO(PropertyAccessExpression): unionTypes.get */ TODO(id)
		if !type_ {
			/* TODO(ExpressionStatement): type = createType(TypeFlags.Union) as UnionType; */
			/* TODO(ExpressionStatement): type.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds* / TypeFlags.Nullable); */
			/* TODO(ExpressionStatement): type.types = types; */
			/* TODO(ExpressionStatement): type.origin = origin; */
			/* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
			/* TODO(ExpressionStatement): type.aliasTypeArguments = aliasTypeArguments; */
			if /* TODO(PropertyAccessExpression): types.length */ TODO == 2 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): types[0].flags & TypeFlags.BooleanLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): types[1].flags & TypeFlags.BooleanLiteral */ TODO {
				/* TODO(ExpressionStatement): type.flags |= TypeFlags.Boolean; */
				/* TODO(ExpressionStatement): (type as UnionType & IntrinsicType).intrinsicName = "boolean"; */
			}
			/* TODO(PropertyAccessExpression): unionTypes.set */ TODO(id, type_)
		}
		return type_
	}
	getTypeFromUnionTypeNode := func(node UnionTypeNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			/* TODO(ExpressionStatement): links.resolvedType = getUnionType(map(node.types, getTypeFromTypeNode), UnionReduction.Literal, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol)); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	addTypeToIntersection := func(typeSet Map[string, Type], includes TypeFlags, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Intersection */ TODO {
			return addTypesToIntersection(typeSet, includes /* TODO(PropertyAccessExpression): (type as IntersectionType).types */, TODO)
		}
		if isEmptyAnonymousObjectType(type_) {
			if ! /* TODO(ParenthesizedExpression): (includes & TypeFlags.IncludesEmptyObject) */ TODO {
				/* TODO(ExpressionStatement): includes |= TypeFlags.IncludesEmptyObject; */
				/* TODO(PropertyAccessExpression): typeSet.set */
				TODO( /* TODO(PropertyAccessExpression): type.id.toString */ TODO(), type_)
			}
		} else {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.AnyOrUnknown */ TODO {
				if type_ == wildcardType {
					/* TODO(BinaryExpression): includes |= TypeFlags.IncludesWildcard */
				}
				if isErrorType(type_) {
					/* TODO(BinaryExpression): includes |= TypeFlags.IncludesError */
				}
			} else if strictNullChecks || ! /* TODO(ParenthesizedExpression): (flags & TypeFlags.Nullable) */ TODO {
				if type_ == missingType {
					/* TODO(ExpressionStatement): includes |= TypeFlags.IncludesMissingType; */
					/* TODO(ExpressionStatement): type = undefinedType; */
				}
				if ! /* TODO(PropertyAccessExpression): typeSet.has */ TODO( /* TODO(PropertyAccessExpression): type.id.toString */ TODO()) {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Unit */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Unit */ TODO {
						/* TODO(ExpressionStatement): includes |= TypeFlags.NonPrimitive; */
					}
					/* TODO(PropertyAccessExpression): typeSet.set */ TODO( /* TODO(PropertyAccessExpression): type.id.toString */ TODO(), type_)
				}
			}
			/* TODO(ExpressionStatement): includes |= flags & TypeFlags.IncludesMask; */
		}
		return includes
	}
	addTypesToIntersection := func(typeSet Map[string, Type], includes TypeFlags, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		for _, type_ := range types {
			/* TODO(ExpressionStatement): includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type)); */
		}
		return includes
	}
	removeRedundantSupertypes := func(types []Type, includes TypeFlags) {
		i := /* TODO(PropertyAccessExpression): types.length */ TODO
		/* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             const remove = t.flags & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||                 t.flags & TypeFlags.Number && includes & TypeFlags.NumberLiteral ||                 t.flags & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral ||                 t.flags & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol ||                 t.flags & TypeFlags.Void && includes & TypeFlags.Undefined ||                 isEmptyAnonymousObjectType(t) && includes & TypeFlags.DefinitelyNonNullable;             if (remove) {                 orderedRemoveItemAt(types, i);             }         } */
	}
	eachUnionContains := func(unionTypes []UnionType, type_ Type) /* TODO(undefined): boolean */ TODO {
		for _, u := range unionTypes {
			if !containsType( /* TODO(PropertyAccessExpression): u.types */ TODO, type_) {
				if type_ == missingType {
					return containsType( /* TODO(PropertyAccessExpression): u.types */ TODO, undefinedType)
				}
				if type_ == undefinedType {
					return containsType( /* TODO(PropertyAccessExpression): u.types */ TODO, missingType)
				}
				primitive := /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? stringType :                     type.flags & (TypeFlags.Enum | TypeFlags.NumberLiteral) ? numberType :                     type.flags & TypeFlags.BigIntLiteral ? bigintType :                     type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :                     undefined */ TODO
				if !primitive || !containsType( /* TODO(PropertyAccessExpression): u.types */ TODO, primitive) {
					return /* TODO(FalseKeyword): false */ TODO
				}
			}
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	extractRedundantTemplateLiterals := func(types []Type) bool {
		i := /* TODO(PropertyAccessExpression): types.length */ TODO
		literals := filter(types /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.StringLiteral) */, TODO)
		/* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             if (!(t.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping))) continue;             for (const t2 of literals) {                 if (isTypeSubtypeOf(t2, t)) {                     // For example, `get${T}` & "getX" is just "getX", and Lowercase<string> & "foo" is just "foo"                     orderedRemoveItemAt(types, i);                     break;                 }                 else if (isPatternLiteralType(t)) {                     return true;                 }             }         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	removeFromEach := func(types []Type, flag TypeFlags) {
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             types[i] = filterType(types[i], t => !(t.flags & flag));         } */
	}
	intersectUnionsOfPrimitiveTypes := func(types []Type) /* TODO(undefined): boolean */ TODO {
		var unionTypes /* TODO(ArrayType): UnionType[] */ any
		index := findIndex(types /* TODO(ArrowFunction): t => !!(getObjectFlags(t) & ObjectFlags.PrimitiveUnion) */, TODO)
		if index < 0 {
			return /* TODO(FalseKeyword): false */ TODO
		}
		i := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): index + 1 */ TODO
		/* TODO(WhileStatement): while (i < types.length) {             const t = types[i];             if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {                 (unionTypes || (unionTypes = [types[index] as UnionType])).push(t as UnionType);                 orderedRemoveItemAt(types, i);             }             else {                 i++;             }         } */
		if !unionTypes {
			return /* TODO(FalseKeyword): false */ TODO
		}
		var checked []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, u := range unionTypes {
			for _, t := range /* TODO(PropertyAccessExpression): u.types */ TODO {
				if insertType(checked, t) {
					if eachUnionContains(unionTypes, t) {
						if t == undefinedType && /* TODO(PropertyAccessExpression): result.length */ TODO && /* TODO(ElementAccessExpression): result[0] */ TODO == missingType {
							/* TODO(ContinueStatement): continue; */
						}
						if t == missingType && /* TODO(PropertyAccessExpression): result.length */ TODO && /* TODO(ElementAccessExpression): result[0] */ TODO == undefinedType {
							/* TODO(ExpressionStatement): result[0] = missingType; */
							/* TODO(ContinueStatement): continue; */
						}
						insertType(result, t)
					}
				}
			}
		}
		/* TODO(ExpressionStatement): types[index] = getUnionTypeFromSortedList(result, ObjectFlags.PrimitiveUnion); */
		return /* TODO(TrueKeyword): true */ TODO
	}
	createIntersectionType := func(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionType */ TODO {
		result := createType( /* TODO(PropertyAccessExpression): TypeFlags.Intersection */ TODO) /* as */ /* TODO(TypeReference): IntersectionType */
		/* TODO(ExpressionStatement): result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, /*excludeKinds* / TypeFlags.Nullable); */
		/* TODO(ExpressionStatement): result.types = types; */
		/* TODO(ExpressionStatement): result.aliasSymbol = aliasSymbol; */
		/* TODO(ExpressionStatement): result.aliasTypeArguments = aliasTypeArguments; */
		return result
	}
	getIntersectionType := func(types []Type, flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeMembershipMap := /* TODO(NewExpression): new Map<string, Type>() */ TODO
		includes := addTypesToIntersection(typeMembershipMap, 0 /* as */ /* TODO(TypeReference): TypeFlags */, types)
		var typeSet []Type = arrayFrom( /* TODO(PropertyAccessExpression): typeMembershipMap.values */ TODO())
		objectFlags := /* TODO(PropertyAccessExpression): ObjectFlags.None */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Never */ TODO {
			return /* TODO(ConditionalExpression): contains(typeSet, silentNeverType) ? silentNeverType : neverType */ TODO
		}
		if strictNullChecks && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Nullable */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.Object | TypeFlags.NonPrimitive | TypeFlags.IncludesEmptyObject) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.NonPrimitive */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.DisjointDomains & ~TypeFlags.NonPrimitive) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.StringLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.DisjointDomains & ~TypeFlags.StringLike) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.NumberLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.DisjointDomains & ~TypeFlags.NumberLike) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.BigIntLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.DisjointDomains & ~TypeFlags.BigIntLike) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.ESSymbolLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.DisjointDomains & ~TypeFlags.ESSymbolLike) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.VoidLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.DisjointDomains & ~TypeFlags.VoidLike) */ TODO {
			return neverType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.StringLiteral */ TODO && extractRedundantTemplateLiterals(typeSet) {
			return neverType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Any */ TODO {
			return /* TODO(ConditionalExpression): includes & TypeFlags.IncludesWildcard ? wildcardType : includes & TypeFlags.IncludesError ? errorType : anyType */ TODO
		}
		if !strictNullChecks && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Nullable */ TODO {
			return /* TODO(ConditionalExpression): includes & TypeFlags.IncludesEmptyObject ? neverType : includes & TypeFlags.Undefined ? undefinedType : nullType */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.String */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Number */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.NumberLiteral */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.BigInt */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.BigIntLiteral */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.ESSymbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.UniqueESSymbol */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Void */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Undefined */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.IncludesEmptyObject */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.DefinitelyNonNullable */ TODO {
			if ! /* TODO(ParenthesizedExpression): (flags & IntersectionFlags.NoSupertypeReduction) */ TODO {
				/* TODO(CallExpression): removeRedundantSupertypes(typeSet, includes) */
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.IncludesMissingType */ TODO {
			/* TODO(ExpressionStatement): typeSet[typeSet.indexOf(undefinedType)] = missingType; */
		}
		if /* TODO(PropertyAccessExpression): typeSet.length */ TODO == 0 {
			return unknownType
		}
		if /* TODO(PropertyAccessExpression): typeSet.length */ TODO == 1 {
			return /* TODO(ElementAccessExpression): typeSet[0] */ TODO
		}
		if /* TODO(PropertyAccessExpression): typeSet.length */ TODO == 2 && ! /* TODO(ParenthesizedExpression): (flags & IntersectionFlags.NoConstraintReduction) */ TODO {
			typeVarIndex := /* TODO(ConditionalExpression): typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
			typeVariable := /* TODO(ElementAccessExpression): typeSet[typeVarIndex] */ TODO
			primitiveType := /* TODO(ElementAccessExpression): typeSet[1 - typeVarIndex] */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): typeVariable.flags & TypeFlags.TypeVariable */ TODO && /* TODO(ParenthesizedExpression): (primitiveType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) && !isGenericStringLikeType(primitiveType) || includes & TypeFlags.IncludesEmptyObject) */ TODO {
				constraint := getBaseConstraintOfType(typeVariable)
				if constraint && everyType(constraint /* TODO(ArrowFunction): t => !!(t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) || isEmptyAnonymousObjectType(t) */, TODO) {
					if isTypeStrictSubtypeOf(constraint, primitiveType) {
						return typeVariable
					}
					if ! /* TODO(ParenthesizedExpression): (constraint.flags & TypeFlags.Union && someType(constraint, c => isTypeStrictSubtypeOf(c, primitiveType))) */ TODO {
						if !isTypeStrictSubtypeOf(primitiveType, constraint) {
							return neverType
						}
					}
					/* TODO(ExpressionStatement): objectFlags = ObjectFlags.IsConstrainedTypeVariable; */
				}
			}
		}
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeSet) + (flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments)) */ TODO
		result := /* TODO(PropertyAccessExpression): intersectionTypes.get */ TODO(id)
		if !result {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): includes & TypeFlags.Union */ TODO {
				if intersectUnionsOfPrimitiveTypes(typeSet) {
					/* TODO(ExpressionStatement): result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments); */
				} else if every(typeSet /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Union && (t as UnionType).types[0].flags & TypeFlags.Undefined) */, TODO) {
					containedUndefinedType := /* TODO(ConditionalExpression): some(typeSet, containsMissingType) ? missingType : undefinedType */ TODO
					removeFromEach(typeSet /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, TODO)
					/* TODO(ExpressionStatement): result = getUnionType([getIntersectionType(typeSet, flags), containedUndefinedType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments); */
				} else if every(typeSet /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Union && ((t as UnionType).types[0].flags & TypeFlags.Null || (t as UnionType).types[1].flags & TypeFlags.Null)) */, TODO) {
					removeFromEach(typeSet /* TODO(PropertyAccessExpression): TypeFlags.Null */, TODO)
					/* TODO(ExpressionStatement): result = getUnionType([getIntersectionType(typeSet, flags), nullType], UnionReduction.Literal, aliasSymbol, aliasTypeArguments); */
				} else if /* TODO(PropertyAccessExpression): typeSet.length */ TODO >= 3 && /* TODO(PropertyAccessExpression): types.length */ TODO > 2 {
					middle := /* TODO(PropertyAccessExpression): Math.floor */ TODO( /* TODO(SlashToken): / */ /* TODO(BinaryExpression): typeSet.length / 2 */ TODO)
					/* TODO(ExpressionStatement): result = getIntersectionType([getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)], flags, aliasSymbol, aliasTypeArguments); */
				} else {
					if !checkCrossProductUnion(typeSet) {
						return errorType
					}
					constituents := getCrossProductIntersections(typeSet, flags)
					origin := /* TODO(ConditionalExpression): some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined */ TODO
					/* TODO(ExpressionStatement): result = getUnionType(constituents, UnionReduction.Literal, aliasSymbol, aliasTypeArguments, origin); */
				}
			} else {
				/* TODO(ExpressionStatement): result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments); */
			}
			/* TODO(PropertyAccessExpression): intersectionTypes.set */ TODO(id, result)
		}
		return result
	}
	getCrossProductUnionSize := func(types []Type) /* TODO(undefined): number */ TODO {
		return reduceLeft(types /* TODO(ArrowFunction): (n, t) => t.flags & TypeFlags.Union ? n * (t as UnionType).types.length : t.flags & TypeFlags.Never ? 0 : n */, TODO, 1)
	}
	checkCrossProductUnion := func(types []Type) /* TODO(undefined): boolean */ TODO {
		size := getCrossProductUnionSize(types)
		if size >= 100000 {
			/* TODO(PropertyAccessExpression): tracing?.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "checkCrossProductUnion_DepthLimit" /* TODO(ObjectLiteralExpression): { typeIds: types.map(t => t.id), size } */, TODO)
			error(currentNode /* TODO(PropertyAccessExpression): Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent */, TODO)
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getCrossProductIntersections := func(types []Type, flags IntersectionFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		count := getCrossProductUnionSize(types)
		var intersections []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < count; i++) {             const constituents = types.slice();             let n = i;             for (let j = types.length - 1; j >= 0; j--) {                 if (types[j].flags & TypeFlags.Union) {                     const sourceTypes = (types[j] as UnionType).types;                     const length = sourceTypes.length;                     constituents[j] = sourceTypes[n % length];                     n = Math.floor(n / length);                 }             }             const t = getIntersectionType(constituents, flags);             if (!(t.flags & TypeFlags.Never)) intersections.push(t);         } */
		return intersections
	}
	getConstituentCount := func(type_ Type) number {
		return /* TODO(ConditionalExpression): !(type.flags & TypeFlags.UnionOrIntersection) || type.aliasSymbol ? 1 :             type.flags & TypeFlags.Union && (type as UnionType).origin ? getConstituentCount((type as UnionType).origin!) :             getConstituentCountOfTypes((type as UnionOrIntersectionType).types) */ TODO
	}
	getConstituentCountOfTypes := func(types []Type) number {
		return reduceLeft(types /* TODO(ArrowFunction): (n, t) => n + getConstituentCount(t) */, TODO, 0)
	}
	getTypeFromIntersectionTypeNode := func(node IntersectionTypeNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			types := map_( /* TODO(PropertyAccessExpression): node.types */ TODO, getTypeFromTypeNode)
			emptyIndex := /* TODO(ConditionalExpression): types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1 */ TODO
			t := /* TODO(ConditionalExpression): emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType */ TODO
			noSupertypeReduction := !! /* TODO(ParenthesizedExpression): (t.flags & (TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt) || t.flags & TypeFlags.TemplateLiteral && isPatternLiteralType(t)) */ TODO
			/* TODO(ExpressionStatement): links.resolvedType = getIntersectionType(types, noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol)); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	createIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		result := createType( /* TODO(PropertyAccessExpression): TypeFlags.Index */ TODO) /* as */ /* TODO(TypeReference): IndexType */
		/* TODO(ExpressionStatement): result.type = type; */
		/* TODO(ExpressionStatement): result.indexFlags = indexFlags; */
		return result
	}
	createOriginIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		result := createOriginType( /* TODO(PropertyAccessExpression): TypeFlags.Index */ TODO) /* as */ /* TODO(TypeReference): IndexType */
		/* TODO(ExpressionStatement): result.type = type; */
		return result
	}
	getIndexTypeForGenericType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		return /* TODO(ConditionalExpression): indexFlags & IndexFlags.StringsOnly ?             type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly)) :             type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, IndexFlags.None)) */ TODO
	}
	getIndexTypeForMappedType := func(type_ MappedType, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		nameType := getNameTypeFromMappedType( /* TODO(PropertyAccessExpression): type.target */ TODO /* as */ /* TODO(TypeReference): MappedType */ || type_)
		if !nameType && ! /* TODO(ParenthesizedExpression): (indexFlags & IndexFlags.NoIndexSignatures) */ TODO {
			return constraintType
		}
		var keyTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		if isGenericIndexType(constraintType) {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				return getIndexTypeForGenericType(type_, indexFlags)
			}
			forEachType(constraintType, addMemberForKeyType)
		} else if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO, !! /* TODO(ParenthesizedExpression): (indexFlags & IndexFlags.StringsOnly) */ TODO, addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		result := /* TODO(ConditionalExpression): indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes) */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & TypeFlags.Union */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constraintType.flags & TypeFlags.Union */ TODO && getTypeListId( /* TODO(PropertyAccessExpression): (result as UnionType).types */ TODO) == getTypeListId( /* TODO(PropertyAccessExpression): (constraintType as UnionType).types */ TODO) {
			return constraintType
		}
		return result
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			/* TODO(PropertyAccessExpression): keyTypes.push */ TODO( /* TODO(ConditionalExpression): propNameType === stringType ? stringOrNumberType : propNameType */ TODO)
		}
	}
	hasDistributiveNameType := func(mappedType MappedType) /* TODO(undefined): boolean */ TODO {
		typeVariable := getTypeParameterFromMappedType(mappedType)
		return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable)
		isDistributive := func(type_ Type) bool {
			return /* TODO(ConditionalExpression): type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true :                 type.flags & TypeFlags.Conditional ? (type as ConditionalType).root.isDistributive && (type as ConditionalType).checkType === typeVariable :                 type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every((type as UnionOrIntersectionType | TemplateLiteralType).types, isDistributive) :                 type.flags & TypeFlags.IndexedAccess ? isDistributive((type as IndexedAccessType).objectType) && isDistributive((type as IndexedAccessType).indexType) :                 type.flags & TypeFlags.Substitution ? isDistributive((type as SubstitutionType).baseType) && isDistributive((type as SubstitutionType).constraint) :                 type.flags & TypeFlags.StringMapping ? isDistributive((type as StringMappingType).type) :                 false */ TODO
		}
	}
	getLiteralTypeFromPropertyName := func(name /* TODO(UnionType): PropertyName | JsxAttributeName */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isPrivateIdentifier(name) {
			return neverType
		}
		if isNumericLiteral(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		if isComputedPropertyName(name) {
			return getRegularTypeOfLiteralType(checkComputedPropertyName(name))
		}
		propertyName := getPropertyNameForPropertyNameNode(name)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propertyName !== undefined */ TODO {
			return getStringLiteralType(unescapeLeadingUnderscores(propertyName))
		}
		if isExpression(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		return neverType
	}
	getLiteralTypeFromProperty := func(prop Symbol, include TypeFlags, includeNonPublic bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if includeNonPublic || ! /* TODO(ParenthesizedExpression): (getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlags.NonPublicAccessibilityModifier) */ TODO {
			type_ := /* TODO(PropertyAccessExpression): getSymbolLinks(getLateBoundSymbol(prop)).nameType */ TODO
			if !type_ {
				name := getNameOfDeclaration( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) /* as */ /* TODO(UnionType): PropertyName | JsxAttributeName */
				/* TODO(ExpressionStatement): type = prop.escapedName === InternalSymbolName.Default ? getStringLiteralType("default") :                     name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined); */
			}
			if type_ && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & include */ TODO {
				return type_
			}
		}
		return neverType
	}
	isKeyTypeIncluded := func(keyType Type, include TypeFlags) bool {
		return !! /* TODO(ParenthesizedExpression): (keyType.flags & include || keyType.flags & TypeFlags.Intersection && some((keyType as IntersectionType).types, t => isKeyTypeIncluded(t, include))) */ TODO
	}
	getLiteralTypeFromProperties := func(type_ Type, include TypeFlags, includeOrigin bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		origin := /* TODO(ConditionalExpression): includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined */ TODO
		propertyTypes := map_(getPropertiesOfType(type_) /* TODO(ArrowFunction): prop => getLiteralTypeFromProperty(prop, include) */, TODO)
		indexKeyTypes := map_(getIndexInfosOfType(type_) /* TODO(ArrowFunction): info =>             info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ?                 info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType */, TODO)
		return getUnionType(concatenate(propertyTypes, indexKeyTypes) /* TODO(PropertyAccessExpression): UnionReduction.Literal */, TODO, nil, nil, origin)
	}
	shouldDeferIndexType := func(type_ Type, indexFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IndexFlags.None */) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.InstantiableNonPrimitive ||             isGenericTupleType(type) ||             isGenericMappedType(type) && (!hasDistributiveNameType(type) || getMappedTypeNameTypeKind(type) === MappedTypeNameTypeKind.Remapping) ||             type.flags & TypeFlags.Union && !(indexFlags & IndexFlags.NoReducibleCheck) && isGenericReducibleType(type) ||             type.flags & TypeFlags.Intersection && maybeTypeOfKind(type, TypeFlags.Instantiable) && some((type as IntersectionType).types, isEmptyAnonymousObjectType)) */ TODO
	}
	getIndexType := func(type_ Type, indexFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IndexFlags.None */) Type {
		/* TODO(ExpressionStatement): type = getReducedType(type); */
		return /* TODO(ConditionalExpression): isNoInferType(type) ? getNoInferType(getIndexType((type as SubstitutionType).baseType, indexFlags)) :             shouldDeferIndexType(type, indexFlags) ? getIndexTypeForGenericType(type as InstantiableType | UnionOrIntersectionType, indexFlags) :             type.flags & TypeFlags.Union ? getIntersectionType(map((type as UnionType).types, t => getIndexType(t, indexFlags))) :             type.flags & TypeFlags.Intersection ? getUnionType(map((type as IntersectionType).types, t => getIndexType(t, indexFlags))) :             getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(type as MappedType, indexFlags) :             type === wildcardType ? wildcardType :             type.flags & TypeFlags.Unknown ? neverType :             type.flags & (TypeFlags.Any | TypeFlags.Never) ? stringNumberSymbolType :             getLiteralTypeFromProperties(type, (indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike), indexFlags === IndexFlags.None) */ TODO
	}
	getExtractStringType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		extractTypeAlias := getGlobalExtractSymbol()
		return /* TODO(ConditionalExpression): extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType */ TODO
	}
	getIndexTypeOrString := func(type_ Type) Type {
		indexType := getExtractStringType(getIndexType(type_))
		return /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Never ? stringType : indexType */ TODO
	}
	getTypeFromTypeOperatorNode := func(node TypeOperatorNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			/* TODO(SwitchStatement): switch (node.operator) {                 case SyntaxKind.KeyOfKeyword:                     links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));                     break;                 case SyntaxKind.UniqueKeyword:                     links.resolvedType = node.type.kind === SyntaxKind.SymbolKeyword                         ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))                         : errorType;                     break;                 case SyntaxKind.ReadonlyKeyword:                     links.resolvedType = getTypeFromTypeNode(node.type);                     break;                 default:                     Debug.assertNever(node.operator);             } */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getTypeFromTemplateTypeNode := func(node TemplateLiteralTypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			/* TODO(ExpressionStatement): links.resolvedType = getTemplateLiteralType(                 [node.head.text, ...map(node.templateSpans, span => span.literal.text)],                 map(node.templateSpans, span => getTypeFromTypeNode(span.type)),             ); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getTemplateLiteralType := func(texts []string, types []Type) Type {
		unionIndex := findIndex(types /* TODO(ArrowFunction): t => !!(t.flags & (TypeFlags.Never | TypeFlags.Union)) */, TODO)
		if unionIndex >= 0 {
			return /* TODO(ConditionalExpression): checkCrossProductUnion(types) ?                 mapType(types[unionIndex], t => getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))) :                 errorType */ TODO
		}
		if contains(types, wildcardType) {
			return wildcardType
		}
		var newTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var newTexts []string = /* TODO(ArrayLiteralExpression): [] */ TODO
		text := /* TODO(ElementAccessExpression): texts[0] */ TODO
		if !addSpans(texts, types) {
			return stringType
		}
		if /* TODO(PropertyAccessExpression): newTypes.length */ TODO == 0 {
			return getStringLiteralType(text)
		}
		/* TODO(PropertyAccessExpression): newTexts.push */ TODO(text)
		if every(newTexts /* TODO(ArrowFunction): t => t === "" */, TODO) {
			if every(newTypes /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.String) */, TODO) {
				return stringType
			}
			if /* TODO(PropertyAccessExpression): newTypes.length */ TODO == 1 && isPatternLiteralType( /* TODO(ElementAccessExpression): newTypes[0] */ TODO) {
				return /* TODO(ElementAccessExpression): newTypes[0] */ TODO
			}
		}
		id := /* TODO(TemplateExpression): `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}` */ TODO
		type_ := /* TODO(PropertyAccessExpression): templateLiteralTypes.get */ TODO(id)
		if !type_ {
			/* TODO(PropertyAccessExpression): templateLiteralTypes.set */ TODO(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createTemplateLiteralType(newTexts, newTypes) */, TODO)
		}
		return type_
		addSpans := func(texts []string, types []Type) bool {
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 const t = types[i];                 if (t.flags & (TypeFlags.Literal | TypeFlags.Null | TypeFlags.Undefined)) {                     text += getTemplateStringForType(t) || "";                     text += texts[i + 1];                 }                 else if (t.flags & TypeFlags.TemplateLiteral) {                     text += (t as TemplateLiteralType).texts[0];                     if (!addSpans((t as TemplateLiteralType).texts, (t as TemplateLiteralType).types)) return false;                     text += texts[i + 1];                 }                 else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {                     newTypes.push(t);                     newTexts.push(text);                     text = texts[i + 1];                 }                 else {                     return false;                 }             } */
			return /* TODO(TrueKeyword): true */ TODO
		}
	}
	getTemplateStringForType := func(type_ Type) /* TODO(undefined): string | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? (type as StringLiteralType).value :             type.flags & TypeFlags.NumberLiteral ? "" + (type as NumberLiteralType).value :             type.flags & TypeFlags.BigIntLiteral ? pseudoBigIntToString((type as BigIntLiteralType).value) :             type.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) ? (type as IntrinsicType).intrinsicName :             undefined */ TODO
	}
	createTemplateLiteralType := func(texts []string, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ TODO {
		type_ := createType( /* TODO(PropertyAccessExpression): TypeFlags.TemplateLiteral */ TODO) /* as */ /* TODO(TypeReference): TemplateLiteralType */
		/* TODO(ExpressionStatement): type.texts = texts; */
		/* TODO(ExpressionStatement): type.types = types; */
		return type_
	}
	getStringMappingType := func(symbol Symbol, type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Union | TypeFlags.Never) ? mapType(type, t => getStringMappingType(symbol, t)) :             type.flags & TypeFlags.StringLiteral ? getStringLiteralType(applyStringMapping(symbol, (type as StringLiteralType).value)) :             type.flags & TypeFlags.TemplateLiteral ? getTemplateLiteralType(...applyTemplateStringMapping(symbol, (type as TemplateLiteralType).texts, (type as TemplateLiteralType).types)) :             // Mapping<Mapping<T>> === Mapping<T>             type.flags & TypeFlags.StringMapping && symbol === type.symbol ? type :             type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.StringMapping) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :             // This handles Mapping<`${number}`> and Mapping<`${bigint}`>             isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) :             type */ TODO
	}
	applyStringMapping := func(symbol Symbol, str string) /* TODO(undefined): string */ TODO {
		/* TODO(SwitchStatement): switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {             case IntrinsicTypeKind.Uppercase:                 return str.toUpperCase();             case IntrinsicTypeKind.Lowercase:                 return str.toLowerCase();             case IntrinsicTypeKind.Capitalize:                 return str.charAt(0).toUpperCase() + str.slice(1);             case IntrinsicTypeKind.Uncapitalize:                 return str.charAt(0).toLowerCase() + str.slice(1);         } */
		return str
	}
	applyTemplateStringMapping := func(symbol Symbol, texts []string, types []Type) /* TODO(TupleType): [texts: readonly string[], types: readonly Type[]] */ TODO {
		/* TODO(SwitchStatement): switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {             case IntrinsicTypeKind.Uppercase:                 return [texts.map(t => t.toUpperCase()), types.map(t => getStringMappingType(symbol, t))];             case IntrinsicTypeKind.Lowercase:                 return [texts.map(t => t.toLowerCase()), types.map(t => getStringMappingType(symbol, t))];             case IntrinsicTypeKind.Capitalize:                 return [texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];             case IntrinsicTypeKind.Uncapitalize:                 return [texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];         } */
		return /* TODO(ArrayLiteralExpression): [texts, types] */ TODO
	}
	getStringMappingTypeForGenericType := func(symbol Symbol, type_ Type) Type {
		id := /* TODO(TemplateExpression): `${getSymbolId(symbol)},${getTypeId(type)}` */ TODO
		result := /* TODO(PropertyAccessExpression): stringMappingTypes.get */ TODO(id)
		if !result {
			/* TODO(PropertyAccessExpression): stringMappingTypes.set */ TODO(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = createStringMappingType(symbol, type) */, TODO)
		}
		return result
	}
	createStringMappingType := func(symbol Symbol, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO {
		result := createTypeWithSymbol( /* TODO(PropertyAccessExpression): TypeFlags.StringMapping */ TODO, symbol) /* as */ /* TODO(TypeReference): StringMappingType */
		/* TODO(ExpressionStatement): result.type = type; */
		return result
	}
	createIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexedAccessType */ TODO {
		type_ := createType( /* TODO(PropertyAccessExpression): TypeFlags.IndexedAccess */ TODO) /* as */ /* TODO(TypeReference): IndexedAccessType */
		/* TODO(ExpressionStatement): type.objectType = objectType; */
		/* TODO(ExpressionStatement): type.indexType = indexType; */
		/* TODO(ExpressionStatement): type.accessFlags = accessFlags; */
		/* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
		/* TODO(ExpressionStatement): type.aliasTypeArguments = aliasTypeArguments; */
		return type_
	}
	isJSLiteralType := func(type_ Type) bool {
		if noImplicitAny {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.JSLiteral */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			return every( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isJSLiteralType)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			return some( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, isJSLiteralType)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Instantiable */ TODO {
			constraint := getResolvedBaseConstraint(type_)
			return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== type */ TODO && isJSLiteralType(constraint)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getPropertyNameFromIndex := func(indexType Type, accessNode /* TODO(UnionType): PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(indexType) ?             getPropertyNameFromType(indexType) :             accessNode && isPropertyName(accessNode) ?             // late bound names are handled in the first branch, so here we only need to handle normal names             getPropertyNameForPropertyNameNode(accessNode) :             undefined */ TODO
	}
	isUncalledFunctionReference := func(node Node, symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method) */ TODO {
			parent := findAncestor( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): n => !isAccessExpression(n) */, TODO) || /* TODO(PropertyAccessExpression): node.parent */ TODO
			if isCallLikeExpression(parent) {
				return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node)
			}
			return every( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => !isFunctionLike(d) || isDeprecatedDeclaration(d) */, TODO)
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getPropertyTypeForIndexType := func(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessExpression := /* TODO(ConditionalExpression): accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined */ TODO
		propName := /* TODO(ConditionalExpression): accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode) */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.Contextual */ TODO {
				return getTypeOfPropertyOfContextualType(objectType, propName) || anyType
			}
			prop := getPropertyOfType(objectType, propName)
			if prop {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.ReportDeprecated */ TODO && accessNode && /* TODO(PropertyAccessExpression): prop.declarations */ TODO && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop) {
					deprecatedNode := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
					addDeprecatedSuggestion(deprecatedNode /* TODO(PropertyAccessExpression): prop.declarations */, TODO, propName /* as */ /* TODO(StringKeyword): string */)
				}
				if accessExpression {
					markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess( /* TODO(PropertyAccessExpression): accessExpression.expression */ TODO /* TODO(PropertyAccessExpression): objectType.symbol */, TODO))
					if isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
						error( /* TODO(PropertyAccessExpression): accessExpression.argumentExpression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property */, TODO, symbolToString(prop))
						return nil
					}
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.CacheSymbol */ TODO {
						/* TODO(ExpressionStatement): getNodeLinks(accessNode!).resolvedSymbol = prop; */
					}
					if isThisPropertyAccessInConstructor(accessExpression, prop) {
						return autoType
					}
				}
				propType := /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
				return /* TODO(ConditionalExpression): accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) :                     accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) :                     propType */ TODO
			}
			if everyType(objectType, isTupleType) && isNumericLiteralName(propName) {
				index := +propName
				if accessNode && everyType(objectType /* TODO(ArrowFunction): t => !((t as TupleTypeReference).target.combinedFlags & ElementFlags.Variable) */, TODO) && ! /* TODO(ParenthesizedExpression): (accessFlags & AccessFlags.AllowMissing) */ TODO {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					if isTupleType(objectType) {
						if index < 0 {
							error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value */, TODO)
							return undefinedType
						}
						error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2 */, TODO, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName))
					} else {
						error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO, unescapeLeadingUnderscores(propName), typeToString(objectType))
					}
				}
				if index >= 0 {
					errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType))
					return getTupleElementTypeOutOfStartCount(objectType, index /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined */, TODO)
				}
			}
		}
		if ! /* TODO(ParenthesizedExpression): (indexType.flags & TypeFlags.Nullable) */ TODO && isTypeAssignableToKind(indexType /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike */, TODO) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectType.flags & (TypeFlags.Any | TypeFlags.Never) */ TODO {
				return objectType
			}
			indexInfo := getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType)
			if indexInfo {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.NoIndexSignatures */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexInfo.keyType !== numberType */ TODO {
					if accessExpression {
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.Writing */ TODO {
							error(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading */, TODO, typeToString(originalObjectType))
						} else {
							error(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Type_0_cannot_be_used_to_index_type_1 */, TODO, typeToString(indexType), typeToString(originalObjectType))
						}
					}
					return nil
				}
				if accessNode && /* TODO(PropertyAccessExpression): indexInfo.keyType */ TODO == stringType && !isTypeAssignableToKind(indexType /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.String | TypeFlags.Number */, TODO) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.Type_0_cannot_be_used_as_an_index_type */, TODO, typeToString(indexType))
					return /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, missingType]) : indexInfo.type */ TODO
				}
				errorIfWritingToReadonlyIndex(indexInfo)
				if /* TODO(ParenthesizedExpression): (accessFlags & AccessFlags.IncludeUndefined) */ TODO && ! /* TODO(ParenthesizedExpression): (objectType.symbol &&                         objectType.symbol.flags & (SymbolFlags.RegularEnum | SymbolFlags.ConstEnum) &&                         (indexType.symbol &&                             indexType.flags & TypeFlags.EnumLiteral &&                             getParentOfSymbol(indexType.symbol) === objectType.symbol)) */ TODO {
					return getUnionType( /* TODO(ArrayLiteralExpression): [indexInfo.type, missingType] */ TODO)
				}
				return /* TODO(PropertyAccessExpression): indexInfo.type */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.Never */ TODO {
				return neverType
			}
			if isJSLiteralType(objectType) {
				return anyType
			}
			if accessExpression && !isConstEnumObjectType(objectType) {
				if isObjectLiteralType(objectType) {
					if noImplicitAny && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) */ TODO {
						/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNode(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO /* TODO(PropertyAccessExpression): (indexType as StringLiteralType).value */, TODO, typeToString(objectType)))
						return undefinedType
					} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & (TypeFlags.Number | TypeFlags.String) */ TODO {
						types := map_( /* TODO(PropertyAccessExpression): (objectType as ResolvedType).properties */ TODO /* TODO(ArrowFunction): property => {                             return getTypeOfSymbol(property);                         } */, TODO)
						return getUnionType(append(types, undefinedType))
					}
				}
				if /* TODO(PropertyAccessExpression): objectType.symbol */ TODO == globalThisSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO && /* TODO(PropertyAccessExpression): globalThisSymbol.exports!.has */ TODO(propName) && /* TODO(ParenthesizedExpression): (globalThisSymbol.exports!.get(propName)!.flags & SymbolFlags.BlockScoped) */ TODO {
					error(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO, unescapeLeadingUnderscores(propName), typeToString(objectType))
				} else if noImplicitAny && ! /* TODO(ParenthesizedExpression): (accessFlags & AccessFlags.SuppressNoImplicitAnyError) */ TODO {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO && typeHasStaticProperty(propName, objectType) {
						typeName := typeToString(objectType)
						error(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead */, TODO, propName /* as */ /* TODO(StringKeyword): string */, typeName /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]" */, TODO)
					} else if getIndexTypeOfType(objectType, numberType) {
						error( /* TODO(PropertyAccessExpression): accessExpression.argumentExpression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number */, TODO)
					} else {
						var suggestion /* TODO(StringKeyword): string */ any
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO && /* TODO(ParenthesizedExpression): (suggestion = getSuggestionForNonexistentProperty(propName as string, objectType)) */ TODO {
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
								error( /* TODO(PropertyAccessExpression): accessExpression.argumentExpression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */, TODO, propName /* as */ /* TODO(StringKeyword): string */, typeToString(objectType), suggestion)
							}
						} else {
							suggestion := getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
								error(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1 */, TODO, typeToString(objectType), suggestion)
							} else {
								var errorInfo *DiagnosticMessageChain
								if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.EnumLiteral */ TODO {
									/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType)); */
								} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.UniqueESSymbol */ TODO {
									symbolName := getFullyQualifiedName( /* TODO(PropertyAccessExpression): (indexType as UniqueESSymbolType).symbol */ TODO, accessExpression)
									/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName + "]", typeToString(objectType)); */
								} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.StringLiteral */ TODO {
									/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as StringLiteralType).value, typeToString(objectType)); */
								} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.NumberLiteral */ TODO {
									/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType as NumberLiteralType).value, typeToString(objectType)); */
								} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & (TypeFlags.Number | TypeFlags.String) */ TODO {
									/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(/*details* / undefined, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType)); */
								}
								/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                                     errorInfo,                                     Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1,                                     typeToString(fullIndexType),                                     typeToString(objectType),                                 ); */
								/* TODO(PropertyAccessExpression): diagnostics.add */
								TODO(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo))
							}
						}
					}
				}
				return nil
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.AllowMissing */ TODO && isObjectLiteralType(objectType) {
			return undefinedType
		}
		if isJSLiteralType(objectType) {
			return anyType
		}
		if accessNode {
			indexNode := getIndexNodeForAccessExpression(accessNode)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexNode.kind !== SyntaxKind.BigIntLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) */ TODO {
				error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (indexType as StringLiteralType | NumberLiteralType).value */, TODO, typeToString(objectType))
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & (TypeFlags.String | TypeFlags.Number) */ TODO {
				error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.Type_0_has_no_matching_index_signature_for_type_1 */, TODO, typeToString(objectType), typeToString(indexType))
			} else {
				typeString := /* TODO(ConditionalExpression): indexNode.kind === SyntaxKind.BigIntLiteral ? "bigint" : typeToString(indexType) */ TODO
				error(indexNode /* TODO(PropertyAccessExpression): Diagnostics.Type_0_cannot_be_used_as_an_index_type */, TODO, typeString)
			}
		}
		if isTypeAny(indexType) {
			return indexType
		}
		return nil
		errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
			if indexInfo && /* TODO(PropertyAccessExpression): indexInfo.isReadonly */ TODO && accessExpression && /* TODO(ParenthesizedExpression): (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) */ TODO {
				error(accessExpression /* TODO(PropertyAccessExpression): Diagnostics.Index_signature_in_type_0_only_permits_reading */, TODO, typeToString(objectType))
			}
		}
	}
	getIndexNodeForAccessExpression := func(accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrayBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
		return /* TODO(ConditionalExpression): accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression :             accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType :             accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression :             accessNode */ TODO
	}
	isPatternLiteralPlaceholderType := func(type_ Type) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			seenPlaceholder := /* TODO(FalseKeyword): false */ TODO
			for _, t := range /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & (TypeFlags.Literal | TypeFlags.Nullable) */ TODO || isPatternLiteralPlaceholderType(t) {
					/* TODO(ExpressionStatement): seenPlaceholder = true; */
				} else if ! /* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Object) */ TODO {
					return /* TODO(FalseKeyword): false */ TODO
				}
			}
			return seenPlaceholder
		}
		return !! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.Number | TypeFlags.BigInt)) */ TODO || isPatternLiteralType(type_)
	}
	isPatternLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.TemplateLiteral) */ TODO && every( /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).types */ TODO, isPatternLiteralPlaceholderType) || !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.StringMapping) */ TODO && isPatternLiteralPlaceholderType( /* TODO(PropertyAccessExpression): (type as StringMappingType).type */ TODO)
	}
	isGenericStringLikeType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping)) */ TODO && !isPatternLiteralType(type_)
	}
	isGenericType := func(type_ Type) bool {
		return !!getGenericObjectFlags(type_)
	}
	isGenericObjectType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (getGenericObjectFlags(type) & ObjectFlags.IsGenericObjectType) */ TODO
	}
	isGenericIndexType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (getGenericObjectFlags(type) & ObjectFlags.IsGenericIndexType) */ TODO
	}
	getGenericObjectFlags := func(type_ Type) ObjectFlags {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.UnionOrIntersection) */ TODO {
			if ! /* TODO(ParenthesizedExpression): ((type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericTypeComputed) */ TODO {
				/* TODO(ExpressionStatement): (type as UnionOrIntersectionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |                     reduceLeft((type as UnionOrIntersectionType).types, (flags, t) => flags | getGenericObjectFlags(t), 0); */
			}
			return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as UnionOrIntersectionType).objectFlags & ObjectFlags.IsGenericType */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
			if ! /* TODO(ParenthesizedExpression): ((type as SubstitutionType).objectFlags & ObjectFlags.IsGenericTypeComputed) */ TODO {
				/* TODO(ExpressionStatement): (type as SubstitutionType).objectFlags |= ObjectFlags.IsGenericTypeComputed |                     getGenericObjectFlags((type as SubstitutionType).baseType) | getGenericObjectFlags((type as SubstitutionType).constraint); */
			}
			return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as SubstitutionType).objectFlags & ObjectFlags.IsGenericType */ TODO
		}
		return /* TODO(BarToken): | */ /* TODO(BinaryExpression): (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0) |             (type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0) */ TODO
	}
	getSimplifiedType := func(type_ Type, writing bool) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(type as IndexedAccessType, writing) :             type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(type as ConditionalType, writing) :             type */ TODO
	}
	distributeIndexOverObjectType := func(objectType Type, indexType Type, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectType.flags & TypeFlags.Union */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectType.flags & TypeFlags.Intersection */ TODO && !shouldDeferIndexType(objectType) {
			types := map_( /* TODO(PropertyAccessExpression): (objectType as UnionOrIntersectionType).types */ TODO /* TODO(ArrowFunction): t => getSimplifiedType(getIndexedAccessType(t, indexType), writing) */, TODO)
			return /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types) */ TODO
		}
	}
	distributeObjectOverIndexType := func(objectType Type, indexType Type, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.Union */ TODO {
			types := map_( /* TODO(PropertyAccessExpression): (indexType as UnionType).types */ TODO /* TODO(ArrowFunction): t => getSimplifiedType(getIndexedAccessType(objectType, t), writing) */, TODO)
			return /* TODO(ConditionalExpression): writing ? getIntersectionType(types) : getUnionType(types) */ TODO
		}
	}
	getSimplifiedIndexedAccessType := func(type_ IndexedAccessType, writing bool) Type {
		cache := /* TODO(ConditionalExpression): writing ? "simplifiedForWriting" : "simplifiedForReading" */ TODO
		if /* TODO(ElementAccessExpression): type[cache] */ TODO {
			return /* TODO(ConditionalExpression): type[cache] === circularConstraintType ? type : type[cache] */ TODO
		}
		/* TODO(ExpressionStatement): type[cache] = circularConstraintType; */
		objectType := getSimplifiedType( /* TODO(PropertyAccessExpression): type.objectType */ TODO, writing)
		indexType := getSimplifiedType( /* TODO(PropertyAccessExpression): type.indexType */ TODO, writing)
		distributedOverIndex := distributeObjectOverIndexType(objectType, indexType, writing)
		if distributedOverIndex {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = distributedOverIndex */ TODO
		}
		if ! /* TODO(ParenthesizedExpression): (indexType.flags & TypeFlags.Instantiable) */ TODO {
			distributedOverObject := distributeIndexOverObjectType(objectType, indexType, writing)
			if distributedOverObject {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = distributedOverObject */ TODO
			}
		}
		if isGenericTupleType(objectType) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.NumberLike */ TODO {
			elementType := getElementTypeOfSliceOfTupleType(objectType /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength */, TODO, 0, writing)
			if elementType {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = elementType */ TODO
			}
		}
		if isGenericMappedType(objectType) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedTypeNameTypeKind(objectType) !== MappedTypeNameTypeKind.Remapping */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing)) */ TODO
			}
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = type */ TODO
	}
	getSimplifiedConditionalType := func(type_ ConditionalType, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkType := /* TODO(PropertyAccessExpression): type.checkType */ TODO
		extendsType := /* TODO(PropertyAccessExpression): type.extendsType */ TODO
		trueType := getTrueTypeFromConditionalType(type_)
		falseType := getFalseTypeFromConditionalType(type_)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): falseType.flags & TypeFlags.Never */ TODO && getActualTypeVariable(trueType) == getActualTypeVariable(checkType) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkType.flags & TypeFlags.Any */ TODO || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return getSimplifiedType(trueType, writing)
			} else if isIntersectionEmpty(checkType, extendsType) {
				return neverType
			}
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): trueType.flags & TypeFlags.Never */ TODO && getActualTypeVariable(falseType) == getActualTypeVariable(checkType) {
			if ! /* TODO(ParenthesizedExpression): (checkType.flags & TypeFlags.Any) */ TODO && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return neverType
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkType.flags & TypeFlags.Any */ TODO || isIntersectionEmpty(checkType, extendsType) {
				return getSimplifiedType(falseType, writing)
			}
		}
		return type_
	}
	isIntersectionEmpty := func(type1 Type, type2 Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getUnionType([intersectTypes(type1, type2), neverType]).flags & TypeFlags.Never) */ TODO
	}
	substituteIndexedMappedType := func(objectType MappedType, index Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		mapper := createTypeMapper( /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(objectType)] */ TODO /* TODO(ArrayLiteralExpression): [index] */, TODO)
		templateMapper := combineTypeMappers( /* TODO(PropertyAccessExpression): objectType.mapper */ TODO, mapper)
		instantiatedTemplateType := instantiateType(getTemplateTypeFromMappedType( /* TODO(PropertyAccessExpression): objectType.target */ TODO /* as */ /* TODO(TypeReference): MappedType */ || objectType), templateMapper)
		isOptional := getMappedTypeOptionality(objectType) > 0 || /* TODO(ParenthesizedExpression): (isGenericType(objectType) ?             getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 :             couldAccessOptionalProperty(objectType, index)) */ TODO
		return addOptionality(instantiatedTemplateType /* TODO(TrueKeyword): true */, TODO, isOptional)
	}
	couldAccessOptionalProperty := func(objectType Type, indexType Type) /* TODO(undefined): boolean */ TODO {
		indexConstraint := getBaseConstraintOfType(indexType)
		return !!indexConstraint && some(getPropertiesOfType(objectType) /* TODO(ArrowFunction): p =>             !!(p.flags & SymbolFlags.Optional) &&             isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlags.StringOrNumberLiteralOrUnique), indexConstraint) */, TODO)
	}
	getIndexedAccessType := func(objectType Type, indexType Type, accessFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || /* TODO(ParenthesizedExpression): (accessNode ? errorType : unknownType) */ TODO
	}
	indexTypeLessThan := func(indexType Type, limit number) /* TODO(undefined): boolean */ TODO {
		return everyType(indexType /* TODO(ArrowFunction): t => {             if (t.flags & TypeFlags.StringOrNumberLiteral) {                 const propName = getPropertyNameFromType(t as StringLiteralType | NumberLiteralType);                 if (isNumericLiteralName(propName)) {                     const index = +propName;                     return index >= 0 && index < limit;                 }             }             return false;         } */, TODO)
	}
	getIndexedAccessTypeOrUndefined := func(objectType Type, indexType Type, accessFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) *Type {
		if objectType == wildcardType || indexType == wildcardType {
			return wildcardType
		}
		/* TODO(ExpressionStatement): objectType = getReducedType(objectType); */
		if isStringIndexSignatureOnlyType(objectType) && ! /* TODO(ParenthesizedExpression): (indexType.flags & TypeFlags.Nullable) */ TODO && isTypeAssignableToKind(indexType /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.String | TypeFlags.Number */, TODO) {
			/* TODO(ExpressionStatement): indexType = stringType; */
		}
		if /* TODO(PropertyAccessExpression): compilerOptions.noUncheckedIndexedAccess */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.ExpressionPosition */ TODO {
			/* TODO(BinaryExpression): accessFlags |= AccessFlags.IncludeUndefined */
		}
		if isGenericIndexType(indexType) || /* TODO(ParenthesizedExpression): (accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ?                 isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)) :                 isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType)) */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectType.flags & TypeFlags.AnyOrUnknown */ TODO {
				return objectType
			}
			persistentAccessFlags := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): accessFlags & AccessFlags.Persistent */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			type_ := /* TODO(PropertyAccessExpression): indexedAccessTypes.get */ TODO(id)
			if !type_ {
				/* TODO(PropertyAccessExpression): indexedAccessTypes.set */ TODO(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments) */, TODO)
			}
			return type_
		}
		apparentObjectType := getReducedApparentType(objectType)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.Union */ TODO && ! /* TODO(ParenthesizedExpression): (indexType.flags & TypeFlags.Boolean) */ TODO {
			var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			wasMissingProp := /* TODO(FalseKeyword): false */ TODO
			for _, t := range /* TODO(PropertyAccessExpression): (indexType as UnionType).types */ TODO {
				propType := getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode /* TODO(BarToken): | */ /* TODO(BinaryExpression): accessFlags | (wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0) */, TODO)
				if propType {
					/* TODO(PropertyAccessExpression): propTypes.push */ TODO(propType)
				} else if !accessNode {
					return nil
				} else {
					/* TODO(ExpressionStatement): wasMissingProp = true; */
				}
			}
			if wasMissingProp {
				return nil
			}
			return /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing                 ? getIntersectionType(propTypes, IntersectionFlags.None, aliasSymbol, aliasTypeArguments)                 : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments) */ TODO
		}
		return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode /* TODO(BarToken): | */ /* TODO(BinaryExpression): accessFlags | AccessFlags.CacheSymbol | AccessFlags.ReportDeprecated */, TODO)
	}
	getTypeFromIndexedAccessTypeNode := func(node IndexedAccessTypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			objectType := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.objectType */ TODO)
			indexType := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.indexType */ TODO)
			potentialAlias := getAliasSymbolForTypeNode(node)
			/* TODO(ExpressionStatement): links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlags.None, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias)); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getTypeFromMappedTypeNode := func(node MappedTypeNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			type_ := createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.Mapped */ TODO /* TODO(PropertyAccessExpression): node.symbol */, TODO) /* as */ /* TODO(TypeReference): MappedType */
			/* TODO(ExpressionStatement): type.declaration = node; */
			/* TODO(ExpressionStatement): type.aliasSymbol = getAliasSymbolForTypeNode(node); */
			/* TODO(ExpressionStatement): type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol); */
			/* TODO(ExpressionStatement): links.resolvedType = type; */
			getConstraintTypeFromMappedType(type_)
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getActualTypeVariable := func(type_ Type) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
			return getActualTypeVariable( /* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.IndexedAccess */ TODO && /* TODO(ParenthesizedExpression): (                 (type as IndexedAccessType).objectType.flags & TypeFlags.Substitution ||                 (type as IndexedAccessType).indexType.flags & TypeFlags.Substitution             ) */ TODO {
			return getIndexedAccessType(getActualTypeVariable( /* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO), getActualTypeVariable( /* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO))
		}
		return type_
	}
	isSimpleTupleType := func(node TypeNode) bool {
		return isTupleTypeNode(node) && length( /* TODO(PropertyAccessExpression): node.elements */ TODO) > 0 && !some( /* TODO(PropertyAccessExpression): node.elements */ TODO /* TODO(ArrowFunction): e => isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken) */, TODO)
	}
	isDeferredType := func(type_ Type, checkTuples bool) /* TODO(undefined): boolean */ TODO {
		return isGenericType(type_) || checkTuples && isTupleType(type_) && some(getElementTypes(type_), isGenericType)
	}
	getConditionalType := func(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		var result TODO
		var extraTypes /* TODO(ArrayType): Type[] */ any
		tailCount := 0
		/* TODO(WhileStatement): while (true) {             if (tailCount === 1000) {                 error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);                 return errorType;             }             const checkType = instantiateType(getActualTypeVariable(root.checkType), mapper);             const extendsType = instantiateType(root.extendsType, mapper);             if (checkType === errorType || extendsType === errorType) {                 return errorType;             }             if (checkType === wildcardType || extendsType === wildcardType) {                 return wildcardType;             }             const checkTypeNode = skipTypeParentheses(root.node.checkType);             const extendsTypeNode = skipTypeParentheses(root.node.extendsType);             // When the check and extends types are simple tuple types of the same arity, we defer resolution of the             // conditional type when any tuple elements are generic. This is such that non-distributable conditional             // types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.             const checkTuples = isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) &&                 length((checkTypeNode as TupleTypeNode).elements) === length((extendsTypeNode as TupleTypeNode).elements);             const checkTypeDeferred = isDeferredType(checkType, checkTuples);             let combinedMapper: TypeMapper | undefined;             if (root.inferTypeParameters) {                 // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be                 // instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint                 // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].                 // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated                 // as `number`                 // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`                 // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`                 // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.                 // So we need to:                 //    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)                 //    * incorporate all of the component mappers into the combined mapper for the true and false members                 // This means we have two mappers that need applying:                 //    * The original `mapper` used to create this conditional                 //    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)                 const context = createInferenceContext(root.inferTypeParameters, /*signature* / undefined, InferenceFlags.None);                 if (mapper) {                     context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper);                 }                 if (!checkTypeDeferred) {                     // We don't want inferences from constraints as they may cause us to eagerly resolve the                     // conditional type instead of deferring resolution. Also, we always want strict function                     // types rules (i.e. proper contravariance) for inferences.                     inferTypes(context.inferences, checkType, extendsType, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);                 }                 // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the                 // those type parameters are used in type references (see getInferredTypeParameterConstraint). For                 // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.                 combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;             }             // Instantiate the extends type including inferences for 'infer T' type parameters             const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;             // We attempt to resolve the conditional type only when the check and extends types are non-generic             if (!checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples)) {                 // Return falseType for a definitely false extends check. We check an instantiations of the two                 // types with type parameters mapped to the wildcard type, the most permissive instantiations                 // possible (the wildcard type is assignable to and from all types). If those are not related,                 // then no instantiations will be and we can just return the false branch type.                 if (!(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) && (checkType.flags & TypeFlags.Any || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {                     // Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a                     // distributive conditional type applied to the constraint of a type variable, include trueType if                     // there are possible values of the check type that are also possible values of the extends type.                     // We use a reverse assignability check as it is less expensive than the comparable relationship                     // and avoids false positives of a non-empty intersection check.                     if (checkType.flags & TypeFlags.Any || forConstraint && !(inferredExtendsType.flags & TypeFlags.Never) && someType(getPermissiveInstantiation(inferredExtendsType), t => isTypeAssignableTo(t, getPermissiveInstantiation(checkType)))) {                         (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));                     }                     // If falseType is an immediately nested conditional type that isn't distributive or has an                     // identical checkType, switch to that type and loop.                     const falseType = getTypeFromTypeNode(root.node.falseType);                     if (falseType.flags & TypeFlags.Conditional) {                         const newRoot = (falseType as ConditionalType).root;                         if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {                             root = newRoot;                             continue;                         }                         if (canTailRecurse(falseType, mapper)) {                             continue;                         }                     }                     result = instantiateType(falseType, mapper);                     break;                 }                 // Return trueType for a definitely true extends check. We check instantiations of the two                 // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter                 // that has no constraint. This ensures that, for example, the type                 //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number                 // doesn't immediately resolve to 'string' instead of being deferred.                 if (inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {                     const trueType = getTypeFromTypeNode(root.node.trueType);                     const trueMapper = combinedMapper || mapper;                     if (canTailRecurse(trueType, trueMapper)) {                         continue;                     }                     result = instantiateType(trueType, trueMapper);                     break;                 }             }             // Return a deferred type for a check that is neither definitely true nor definitely false             result = createType(TypeFlags.Conditional) as ConditionalType;             result.root = root;             result.checkType = instantiateType(root.checkType, mapper);             result.extendsType = instantiateType(root.extendsType, mapper);             result.mapper = mapper;             result.combinedMapper = combinedMapper;             result.aliasSymbol = aliasSymbol || root.aliasSymbol;             result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!); // TODO: GH#18217             break;         } */
		return /* TODO(ConditionalExpression): extraTypes ? getUnionType(append(extraTypes, result)) : result */ TODO
		canTailRecurse := func(newType Type, newMapper *TypeMapper) /* TODO(undefined): boolean */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): newType.flags & TypeFlags.Conditional */ TODO && newMapper {
				newRoot := /* TODO(PropertyAccessExpression): (newType as ConditionalType).root */ TODO
				if /* TODO(PropertyAccessExpression): newRoot.outerTypeParameters */ TODO {
					typeParamMapper := combineTypeMappers( /* TODO(PropertyAccessExpression): (newType as ConditionalType).mapper */ TODO, newMapper)
					typeArguments := map_( /* TODO(PropertyAccessExpression): newRoot.outerTypeParameters */ TODO /* TODO(ArrowFunction): t => getMappedType(t, typeParamMapper) */, TODO)
					newRootMapper := createTypeMapper( /* TODO(PropertyAccessExpression): newRoot.outerTypeParameters */ TODO, typeArguments)
					newCheckType := /* TODO(ConditionalExpression): newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined */ TODO
					if !newCheckType || newCheckType == /* TODO(PropertyAccessExpression): newRoot.checkType */ TODO || ! /* TODO(ParenthesizedExpression): (newCheckType.flags & (TypeFlags.Union | TypeFlags.Never)) */ TODO {
						/* TODO(ExpressionStatement): root = newRoot; */
						/* TODO(ExpressionStatement): mapper = newRootMapper; */
						/* TODO(ExpressionStatement): aliasSymbol = undefined; */
						/* TODO(ExpressionStatement): aliasTypeArguments = undefined; */
						if /* TODO(PropertyAccessExpression): newRoot.aliasSymbol */ TODO {
							/* TODO(ExpressionStatement): tailCount++; */
						}
						return /* TODO(TrueKeyword): true */ TODO
					}
				}
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	getTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(PropertyAccessExpression): type.resolvedTrueType */ TODO || /* TODO(ParenthesizedExpression): (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper)) */ TODO
	}
	getFalseTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(PropertyAccessExpression): type.resolvedFalseType */ TODO || /* TODO(ParenthesizedExpression): (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper)) */ TODO
	}
	getInferredTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(PropertyAccessExpression): type.resolvedInferredTrueType */ TODO || /* TODO(ParenthesizedExpression): (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type)) */ TODO
	}
	getInferTypeParameters := func(node ConditionalTypeNode) /* TODO(ArrayType): TypeParameter[] */ any {
		var result /* TODO(ArrayType): TypeParameter[] */ any
		if /* TODO(PropertyAccessExpression): node.locals */ TODO {
			/* TODO(PropertyAccessExpression): node.locals.forEach */ TODO( /* TODO(ArrowFunction): symbol => {                 if (symbol.flags & SymbolFlags.TypeParameter) {                     result = append(result, getDeclaredTypeOfSymbol(symbol));                 }             } */ TODO)
		}
		return result
	}
	isDistributionDependent := func(root ConditionalRoot) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): root.isDistributive */ TODO && /* TODO(ParenthesizedExpression): (             isTypeParameterPossiblyReferenced(root.checkType as TypeParameter, root.node.trueType) ||             isTypeParameterPossiblyReferenced(root.checkType as TypeParameter, root.node.falseType)         ) */ TODO
	}
	getTypeFromConditionalTypeNode := func(node ConditionalTypeNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			checkType := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.checkType */ TODO)
			aliasSymbol := getAliasSymbolForTypeNode(node)
			aliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			allOuterTypeParameters := getOuterTypeParameters(node /* TODO(TrueKeyword): true */, TODO)
			outerTypeParameters := /* TODO(ConditionalExpression): aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node)) */ TODO
			var root ConditionalRoot = /* TODO(ObjectLiteralExpression): {                 node,                 checkType,                 extendsType: getTypeFromTypeNode(node.extendsType),                 isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),                 inferTypeParameters: getInferTypeParameters(node),                 outerTypeParameters,                 instantiations: undefined,                 aliasSymbol,                 aliasTypeArguments,             } */ TODO
			/* TODO(ExpressionStatement): links.resolvedType = getConditionalType(root, /*mapper* / undefined, /*forConstraint* / false); */
			if outerTypeParameters {
				/* TODO(ExpressionStatement): root.instantiations = new Map<string, Type>(); */
				/* TODO(PropertyAccessExpression): root.instantiations.set */
				TODO(getTypeListId(outerTypeParameters) /* TODO(PropertyAccessExpression): links.resolvedType */, TODO)
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getTypeFromInferTypeNode := func(node InferTypeNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			/* TODO(ExpressionStatement): links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter)); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getIdentifierChain := func(node EntityName) []Identifier {
		if isIdentifier(node) {
			return /* TODO(ArrayLiteralExpression): [node] */ TODO
		} else {
			return append(getIdentifierChain( /* TODO(PropertyAccessExpression): node.left */ TODO) /* TODO(PropertyAccessExpression): node.right */, TODO)
		}
	}
	getTypeFromImportTypeNode := func(node ImportTypeNode) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			if !isLiteralImportTypeNode(node) {
				error( /* TODO(PropertyAccessExpression): node.argument */ TODO /* TODO(PropertyAccessExpression): Diagnostics.String_literal_expected */, TODO)
				/* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			targetMeaning := /* TODO(ConditionalExpression): node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type */ TODO
			innerModuleSymbol := resolveExternalModuleName(node /* TODO(PropertyAccessExpression): node.argument.literal */, TODO)
			if !innerModuleSymbol {
				/* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			isExportEquals := !! /* TODO(PropertyAccessExpression): innerModuleSymbol.exports?.get */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.ExportEquals */ TODO)
			moduleSymbol := resolveExternalModuleSymbol(innerModuleSymbol /* TODO(FalseKeyword): false */, TODO)
			if !nodeIsMissing( /* TODO(PropertyAccessExpression): node.qualifier */ TODO) {
				var nameStack []Identifier = getIdentifierChain( /* TODO(NonNullExpression): node.qualifier! */ TODO)
				currentNamespace := moduleSymbol
				var current *Identifier
				/* TODO(WhileStatement): while (current = nameStack.shift()) {                     const meaning = nameStack.length ? SymbolFlags.Namespace : targetMeaning;                     // typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`                     // That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from                     // the `exports` lookup process that only looks up namespace members which is used for most type references                     const mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));                     const symbolFromVariable = node.isTypeOf || isInJSFile(node) && isExportEquals                         ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment* / false, /*includeTypeOnlyMembers* / true)                         : undefined;                     const symbolFromModule = node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);                     const next = symbolFromModule ?? symbolFromVariable;                     if (!next) {                         error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current));                         return links.resolvedType = errorType;                     }                     getNodeLinks(current).resolvedSymbol = next;                     getNodeLinks(current.parent).resolvedSymbol = next;                     currentNamespace = next;                 } */
				/* TODO(ExpressionStatement): links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning); */
			} else {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): moduleSymbol.flags & targetMeaning */ TODO {
					/* TODO(ExpressionStatement): links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning); */
				} else {
					errorMessage := /* TODO(ConditionalExpression): targetMeaning === SymbolFlags.Value                         ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here                         : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 */ TODO
					error(node, errorMessage /* TODO(PropertyAccessExpression): node.argument.literal.text */, TODO)
					/* TODO(ExpressionStatement): links.resolvedSymbol = unknownSymbol; */
					/* TODO(ExpressionStatement): links.resolvedType = errorType; */
				}
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	resolveImportSymbolType := func(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		resolvedSymbol := resolveSymbol(symbol)
		/* TODO(ExpressionStatement): links.resolvedSymbol = resolvedSymbol; */
		if meaning == /* TODO(PropertyAccessExpression): SymbolFlags.Value */ TODO {
			return getInstantiationExpressionType(getTypeOfSymbol(symbol), node)
		} else {
			return getTypeReferenceType(node, resolvedSymbol)
		}
	}
	getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode := func(node /* TODO(UnionType): TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			if /* TODO(PropertyAccessExpression): getMembersOfSymbol(node.symbol).size */ TODO == 0 && !aliasSymbol {
				/* TODO(ExpressionStatement): links.resolvedType = emptyTypeLiteralType; */
			} else {
				type_ := createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO /* TODO(PropertyAccessExpression): node.symbol */, TODO)
				/* TODO(ExpressionStatement): type.aliasSymbol = aliasSymbol; */
				/* TODO(ExpressionStatement): type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol); */
				if isJSDocTypeLiteral(node) && /* TODO(PropertyAccessExpression): node.isArrayType */ TODO {
					/* TODO(ExpressionStatement): type = createArrayType(type); */
				}
				/* TODO(ExpressionStatement): links.resolvedType = type; */
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getAliasSymbolForTypeNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		host := /* TODO(PropertyAccessExpression): node.parent */ TODO
		/* TODO(WhileStatement): while (isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator === SyntaxKind.ReadonlyKeyword) {             host = host.parent;         } */
		return /* TODO(ConditionalExpression): isTypeAlias(host) ? getSymbolOfDeclaration(host) : undefined */ TODO
	}
	getTypeArgumentsForAliasSymbol := func(symbol *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		return /* TODO(ConditionalExpression): symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined */ TODO
	}
	isNonGenericObjectType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object) */ TODO && !isGenericMappedType(type_)
	}
	isEmptyObjectTypeOrSpreadsIntoEmptyObject := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return isEmptyObjectType(type_) || !! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.Null | TypeFlags.Undefined | TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index)) */ TODO
	}
	tryMergeUnionOfObjectTypeAndEmptyObject := func(type_ Type, readonly bool) Type {
		if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union) */ TODO {
			return type_
		}
		if every( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
			return find( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isEmptyObjectType) || emptyObjectType
		}
		firstType := find( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO /* TODO(ArrowFunction): t => !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t) */, TODO)
		if !firstType {
			return type_
		}
		secondType := find( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO /* TODO(ArrowFunction): t => t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t) */, TODO)
		if secondType {
			return type_
		}
		return getAnonymousPartialType(firstType)
		getAnonymousPartialType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			members := createSymbolTable()
			for _, prop := range getPropertiesOfType(type_) {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlags.Private | ModifierFlags.Protected) */ TODO {
				} else if isSpreadableProperty(prop) {
					isSetonlyAccessor := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): prop.flags & SymbolFlags.SetAccessor */ TODO && ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.GetAccessor) */ TODO
					flags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | SymbolFlags.Optional */ TODO
					result := createSymbol(flags /* TODO(PropertyAccessExpression): prop.escapedName */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0) */, TODO)
					/* TODO(ExpressionStatement): result.links.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty* / true); */
					/* TODO(ExpressionStatement): result.declarations = prop.declarations; */
					/* TODO(ExpressionStatement): result.links.nameType = getSymbolLinks(prop).nameType; */
					/* TODO(ExpressionStatement): result.links.syntheticOrigin = prop; */
					/* TODO(PropertyAccessExpression): members.set */
					TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, result)
				}
			}
			spread := createAnonymousType( /* TODO(PropertyAccessExpression): type.symbol */ TODO, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
			/* TODO(ExpressionStatement): spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
			return spread
		}
	}
	getSpreadType := func(left Type, right Type, symbol *Symbol, objectFlags ObjectFlags, readonly bool) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): left.flags & TypeFlags.Any */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): right.flags & TypeFlags.Any */ TODO {
			return anyType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): left.flags & TypeFlags.Unknown */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): right.flags & TypeFlags.Unknown */ TODO {
			return unknownType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): left.flags & TypeFlags.Never */ TODO {
			return right
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): right.flags & TypeFlags.Never */ TODO {
			return left
		}
		/* TODO(ExpressionStatement): left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly); */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): left.flags & TypeFlags.Union */ TODO {
			return /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(left, t => getSpreadType(t, right, symbol, objectFlags, readonly))                 : errorType */ TODO
		}
		/* TODO(ExpressionStatement): right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly); */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): right.flags & TypeFlags.Union */ TODO {
			return /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(right, t => getSpreadType(left, t, symbol, objectFlags, readonly))                 : errorType */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): right.flags & (TypeFlags.BooleanLike | TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.EnumLike | TypeFlags.NonPrimitive | TypeFlags.Index) */ TODO {
			return left
		}
		if isGenericObjectType(left) || isGenericObjectType(right) {
			if isEmptyObjectType(left) {
				return right
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): left.flags & TypeFlags.Intersection */ TODO {
				types := /* TODO(PropertyAccessExpression): (left as IntersectionType).types */ TODO
				lastLeft := /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO
				if isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right) {
					return getIntersectionType(concatenate( /* TODO(PropertyAccessExpression): types.slice */ TODO(0 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - 1 */, TODO) /* TODO(ArrayLiteralExpression): [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)] */, TODO))
				}
			}
			return getIntersectionType( /* TODO(ArrayLiteralExpression): [left, right] */ TODO)
		}
		members := createSymbolTable()
		skippedPrivateMembers := /* TODO(NewExpression): new Set<__String>() */ TODO
		indexInfos := /* TODO(ConditionalExpression): left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]) */ TODO
		for _, rightProp := range getPropertiesOfType(right) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlags.Private | ModifierFlags.Protected) */ TODO {
				/* TODO(PropertyAccessExpression): skippedPrivateMembers.add */ TODO( /* TODO(PropertyAccessExpression): rightProp.escapedName */ TODO)
			} else if isSpreadableProperty(rightProp) {
				/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): rightProp.escapedName */ TODO, getSpreadSymbol(rightProp, readonly))
			}
		}
		for _, leftProp := range getPropertiesOfType(left) {
			if /* TODO(PropertyAccessExpression): skippedPrivateMembers.has */ TODO( /* TODO(PropertyAccessExpression): leftProp.escapedName */ TODO) || !isSpreadableProperty(leftProp) {
				/* TODO(ContinueStatement): continue; */
			}
			if /* TODO(PropertyAccessExpression): members.has */ TODO( /* TODO(PropertyAccessExpression): leftProp.escapedName */ TODO) {
				rightProp := /* TODO(NonNullExpression): members.get(leftProp.escapedName)! */ TODO
				rightType := getTypeOfSymbol(rightProp)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): rightProp.flags & SymbolFlags.Optional */ TODO {
					declarations := concatenate( /* TODO(PropertyAccessExpression): leftProp.declarations */ TODO /* TODO(PropertyAccessExpression): rightProp.declarations */, TODO)
					flags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | (leftProp.flags & SymbolFlags.Optional) */ TODO
					result := createSymbol(flags /* TODO(PropertyAccessExpression): leftProp.escapedName */, TODO)
					leftType := getTypeOfSymbol(leftProp)
					leftTypeWithoutUndefined := removeMissingOrUndefinedType(leftType)
					rightTypeWithoutUndefined := removeMissingOrUndefinedType(rightType)
					/* TODO(ExpressionStatement): result.links.type = leftTypeWithoutUndefined === rightTypeWithoutUndefined ? leftType : getUnionType([leftType, rightTypeWithoutUndefined], UnionReduction.Subtype); */
					/* TODO(ExpressionStatement): result.links.leftSpread = leftProp; */
					/* TODO(ExpressionStatement): result.links.rightSpread = rightProp; */
					/* TODO(ExpressionStatement): result.declarations = declarations; */
					/* TODO(ExpressionStatement): result.links.nameType = getSymbolLinks(leftProp).nameType; */
					/* TODO(PropertyAccessExpression): members.set */
					TODO( /* TODO(PropertyAccessExpression): leftProp.escapedName */ TODO, result)
				}
			} else {
				/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): leftProp.escapedName */ TODO, getSpreadSymbol(leftProp, readonly))
			}
		}
		spread := createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos /* TODO(ArrowFunction): info => getIndexInfoWithReadonly(info, readonly) */, TODO))
		/* TODO(ExpressionStatement): spread.objectFlags |= ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral | ObjectFlags.ContainsSpread | objectFlags; */
		return spread
	}
	isSpreadableProperty := func(prop Symbol) bool {
		return !some( /* TODO(PropertyAccessExpression): prop.declarations */ TODO, isPrivateIdentifierClassElementDeclaration) && /* TODO(ParenthesizedExpression): (!(prop.flags & (SymbolFlags.Method | SymbolFlags.GetAccessor | SymbolFlags.SetAccessor)) ||                 !prop.declarations?.some(decl => isClassLike(decl.parent))) */ TODO
	}
	getSpreadSymbol := func(prop Symbol, readonly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		isSetonlyAccessor := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): prop.flags & SymbolFlags.SetAccessor */ TODO && ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.GetAccessor) */ TODO
		if !isSetonlyAccessor && readonly == isReadonlySymbol(prop) {
			return prop
		}
		flags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | (prop.flags & SymbolFlags.Optional) */ TODO
		result := createSymbol(flags /* TODO(PropertyAccessExpression): prop.escapedName */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): getIsLateCheckFlag(prop) | (readonly ? CheckFlags.Readonly : 0) */, TODO)
		/* TODO(ExpressionStatement): result.links.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop); */
		/* TODO(ExpressionStatement): result.declarations = prop.declarations; */
		/* TODO(ExpressionStatement): result.links.nameType = getSymbolLinks(prop).nameType; */
		/* TODO(ExpressionStatement): result.links.syntheticOrigin = prop; */
		return result
	}
	getIndexInfoWithReadonly := func(info IndexInfo, readonly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
		return /* TODO(ConditionalExpression): info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info */ TODO
	}
	createLiteralType := func(flags TypeFlags, value /* TODO(UnionType): string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType */ TODO {
		type_ := createTypeWithSymbol(flags /* TODO(NonNullExpression): symbol! */, TODO) /* as */ /* TODO(TypeReference): LiteralType */
		/* TODO(ExpressionStatement): type.value = value; */
		/* TODO(ExpressionStatement): type.regularType = regularType || type; */
		return type_
	}
	getFreshTypeOfLiteralType := func(type_ Type) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Freshable */ TODO {
			if ! /* TODO(PropertyAccessExpression): (type as FreshableType).freshType */ TODO {
				freshType := createLiteralType( /* TODO(PropertyAccessExpression): type.flags */ TODO /* TODO(PropertyAccessExpression): (type as LiteralType).value */, TODO /* TODO(PropertyAccessExpression): (type as LiteralType).symbol */, TODO, type_ /* as */ /* TODO(TypeReference): LiteralType */)
				/* TODO(ExpressionStatement): freshType.freshType = freshType; */
				/* TODO(ExpressionStatement): (type as FreshableType).freshType = freshType; */
			}
			return /* TODO(PropertyAccessExpression): (type as FreshableType).freshType */ TODO
		}
		return type_
	}
	getRegularTypeOfLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Freshable ? (type as FreshableType).regularType :             type.flags & TypeFlags.Union ? ((type as UnionType).regularType || ((type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType)) :             type */ TODO
	}
	isFreshLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Freshable) */ TODO && /* TODO(PropertyAccessExpression): (type as LiteralType).freshType */ TODO == type_
	}
	getStringLiteralType := func(value string) StringLiteralType {
		var type_ TODO
		return /* TODO(PropertyAccessExpression): stringLiteralTypes.get */ TODO(value) || /* TODO(ParenthesizedExpression): (stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type) */ TODO
	}
	getNumberLiteralType := func(value number) NumberLiteralType {
		var type_ TODO
		return /* TODO(PropertyAccessExpression): numberLiteralTypes.get */ TODO(value) || /* TODO(ParenthesizedExpression): (numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type) */ TODO
	}
	getBigIntLiteralType := func(value PseudoBigInt) BigIntLiteralType {
		var type_ TODO
		key := pseudoBigIntToString(value)
		return /* TODO(PropertyAccessExpression): bigIntLiteralTypes.get */ TODO(key) || /* TODO(ParenthesizedExpression): (bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type) */ TODO
	}
	getEnumLiteralType := func(value /* TODO(UnionType): string | number */ any, enumId number, symbol Symbol) LiteralType {
		var type_ TODO
		key := /* TODO(TemplateExpression): `${enumId}${typeof value === "string" ? "@" : "#"}${value}` */ TODO
		flags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.EnumLiteral | (typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral) */ TODO
		return /* TODO(PropertyAccessExpression): enumLiteralTypes.get */ TODO(key) || /* TODO(ParenthesizedExpression): (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type) */ TODO
	}
	getTypeFromLiteralTypeNode := func(node LiteralTypeNode) Type {
		if /* TODO(PropertyAccessExpression): node.literal.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NullKeyword */ TODO {
			return nullType
		}
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			/* TODO(ExpressionStatement): links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal)); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	createUniqueESSymbolType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").UniqueESSymbolType */ TODO {
		type_ := createTypeWithSymbol( /* TODO(PropertyAccessExpression): TypeFlags.UniqueESSymbol */ TODO, symbol) /* as */ /* TODO(TypeReference): UniqueESSymbolType */
		/* TODO(ExpressionStatement): type.escapedName = `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}` as __String; */
		return type_
	}
	getESSymbolLikeTypeForNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isInJSFile(node) && isJSDocTypeExpression(node) {
			host := getJSDocHost(node)
			if host {
				/* TODO(ExpressionStatement): node = getSingleVariableOfVariableStatement(host) || host; */
			}
		}
		if isValidESSymbolDeclaration(node) {
			symbol := /* TODO(ConditionalExpression): isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode((node as BinaryExpression).left) : getSymbolOfNode(node) */ TODO
			if symbol {
				links := getSymbolLinks(symbol)
				return /* TODO(PropertyAccessExpression): links.uniqueESSymbolType */ TODO || /* TODO(ParenthesizedExpression): (links.uniqueESSymbolType = createUniqueESSymbolType(symbol)) */ TODO
			}
		}
		return esSymbolType
	}
	getThisType := func(node Node) Type {
		container := getThisContainer(node /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		parent := container && /* TODO(PropertyAccessExpression): container.parent */ TODO
		if parent && /* TODO(ParenthesizedExpression): (isClassLike(parent) || parent.kind === SyntaxKind.InterfaceDeclaration) */ TODO {
			if !isStatic(container) && /* TODO(ParenthesizedExpression): (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) */ TODO {
				return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent as ClassLikeDeclaration | InterfaceDeclaration)).thisType! */ TODO
			}
		}
		if parent && isObjectLiteralExpression(parent) && isBinaryExpression( /* TODO(PropertyAccessExpression): parent.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): parent.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.Prototype */ TODO {
			return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left)!.parent!).thisType! */ TODO
		}
		host := /* TODO(ConditionalExpression): node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined */ TODO
		if host && isFunctionExpression(host) && isBinaryExpression( /* TODO(PropertyAccessExpression): host.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): host.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.PrototypeProperty */ TODO {
			return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left)!.parent!).thisType! */ TODO
		}
		if isJSConstructor(container) && isNodeDescendantOf(node /* TODO(PropertyAccessExpression): container.body */, TODO) {
			return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType! */ TODO
		}
		error(node /* TODO(PropertyAccessExpression): Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface */, TODO)
		return errorType
	}
	getTypeFromThisTypeNode := func(node /* TODO(UnionType): ThisExpression | ThisTypeNode */ any) Type {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			/* TODO(ExpressionStatement): links.resolvedType = getThisType(node); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	getTypeFromRestTypeNode := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeFromTypeNode(getArrayElementTypeNode( /* TODO(PropertyAccessExpression): node.type */ TODO) || /* TODO(PropertyAccessExpression): node.type */ TODO)
	}
	getArrayElementTypeNode := func(node TypeNode) *TypeNode {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ParenthesizedType:                 return getArrayElementTypeNode((node as ParenthesizedTypeNode).type);             case SyntaxKind.TupleType:                 if ((node as TupleTypeNode).elements.length === 1) {                     node = (node as TupleTypeNode).elements[0];                     if (node.kind === SyntaxKind.RestType || node.kind === SyntaxKind.NamedTupleMember && (node as NamedTupleMember).dotDotDotToken) {                         return getArrayElementTypeNode((node as RestTypeNode | NamedTupleMember).type);                     }                 }                 break;             case SyntaxKind.ArrayType:                 return (node as ArrayTypeNode).elementType;         } */
		return nil
	}
	getTypeFromNamedTupleTypeNode := func(node NamedTupleMember) Type {
		links := getNodeLinks(node)
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO || /* TODO(ParenthesizedExpression): (links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) :             addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken)) */ TODO
	}
	getTypeFromTypeNode := func(node TypeNode) Type {
		return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node)
	}
	getTypeFromTypeNodeWorker := func(node TypeNode) Type {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AnyKeyword:             case SyntaxKind.JSDocAllType:             case SyntaxKind.JSDocUnknownType:                 return anyType;             case SyntaxKind.UnknownKeyword:                 return unknownType;             case SyntaxKind.StringKeyword:                 return stringType;             case SyntaxKind.NumberKeyword:                 return numberType;             case SyntaxKind.BigIntKeyword:                 return bigintType;             case SyntaxKind.BooleanKeyword:                 return booleanType;             case SyntaxKind.SymbolKeyword:                 return esSymbolType;             case SyntaxKind.VoidKeyword:                 return voidType;             case SyntaxKind.UndefinedKeyword:                 return undefinedType;             case SyntaxKind.NullKeyword as TypeNodeSyntaxKind:                 // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.                 return nullType;             case SyntaxKind.NeverKeyword:                 return neverType;             case SyntaxKind.ObjectKeyword:                 return node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType;             case SyntaxKind.IntrinsicKeyword:                 return intrinsicMarkerType;             case SyntaxKind.ThisType:             case SyntaxKind.ThisKeyword as TypeNodeSyntaxKind:                 // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.                 return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode);             case SyntaxKind.LiteralType:                 return getTypeFromLiteralTypeNode(node as LiteralTypeNode);             case SyntaxKind.TypeReference:                 return getTypeFromTypeReference(node as TypeReferenceNode);             case SyntaxKind.TypePredicate:                 return (node as TypePredicateNode).assertsModifier ? voidType : booleanType;             case SyntaxKind.ExpressionWithTypeArguments:                 return getTypeFromTypeReference(node as ExpressionWithTypeArguments);             case SyntaxKind.TypeQuery:                 return getTypeFromTypeQueryNode(node as TypeQueryNode);             case SyntaxKind.ArrayType:             case SyntaxKind.TupleType:                 return getTypeFromArrayOrTupleTypeNode(node as ArrayTypeNode | TupleTypeNode);             case SyntaxKind.OptionalType:                 return getTypeFromOptionalTypeNode(node as OptionalTypeNode);             case SyntaxKind.UnionType:                 return getTypeFromUnionTypeNode(node as UnionTypeNode);             case SyntaxKind.IntersectionType:                 return getTypeFromIntersectionTypeNode(node as IntersectionTypeNode);             case SyntaxKind.JSDocNullableType:                 return getTypeFromJSDocNullableTypeNode(node as JSDocNullableType);             case SyntaxKind.JSDocOptionalType:                 return addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type));             case SyntaxKind.NamedTupleMember:                 return getTypeFromNamedTupleTypeNode(node as NamedTupleMember);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocTypeExpression:                 return getTypeFromTypeNode((node as ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember).type);             case SyntaxKind.RestType:                 return getTypeFromRestTypeNode(node as RestTypeNode);             case SyntaxKind.JSDocVariadicType:                 return getTypeFromJSDocVariadicType(node as JSDocVariadicType);             case SyntaxKind.FunctionType:             case SyntaxKind.ConstructorType:             case SyntaxKind.TypeLiteral:             case SyntaxKind.JSDocTypeLiteral:             case SyntaxKind.JSDocFunctionType:             case SyntaxKind.JSDocSignature:                 return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node as TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature);             case SyntaxKind.TypeOperator:                 return getTypeFromTypeOperatorNode(node as TypeOperatorNode);             case SyntaxKind.IndexedAccessType:                 return getTypeFromIndexedAccessTypeNode(node as IndexedAccessTypeNode);             case SyntaxKind.MappedType:                 return getTypeFromMappedTypeNode(node as MappedTypeNode);             case SyntaxKind.ConditionalType:                 return getTypeFromConditionalTypeNode(node as ConditionalTypeNode);             case SyntaxKind.InferType:                 return getTypeFromInferTypeNode(node as InferTypeNode);             case SyntaxKind.TemplateLiteralType:                 return getTypeFromTemplateTypeNode(node as TemplateLiteralTypeNode);             case SyntaxKind.ImportType:                 return getTypeFromImportTypeNode(node as ImportTypeNode);             // This function assumes that an identifier, qualified name, or property access expression is a type expression             // Callers should first ensure this by calling `isPartOfTypeNode`             // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.             case SyntaxKind.Identifier as TypeNodeSyntaxKind:             case SyntaxKind.QualifiedName as TypeNodeSyntaxKind:             case SyntaxKind.PropertyAccessExpression as TypeNodeSyntaxKind:                 const symbol = getSymbolAtLocation(node);                 return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;             default:                 return errorType;         } */
	}
	// OVERLOAD: instantiateList := func(items []T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) []T
	// OVERLOAD: instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any
	instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any {
		if items && /* TODO(PropertyAccessExpression): items.length */ TODO {
			/* TODO(ForStatement): for (let i = 0; i < items.length; i++) {                 const item = items[i];                 const mapped = instantiator(item, mapper);                 if (item !== mapped) {                     const result = i === 0 ? [] : items.slice(0, i);                     result.push(mapped);                     for (i++; i < items.length; i++) {                         result.push(instantiator(items[i], mapper));                     }                     return result;                 }             } */
		}
		return items
	}
	// OVERLOAD: instantiateTypes := func(types []Type, mapper TypeMapper) []Type
	// OVERLOAD: instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any
	instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any {
		return instantiateList(types, mapper, instantiateType)
	}
	instantiateSignatures := func(signatures []Signature, mapper TypeMapper) []Signature {
		return instantiateList(signatures, mapper, instantiateSignature)
	}
	instantiateIndexInfos := func(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
		return instantiateList(indexInfos, mapper, instantiateIndexInfo)
	}
	createTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return /* TODO(ConditionalExpression): sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets) */ TODO
	}
	getMappedType := func(type_ Type, mapper TypeMapper) Type {
		/* TODO(SwitchStatement): switch (mapper.kind) {             case TypeMapKind.Simple:                 return type === mapper.source ? mapper.target : type;             case TypeMapKind.Array: {                 const sources = mapper.sources;                 const targets = mapper.targets;                 for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets ? targets[i] : anyType;                     }                 }                 return type;             }             case TypeMapKind.Deferred: {                 const sources = mapper.sources;                 const targets = mapper.targets;                 for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets[i]();                     }                 }                 return type;             }             case TypeMapKind.Function:                 return mapper.func(type);             case TypeMapKind.Composite:             case TypeMapKind.Merged:                 const t1 = getMappedType(type, mapper.mapper1);                 return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);         } */
	}
	makeUnaryTypeMapper := func(source Type, target Type) TypeMapper {
		return /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Simple, source, target } */ TODO)
	}
	makeArrayTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Array, sources, targets } */ TODO)
	}
	makeFunctionTypeMapper := func(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
		return /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined } */ TODO)
	}
	makeDeferredTypeMapper := func(sources []TypeParameter, targets []func() Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Deferred, sources, targets } */ TODO)
	}
	makeCompositeTypeMapper := func(kind /* TODO(UnionType): TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(PropertyAccessExpression): Debug.attachDebugPrototypeIfDebug */ TODO( /* TODO(ObjectLiteralExpression): { kind, mapper1, mapper2 } */ TODO)
	}
	createTypeEraser := func(sources []TypeParameter) TypeMapper {
		return createTypeMapper(sources, nil)
	}
	createBackreferenceMapper := func(context InferenceContext, index number) TypeMapper {
		forwardInferences := /* TODO(PropertyAccessExpression): context.inferences.slice */ TODO(index)
		return createTypeMapper(map_(forwardInferences /* TODO(ArrowFunction): i => i.typeParameter */, TODO), map_(forwardInferences /* TODO(ArrowFunction): () => unknownType */, TODO))
	}
	combineTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2 */ TODO
	}
	mergeTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2 */ TODO
	}
	prependTypeMapping := func(source Type, target Type, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper) */ TODO
	}
	appendTypeMapping := func(mapper *TypeMapper, source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target)) */ TODO
	}
	getRestrictiveTypeParameter := func(tp TypeParameter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (             tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation         ) */ TODO
	}
	cloneTypeParameter := func(typeParameter TypeParameter) TypeParameter {
		result := createTypeParameter( /* TODO(PropertyAccessExpression): typeParameter.symbol */ TODO)
		/* TODO(ExpressionStatement): result.target = typeParameter; */
		return result
	}
	instantiateTypePredicate := func(predicate TypePredicate, mapper TypeMapper) TypePredicate {
		return createTypePredicate( /* TODO(PropertyAccessExpression): predicate.kind */ TODO /* TODO(PropertyAccessExpression): predicate.parameterName */, TODO /* TODO(PropertyAccessExpression): predicate.parameterIndex */, TODO, instantiateType( /* TODO(PropertyAccessExpression): predicate.type */ TODO, mapper))
	}
	instantiateSignature := func(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
		var freshTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		if /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO && !eraseTypeParameters {
			/* TODO(ExpressionStatement): freshTypeParameters = map(signature.typeParameters, cloneTypeParameter); */
			/* TODO(ExpressionStatement): mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper); */
			for _, tp := range freshTypeParameters {
				/* TODO(ExpressionStatement): tp.mapper = mapper; */
			}
		}
		result := createSignature( /* TODO(PropertyAccessExpression): signature.declaration */ TODO, freshTypeParameters /* TODO(PropertyAccessExpression): signature.thisParameter */, TODO && instantiateSymbol( /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO, mapper), instantiateList( /* TODO(PropertyAccessExpression): signature.parameters */ TODO, mapper, instantiateSymbol), nil, nil /* TODO(PropertyAccessExpression): signature.minArgumentCount */, TODO /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.PropagatingFlags */, TODO)
		/* TODO(ExpressionStatement): result.target = signature; */
		/* TODO(ExpressionStatement): result.mapper = mapper; */
		return result
	}
	instantiateSymbol := func(symbol Symbol, mapper TypeMapper) Symbol {
		links := getSymbolLinks(symbol)
		if /* TODO(PropertyAccessExpression): links.type */ TODO && !couldContainTypeVariables( /* TODO(PropertyAccessExpression): links.type */ TODO) {
			if ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.SetAccessor) */ TODO {
				return symbol
			}
			if /* TODO(PropertyAccessExpression): links.writeType */ TODO && !couldContainTypeVariables( /* TODO(PropertyAccessExpression): links.writeType */ TODO) {
				return symbol
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Instantiated */ TODO {
			/* TODO(ExpressionStatement): symbol = links.target!; */
			/* TODO(ExpressionStatement): mapper = combineTypeMappers(links.mapper, mapper); */
		}
		result := createSymbol( /* TODO(PropertyAccessExpression): symbol.flags */ TODO /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): CheckFlags.Instantiated | getCheckFlags(symbol) & (CheckFlags.Readonly | CheckFlags.Late | CheckFlags.OptionalParameter | CheckFlags.RestParameter) */, TODO)
		/* TODO(ExpressionStatement): result.declarations = symbol.declarations; */
		/* TODO(ExpressionStatement): result.parent = symbol.parent; */
		/* TODO(ExpressionStatement): result.links.target = symbol; */
		/* TODO(ExpressionStatement): result.links.mapper = mapper; */
		if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
			/* TODO(ExpressionStatement): result.valueDeclaration = symbol.valueDeclaration; */
		}
		if /* TODO(PropertyAccessExpression): links.nameType */ TODO {
			/* TODO(ExpressionStatement): result.links.nameType = links.nameType; */
		}
		return result
	}
	getObjectTypeInstantiation := func(type_ /* TODO(UnionType): AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		declaration := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! :             type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node :             type.symbol.declarations![0] */ TODO
		links := getNodeLinks(declaration)
		target := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference :             type.objectFlags & ObjectFlags.Instantiated ? type.target! : type */ TODO
		typeParameters := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.SingleSignatureType ? (type as SingleSignatureType).outerTypeParameters : links.outerTypeParameters */ TODO
		if !typeParameters {
			outerTypeParameters := getOuterTypeParameters(declaration /* TODO(TrueKeyword): true */, TODO)
			if isJSConstructor(declaration) {
				templateTagParameters := getTypeParametersFromDeclaration(declaration /* as */ /* TODO(TypeReference): DeclarationWithTypeParameters */)
				/* TODO(ExpressionStatement): outerTypeParameters = addRange(outerTypeParameters, templateTagParameters); */
			}
			/* TODO(ExpressionStatement): typeParameters = outerTypeParameters || emptyArray; */
			allDeclarations := /* TODO(ConditionalExpression): type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations! */ TODO
			/* TODO(ExpressionStatement): typeParameters = (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ?                 filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) :                 typeParameters; */
			/* TODO(ExpressionStatement): links.outerTypeParameters = typeParameters; */
		}
		if /* TODO(PropertyAccessExpression): typeParameters.length */ TODO {
			combinedMapper := combineTypeMappers( /* TODO(PropertyAccessExpression): type.mapper */ TODO, mapper)
			typeArguments := map_(typeParameters /* TODO(ArrowFunction): t => getMappedType(t, combinedMapper) */, TODO)
			newAliasSymbol := aliasSymbol || /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (type.objectFlags & ObjectFlags.SingleSignatureType ? "S" : "") + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments) */ TODO
			if ! /* TODO(PropertyAccessExpression): target.instantiations */ TODO {
				/* TODO(ExpressionStatement): target.instantiations = new Map<string, Type>(); */
				/* TODO(PropertyAccessExpression): target.instantiations.set */
				TODO( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments) */ TODO, target)
			}
			result := /* TODO(PropertyAccessExpression): target.instantiations.get */ TODO(id)
			if !result {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.SingleSignatureType */ TODO {
					/* TODO(ExpressionStatement): result = instantiateAnonymousType(type, mapper); */
					/* TODO(PropertyAccessExpression): target.instantiations.set */
					TODO(id, result)
					return result
				}
				newMapper := createTypeMapper(typeParameters, typeArguments)
				/* TODO(ExpressionStatement): result = target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) :                     target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) :                     instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments); */
				/* TODO(PropertyAccessExpression): target.instantiations.set */
				TODO(id, result)
				resultObjectFlags := getObjectFlags(result)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & TypeFlags.ObjectFlagsType */ TODO && ! /* TODO(ParenthesizedExpression): (resultObjectFlags & ObjectFlags.CouldContainTypeVariablesComputed) */ TODO {
					resultCouldContainTypeVariables := some(typeArguments, couldContainTypeVariables)
					if ! /* TODO(ParenthesizedExpression): (getObjectFlags(result) & ObjectFlags.CouldContainTypeVariablesComputed) */ TODO {
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): resultObjectFlags & (ObjectFlags.Mapped | ObjectFlags.Anonymous | ObjectFlags.Reference) */ TODO {
							/* TODO(ExpressionStatement): (result as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0); */
						} else {
							/* TODO(ExpressionStatement): (result as ObjectFlagsType).objectFlags |= !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0; */
						}
					}
				}
			}
			return result
		}
		return type_
	}
	maybeTypeParameterReference := func(node Node) /* TODO(undefined): boolean */ TODO {
		return ! /* TODO(ParenthesizedExpression): (node.parent.kind === SyntaxKind.TypeReference && (node.parent as TypeReferenceNode).typeArguments && node === (node.parent as TypeReferenceNode).typeName ||             node.parent.kind === SyntaxKind.ImportType && (node.parent as ImportTypeNode).typeArguments && node === (node.parent as ImportTypeNode).qualifier) */ TODO
	}
	isTypeParameterPossiblyReferenced := func(tp TypeParameter, node Node) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): tp.symbol */ TODO && /* TODO(PropertyAccessExpression): tp.symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): tp.symbol.declarations.length */ TODO == 1 {
			container := /* TODO(PropertyAccessExpression): tp.symbol.declarations[0].parent */ TODO
			/* TODO(ForStatement): for (let n = node; n !== container; n = n.parent) {                 if (!n || n.kind === SyntaxKind.Block || n.kind === SyntaxKind.ConditionalType && forEachChild((n as ConditionalTypeNode).extendsType, containsReference)) {                     return true;                 }             } */
			return containsReference(node)
		}
		return /* TODO(TrueKeyword): true */ TODO
		containsReference := func(node Node) bool {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ThisType:                     return !!tp.isThisType;                 case SyntaxKind.Identifier:                     return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&                         getTypeFromTypeNodeWorker(node as TypeNode) === tp; // use worker because we're looking for === equality                 case SyntaxKind.TypeQuery:                     const entityName = (node as TypeQueryNode).exprName;                     const firstIdentifier = getFirstIdentifier(entityName);                     if (!isThisIdentifier(firstIdentifier)) { // Don't attempt to analyze typeof this.xxx                         const firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);                         const tpDeclaration = tp.symbol.declarations![0]; // There is exactly one declaration, otherwise `containsReference` is not called                         const tpScope = tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T>                             tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration.                             undefined; // Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.                         if (firstIdentifierSymbol.declarations && tpScope) {                             return some(firstIdentifierSymbol.declarations, idDecl => isNodeDescendantOf(idDecl, tpScope)) ||                                 some((node as TypeQueryNode).typeArguments, containsReference);                         }                     }                     return true;                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.MethodSignature:                     return !(node as FunctionLikeDeclaration).type && !!(node as FunctionLikeDeclaration).body ||                         some((node as FunctionLikeDeclaration).typeParameters, containsReference) ||                         some((node as FunctionLikeDeclaration).parameters, containsReference) ||                         !!(node as FunctionLikeDeclaration).type && containsReference((node as FunctionLikeDeclaration).type!);             } */
			return !!forEachChild(node, containsReference)
		}
	}
	getHomomorphicTypeVariable := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter | undefined */ TODO {
		constraintType := getConstraintTypeFromMappedType(type_)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constraintType.flags & TypeFlags.Index */ TODO {
			typeVariable := getActualTypeVariable( /* TODO(PropertyAccessExpression): (constraintType as IndexType).type */ TODO)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): typeVariable.flags & TypeFlags.TypeParameter */ TODO {
				return typeVariable /* as */ /* TODO(TypeReference): TypeParameter */
			}
		}
		return nil
	}
	instantiateMappedType := func(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeVariable := getHomomorphicTypeVariable(type_)
		if typeVariable {
			mappedTypeVariable := instantiateType(typeVariable, mapper)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeVariable !== mappedTypeVariable */ TODO {
				return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
			}
		}
		return /* TODO(ConditionalExpression): instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) */ TODO
		instantiateConstituent := func(t Type) Type {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.InstantiableNonPrimitive | TypeFlags.Object | TypeFlags.Intersection) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): t !== wildcardType */ TODO && !isErrorType(t) {
				if ! /* TODO(PropertyAccessExpression): type.declaration.nameType */ TODO {
					var constraint TODO
					if isArrayType(t) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Any */ TODO && findResolutionCycleStartIndex( /* TODO(NonNullExpression): typeVariable! */ TODO /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ImmediateBaseConstraint */, TODO) < 0 && /* TODO(ParenthesizedExpression): (constraint = getConstraintOfTypeParameter(typeVariable!)) */ TODO && everyType(constraint, isArrayOrTupleType) {
						return instantiateMappedArrayType(t, type_, prependTypeMapping( /* TODO(NonNullExpression): typeVariable! */ TODO, t, mapper))
					}
					if isTupleType(t) {
						return instantiateMappedTupleType(t, type_ /* TODO(NonNullExpression): typeVariable! */, TODO, mapper)
					}
					if isArrayOrTupleOrIntersection(t) {
						return getIntersectionType(map_( /* TODO(PropertyAccessExpression): (t as IntersectionType).types */ TODO, instantiateConstituent))
					}
				}
				return instantiateAnonymousType(type_, prependTypeMapping( /* TODO(NonNullExpression): typeVariable! */ TODO, t, mapper))
			}
			return t
		}
	}
	getModifiedReadonlyState := func(state bool, modifiers MappedTypeModifiers) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state */ TODO
	}
	instantiateMappedTupleType := func(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		elementFlags := /* TODO(PropertyAccessExpression): tupleType.target.elementFlags */ TODO
		fixedLength := /* TODO(PropertyAccessExpression): tupleType.target.fixedLength */ TODO
		fixedMapper := /* TODO(ConditionalExpression): fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper */ TODO
		newElementTypes := map_(getElementTypes(tupleType) /* TODO(ArrowFunction): (type, i) => {             const flags = elementFlags[i];             return i < fixedLength ? instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(flags & ElementFlags.Optional), fixedMapper) :                 flags & ElementFlags.Variadic ? instantiateType(mappedType, prependTypeMapping(typeVariable, type, mapper)) :                 getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType;         } */, TODO)
		modifiers := getMappedTypeModifiers(mappedType)
		newElementFlags := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) :             modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :             elementFlags */ TODO
		newReadonly := getModifiedReadonlyState( /* TODO(PropertyAccessExpression): tupleType.target.readonly */ TODO, getMappedTypeModifiers(mappedType))
		return /* TODO(ConditionalExpression): contains(newElementTypes, errorType) ? errorType :             createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations) */ TODO
	}
	instantiateMappedArrayType := func(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		elementType := instantiateMappedTypeTemplate(mappedType, numberType /* TODO(TrueKeyword): true */, TODO, mapper)
		return /* TODO(ConditionalExpression): isErrorType(elementType) ? errorType :             createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType))) */ TODO
	}
	instantiateMappedTypeTemplate := func(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		templateMapper := appendTypeMapping(mapper, getTypeParameterFromMappedType(type_), key)
		propType := instantiateType(getTemplateTypeFromMappedType( /* TODO(PropertyAccessExpression): type.target */ TODO /* as */ /* TODO(TypeReference): MappedType */ || type_), templateMapper)
		modifiers := getMappedTypeModifiers(type_)
		return /* TODO(ConditionalExpression): strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :             strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional ? getTypeWithFacts(propType, TypeFacts.NEUndefined) :             propType */ TODO
	}
	instantiateAnonymousType := func(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): type.symbol */ TODO, "anonymous type must have symbol to be instantiated")
		result := createObjectType( /* TODO(BarToken): | */ /* TODO(BinaryExpression): type.objectFlags & ~(ObjectFlags.CouldContainTypeVariablesComputed | ObjectFlags.CouldContainTypeVariables) | ObjectFlags.Instantiated */ TODO /* TODO(PropertyAccessExpression): type.symbol */, TODO) /* as */ /* TODO(TypeReference): AnonymousType */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.Mapped */ TODO {
			/* TODO(ExpressionStatement): (result as MappedType).declaration = (type as MappedType).declaration; */
			origTypeParameter := getTypeParameterFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
			freshTypeParameter := cloneTypeParameter(origTypeParameter)
			/* TODO(ExpressionStatement): (result as MappedType).typeParameter = freshTypeParameter; */
			/* TODO(ExpressionStatement): mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper); */
			/* TODO(ExpressionStatement): freshTypeParameter.mapper = mapper; */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.InstantiationExpressionType */ TODO {
			/* TODO(ExpressionStatement): (result as InstantiationExpressionType).node = (type as InstantiationExpressionType).node; */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.objectFlags & ObjectFlags.SingleSignatureType */ TODO {
			/* TODO(ExpressionStatement): (result as SingleSignatureType).outerTypeParameters = (type as SingleSignatureType).outerTypeParameters; */
		}
		/* TODO(ExpressionStatement): result.target = type; */
		/* TODO(ExpressionStatement): result.mapper = mapper; */
		/* TODO(ExpressionStatement): result.aliasSymbol = aliasSymbol || type.aliasSymbol; */
		/* TODO(ExpressionStatement): result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper); */
		/* TODO(ExpressionStatement): result.objectFlags |= result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0; */
		return result
	}
	getConditionalTypeInstantiation := func(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		root := /* TODO(PropertyAccessExpression): type.root */ TODO
		if /* TODO(PropertyAccessExpression): root.outerTypeParameters */ TODO {
			typeArguments := map_( /* TODO(PropertyAccessExpression): root.outerTypeParameters */ TODO /* TODO(ArrowFunction): t => getMappedType(t, mapper) */, TODO)
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (forConstraint ? "C" : "") + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			result := /* TODO(PropertyAccessExpression): root.instantiations!.get */ TODO(id)
			if !result {
				newMapper := createTypeMapper( /* TODO(PropertyAccessExpression): root.outerTypeParameters */ TODO, typeArguments)
				checkType := /* TODO(PropertyAccessExpression): root.checkType */ TODO
				distributionType := /* TODO(ConditionalExpression): root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined */ TODO
				/* TODO(ExpressionStatement): result = distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?                     mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) :                     getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments); */
				/* TODO(PropertyAccessExpression): root.instantiations!.set */
				TODO(id, result)
			}
			return result
		}
		return type_
	}
	// OVERLOAD: instantiateType := func(type_ Type, mapper *TypeMapper) Type
	// OVERLOAD: instantiateType := func(type_ *Type, mapper *TypeMapper) *Type
	instantiateType := func(type_ *Type, mapper *TypeMapper) *Type {
		return /* TODO(ConditionalExpression): type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol* / undefined, /*aliasTypeArguments* / undefined) : type */ TODO
	}
	instantiateTypeWithAlias := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		if !couldContainTypeVariables(type_) {
			return type_
		}
		if instantiationDepth == 100 || instantiationCount >= 5000000 {
			/* TODO(PropertyAccessExpression): tracing?.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "instantiateType_DepthLimit" /* TODO(ObjectLiteralExpression): { typeId: type.id, instantiationDepth, instantiationCount } */, TODO)
			error(currentNode /* TODO(PropertyAccessExpression): Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite */, TODO)
			return errorType
		}
		/* TODO(ExpressionStatement): totalInstantiationCount++; */
		/* TODO(ExpressionStatement): instantiationCount++; */
		/* TODO(ExpressionStatement): instantiationDepth++; */
		result := instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
		/* TODO(ExpressionStatement): instantiationDepth--; */
		return result
	}
	instantiateTypeWorker := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.TypeParameter */ TODO {
			return getMappedType(type_, mapper)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Object */ TODO {
			objectFlags := /* TODO(PropertyAccessExpression): (type as ObjectType).objectFlags */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped) */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & ObjectFlags.Reference */ TODO && ! /* TODO(PropertyAccessExpression): (type as TypeReference).node */ TODO {
					resolvedTypeArguments := /* TODO(PropertyAccessExpression): (type as TypeReference).resolvedTypeArguments */ TODO
					newTypeArguments := instantiateTypes(resolvedTypeArguments, mapper)
					return /* TODO(ConditionalExpression): newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference((type as TypeReference).target, newTypeArguments) : type */ TODO
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & ObjectFlags.ReverseMapped */ TODO {
					return instantiateReverseMappedType(type_ /* as */ /* TODO(TypeReference): ReverseMappedType */, mapper)
				}
				return getObjectTypeInstantiation(type_ /* as */ /* TODO(UnionType): TypeReference | AnonymousType | MappedType */, mapper, aliasSymbol, aliasTypeArguments)
			}
			return type_
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.UnionOrIntersection */ TODO {
			origin := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined */ TODO
			types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types */ TODO
			newTypes := instantiateTypes(types, mapper)
			if newTypes == types && aliasSymbol == /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO {
				return type_
			}
			newAliasSymbol := aliasSymbol || /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return /* TODO(ConditionalExpression): flags & TypeFlags.Intersection || origin && origin.flags & TypeFlags.Intersection ?                 getIntersectionType(newTypes, IntersectionFlags.None, newAliasSymbol, newAliasTypeArguments) :                 getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments) */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Index */ TODO {
			return getIndexType(instantiateType( /* TODO(PropertyAccessExpression): (type as IndexType).type */ TODO, mapper))
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.TemplateLiteral */ TODO {
			return getTemplateLiteralType( /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).texts */ TODO, instantiateTypes( /* TODO(PropertyAccessExpression): (type as TemplateLiteralType).types */ TODO, mapper))
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.StringMapping */ TODO {
			return getStringMappingType( /* TODO(PropertyAccessExpression): (type as StringMappingType).symbol */ TODO, instantiateType( /* TODO(PropertyAccessExpression): (type as StringMappingType).type */ TODO, mapper))
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.IndexedAccess */ TODO {
			newAliasSymbol := aliasSymbol || /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return getIndexedAccessType(instantiateType( /* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO, mapper), instantiateType( /* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO, mapper) /* TODO(PropertyAccessExpression): (type as IndexedAccessType).accessFlags */, TODO, nil, newAliasSymbol, newAliasTypeArguments)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Conditional */ TODO {
			return getConditionalTypeInstantiation(type_ /* as */ /* TODO(TypeReference): ConditionalType */, combineTypeMappers( /* TODO(PropertyAccessExpression): (type as ConditionalType).mapper */ TODO, mapper) /* TODO(FalseKeyword): false */, TODO, aliasSymbol, aliasTypeArguments)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Substitution */ TODO {
			newBaseType := instantiateType( /* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO, mapper)
			if isNoInferType(type_) {
				return getNoInferType(newBaseType)
			}
			newConstraint := instantiateType( /* TODO(PropertyAccessExpression): (type as SubstitutionType).constraint */ TODO, mapper)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): newBaseType.flags & TypeFlags.TypeVariable */ TODO && isGenericType(newConstraint) {
				return getSubstitutionType(newBaseType, newConstraint)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): newConstraint.flags & TypeFlags.AnyOrUnknown */ TODO || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint)) {
				return newBaseType
			}
			return /* TODO(ConditionalExpression): newBaseType.flags & TypeFlags.TypeVariable ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]) */ TODO
		}
		return type_
	}
	instantiateReverseMappedType := func(type_ ReverseMappedType, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		innerMappedType := instantiateType( /* TODO(PropertyAccessExpression): type.mappedType */ TODO, mapper)
		if ! /* TODO(ParenthesizedExpression): (getObjectFlags(innerMappedType) & ObjectFlags.Mapped) */ TODO {
			return type_
		}
		innerIndexType := instantiateType( /* TODO(PropertyAccessExpression): type.constraintType */ TODO, mapper)
		if ! /* TODO(ParenthesizedExpression): (innerIndexType.flags & TypeFlags.Index) */ TODO {
			return type_
		}
		instantiated := inferTypeForHomomorphicMappedType(instantiateType( /* TODO(PropertyAccessExpression): type.source */ TODO, mapper), innerMappedType /* as */ /* TODO(TypeReference): MappedType */, innerIndexType /* as */ /* TODO(TypeReference): IndexType */)
		if instantiated {
			return instantiated
		}
		return type_
	}
	getPermissiveInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type :             type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper)) */ TODO
	}
	getRestrictiveInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) */ TODO {
			return type_
		}
		if /* TODO(PropertyAccessExpression): type.restrictiveInstantiation */ TODO {
			return /* TODO(PropertyAccessExpression): type.restrictiveInstantiation */ TODO
		}
		/* TODO(ExpressionStatement): type.restrictiveInstantiation = instantiateType(type, restrictiveMapper); */
		/* TODO(ExpressionStatement): type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation; */
		return /* TODO(PropertyAccessExpression): type.restrictiveInstantiation */ TODO
	}
	instantiateIndexInfo := func(info IndexInfo, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
		return createIndexInfo( /* TODO(PropertyAccessExpression): info.keyType */ TODO, instantiateType( /* TODO(PropertyAccessExpression): info.type */ TODO, mapper) /* TODO(PropertyAccessExpression): info.isReadonly */, TODO /* TODO(PropertyAccessExpression): info.declaration */, TODO)
	}
	isContextSensitive := func(node /* TODO(UnionType): Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.FunctionDeclaration: // Function declarations can have context when annotated with a jsdoc @type                 return isContextSensitiveFunctionLikeDeclaration(node as FunctionExpression | ArrowFunction | MethodDeclaration);             case SyntaxKind.ObjectLiteralExpression:                 return some((node as ObjectLiteralExpression).properties, isContextSensitive);             case SyntaxKind.ArrayLiteralExpression:                 return some((node as ArrayLiteralExpression).elements, isContextSensitive);             case SyntaxKind.ConditionalExpression:                 return isContextSensitive((node as ConditionalExpression).whenTrue) ||                     isContextSensitive((node as ConditionalExpression).whenFalse);             case SyntaxKind.BinaryExpression:                 return ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken || (node as BinaryExpression).operatorToken.kind === SyntaxKind.QuestionQuestionToken) &&                     (isContextSensitive((node as BinaryExpression).left) || isContextSensitive((node as BinaryExpression).right));             case SyntaxKind.PropertyAssignment:                 return isContextSensitive((node as PropertyAssignment).initializer);             case SyntaxKind.ParenthesizedExpression:                 return isContextSensitive((node as ParenthesizedExpression).expression);             case SyntaxKind.JsxAttributes:                 return some((node as JsxAttributes).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive);             case SyntaxKind.JsxAttribute: {                 // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.                 const { initializer } = node as JsxAttribute;                 return !!initializer && isContextSensitive(initializer);             }             case SyntaxKind.JsxExpression: {                 // It is possible to that node.expression is undefined (e.g <div x={} />)                 const { expression } = node as JsxExpression;                 return !!expression && isContextSensitive(expression);             }         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	isContextSensitiveFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node)
	}
	hasContextSensitiveReturnExpression := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): node.typeParameters */ TODO || getEffectiveReturnTypeNode(node) || ! /* TODO(PropertyAccessExpression): node.body */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.body.kind !== SyntaxKind.Block */ TODO {
			return isContextSensitive( /* TODO(PropertyAccessExpression): node.body */ TODO)
		}
		return !!forEachReturnStatement( /* TODO(PropertyAccessExpression): node.body */ TODO /* as */ /* TODO(TypeReference): Block */ /* TODO(ArrowFunction): statement => !!statement.expression && isContextSensitive(statement.expression) */, TODO)
	}
	isContextSensitiveFunctionOrObjectLiteralMethod := func(func_ Node) /* TODO(TypePredicate): func is FunctionExpression | ArrowFunction | MethodDeclaration */ TODO {
		return /* TODO(ParenthesizedExpression): (isFunctionExpressionOrArrowFunction(func) || isObjectLiteralMethod(func)) */ TODO && isContextSensitiveFunctionLikeDeclaration(func_)
	}
	getTypeWithoutSignatures := func(type_ Type) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			if /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO || /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO {
				result := createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.Anonymous */ TODO /* TODO(PropertyAccessExpression): type.symbol */, TODO)
				/* TODO(ExpressionStatement): result.members = resolved.members; */
				/* TODO(ExpressionStatement): result.properties = resolved.properties; */
				/* TODO(ExpressionStatement): result.callSignatures = emptyArray; */
				/* TODO(ExpressionStatement): result.constructSignatures = emptyArray; */
				/* TODO(ExpressionStatement): result.indexInfos = emptyArray; */
				return result
			}
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			return getIntersectionType(map_( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, getTypeWithoutSignatures))
		}
		return type_
	}
	isTypeIdenticalTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, identityRelation)
	}
	compareTypesIdentical := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False */ TODO
	}
	compareTypesAssignable := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False */ TODO
	}
	compareTypesSubtypeOf := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False */ TODO
	}
	isTypeSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, subtypeRelation)
	}
	isTypeStrictSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, strictSubtypeRelation)
	}
	isTypeAssignableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, assignableRelation)
	}
	isTypeDerivedFrom := func(source Type, target Type) bool {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? every((source as UnionType).types, t => isTypeDerivedFrom(t, target)) :             target.flags & TypeFlags.Union ? some((target as UnionType).types, t => isTypeDerivedFrom(source, t)) :             source.flags & TypeFlags.Intersection ? some((source as IntersectionType).types, t => isTypeDerivedFrom(t, target)) :             source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :             isEmptyAnonymousObjectType(target) ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) :             target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) && !isEmptyAnonymousObjectType(source) :             target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType) :             hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType)) */ TODO
	}
	isTypeComparableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, comparableRelation)
	}
	areTypesComparable := func(type1 Type, type2 Type) bool {
		return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1)
	}
	checkTypeAssignableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO) bool {
		return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
	}
	checkTypeAssignableToAndOptionallyElaborate := func(source Type, target Type, errorNode Node, expr *Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, nil)
	}
	checkTypeRelatedToAndOptionallyElaborate := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr *Expression, headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isTypeRelatedTo(source, target, relation) {
			/* TODO(TrueKeyword): true */
		}
		if !errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isOrHasGenericConditional := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Conditional || (type.flags & TypeFlags.Intersection && some((type as IntersectionType).types, isOrHasGenericConditional))) */ TODO
	}
	elaborateError := func(node *Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if !node || isOrHasGenericConditional(target) {
			/* TODO(FalseKeyword): false */
		}
		if !checkTypeRelatedTo(source, target, relation, nil) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AsExpression:                 if (!isConstAssertion(node)) {                     break;                 }                 // fallthrough             case SyntaxKind.JsxExpression:             case SyntaxKind.ParenthesizedExpression:                 return elaborateError((node as AsExpression | ParenthesizedExpression | JsxExpression).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);             case SyntaxKind.BinaryExpression:                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.CommaToken:                         return elaborateError((node as BinaryExpression).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);                 }                 break;             case SyntaxKind.ObjectLiteralExpression:                 return elaborateObjectLiteral(node as ObjectLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.ArrayLiteralExpression:                 return elaborateArrayLiteral(node as ArrayLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.JsxAttributes:                 return elaborateJsxComponents(node as JsxAttributes, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.ArrowFunction:                 return elaborateArrowFunction(node as ArrowFunction, source, target, relation, containingMessageChain, errorOutputContainer);         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	elaborateDidYouMeanToCallOrConstruct := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		callSignatures := getSignaturesOfType(source /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		constructSignatures := getSignaturesOfType(source /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		for _, signatures := range /* TODO(ArrayLiteralExpression): [constructSignatures, callSignatures] */ TODO {
			if some(signatures /* TODO(ArrowFunction): s => {                     const returnType = getReturnTypeOfSignature(s);                     return !(returnType.flags & (TypeFlags.Any | TypeFlags.Never)) && checkTypeRelatedTo(returnType, target, relation, /*errorNode* / undefined);                 } */, TODO) {
				var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
				checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj)
				diagnostic := /* TODO(ElementAccessExpression): resultObj.errors![resultObj.errors!.length - 1] */ TODO
				addRelatedInfo(diagnostic, createDiagnosticForNode(node /* TODO(ConditionalExpression): signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression */, TODO))
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	elaborateArrowFunction := func(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isBlock( /* TODO(PropertyAccessExpression): node.body */ TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if some( /* TODO(PropertyAccessExpression): node.parameters */ TODO, hasType) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		sourceSig := getSingleCallSignature(source)
		if !sourceSig {
			return /* TODO(FalseKeyword): false */ TODO
		}
		targetSignatures := getSignaturesOfType(target /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		if !length(targetSignatures) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		returnExpression := /* TODO(PropertyAccessExpression): node.body */ TODO
		sourceReturn := getReturnTypeOfSignature(sourceSig)
		targetReturn := getUnionType(map_(targetSignatures, getReturnTypeOfSignature))
		if !checkTypeRelatedTo(sourceReturn, targetReturn, relation, nil) {
			elaborated := returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, nil, containingMessageChain, errorOutputContainer)
			if elaborated {
				return elaborated
			}
			var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
			checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, nil, containingMessageChain, resultObj)
			if /* TODO(PropertyAccessExpression): resultObj.errors */ TODO {
				if /* TODO(PropertyAccessExpression): target.symbol */ TODO && length( /* TODO(PropertyAccessExpression): target.symbol.declarations */ TODO) {
					addRelatedInfo( /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO, createDiagnosticForNode( /* TODO(ElementAccessExpression): target.symbol.declarations![0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature */, TODO))
				}
				if /* TODO(ParenthesizedExpression): (getFunctionFlags(node) & FunctionFlags.Async) */ TODO == 0 && !getTypeOfPropertyOfType(sourceReturn, "then" /* as */ /* TODO(TypeReference): __String */) && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, nil) {
					addRelatedInfo( /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO, createDiagnosticForNode(node /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_to_mark_this_function_as_async */, TODO))
				}
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getBestMatchIndexedAccessTypeOrUndefined := func(source Type, target Type, nameType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		idx := getIndexedAccessTypeOrUndefined(target, nameType)
		if idx {
			return idx
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
			best := getBestMatchingType(source, target /* as */ /* TODO(TypeReference): UnionType */)
			if best {
				return getIndexedAccessTypeOrUndefined(best, nameType)
			}
		}
	}
	checkExpressionForMutableLocationWithContextualType := func(next Expression, sourcePropType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		pushContextualType(next, sourcePropType /* TODO(FalseKeyword): false */, TODO)
		result := checkExpressionForMutableLocation(next /* TODO(PropertyAccessExpression): CheckMode.Contextual */, TODO)
		popContextualType()
		return result
	}
	type ElaborationIterator IterableIterator[ /* TODO(TypeLiteral): { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ TODO]
	elaborateElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		reportedError := /* TODO(FalseKeyword): false */ TODO
		for _, value := range iterator {
			TODO_IDENTIFIER := value
			targetPropType := getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType)
			if !targetPropType || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetPropType.flags & TypeFlags.IndexedAccess */ TODO {
			}
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
			}
			propName := getPropertyNameFromIndex(nameType, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation, nil, containingMessageChain, errorOutputContainer)
				/* TODO(ExpressionStatement): reportedError = true; */
				if !elaborated {
					var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
					specificSource := /* TODO(ConditionalExpression): next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType */ TODO
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target */, TODO, typeToString(specificSource), typeToString(targetPropType))
						/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
						/* TODO(ExpressionStatement): resultObj.errors = [diag]; */
					} else {
						targetIsOptional := !! /* TODO(ParenthesizedExpression): (propName && (getPropertyOfType(target, propName) || unknownSymbol).flags & SymbolFlags.Optional) */ TODO
						sourceIsOptional := !! /* TODO(ParenthesizedExpression): (propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional) */ TODO
						/* TODO(ExpressionStatement): targetPropType = removeMissingType(targetPropType, targetIsOptional); */
						/* TODO(ExpressionStatement): sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional); */
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): specificSource !== sourcePropType */ TODO {
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
					if /* TODO(PropertyAccessExpression): resultObj.errors */ TODO {
						reportedDiag := /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO
						propertyName := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
						targetProp := /* TODO(ConditionalExpression): propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined */ TODO
						issuedElaboration := /* TODO(FalseKeyword): false */ TODO
						if !targetProp {
							indexInfo := getApplicableIndexInfo(target, nameType)
							if indexInfo && /* TODO(PropertyAccessExpression): indexInfo.declaration */ TODO && ! /* TODO(PropertyAccessExpression): getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib */ TODO {
								/* TODO(ExpressionStatement): issuedElaboration = true; */
								addRelatedInfo(reportedDiag, createDiagnosticForNode( /* TODO(PropertyAccessExpression): indexInfo.declaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_expected_type_comes_from_this_index_signature */, TODO))
							}
						}
						if !issuedElaboration && /* TODO(ParenthesizedExpression): (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations)) */ TODO {
							targetNode := /* TODO(ConditionalExpression): targetProp && length(targetProp.declarations) ? targetProp.declarations![0] : target.symbol.declarations![0] */ TODO
							if ! /* TODO(PropertyAccessExpression): getSourceFileOfNode(targetNode).hasNoDefaultLib */ TODO {
								addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode /* TODO(PropertyAccessExpression): Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1 */, TODO /* TODO(ConditionalExpression): propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType) */, TODO, typeToString(target)))
							}
						}
					}
				}
			}
		}
		return reportedError
	}
	elaborateIterableOrArrayLikeTargetElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		tupleOrArrayLikeTargetParts := filterType(target, isArrayOrTupleLikeType)
		nonTupleOrArrayLikeTargetParts := filterType(target /* TODO(ArrowFunction): t => !isArrayOrTupleLikeType(t) */, TODO)
		iterationType := /* TODO(ConditionalExpression): nonTupleOrArrayLikeTargetParts !== neverType             ? getIterationTypeOfIterable(IterationUse.ForOf, IterationTypeKind.Yield, nonTupleOrArrayLikeTargetParts, /*errorNode* / undefined)             : undefined */ TODO
		reportedError := /* TODO(FalseKeyword): false */ TODO
		/* TODO(ForStatement): for (let status = iterator.next(); !status.done; status = iterator.next()) {             const { errorNode: prop, innerExpression: next, nameType, errorMessage } = status.value;             let targetPropType = iterationType;             const targetIndexedPropType = tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : undefined;             if (targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlags.IndexedAccess)) { // Don't elaborate on indexes on generic variables                 targetPropType = iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType;             }             if (!targetPropType) continue;             let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);             if (!sourcePropType) continue;             const propName = getPropertyNameFromIndex(nameType, /*accessNode* / undefined);             if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode* / undefined)) {                 const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage* / undefined, containingMessageChain, errorOutputContainer);                 reportedError = true;                 if (!elaborated) {                     // Issue error on the prop itself, since the prop couldn't elaborate the error                     const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};                     // Use the expression type, if available                     const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;                     if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {                         const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));                         diagnostics.add(diag);                         resultObj.errors = [diag];                     }                     else {                         const targetIsOptional = !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         targetPropType = removeMissingType(targetPropType, targetIsOptional);                         sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);                         const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         if (result && specificSource !== sourcePropType) {                             // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType                             checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         }                     }                 }             }         } */
		return reportedError
	}
	generateJsxAttributes := func(node JsxAttributes) ElaborationIterator {
		if !length( /* TODO(PropertyAccessExpression): node.properties */ TODO) {
		}
		for _, prop := range /* TODO(PropertyAccessExpression): node.properties */ TODO {
			if isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName( /* TODO(PropertyAccessExpression): prop.name */ TODO)) {
			}
			/* TODO(ExpressionStatement): yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) }; */
		}
	}
	generateJsxChildren := func(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
		if !length( /* TODO(PropertyAccessExpression): node.children */ TODO) {
		}
		memberOffset := 0
		/* TODO(ForStatement): for (let i = 0; i < node.children.length; i++) {             const child = node.children[i];             const nameType = getNumberLiteralType(i - memberOffset);             const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);             if (elem) {                 yield elem;             }             else {                 memberOffset++;             }         } */
	}
	getElaborationElementForJsxChild := func(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) /* TODO(undefined): { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxExpression; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxText; innerExpression: undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | undefined */ TODO {
		/* TODO(SwitchStatement): switch (child.kind) {             case SyntaxKind.JsxExpression:                 // child is of the type of the expression                 return { errorNode: child, innerExpression: child.expression, nameType };             case SyntaxKind.JsxText:                 if (child.containsOnlyTriviaWhiteSpaces) {                     break; // Whitespace only jsx text isn't real jsx text                 }                 // child is a string                 return { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() };             case SyntaxKind.JsxElement:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.JsxFragment:                 // child is of type JSX.Element                 return { errorNode: child, innerExpression: child, nameType };             default:                 return Debug.assertNever(child, "Found invalid jsx child");         } */
	}
	elaborateJsxComponents := func(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		result := elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
		var invalidTextDiagnostic *DiagnosticMessage
		if isJsxOpeningElement( /* TODO(PropertyAccessExpression): node.parent */ TODO) && isJsxElement( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO) {
			containingElement := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
			childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
			childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
			childrenNameType := getStringLiteralType(childrenPropName)
			childrenTargetType := getIndexedAccessType(target, childrenNameType)
			validChildren := getSemanticJsxChildren( /* TODO(PropertyAccessExpression): containingElement.children */ TODO)
			if !length(validChildren) {
				return result
			}
			moreThanOneRealChildren := length(validChildren) > 1
			var arrayLikeTargetParts Type
			var nonArrayLikeTargetParts Type
			iterableType := getGlobalIterableType( /* TODO(FalseKeyword): false */ TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterableType !== emptyGenericType */ TODO {
				anyIterable := createIterableType(anyType)
				/* TODO(ExpressionStatement): arrayLikeTargetParts = filterType(childrenTargetType, t => isTypeAssignableTo(t, anyIterable)); */
				/* TODO(ExpressionStatement): nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isTypeAssignableTo(t, anyIterable)); */
			} else {
				/* TODO(ExpressionStatement): arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType); */
				/* TODO(ExpressionStatement): nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isArrayOrTupleLikeType(t)); */
			}
			if moreThanOneRealChildren {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): arrayLikeTargetParts !== neverType */ TODO {
					realSource := createTupleType(checkJsxChildren(containingElement /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO))
					children := generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
					/* TODO(ExpressionStatement): result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result; */
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					/* TODO(ExpressionStatement): result = true; */
					diag := error( /* TODO(PropertyAccessExpression): containingElement.openingElement.tagName */ TODO /* TODO(PropertyAccessExpression): Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided */, TODO, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && /* TODO(PropertyAccessExpression): errorOutputContainer.skipLogging */ TODO {
						/* TODO(PropertyAccessExpression): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push */ TODO(diag)
					}
				}
			} else {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonArrayLikeTargetParts !== neverType */ TODO {
					child := /* TODO(ElementAccessExpression): validChildren[0] */ TODO
					elem := getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
					if elem {
						/* TODO(ExpressionStatement): result = elaborateElementwise(                             (function* () {                                 yield elem;                             })(),                             source,                             target,                             relation,                             containingMessageChain,                             errorOutputContainer,                         ) || result; */
					}
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					/* TODO(ExpressionStatement): result = true; */
					diag := error( /* TODO(PropertyAccessExpression): containingElement.openingElement.tagName */ TODO /* TODO(PropertyAccessExpression): Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided */, TODO, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && /* TODO(PropertyAccessExpression): errorOutputContainer.skipLogging */ TODO {
						/* TODO(PropertyAccessExpression): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push */ TODO(diag)
					}
				}
			}
		}
		return result
		getInvalidTextualChildDiagnostic := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
			if !invalidTextDiagnostic {
				tagNameText := getTextOfNode( /* TODO(PropertyAccessExpression): node.parent.tagName */ TODO)
				childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
				childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
				childrenTargetType := getIndexedAccessType(target, getStringLiteralType(childrenPropName))
				diagnostic := /* TODO(PropertyAccessExpression): Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2 */ TODO
				/* TODO(ExpressionStatement): invalidTextDiagnostic = { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) }; */
			}
			return invalidTextDiagnostic
		}
	}
	generateLimitedTupleElements := func(node ArrayLiteralExpression, target Type) ElaborationIterator {
		len := length( /* TODO(PropertyAccessExpression): node.elements */ TODO)
		if !len {
		}
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature             if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i) as __String)) continue;             const elem = node.elements[i];             if (isOmittedExpression(elem)) continue;             const nameType = getNumberLiteralType(i);             const checkNode = getEffectiveCheckNode(elem);             yield { errorNode: checkNode, innerExpression: checkNode, nameType };         } */
	}
	elaborateArrayLiteral := func(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & (TypeFlags.Primitive | TypeFlags.Never) */ TODO {
			/* TODO(FalseKeyword): false */
		}
		if isTupleLikeType(source) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
		}
		pushContextualType(node, target /* TODO(FalseKeyword): false */, TODO)
		tupleizedType := checkArrayLiteral(node /* TODO(PropertyAccessExpression): CheckMode.Contextual */, TODO /* TODO(TrueKeyword): true */, TODO)
		popContextualType()
		if isTupleLikeType(tupleizedType) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	generateObjectLiteralElements := func(node ObjectLiteralExpression) ElaborationIterator {
		if !length( /* TODO(PropertyAccessExpression): node.properties */ TODO) {
		}
		for _, prop := range /* TODO(PropertyAccessExpression): node.properties */ TODO {
			if isSpreadAssignment(prop) {
			}
			type_ := getLiteralTypeFromProperty(getSymbolOfDeclaration(prop) /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO)
			if !type_ || /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Never) */ TODO {
				/* TODO(ContinueStatement): continue; */
			}
			/* TODO(SwitchStatement): switch (prop.kind) {                 case SyntaxKind.SetAccessor:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.ShorthandPropertyAssignment:                     yield { errorNode: prop.name, innerExpression: undefined, nameType: type };                     break;                 case SyntaxKind.PropertyAssignment:                     yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined };                     break;                 default:                     Debug.assertNever(prop);             } */
		}
	}
	elaborateObjectLiteral := func(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & (TypeFlags.Primitive | TypeFlags.Never) */ TODO {
			/* TODO(FalseKeyword): false */
		}
		return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
	}
	checkTypeComparableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain)
	}
	isSignatureAssignableTo := func(source Signature, target Signature, ignoreReturnTypes bool) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): compareSignaturesRelated(source, target, ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None, /*reportErrors* / false, /*errorReporter* / undefined, /*incompatibleErrorReporter* / undefined, compareTypesAssignable, /*reportUnreliableMarkers* / undefined) !== Ternary.False */ TODO
	}
	type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments)
	isTopSignature := func(s Signature) /* TODO(undefined): boolean */ TODO {
		if ! /* TODO(PropertyAccessExpression): s.typeParameters */ TODO && /* TODO(ParenthesizedExpression): (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) */ TODO && /* TODO(PropertyAccessExpression): s.parameters.length */ TODO == 1 && signatureHasRestParameter(s) {
			paramType := getTypeOfParameter( /* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
			restType := /* TODO(ConditionalExpression): isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType */ TODO
			return !! /* TODO(ParenthesizedExpression): (restType.flags & (TypeFlags.Any | TypeFlags.Never) && getReturnTypeOfSignature(s).flags & TypeFlags.AnyOrUnknown) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	compareSignaturesRelated := func(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter /* TODO(ParenthesizedType): ((source: Type, target: Type) => void) */ any, compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
		if source == target {
			return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		}
		if ! /* TODO(ParenthesizedExpression): (checkMode & SignatureCheckMode.StrictTopSignature && isTopSignature(source)) */ TODO && isTopSignature(target) {
			return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & SignatureCheckMode.StrictTopSignature */ TODO && isTopSignature(source) && !isTopSignature(target) {
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		targetCount := getParameterCount(target)
		sourceHasMoreParameters := !hasEffectiveRestParameter(target) && /* TODO(ParenthesizedExpression): (checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount) */ TODO
		if sourceHasMoreParameters {
			if reportErrors && ! /* TODO(ParenthesizedExpression): (checkMode & SignatureCheckMode.StrictArity) */ TODO {
				/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1 */ TODO, getMinArgumentCount(source), targetCount)
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		if /* TODO(PropertyAccessExpression): source.typeParameters */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.typeParameters !== target.typeParameters */ TODO {
			/* TODO(ExpressionStatement): target = getCanonicalSignature(target); */
			/* TODO(ExpressionStatement): source = instantiateSignatureInContextOf(source, target, /*inferenceContext* / undefined, compareTypes); */
		}
		sourceCount := getParameterCount(source)
		sourceRestType := getNonArrayRestType(source)
		targetRestType := getNonArrayRestType(target)
		if sourceRestType || targetRestType {
			/* TODO(ExpressionStatement): void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers); */
		}
		kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
		strictVariance := ! /* TODO(ParenthesizedExpression): (checkMode & SignatureCheckMode.Callback) */ TODO && strictFunctionTypes && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== SyntaxKind.MethodDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== SyntaxKind.MethodSignature */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== SyntaxKind.Constructor */ TODO
		result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceThisType !== voidType */ TODO {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				related := !strictVariance && compareTypes(sourceThisType, targetThisType /* TODO(FalseKeyword): false */, TODO) || compareTypes(targetThisType, sourceThisType, reportErrors)
				if !related {
					if reportErrors {
						/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.The_this_types_of_each_signature_are_incompatible */ TODO)
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				/* TODO(ExpressionStatement): result &= related; */
			}
		}
		paramCount := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount) */ TODO
		restIndex := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? paramCount - 1 : -1 */ TODO
		/* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             const sourceType = i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);             const targetType = i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);             if (sourceType && targetType && (sourceType !== targetType || checkMode & SignatureCheckMode.StrictArity)) {                 // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter                 // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,                 // they naturally relate only contra-variantly). However, if the source and target parameters both have                 // function types with a single call signature, we know we are relating two callback parameters. In                 // that case it is sufficient to only relate the parameters of the signatures co-variantly because,                 // similar to return values, callback parameters are output positions. This means that a Promise<T>,                 // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)                 // with respect to T.                 const sourceSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType));                 const targetSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType));                 const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&                     getTypeFacts(sourceType, TypeFacts.IsUndefinedOrNull) === getTypeFacts(targetType, TypeFacts.IsUndefinedOrNull);                 let related = callbacks ?                     compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :                     !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors* / false) || compareTypes(targetType, sourceType, reportErrors);                 // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void                 if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors* / false)) {                     related = Ternary.False;                 }                 if (!related) {                     if (reportErrors) {                         errorReporter!(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));                     }                     return Ternary.False;                 }                 result &= related;             }         } */
		if ! /* TODO(ParenthesizedExpression): (checkMode & SignatureCheckMode.IgnoreReturnTypes) */ TODO {
			targetReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(target) ? anyType                 : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))                 : getReturnTypeOfSignature(target) */ TODO
			if targetReturnType == voidType || targetReturnType == anyType {
				return result
			}
			sourceReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(source) ? anyType                 : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))                 : getReturnTypeOfSignature(source) */ TODO
			targetTypePredicate := getTypePredicateOfSignature(target)
			if targetTypePredicate {
				sourceTypePredicate := getTypePredicateOfSignature(source)
				if sourceTypePredicate {
					/* TODO(ExpressionStatement): result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes); */
				} else if isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) {
					if reportErrors {
						/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.Signature_0_must_be_a_type_predicate */ TODO, signatureToString(source))
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			} else {
				/* TODO(ExpressionStatement): result &= checkMode & SignatureCheckMode.BivariantCallback && compareTypes(targetReturnType, sourceReturnType, /*reportErrors* / false) ||                     compareTypes(sourceReturnType, targetReturnType, reportErrors); */
				if !result && reportErrors && incompatibleErrorReporter {
					incompatibleErrorReporter(sourceReturnType, targetReturnType)
				}
			}
		}
		return result
	}
	compareTypePredicateRelatedTo := func(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.kind !== target.kind */ TODO {
			if reportErrors {
				/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard */ TODO)
				/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.Type_predicate_0_is_not_assignable_to_1 */ TODO, typePredicateToString(source), typePredicateToString(target))
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		if /* TODO(PropertyAccessExpression): source.kind */ TODO == /* TODO(PropertyAccessExpression): TypePredicateKind.Identifier */ TODO || /* TODO(PropertyAccessExpression): source.kind */ TODO == /* TODO(PropertyAccessExpression): TypePredicateKind.AssertsIdentifier */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.parameterIndex !== (target as IdentifierTypePredicate).parameterIndex */ TODO {
				if reportErrors {
					/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1 */ TODO /* TODO(PropertyAccessExpression): source.parameterName */, TODO /* TODO(PropertyAccessExpression): (target as IdentifierTypePredicate).parameterName */, TODO)
					/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.Type_predicate_0_is_not_assignable_to_1 */ TODO, typePredicateToString(source), typePredicateToString(target))
				}
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
		}
		related := /* TODO(ConditionalExpression): source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :             Ternary.False */ TODO
		if related == /* TODO(PropertyAccessExpression): Ternary.False */ TODO && reportErrors {
			/* TODO(NonNullExpression): errorReporter! */ TODO( /* TODO(PropertyAccessExpression): Diagnostics.Type_predicate_0_is_not_assignable_to_1 */ TODO, typePredicateToString(source), typePredicateToString(target))
		}
		return related
	}
	isImplementationCompatibleWithOverload := func(implementation Signature, overload Signature) bool {
		erasedSource := getErasedSignature(implementation)
		erasedTarget := getErasedSignature(overload)
		sourceReturnType := getReturnTypeOfSignature(erasedSource)
		targetReturnType := getReturnTypeOfSignature(erasedTarget)
		if targetReturnType == voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation) {
			return isSignatureAssignableTo(erasedSource, erasedTarget /* TODO(TrueKeyword): true */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isEmptyResolvedType := func(t ResolvedType) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): t !== anyFunctionType */ TODO && /* TODO(PropertyAccessExpression): t.properties.length */ TODO == 0 && /* TODO(PropertyAccessExpression): t.callSignatures.length */ TODO == 0 && /* TODO(PropertyAccessExpression): t.constructSignatures.length */ TODO == 0 && /* TODO(PropertyAccessExpression): t.indexInfos.length */ TODO == 0
	}
	isEmptyObjectType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Object ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type as ObjectType)) :             type.flags & TypeFlags.NonPrimitive ? true :             type.flags & TypeFlags.Union ? some((type as UnionType).types, isEmptyObjectType) :             type.flags & TypeFlags.Intersection ? every((type as UnionType).types, isEmptyObjectType) :             false */ TODO
	}
	isEmptyAnonymousObjectType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Anonymous && (             (type as ResolvedType).members && isEmptyResolvedType(type as ResolvedType) ||             type.symbol && type.symbol.flags & SymbolFlags.TypeLiteral && getMembersOfSymbol(type.symbol).size === 0         )) */ TODO
	}
	isUnknownLikeUnionType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		if strictNullChecks && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			if ! /* TODO(ParenthesizedExpression): ((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnionComputed) */ TODO {
				types := /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO
				/* TODO(ExpressionStatement): (type as UnionType).objectFlags |= ObjectFlags.IsUnknownLikeUnionComputed | (types.length >= 3 && types[0].flags & TypeFlags.Undefined &&                         types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0); */
			}
			return !! /* TODO(ParenthesizedExpression): ((type as UnionType).objectFlags & ObjectFlags.IsUnknownLikeUnion) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	containsUndefinedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): ((type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type).flags & TypeFlags.Undefined) */ TODO
	}
	containsNonMissingUndefinedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		candidate := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO
		return !! /* TODO(ParenthesizedExpression): (candidate.flags & TypeFlags.Undefined) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): candidate !== missingType */ TODO
	}
	isStringIndexSignatureOnlyType := func(type_ Type) bool {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO && !isGenericMappedType(type_) && /* TODO(PropertyAccessExpression): getPropertiesOfType(type).length */ TODO == 0 && /* TODO(PropertyAccessExpression): getIndexInfosOfType(type).length */ TODO == 1 && !!getIndexInfoOfType(type_, stringType) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.UnionOrIntersection */ TODO && every( /* TODO(PropertyAccessExpression): (type as UnionOrIntersectionType).types */ TODO, isStringIndexSignatureOnlyType) || /* TODO(FalseKeyword): false */ TODO
	}
	isEnumTypeRelatedTo := func(source Symbol, target Symbol, errorReporter ErrorReporter) /* TODO(undefined): boolean */ TODO {
		sourceSymbol := /* TODO(ConditionalExpression): source.flags & SymbolFlags.EnumMember ? getParentOfSymbol(source)! : source */ TODO
		targetSymbol := /* TODO(ConditionalExpression): target.flags & SymbolFlags.EnumMember ? getParentOfSymbol(target)! : target */ TODO
		if sourceSymbol == targetSymbol {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSymbol.escapedName !== targetSymbol.escapedName */ TODO || ! /* TODO(ParenthesizedExpression): (sourceSymbol.flags & SymbolFlags.RegularEnum) */ TODO || ! /* TODO(ParenthesizedExpression): (targetSymbol.flags & SymbolFlags.RegularEnum) */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol) */ TODO
		entry := /* TODO(PropertyAccessExpression): enumRelation.get */ TODO(id)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): entry !== undefined */ TODO && ! /* TODO(ParenthesizedExpression): (entry & RelationComparisonResult.Failed && errorReporter) */ TODO {
			return !! /* TODO(ParenthesizedExpression): (entry & RelationComparisonResult.Succeeded) */ TODO
		}
		targetEnumType := getTypeOfSymbol(targetSymbol)
		for _, sourceProperty := range getPropertiesOfType(getTypeOfSymbol(sourceSymbol)) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceProperty.flags & SymbolFlags.EnumMember */ TODO {
				targetProperty := getPropertyOfType(targetEnumType /* TODO(PropertyAccessExpression): sourceProperty.escapedName */, TODO)
				if !targetProperty || ! /* TODO(ParenthesizedExpression): (targetProperty.flags & SymbolFlags.EnumMember) */ TODO {
					if errorReporter {
						errorReporter( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_missing_in_type_1 */ TODO, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol), nil /* TODO(PropertyAccessExpression): TypeFormatFlags.UseFullyQualifiedType */, TODO))
					}
					/* TODO(PropertyAccessExpression): enumRelation.set */ TODO(id /* TODO(PropertyAccessExpression): RelationComparisonResult.Failed */, TODO)
					return /* TODO(FalseKeyword): false */ TODO
				}
				sourceValue := /* TODO(PropertyAccessExpression): getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKind.EnumMember)!).value */ TODO
				targetValue := /* TODO(PropertyAccessExpression): getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKind.EnumMember)!).value */ TODO
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceValue !== targetValue */ TODO {
					sourceIsString := /* TODO(TypeOfExpression): typeof sourceValue */ TODO == "string"
					targetIsString := /* TODO(TypeOfExpression): typeof targetValue */ TODO == "string"
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceValue !== undefined */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetValue !== undefined */ TODO {
						if errorReporter {
							escapedSource := /* TODO(ConditionalExpression): sourceIsString ? `"${escapeString(sourceValue)}"` : sourceValue */ TODO
							escapedTarget := /* TODO(ConditionalExpression): targetIsString ? `"${escapeString(targetValue)}"` : targetValue */ TODO
							errorReporter( /* TODO(PropertyAccessExpression): Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given */ TODO, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource)
						}
						/* TODO(PropertyAccessExpression): enumRelation.set */ TODO(id /* TODO(PropertyAccessExpression): RelationComparisonResult.Failed */, TODO)
						return /* TODO(FalseKeyword): false */ TODO
					}
					if sourceIsString || targetIsString {
						if errorReporter {
							knownStringValue := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): sourceValue ?? targetValue */ TODO
							/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(TypeOfExpression): typeof knownStringValue */ TODO == "string")
							escapedValue := /* TODO(TemplateExpression): `"${escapeString(knownStringValue)}"` */ TODO
							errorReporter( /* TODO(PropertyAccessExpression): Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value */ TODO, symbolName(targetSymbol), symbolName(targetProperty), escapedValue)
						}
						/* TODO(PropertyAccessExpression): enumRelation.set */ TODO(id /* TODO(PropertyAccessExpression): RelationComparisonResult.Failed */, TODO)
						return /* TODO(FalseKeyword): false */ TODO
					}
				}
			}
		}
		/* TODO(PropertyAccessExpression): enumRelation.set */ TODO(id /* TODO(PropertyAccessExpression): RelationComparisonResult.Succeeded */, TODO)
		return /* TODO(TrueKeyword): true */ TODO
	}
	isSimpleTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) /* TODO(undefined): boolean */ TODO {
		s := /* TODO(PropertyAccessExpression): source.flags */ TODO
		t := /* TODO(PropertyAccessExpression): target.flags */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Any */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Never */ TODO || source == wildcardType {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Unknown */ TODO && ! /* TODO(ParenthesizedExpression): (relation === strictSubtypeRelation && s & TypeFlags.Any) */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Never */ TODO {
			/* TODO(FalseKeyword): false */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.StringLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.String */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.StringLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.EnumLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.StringLiteral */ TODO && ! /* TODO(ParenthesizedExpression): (t & TypeFlags.EnumLiteral) */ TODO && /* TODO(PropertyAccessExpression): (source as StringLiteralType).value */ TODO == /* TODO(PropertyAccessExpression): (target as StringLiteralType).value */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.NumberLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Number */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.NumberLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.EnumLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.NumberLiteral */ TODO && ! /* TODO(ParenthesizedExpression): (t & TypeFlags.EnumLiteral) */ TODO && /* TODO(PropertyAccessExpression): (source as NumberLiteralType).value */ TODO == /* TODO(PropertyAccessExpression): (target as NumberLiteralType).value */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.BigIntLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.BigInt */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.BooleanLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Boolean */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.ESSymbolLike */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.ESSymbol */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Enum */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Enum */ TODO && /* TODO(PropertyAccessExpression): source.symbol.escapedName */ TODO == /* TODO(PropertyAccessExpression): target.symbol.escapedName */ TODO && isEnumTypeRelatedTo( /* TODO(PropertyAccessExpression): source.symbol */ TODO /* TODO(PropertyAccessExpression): target.symbol */, TODO, errorReporter) {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.EnumLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.EnumLiteral */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Union */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Union */ TODO && isEnumTypeRelatedTo( /* TODO(PropertyAccessExpression): source.symbol */ TODO /* TODO(PropertyAccessExpression): target.symbol */, TODO, errorReporter) {
				/* TODO(TrueKeyword): true */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Literal */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.Literal */ TODO && /* TODO(PropertyAccessExpression): (source as LiteralType).value */ TODO == /* TODO(PropertyAccessExpression): (target as LiteralType).value */ TODO && isEnumTypeRelatedTo( /* TODO(PropertyAccessExpression): source.symbol */ TODO /* TODO(PropertyAccessExpression): target.symbol */, TODO, errorReporter) {
				/* TODO(TrueKeyword): true */
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Undefined */ TODO && /* TODO(ParenthesizedExpression): (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & (TypeFlags.Undefined | TypeFlags.Void)) */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Null */ TODO && /* TODO(ParenthesizedExpression): (!strictNullChecks && !(t & TypeFlags.UnionOrIntersection) || t & TypeFlags.Null) */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t & TypeFlags.NonPrimitive */ TODO && ! /* TODO(ParenthesizedExpression): (relation === strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlags.FreshLiteral)) */ TODO {
			/* TODO(TrueKeyword): true */
		}
		if relation == assignableRelation || relation == comparableRelation {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Any */ TODO {
				/* TODO(TrueKeyword): true */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.Number */ TODO && /* TODO(ParenthesizedExpression): (t & TypeFlags.Enum || t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral) */ TODO {
				/* TODO(TrueKeyword): true */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): s & TypeFlags.NumberLiteral */ TODO && ! /* TODO(ParenthesizedExpression): (s & TypeFlags.EnumLiteral) */ TODO && /* TODO(ParenthesizedExpression): (t & TypeFlags.Enum ||                     t & TypeFlags.NumberLiteral && t & TypeFlags.EnumLiteral &&                         (source as NumberLiteralType).value === (target as NumberLiteralType).value) */ TODO {
				/* TODO(TrueKeyword): true */
			}
			if isUnknownLikeUnionType(target) {
				/* TODO(TrueKeyword): true */
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult]) /* TODO(undefined): boolean */ TODO {
		if isFreshLiteralType(source) {
			/* TODO(ExpressionStatement): source = (source as FreshableType).regularType; */
		}
		if isFreshLiteralType(target) {
			/* TODO(ExpressionStatement): target = (target as FreshableType).regularType; */
		}
		if source == target {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
			if relation == comparableRelation && ! /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.Never) */ TODO && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		} else if ! /* TODO(ParenthesizedExpression): ((source.flags | target.flags) & (TypeFlags.UnionOrIntersection | TypeFlags.IndexedAccess | TypeFlags.Conditional | TypeFlags.Substitution)) */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.flags !== target.flags */ TODO {
				/* TODO(FalseKeyword): false */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Singleton */ TODO {
				/* TODO(TrueKeyword): true */
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Object */ TODO {
			related := /* TODO(PropertyAccessExpression): relation.get */ TODO(getRelationKey(source, target /* TODO(PropertyAccessExpression): IntersectionState.None */, TODO, relation /* TODO(FalseKeyword): false */, TODO))
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): related !== undefined */ TODO {
				return !! /* TODO(ParenthesizedExpression): (related & RelationComparisonResult.Succeeded) */ TODO
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.StructuredOrInstantiable */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.StructuredOrInstantiable */ TODO {
			return checkTypeRelatedTo(source, target, relation, nil)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isIgnoredJsxProperty := func(source Type, sourceProp Symbol) /* TODO(undefined): boolean | 0 */ TODO {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.JsxAttributes */ TODO && isHyphenatedJsxName( /* TODO(PropertyAccessExpression): sourceProp.escapedName */ TODO)
	}
	getNormalizedType := func(type_ Type, writing bool) Type {
		/* TODO(WhileStatement): while (true) {             const t = isFreshLiteralType(type) ? (type as FreshableType).regularType :                 isGenericTupleType(type) ? getNormalizedTupleType(type, writing) :                 getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type :                 type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) :                 type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) :                 type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) :                 type;             if (t === type) return t;             type = t;         } */
	}
	getNormalizedUnionOrIntersectionType := func(type_ UnionOrIntersectionType, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reduced := getReducedType(type_)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): reduced !== type */ TODO {
			return reduced
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO && shouldNormalizeIntersection(type_ /* as */ /* TODO(TypeReference): IntersectionType */) {
			normalizedTypes := sameMap( /* TODO(PropertyAccessExpression): type.types */ TODO /* TODO(ArrowFunction): t => getNormalizedType(t, writing) */, TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): normalizedTypes !== type.types */ TODO {
				return getIntersectionType(normalizedTypes)
			}
		}
		return type_
	}
	shouldNormalizeIntersection := func(type_ IntersectionType) /* TODO(undefined): boolean */ TODO {
		hasInstantiable := /* TODO(FalseKeyword): false */ TODO
		hasNullableOrEmpty := /* TODO(FalseKeyword): false */ TODO
		for _, t := range /* TODO(PropertyAccessExpression): type.types */ TODO {
			/* TODO(ExpressionStatement): hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable); */
			/* TODO(ExpressionStatement): hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t); */
			if hasInstantiable && hasNullableOrEmpty {
				/* TODO(TrueKeyword): true */
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getNormalizedTupleType := func(type_ TupleTypeReference, writing bool) Type {
		elements := getElementTypes(type_)
		normalizedElements := sameMap(elements /* TODO(ArrowFunction): t => t.flags & TypeFlags.Simplifiable ? getSimplifiedType(t, writing) : t */, TODO)
		return /* TODO(ConditionalExpression): elements !== normalizedElements ? createNormalizedTupleType(type.target, normalizedElements) : type */ TODO
	}
	checkTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO) bool {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo /* TODO(TupleType): [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
		var maybeKeys []string
		var maybeKeysSet Set[string]
		var sourceStack []Type
		var targetStack []Type
		maybeCount := 0
		sourceDepth := 0
		targetDepth := 0
		expandingFlags := /* TODO(PropertyAccessExpression): ExpandingFlags.None */ TODO
		overflow := /* TODO(FalseKeyword): false */ TODO
		overrideNextErrorInfo := 0
		skipParentCounter := 0
		var lastSkippedInfo /* TODO(TupleType): [Type, Type] */ any
		var incompatibleStack /* TODO(ArrayType): DiagnosticAndArguments[] */ any
		relationCount := /* TODO(GreaterThanGreaterThanToken): >> */ /* TODO(BinaryExpression): (16_000_000 - relation.size) >> 3 */ TODO
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO || !errorNode, "no error reporting in identity checking")
		result := isRelatedTo(source, target /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, !!errorNode, headMessage)
		if incompatibleStack {
			reportIncompatibleStack()
		}
		if overflow {
			id := getRelationKey(source, target /* TODO(PropertyAccessExpression): IntersectionState.None */, TODO, relation /* TODO(FalseKeyword): false */, TODO)
			/* TODO(PropertyAccessExpression): relation.set */ TODO(id /* TODO(BarToken): | */ /* TODO(BinaryExpression): RelationComparisonResult.Failed | (relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow) */, TODO)
			/* TODO(PropertyAccessExpression): tracing?.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "checkTypeRelatedTo_DepthLimit" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth } */, TODO)
			message := /* TODO(ConditionalExpression): relationCount <= 0 ?                 Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                 Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
			diag := error(errorNode || currentNode, message, typeToString(source), typeToString(target))
			if errorOutputContainer {
				/* TODO(PropertyAccessExpression): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push */ TODO(diag)
			}
		} else if errorInfo {
			if containingMessageChain {
				chain := containingMessageChain()
				if chain {
					concatenateDiagnosticMessageChains(chain, errorInfo)
					/* TODO(ExpressionStatement): errorInfo = chain; */
				}
			}
			var relatedInformation /* TODO(ArrayType): DiagnosticRelatedInformation[] */ any
			if headMessage && errorNode && !result && /* TODO(PropertyAccessExpression): source.symbol */ TODO {
				links := getSymbolLinks( /* TODO(PropertyAccessExpression): source.symbol */ TODO)
				if /* TODO(PropertyAccessExpression): links.originatingImport */ TODO && !isImportCall( /* TODO(PropertyAccessExpression): links.originatingImport */ TODO) {
					helpfulRetry := checkTypeRelatedTo(getTypeOfSymbol( /* TODO(NonNullExpression): links.target! */ TODO), target, relation, nil)
					if helpfulRetry {
						diag := createDiagnosticForNode( /* TODO(PropertyAccessExpression): links.originatingImport */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead */, TODO)
						/* TODO(ExpressionStatement): relatedInformation = append(relatedInformation, diag); */
					}
				}
			}
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode( /* TODO(NonNullExpression): errorNode! */ TODO) /* TODO(NonNullExpression): errorNode! */, TODO, errorInfo, relatedInformation)
			if relatedInfo {
				addRelatedInfo(diag /* TODO(SpreadElement): ...relatedInfo */, TODO)
			}
			if errorOutputContainer {
				/* TODO(PropertyAccessExpression): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push */ TODO(diag)
			}
			if !errorOutputContainer || ! /* TODO(PropertyAccessExpression): errorOutputContainer.skipLogging */ TODO {
				/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
			}
		}
		if errorNode && errorOutputContainer && /* TODO(PropertyAccessExpression): errorOutputContainer.skipLogging */ TODO && result == /* TODO(PropertyAccessExpression): Ternary.False */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO, "missed opportunity to interact with error.")
		}
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== Ternary.False */ TODO
		resetErrorInfo := func(saved ReturnType[ /* TODO(TypeQuery): typeof captureErrorCalculationState */ TODO]) {
			/* TODO(ExpressionStatement): errorInfo = saved.errorInfo; */
			/* TODO(ExpressionStatement): lastSkippedInfo = saved.lastSkippedInfo; */
			/* TODO(ExpressionStatement): incompatibleStack = saved.incompatibleStack; */
			/* TODO(ExpressionStatement): overrideNextErrorInfo = saved.overrideNextErrorInfo; */
			/* TODO(ExpressionStatement): skipParentCounter = saved.skipParentCounter; */
			/* TODO(ExpressionStatement): relatedInfo = saved.relatedInfo; */
		}
		captureErrorCalculationState := func() /* TODO(undefined): { errorInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined; lastSkippedInfo: [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").Type] | undefined; incompatibleStack: [message: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ TODO {
			return /* TODO(ObjectLiteralExpression): {                 errorInfo,                 lastSkippedInfo,                 incompatibleStack: incompatibleStack?.slice(),                 overrideNextErrorInfo,                 skipParentCounter,                 relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined,             } */ TODO
		}
		reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
			/* TODO(ExpressionStatement): overrideNextErrorInfo++; */
			/* TODO(ExpressionStatement): lastSkippedInfo = undefined; */
			/* TODO(PropertyAccessExpression): (incompatibleStack ||= []).push */
			TODO( /* TODO(ArrayLiteralExpression): [message, ...args] */ TODO)
		}
		reportIncompatibleStack := func() /* TODO(undefined): undefined */ TODO {
			stack := incompatibleStack || /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ExpressionStatement): incompatibleStack = undefined; */
			info := lastSkippedInfo
			/* TODO(ExpressionStatement): lastSkippedInfo = undefined; */
			if /* TODO(PropertyAccessExpression): stack.length */ TODO == 1 {
				reportError( /* TODO(SpreadElement): ...stack[0] */ TODO)
				if info {
					reportRelationError(nil /* TODO(SpreadElement): ...info */, TODO)
				}
				return
			}
			path := ""
			var secondaryRootErrors []DiagnosticAndArguments = /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(WhileStatement): while (stack.length) {                 const [msg, ...args] = stack.pop()!;                 switch (msg.code) {                     case Diagnostics.Types_of_property_0_are_incompatible.code: {                         // Parenthesize a `new` if there is one                         if (path.indexOf("new ") === 0) {                             path = `(${path})`;                         }                         const str = "" + args[0];                         // If leading, just print back the arg (irrespective of if it's a valid identifier)                         if (path.length === 0) {                             path = `${str}`;                         }                         // Otherwise write a dotted name if possible                         else if (isIdentifierText(str, getEmitScriptTarget(compilerOptions))) {                             path = `${path}.${str}`;                         }                         // Failing that, check if the name is already a computed name                         else if (str[0] === "[" && str[str.length - 1] === "]") {                             path = `${path}${str}`;                         }                         // And finally write out a computed name as a last resort                         else {                             path = `${path}[${str}]`;                         }                         break;                     }                     case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:                     case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:                     case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:                     case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {                         if (path.length === 0) {                             // Don't flatten signature compatability errors at the start of a chain - instead prefer                             // to unify (the with no arguments bit is excessive for printback) and print them back                             let mappedMsg = msg;                             if (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {                                 mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;                             }                             else if (msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {                                 mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;                             }                             secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);                         }                         else {                             const prefix = (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? "new "                                 : "";                             const params = (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? ""                                 : "...";                             path = `${prefix}${path}(${params})`;                         }                         break;                     }                     case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {                         secondaryRootErrors.unshift([Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);                         break;                     }                     case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {                         secondaryRootErrors.unshift([Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);                         break;                     }                     default:                         return Debug.fail(`Unhandled Diagnostic: ${msg.code}`);                 }             } */
			if path {
				reportError( /* TODO(ConditionalExpression): path[path.length - 1] === ")"                         ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types                         : Diagnostics.The_types_of_0_are_incompatible_between_these_types */ TODO, path)
			} else {
				/* TODO(PropertyAccessExpression): secondaryRootErrors.shift */ TODO()
			}
			for _, TODO_IDENTIFIER := range secondaryRootErrors {
				originalValue := /* TODO(PropertyAccessExpression): msg.elidedInCompatabilityPyramid */ TODO
				/* TODO(ExpressionStatement): msg.elidedInCompatabilityPyramid = false; */
				reportError(msg /* TODO(SpreadElement): ...args */, TODO)
				/* TODO(ExpressionStatement): msg.elidedInCompatabilityPyramid = originalValue; */
			}
			if info {
				reportRelationError(nil /* TODO(SpreadElement): ...info */, TODO)
			}
		}
		reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!!errorNode)
			if incompatibleStack {
				/* TODO(CallExpression): reportIncompatibleStack() */
			}
			if /* TODO(PropertyAccessExpression): message.elidedInCompatabilityPyramid */ TODO {
			}
			if skipParentCounter == 0 {
				/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, message, ...args); */
			} else {
				/* TODO(ExpressionStatement): skipParentCounter--; */
			}
		}
		reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
			reportError(message /* TODO(SpreadElement): ...args */, TODO)
			/* TODO(ExpressionStatement): skipParentCounter++; */
		}
		associateRelatedInfo := func(info DiagnosticRelatedInformation) {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!!errorInfo)
			if !relatedInfo {
				/* TODO(ExpressionStatement): relatedInfo = [info]; */
			} else {
				/* TODO(PropertyAccessExpression): relatedInfo.push */ TODO(info)
			}
		}
		reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
			if incompatibleStack {
				/* TODO(CallExpression): reportIncompatibleStack() */
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(source, target)
			generalizedSource := source
			generalizedSourceType := sourceType
			if isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target) {
				/* TODO(ExpressionStatement): generalizedSource = getBaseTypeOfLiteralType(source); */
				/* TODO(PropertyAccessExpression): Debug.assert */
				TODO(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable")
				/* TODO(ExpressionStatement): generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource); */
			}
			targetFlags := /* TODO(ConditionalExpression): target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ?                 (target as IndexedAccessType).objectType.flags :                 target.flags */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.TypeParameter */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== markerSuperTypeForCheck */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== markerSubTypeForCheck */ TODO {
				constraint := getBaseConstraintOfType(target)
				var needsOriginalSource TODO
				if constraint && /* TODO(ParenthesizedExpression): (isTypeAssignableTo(generalizedSource, constraint) || (needsOriginalSource = isTypeAssignableTo(source, constraint))) */ TODO {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2 */ TODO /* TODO(ConditionalExpression): needsOriginalSource ? sourceType : generalizedSourceType */, TODO, targetType, typeToString(constraint))
				} else {
					/* TODO(ExpressionStatement): errorInfo = undefined; */
					reportError( /* TODO(PropertyAccessExpression): Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1 */ TODO, targetType, generalizedSourceType)
				}
			}
			if !message {
				if relation == comparableRelation {
					/* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_comparable_to_type_1; */
				} else if sourceType == targetType {
					/* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated; */
				} else if exactOptionalPropertyTypes && /* TODO(PropertyAccessExpression): getExactOptionalUnassignableProperties(source, target).length */ TODO {
					/* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties; */
				} else {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.StringLiteral */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
						suggestedType := getSuggestedTypeForNonexistentStringLiteralType(source /* as */ /* TODO(TypeReference): StringLiteralType */, target /* as */ /* TODO(TypeReference): UnionType */)
						if suggestedType {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2 */ TODO, generalizedSourceType, targetType, typeToString(suggestedType))
							return
						}
					}
					/* TODO(ExpressionStatement): message = Diagnostics.Type_0_is_not_assignable_to_type_1; */
				}
			} else if message == /* TODO(PropertyAccessExpression): Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 */ TODO && exactOptionalPropertyTypes && /* TODO(PropertyAccessExpression): getExactOptionalUnassignableProperties(source, target).length */ TODO {
				/* TODO(ExpressionStatement): message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties; */
			}
			reportError(message, generalizedSourceType, targetType)
		}
		tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
			sourceType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source) */ TODO
			targetType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target) */ TODO
			if /* TODO(ParenthesizedExpression): (globalStringType === source && stringType === target) */ TODO || /* TODO(ParenthesizedExpression): (globalNumberType === source && numberType === target) */ TODO || /* TODO(ParenthesizedExpression): (globalBooleanType === source && booleanType === target) */ TODO || /* TODO(ParenthesizedExpression): (getGlobalESSymbolType() === source && esSymbolType === target) */ TODO {
				reportError( /* TODO(PropertyAccessExpression): Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible */ TODO, targetType, sourceType)
			}
		}
		tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
			if isTupleType(source) {
				if /* TODO(PropertyAccessExpression): source.target.readonly */ TODO && isMutableArrayOrTuple(target) {
					if reportErrors {
						reportError( /* TODO(PropertyAccessExpression): Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1 */ TODO, typeToString(source), typeToString(target))
					}
					return /* TODO(FalseKeyword): false */ TODO
				}
				return isArrayOrTupleType(target)
			}
			if isReadonlyArrayType(source) && isMutableArrayOrTuple(target) {
				if reportErrors {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1 */ TODO, typeToString(source), typeToString(target))
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
			if isTupleType(target) {
				return isArrayType(source)
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			return isRelatedTo(source, target /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors)
		}
		isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /* = */ /* TODO(PropertyAccessExpression): RecursionFlags.Both */, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, headMessage DiagnosticMessage, intersectionState /* TODO(undefined): IntersectionState */ TODO /* = */ /* TODO(PropertyAccessExpression): IntersectionState.None */) Ternary {
			if originalSource == originalTarget {
				/* TODO(PropertyAccessExpression): Ternary.True */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): originalSource.flags & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): originalTarget.flags & TypeFlags.Primitive */ TODO {
				if relation == comparableRelation && ! /* TODO(ParenthesizedExpression): (originalTarget.flags & TypeFlags.Never) */ TODO && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) || isSimpleTypeRelatedTo(originalSource, originalTarget, relation /* TODO(ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
					return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
				}
				if reportErrors {
					reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage)
				}
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			source := getNormalizedType(originalSource /* TODO(FalseKeyword): false */, TODO)
			target := getNormalizedType(originalTarget /* TODO(TrueKeyword): true */, TODO)
			if source == target {
				/* TODO(PropertyAccessExpression): Ternary.True */
			}
			if relation == identityRelation {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.flags !== target.flags */ TODO {
					/* TODO(PropertyAccessExpression): Ternary.False */
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Singleton */ TODO {
					/* TODO(PropertyAccessExpression): Ternary.True */
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				return recursiveTypeRelatedTo(source, target /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): IntersectionState.None */, TODO, recursionFlags)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.TypeParameter */ TODO && getConstraintOfType(source) == target {
				return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.DefinitelyNonNullable */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
				types := /* TODO(PropertyAccessExpression): (target as UnionType).types */ TODO
				candidate := /* TODO(ConditionalExpression): types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] :                     types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] :                     undefined */ TODO
				if candidate && ! /* TODO(ParenthesizedExpression): (candidate.flags & TypeFlags.Nullable) */ TODO {
					/* TODO(ExpressionStatement): target = getNormalizedType(candidate, /*writing* / true); */
					if source == target {
						/* TODO(PropertyAccessExpression): Ternary.True */
					}
				}
			}
			if relation == comparableRelation && ! /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.Never) */ TODO && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation /* TODO(ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
				/* TODO(PropertyAccessExpression): Ternary.True */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.StructuredOrInstantiable */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.StructuredOrInstantiable */ TODO {
				isPerformingExcessPropertyChecks := ! /* TODO(ParenthesizedExpression): (intersectionState & IntersectionState.Target) */ TODO && /* TODO(ParenthesizedExpression): (isObjectLiteralType(source) && getObjectFlags(source) & ObjectFlags.FreshLiteral) */ TODO
				if isPerformingExcessPropertyChecks {
					if hasExcessProperties(source /* as */ /* TODO(TypeReference): FreshObjectLiteralType */, target, reportErrors) {
						if reportErrors {
							reportRelationError(headMessage, source /* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */, TODO)
						}
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
				}
				isPerformingCommonPropertyChecks := /* TODO(ParenthesizedExpression): (relation !== comparableRelation || isUnitType(source)) */ TODO && ! /* TODO(ParenthesizedExpression): (intersectionState & IntersectionState.Target) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & (TypeFlags.Primitive | TypeFlags.Object | TypeFlags.Intersection) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source !== globalObjectType */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO && isWeakType(target) && /* TODO(ParenthesizedExpression): (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source)) */ TODO
				isComparingJsxAttributes := !! /* TODO(ParenthesizedExpression): (getObjectFlags(source) & ObjectFlags.JsxAttributes) */ TODO
				if isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes) {
					if reportErrors {
						sourceString := typeToString( /* TODO(ConditionalExpression): originalSource.aliasSymbol ? originalSource : source */ TODO)
						targetString := typeToString( /* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */ TODO)
						calls := getSignaturesOfType(source /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
						constructs := getSignaturesOfType(source /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
						if /* TODO(PropertyAccessExpression): calls.length */ TODO > 0 && isRelatedTo(getReturnTypeOfSignature( /* TODO(ElementAccessExpression): calls[0] */ TODO), target /* TODO(PropertyAccessExpression): RecursionFlags.Source */, TODO /* TODO(FalseKeyword): false */, TODO) || /* TODO(PropertyAccessExpression): constructs.length */ TODO > 0 && isRelatedTo(getReturnTypeOfSignature( /* TODO(ElementAccessExpression): constructs[0] */ TODO), target /* TODO(PropertyAccessExpression): RecursionFlags.Source */, TODO /* TODO(FalseKeyword): false */, TODO) {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it */ TODO, sourceString, targetString)
						} else {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_has_no_properties_in_common_with_type_1 */ TODO, sourceString, targetString)
						}
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				skipCaching := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO && /* TODO(PropertyAccessExpression): (source as UnionType).types.length */ TODO < 4 && ! /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.Union) */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO && /* TODO(PropertyAccessExpression): (target as UnionType).types.length */ TODO < 4 && ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.StructuredOrInstantiable) */ TODO
				result := /* TODO(ConditionalExpression): skipCaching ?                     unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :                     recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) */ TODO
				if result {
					return result
				}
			}
			if reportErrors {
				reportErrorResults(originalSource, originalTarget, source, target, headMessage)
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
			sourceHasBase := !!getSingleBaseForNonAugmentingSubtype(originalSource)
			targetHasBase := !!getSingleBaseForNonAugmentingSubtype(originalTarget)
			/* TODO(ExpressionStatement): source = (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source; */
			/* TODO(ExpressionStatement): target = (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target; */
			maybeSuppress := overrideNextErrorInfo > 0
			if maybeSuppress {
				/* TODO(ExpressionStatement): overrideNextErrorInfo--; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Object */ TODO {
				currentError := errorInfo
				tryElaborateArrayLikeErrors(source, target /* TODO(TrueKeyword): true */, TODO)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorInfo !== currentError */ TODO {
					/* TODO(ExpressionStatement): maybeSuppress = !!errorInfo; */
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Primitive */ TODO {
				tryElaborateErrorsForPrimitivesAndObjects(source, target)
			} else if /* TODO(PropertyAccessExpression): source.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Object */ TODO && globalObjectType == source {
				reportError( /* TODO(PropertyAccessExpression): Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead */ TODO)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.JsxAttributes */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO {
				targetTypes := /* TODO(PropertyAccessExpression): (target as IntersectionType).types */ TODO
				intrinsicAttributes := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicAttributes */ TODO, errorNode)
				intrinsicClassAttributes := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicClassAttributes */ TODO, errorNode)
				if !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) && /* TODO(ParenthesizedExpression): (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) */ TODO {
					return
				}
			} else {
				/* TODO(ExpressionStatement): errorInfo = elaborateNeverIntersection(errorInfo, originalTarget); */
			}
			if !headMessage && maybeSuppress {
				savedErrorState := captureErrorCalculationState()
				reportRelationError(headMessage, source, target)
				var canonical TODO
				if errorInfo && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorInfo !== savedErrorState.errorInfo */ TODO {
					/* TODO(ExpressionStatement): canonical = { code: errorInfo.code, messageText: errorInfo.messageText }; */
				}
				resetErrorInfo(savedErrorState)
				if canonical && errorInfo {
					/* TODO(ExpressionStatement): errorInfo.canonicalHead = canonical; */
				}
				/* TODO(ExpressionStatement): lastSkippedInfo = [source, target]; */
				return
			}
			reportRelationError(headMessage, source, target)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.TypeParameter */ TODO && /* TODO(ElementAccessExpression): source.symbol?.declarations?.[0] */ TODO && !getConstraintOfType(source /* as */ /* TODO(TypeReference): TypeVariable */) {
				syntheticParam := cloneTypeParameter(source /* as */ /* TODO(TypeReference): TypeParameter */)
				/* TODO(ExpressionStatement): syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam)); */
				if hasNonCircularBaseConstraint(syntheticParam) {
					targetConstraintString := typeToString(target /* TODO(ElementAccessExpression): source.symbol.declarations[0] */, TODO)
					associateRelatedInfo(createDiagnosticForNode( /* TODO(ElementAccessExpression): source.symbol.declarations[0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.This_type_parameter_might_need_an_extends_0_constraint */, TODO, targetConstraintString))
				}
			}
		}
		traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
			if !tracing {
				return
			}
			if /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.UnionOrIntersection) */ TODO && /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.UnionOrIntersection) */ TODO {
				sourceUnionOrIntersection := source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
				targetUnionOrIntersection := target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlags.PrimitiveUnion */ TODO {
					return
				}
				sourceSize := /* TODO(PropertyAccessExpression): sourceUnionOrIntersection.types.length */ TODO
				targetSize := /* TODO(PropertyAccessExpression): targetUnionOrIntersection.types.length */ TODO
				if /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): sourceSize * targetSize */ TODO > 1e6 {
					/* TODO(PropertyAccessExpression): tracing.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "traceUnionsOrIntersectionsTooLarge_DepthLimit" /* TODO(ObjectLiteralExpression): {                         sourceId: source.id,                         sourceSize,                         targetId: target.id,                         targetSize,                         pos: errorNode?.pos,                         end: errorNode?.end,                     } */, TODO)
				}
			}
		}
		getTypeOfPropertyInTypes := func(types []Type, name __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			appendPropType := /* TODO(ArrowFunction): (propTypes: Type[] | undefined, type: Type) => {                 type = getApparentType(type);                 const prop = type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name);                 const propType = prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type, name)?.type || undefinedType;                 return append(propTypes, propType);             } */ TODO
			return getUnionType(reduceLeft(types, appendPropType, nil) || emptyArray)
		}
		hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
			if !isExcessPropertyCheckTarget(target) || !noImplicitAny && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.JSLiteral */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
			isComparingJsxAttributes := !! /* TODO(ParenthesizedExpression): (getObjectFlags(source) & ObjectFlags.JsxAttributes) */ TODO
			if /* TODO(ParenthesizedExpression): (relation === assignableRelation || relation === comparableRelation) */ TODO && /* TODO(ParenthesizedExpression): (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target))) */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
			reducedTarget := target
			var checkTypes /* TODO(ArrayType): Type[] */ any
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
				/* TODO(ExpressionStatement): reducedTarget = findMatchingDiscriminantType(source, target as UnionType, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target as UnionType); */
				/* TODO(ExpressionStatement): checkTypes = reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget]; */
			}
			for _, prop := range getPropertiesOfType(source) {
				if shouldCheckAsExcessProperty(prop /* TODO(PropertyAccessExpression): source.symbol */, TODO) && !isIgnoredJsxProperty(source, prop) {
					if !isKnownProperty(reducedTarget /* TODO(PropertyAccessExpression): prop.escapedName */, TODO, isComparingJsxAttributes) {
						if reportErrors {
							errorTarget := filterType(reducedTarget, isExcessPropertyCheckTarget)
							if !errorNode {
								/* TODO(CallExpression): Debug.fail() */
							}
							if isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement( /* TODO(PropertyAccessExpression): errorNode.parent */ TODO) {
								if /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && isJsxAttribute( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) && getSourceFileOfNode(errorNode) == getSourceFileOfNode( /* TODO(PropertyAccessExpression): prop.valueDeclaration.name */ TODO) {
									/* TODO(ExpressionStatement): errorNode = prop.valueDeclaration.name; */
								}
								propName := symbolToString(prop)
								suggestionSymbol := getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget)
								suggestion := /* TODO(ConditionalExpression): suggestionSymbol ? symbolToString(suggestionSymbol) : undefined */ TODO
								if suggestion {
									reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */ TODO, propName, typeToString(errorTarget), suggestion)
								} else {
									reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO, propName, typeToString(errorTarget))
								}
							} else {
								objectLiteralDeclaration := /* TODO(PropertyAccessExpression): source.symbol?.declarations */ TODO && firstOrUndefined( /* TODO(PropertyAccessExpression): source.symbol.declarations */ TODO)
								var suggestion /* TODO(StringKeyword): string */ any
								if /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && findAncestor( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO /* TODO(ArrowFunction): d => d === objectLiteralDeclaration */, TODO) && getSourceFileOfNode(objectLiteralDeclaration) == getSourceFileOfNode(errorNode) {
									propDeclaration := /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): ObjectLiteralElementLike */
									/* TODO(PropertyAccessExpression): Debug.assertNode */ TODO(propDeclaration, isObjectLiteralElementLike)
									name := /* TODO(NonNullExpression): propDeclaration.name! */ TODO
									/* TODO(ExpressionStatement): errorNode = name; */
									if isIdentifier(name) {
										/* TODO(ExpressionStatement): suggestion = getSuggestionForNonexistentProperty(name, errorTarget); */
									}
								}
								if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
									reportParentSkippedError( /* TODO(PropertyAccessExpression): Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2 */ TODO, symbolToString(prop), typeToString(errorTarget), suggestion)
								} else {
									reportParentSkippedError( /* TODO(PropertyAccessExpression): Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1 */ TODO, symbolToString(prop), typeToString(errorTarget))
								}
							}
						}
						return /* TODO(TrueKeyword): true */ TODO
					}
					if checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes /* TODO(PropertyAccessExpression): prop.escapedName */, TODO) /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors) {
						if reportErrors {
							reportIncompatibleError( /* TODO(PropertyAccessExpression): Diagnostics.Types_of_property_0_are_incompatible */ TODO, symbolToString(prop))
						}
						return /* TODO(TrueKeyword): true */ TODO
					}
				}
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) /* TODO(undefined): boolean | undefined */ TODO {
			return /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && /* TODO(PropertyAccessExpression): container.valueDeclaration */ TODO && /* TODO(PropertyAccessExpression): prop.valueDeclaration.parent */ TODO == /* TODO(PropertyAccessExpression): container.valueDeclaration */ TODO
		}
		unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
					sourceOrigin := /* TODO(PropertyAccessExpression): (source as UnionType).origin */ TODO
					if sourceOrigin && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceOrigin.flags & TypeFlags.Intersection */ TODO && /* TODO(PropertyAccessExpression): target.aliasSymbol */ TODO && contains( /* TODO(PropertyAccessExpression): (sourceOrigin as IntersectionType).types */ TODO, target) {
						return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
					}
					targetOrigin := /* TODO(PropertyAccessExpression): (target as UnionType).origin */ TODO
					if targetOrigin && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetOrigin.flags & TypeFlags.Union */ TODO && /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO && contains( /* TODO(PropertyAccessExpression): (targetOrigin as UnionType).types */ TODO, source) {
						return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
					}
				}
				return /* TODO(ConditionalExpression): relation === comparableRelation ?                     someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) :                     eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
				return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target /* as */ /* TODO(TypeReference): UnionType */, reportErrors && ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Primitive) */ TODO && ! /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.Primitive) */ TODO, intersectionState)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO {
				return typeRelatedToEachType(source, target /* as */ /* TODO(TypeReference): IntersectionType */, reportErrors /* TODO(PropertyAccessExpression): IntersectionState.Target */, TODO)
			}
			if relation == comparableRelation && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Primitive */ TODO {
				constraints := sameMap( /* TODO(PropertyAccessExpression): (source as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(t) || unknownType : t */, TODO)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraints !== (source as IntersectionType).types */ TODO {
					/* TODO(ExpressionStatement): source = getIntersectionType(constraints); */
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Never */ TODO {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					if ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Intersection) */ TODO {
						return isRelatedTo(source, target /* TODO(PropertyAccessExpression): RecursionFlags.Source */, TODO /* TODO(FalseKeyword): false */, TODO) || isRelatedTo(target, source /* TODO(PropertyAccessExpression): RecursionFlags.Source */, TODO /* TODO(FalseKeyword): false */, TODO)
					}
				}
			}
			return someTypeRelatedToType(source /* as */ /* TODO(TypeReference): IntersectionType */, target /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): IntersectionState.Source */, TODO)
		}
		eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			sourceTypes := /* TODO(PropertyAccessExpression): source.types */ TODO
			for _, sourceType := range sourceTypes {
				related := typeRelatedToSomeType(sourceType, target /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): IntersectionState.None */, TODO)
				if !related {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				/* TODO(ExpressionStatement): result &= related; */
			}
			return result
		}
		typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetTypes := /* TODO(PropertyAccessExpression): target.types */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
				if containsType(targetTypes, source) {
					return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
				}
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== comparableRelation */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.PrimitiveUnion */ TODO && ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.EnumLiteral) */ TODO && /* TODO(ParenthesizedExpression): (                         source.flags & (TypeFlags.StringLiteral | TypeFlags.BooleanLiteral | TypeFlags.BigIntLiteral) ||                         (relation === subtypeRelation || relation === strictSubtypeRelation) && source.flags & TypeFlags.NumberLiteral                     ) */ TODO {
					alternateForm := /* TODO(ConditionalExpression): source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType */ TODO
					primitive := /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? stringType :                         source.flags & TypeFlags.NumberLiteral ? numberType :                         source.flags & TypeFlags.BigIntLiteral ? bigintType :                         undefined */ TODO
					return /* TODO(ConditionalExpression): primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm) ? Ternary.True : Ternary.False */ TODO
				}
				match := getMatchingUnionConstituentForType(target /* as */ /* TODO(TypeReference): UnionType */, source)
				if match {
					related := isRelatedTo(source, match /* TODO(PropertyAccessExpression): RecursionFlags.Target */, TODO /* TODO(FalseKeyword): false */, TODO, nil, intersectionState)
					if related {
						return related
					}
				}
			}
			for _, type_ := range targetTypes {
				related := isRelatedTo(source, type_ /* TODO(PropertyAccessExpression): RecursionFlags.Target */, TODO /* TODO(FalseKeyword): false */, TODO, nil, intersectionState)
				if related {
					return related
				}
			}
			if reportErrors {
				bestMatchingType := getBestMatchingType(source, target, isRelatedTo)
				if bestMatchingType {
					isRelatedTo(source, bestMatchingType /* TODO(PropertyAccessExpression): RecursionFlags.Target */, TODO /* TODO(TrueKeyword): true */, TODO, nil, intersectionState)
				}
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			targetTypes := /* TODO(PropertyAccessExpression): target.types */ TODO
			for _, targetType := range targetTypes {
				related := isRelatedTo(source, targetType /* TODO(PropertyAccessExpression): RecursionFlags.Target */, TODO, reportErrors, nil, intersectionState)
				if !related {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				/* TODO(ExpressionStatement): result &= related; */
			}
			return result
		}
		someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceTypes := /* TODO(PropertyAccessExpression): source.types */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO && containsType(sourceTypes, target) {
				return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			}
			len := /* TODO(PropertyAccessExpression): sourceTypes.length */ TODO
			/* TODO(ForStatement): for (let i = 0; i < len; i++) {                 const related = isRelatedTo(sourceTypes[i], target, RecursionFlags.Source, reportErrors && i === len - 1, /*headMessage* / undefined, intersectionState);                 if (related) {                     return related;                 }             } */
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO && ! /* TODO(ParenthesizedExpression): ((source as UnionType).types[0].flags & TypeFlags.Undefined) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (target as UnionType).types[0].flags & TypeFlags.Undefined */ TODO {
				return extractTypesOfKind(target, ~ /* TODO(PropertyAccessExpression): TypeFlags.Undefined */ TODO)
			}
			return target
		}
		eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			sourceTypes := /* TODO(PropertyAccessExpression): source.types */ TODO
			undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target /* as */ /* TODO(TypeReference): UnionType */)
			/* TODO(ForStatement): for (let i = 0; i < sourceTypes.length; i++) {                 const sourceType = sourceTypes[i];                 if (undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= (undefinedStrippedTarget as UnionType).types.length && sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length === 0) {                     // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison                     // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large                     // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,                     // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`                     // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union                     const related = isRelatedTo(sourceType, (undefinedStrippedTarget as UnionType).types[i % (undefinedStrippedTarget as UnionType).types.length], RecursionFlags.Both, /*reportErrors* / false, /*headMessage* / undefined, intersectionState);                     if (related) {                         result &= related;                         continue;                     }                 }                 const related = isRelatedTo(sourceType, target, RecursionFlags.Source, reportErrors, /*headMessage* / undefined, intersectionState);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
			return result
		}
		typeArgumentsRelatedTo := func(sources []Type /* = */ /* TODO(Identifier): emptyArray */, targets []Type /* = */ /* TODO(Identifier): emptyArray */, variances []VarianceFlags /* = */ /* TODO(Identifier): emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sources.length !== targets.length */ TODO && relation == identityRelation {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			length := /* TODO(ConditionalExpression): sources.length <= targets.length ? sources.length : targets.length */ TODO
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			/* TODO(ForStatement): for (let i = 0; i < length; i++) {                 // When variance information isn't available we default to covariance. This happens                 // in the process of computing variance information for recursive types and when                 // comparing 'this' type arguments.                 const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;                 const variance = varianceFlags & VarianceFlags.VarianceMask;                 // We ignore arguments for independent type parameters (because they're never witnessed).                 if (variance !== VarianceFlags.Independent) {                     const s = sources[i];                     const t = targets[i];                     let related = Ternary.True;                     if (varianceFlags & VarianceFlags.Unmeasurable) {                         // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.                         // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by                         // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)                         related = relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors* / false) : compareTypesIdentical(s, t);                     }                     else if (variance === VarianceFlags.Covariant) {                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Contravariant) {                         related = isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Bivariant) {                         // In the bivariant case we first compare contravariantly without reporting                         // errors. Then, if that doesn't succeed, we compare covariantly with error                         // reporting. Thus, error elaboration will be based on the the covariant check,                         // which is generally easier to reason about.                         related = isRelatedTo(t, s, RecursionFlags.Both, /*reportErrors* / false);                         if (!related) {                             related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     else {                         // In the invariant case we first compare covariantly, and only when that                         // succeeds do we proceed to compare contravariantly. Thus, error elaboration                         // will typically be based on the covariant check.                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (related) {                             related &= isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 }             } */
			return result
		}
		recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
			if overflow {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			id := getRelationKey(source, target, intersectionState, relation /* TODO(FalseKeyword): false */, TODO)
			entry := /* TODO(PropertyAccessExpression): relation.get */ TODO(id)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): entry !== undefined */ TODO {
				if reportErrors && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): entry & RelationComparisonResult.Failed */ TODO && ! /* TODO(ParenthesizedExpression): (entry & RelationComparisonResult.Overflow) */ TODO {
				} else {
					if outofbandVarianceMarkerHandler {
						saved := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): entry & RelationComparisonResult.ReportsMask */ TODO
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): saved & RelationComparisonResult.ReportsUnmeasurable */ TODO {
							instantiateType(source, reportUnmeasurableMapper)
						}
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): saved & RelationComparisonResult.ReportsUnreliable */ TODO {
							instantiateType(source, reportUnreliableMapper)
						}
					}
					if reportErrors && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): entry & RelationComparisonResult.Overflow */ TODO {
						message := /* TODO(ConditionalExpression): entry & RelationComparisonResult.ComplexityOverflow ?                             Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                             Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
						reportError(message, typeToString(source), typeToString(target))
						/* TODO(ExpressionStatement): overrideNextErrorInfo++; */
					}
					return /* TODO(ConditionalExpression): entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False */ TODO
				}
			}
			if relationCount <= 0 {
				/* TODO(ExpressionStatement): overflow = true; */
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			if !maybeKeys {
				/* TODO(ExpressionStatement): maybeKeys = []; */
				/* TODO(ExpressionStatement): maybeKeysSet = new Set(); */
				/* TODO(ExpressionStatement): sourceStack = []; */
				/* TODO(ExpressionStatement): targetStack = []; */
			} else {
				if /* TODO(PropertyAccessExpression): maybeKeysSet.has */ TODO(id) {
					return /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
				}
				broadestEquivalentId := /* TODO(ConditionalExpression): id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints* / true) : undefined */ TODO
				if broadestEquivalentId && /* TODO(PropertyAccessExpression): maybeKeysSet.has */ TODO(broadestEquivalentId) {
					return /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
				}
				if sourceDepth == 100 || targetDepth == 100 {
					/* TODO(ExpressionStatement): overflow = true; */
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			maybeStart := maybeCount
			/* TODO(ExpressionStatement): maybeKeys[maybeCount] = id; */
			/* TODO(PropertyAccessExpression): maybeKeysSet.add */
			TODO(id)
			/* TODO(ExpressionStatement): maybeCount++; */
			saveExpandingFlags := expandingFlags
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Source */ TODO {
				/* TODO(ExpressionStatement): sourceStack[sourceDepth] = source; */
				/* TODO(ExpressionStatement): sourceDepth++; */
				if ! /* TODO(ParenthesizedExpression): (expandingFlags & ExpandingFlags.Source) */ TODO && isDeeplyNestedType(source, sourceStack, sourceDepth) {
					/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Source */
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Target */ TODO {
				/* TODO(ExpressionStatement): targetStack[targetDepth] = target; */
				/* TODO(ExpressionStatement): targetDepth++; */
				if ! /* TODO(ParenthesizedExpression): (expandingFlags & ExpandingFlags.Target) */ TODO && isDeeplyNestedType(target, targetStack, targetDepth) {
					/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Target */
				}
			}
			var originalHandler /* TODO(TypeQuery): typeof outofbandVarianceMarkerHandler */ TODO
			propagatingVarianceFlags := 0 /* as */ /* TODO(TypeReference): RelationComparisonResult */
			if outofbandVarianceMarkerHandler {
				/* TODO(ExpressionStatement): originalHandler = outofbandVarianceMarkerHandler; */
				/* TODO(ExpressionStatement): outofbandVarianceMarkerHandler = onlyUnreliable => {                     propagatingVarianceFlags |= onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable;                     return originalHandler!(onlyUnreliable);                 }; */
			}
			var result Ternary
			if expandingFlags == /* TODO(PropertyAccessExpression): ExpandingFlags.Both */ TODO {
				/* TODO(PropertyAccessExpression): tracing?.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "recursiveTypeRelatedTo_DepthLimit" /* TODO(ObjectLiteralExpression): {                     sourceId: source.id,                     sourceIdStack: sourceStack.map(t => t.id),                     targetId: target.id,                     targetIdStack: targetStack.map(t => t.id),                     depth: sourceDepth,                     targetDepth,                 } */, TODO)
				/* TODO(ExpressionStatement): result = Ternary.Maybe; */
			} else {
				/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "structuredTypeRelatedTo" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id } */, TODO)
				/* TODO(ExpressionStatement): result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState); */
				/* TODO(PropertyAccessExpression): tracing?.pop */
				TODO()
			}
			if outofbandVarianceMarkerHandler {
				/* TODO(ExpressionStatement): outofbandVarianceMarkerHandler = originalHandler; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Source */ TODO {
				/* TODO(ExpressionStatement): sourceDepth--; */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): recursionFlags & RecursionFlags.Target */ TODO {
				/* TODO(ExpressionStatement): targetDepth--; */
			}
			/* TODO(ExpressionStatement): expandingFlags = saveExpandingFlags; */
			if result {
				if result == /* TODO(PropertyAccessExpression): Ternary.True */ TODO || /* TODO(ParenthesizedExpression): (sourceDepth === 0 && targetDepth === 0) */ TODO {
					if result == /* TODO(PropertyAccessExpression): Ternary.True */ TODO || result == /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO {
						resetMaybeStack( /* TODO(TrueKeyword): true */ TODO)
					} else {
						resetMaybeStack( /* TODO(FalseKeyword): false */ TODO)
					}
				}
			} else {
				/* TODO(PropertyAccessExpression): relation.set */ TODO(id /* TODO(BarToken): | */ /* TODO(BinaryExpression): RelationComparisonResult.Failed | propagatingVarianceFlags */, TODO)
				/* TODO(ExpressionStatement): relationCount--; */
				resetMaybeStack( /* TODO(FalseKeyword): false */ TODO)
			}
			return result
			resetMaybeStack := func(markAllAsSucceeded bool) {
				/* TODO(ForStatement): for (let i = maybeStart; i < maybeCount; i++) {                     maybeKeysSet.delete(maybeKeys[i]);                     if (markAllAsSucceeded) {                         relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);                         relationCount--;                     }                 } */
				/* TODO(ExpressionStatement): maybeCount = maybeStart; */
			}
		}
		structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			saveErrorInfo := captureErrorCalculationState()
			result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
				if !result && /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Intersection || source.flags & TypeFlags.TypeParameter && target.flags & TypeFlags.Union) */ TODO {
					constraint := getEffectiveConstraintOfIntersection( /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, !! /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.Union) */ TODO)
					if constraint && everyType(constraint /* TODO(ArrowFunction): c => c !== source */, TODO) {
						/* TODO(ExpressionStatement): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState); */
					}
				}
				if result && ! /* TODO(ParenthesizedExpression): (intersectionState & IntersectionState.Target) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO && !isGenericObjectType(target) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO {
					/* TODO(ExpressionStatement): result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties* / undefined, /*optionalsOnly* / false, IntersectionState.None); */
					if result && isObjectLiteralType(source) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.FreshLiteral */ TODO {
						/* TODO(ExpressionStatement): result &= indexSignaturesRelatedTo(source, target, /*sourceIsPrimitive* / false, reportErrors, IntersectionState.None); */
					}
				} else if result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Intersection */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getApparentType(source).flags & TypeFlags.StructuredType */ TODO && !some( /* TODO(PropertyAccessExpression): (source as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => t === target || !!(getObjectFlags(t) & ObjectFlags.NonInferrableType) */, TODO) {
					/* TODO(ExpressionStatement): result &= propertiesRelatedTo(source, target, reportErrors, /*excludedProperties* / undefined, /*optionalsOnly* / true, intersectionState); */
				}
			}
			if result {
				resetErrorInfo(saveErrorInfo)
			}
			return result
		}
		getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(targetType))
			var mappedKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO /* TODO(FalseKeyword): false */, TODO /* TODO(ArrowFunction): t => void mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t))) */, TODO)
			return getUnionType(mappedKeys)
		}
		structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[ /* TODO(TypeQuery): typeof captureErrorCalculationState */ TODO]) Ternary {
			var result Ternary
			var originalErrorInfo *DiagnosticMessageChain
			varianceCheckFailed := /* TODO(FalseKeyword): false */ TODO
			sourceFlags := /* TODO(PropertyAccessExpression): source.flags */ TODO
			targetFlags := /* TODO(PropertyAccessExpression): target.flags */ TODO
			if relation == identityRelation {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.UnionOrIntersection */ TODO {
					result := eachTypeRelatedToSomeType(source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */)
					if result {
						/* TODO(ExpressionStatement): result &= eachTypeRelatedToSomeType(target as UnionOrIntersectionType, source as UnionOrIntersectionType); */
					}
					return result
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.Index */ TODO {
					return isRelatedTo( /* TODO(PropertyAccessExpression): (source as IndexType).type */ TODO /* TODO(PropertyAccessExpression): (target as IndexType).type */, TODO /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO /* TODO(FalseKeyword): false */, TODO)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.IndexedAccess */ TODO {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.Conditional */ TODO {
					if /* TODO(PropertyAccessExpression): (source as ConditionalType).root.isDistributive */ TODO == /* TODO(PropertyAccessExpression): (target as ConditionalType).root.isDistributive */ TODO {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
								if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
									if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
										return result
									}
								}
							}
						}
					}
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.Substitution */ TODO {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if ! /* TODO(ParenthesizedExpression): (sourceFlags & TypeFlags.Object) */ TODO {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.UnionOrIntersection */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.UnionOrIntersection */ TODO {
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
					return result
				}
				if ! /* TODO(ParenthesizedExpression): (sourceFlags & TypeFlags.Instantiable ||                         sourceFlags & TypeFlags.Object && targetFlags & TypeFlags.Union ||                         sourceFlags & TypeFlags.Intersection && targetFlags & (TypeFlags.Object | TypeFlags.Union | TypeFlags.Instantiable)) */ TODO {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & (TypeFlags.Object | TypeFlags.Conditional) */ TODO && /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO && /* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO && /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO == /* TODO(PropertyAccessExpression): target.aliasSymbol */ TODO && ! /* TODO(ParenthesizedExpression): (isMarkerType(source) || isMarkerType(target)) */ TODO {
				variances := getAliasVariances( /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO)
				if variances == emptyArray {
					return /* TODO(PropertyAccessExpression): Ternary.Unknown */ TODO
				}
				params := /* TODO(NonNullExpression): getSymbolLinks(source.aliasSymbol).typeParameters! */ TODO
				minParams := getMinTypeArgumentCount(params)
				sourceTypes := fillMissingTypeArguments( /* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO, params, minParams, isInJSFile( /* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
				targetTypes := fillMissingTypeArguments( /* TODO(PropertyAccessExpression): target.aliasTypeArguments */ TODO, params, minParams, isInJSFile( /* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
				varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): varianceResult !== undefined */ TODO {
					return varianceResult
				}
			}
			if isSingleElementGenericTupleType(source) && ! /* TODO(PropertyAccessExpression): source.target.readonly */ TODO && /* TODO(ParenthesizedExpression): (result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source)) */ TODO || isSingleElementGenericTupleType(target) && /* TODO(ParenthesizedExpression): (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) */ TODO && /* TODO(ParenthesizedExpression): (result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target)) */ TODO {
				return result
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.TypeParameter */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Mapped */ TODO && ! /* TODO(PropertyAccessExpression): (source as MappedType).declaration.nameType */ TODO && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */) /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO) {
					if ! /* TODO(ParenthesizedExpression): (getMappedTypeModifiers(source as MappedType) & MappedTypeModifiers.IncludeOptional) */ TODO {
						templateType := getTemplateTypeFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */)
						indexedAccessType := getIndexedAccessType(target, getTypeParameterFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */))
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
							return result
						}
					}
				}
				if relation == comparableRelation && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.TypeParameter */ TODO {
					constraint := getConstraintOfTypeParameter(source)
					if constraint {
						/* TODO(WhileStatement): while (constraint && someType(constraint, c => !!(c.flags & TypeFlags.TypeParameter))) {                             if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false)) {                                 return result;                             }                             constraint = getConstraintOfTypeParameter(constraint);                         } */
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.Index */ TODO {
				targetType := /* TODO(PropertyAccessExpression): (target as IndexType).type */ TODO
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.Index */ TODO {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
				if isTupleType(targetType) {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getSimplifiedTypeOrConstraint(targetType)
					if constraint {
						if isRelatedTo(source, getIndexType(constraint /* TODO(BarToken): | */ /* TODO(BinaryExpression): (target as IndexType).indexFlags | IndexFlags.NoReducibleCheck */, TODO) /* TODO(PropertyAccessExpression): RecursionFlags.Target */, TODO, reportErrors) == /* TODO(PropertyAccessExpression): Ternary.True */ TODO {
							return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
						}
					} else if isGenericMappedType(targetType) {
						nameType := getNameTypeFromMappedType(targetType)
						constraintType := getConstraintTypeFromMappedType(targetType)
						var targetKeys TODO
						if nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType) {
							mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
							/* TODO(ExpressionStatement): targetKeys = getUnionType([mappedKeys, nameType]); */
						} else {
							/* TODO(ExpressionStatement): targetKeys = nameType || constraintType; */
						}
						if isRelatedTo(source, targetKeys /* TODO(PropertyAccessExpression): RecursionFlags.Target */, TODO, reportErrors) == /* TODO(PropertyAccessExpression): Ternary.True */ TODO {
							return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
						}
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.IndexedAccess */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.IndexedAccess */ TODO {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
						/* TODO(ExpressionStatement): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, reportErrors); */
					}
					if result {
						return result
					}
					if reportErrors {
						/* TODO(ExpressionStatement): originalErrorInfo = errorInfo; */
					}
				}
				if relation == assignableRelation || relation == comparableRelation {
					objectType := /* TODO(PropertyAccessExpression): (target as IndexedAccessType).objectType */ TODO
					indexType := /* TODO(PropertyAccessExpression): (target as IndexedAccessType).indexType */ TODO
					baseObjectType := getBaseConstraintOfType(objectType) || objectType
					baseIndexType := getBaseConstraintOfType(indexType) || indexType
					if !isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType) {
						accessFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): AccessFlags.Writing | (baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0) */ TODO
						constraint := getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
						if constraint {
							if reportErrors && originalErrorInfo {
								resetErrorInfo(saveErrorInfo)
							}
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
								return result
							}
							if reportErrors && originalErrorInfo && errorInfo {
								/* TODO(ExpressionStatement): errorInfo = countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo; */
							}
						}
					}
				}
				if reportErrors {
					/* TODO(ExpressionStatement): originalErrorInfo = undefined; */
				}
			} else if isGenericMappedType(target) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
				keysRemapped := !! /* TODO(PropertyAccessExpression): target.declaration.nameType */ TODO
				templateType := getTemplateTypeFromMappedType(target)
				modifiers := getMappedTypeModifiers(target)
				if ! /* TODO(ParenthesizedExpression): (modifiers & MappedTypeModifiers.ExcludeOptional) */ TODO {
					if !keysRemapped && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): templateType.flags & TypeFlags.IndexedAccess */ TODO && /* TODO(PropertyAccessExpression): (templateType as IndexedAccessType).objectType */ TODO == source && /* TODO(PropertyAccessExpression): (templateType as IndexedAccessType).indexType */ TODO == getTypeParameterFromMappedType(target) {
						return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
					}
					if !isGenericMappedType(source) {
						targetKeys := /* TODO(ConditionalExpression): keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target) */ TODO
						sourceKeys := getIndexType(source /* TODO(PropertyAccessExpression): IndexFlags.NoIndexSignatures */, TODO)
						includeOptional := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): modifiers & MappedTypeModifiers.IncludeOptional */ TODO
						filteredByApplicability := /* TODO(ConditionalExpression): includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined */ TODO
						if /* TODO(ConditionalExpression): includeOptional                                 ? !(filteredByApplicability!.flags & TypeFlags.Never)                                 : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both) */ TODO {
							templateType := getTemplateTypeFromMappedType(target)
							typeParameter := getTypeParameterFromMappedType(target)
							nonNullComponent := extractTypesOfKind(templateType, ~ /* TODO(PropertyAccessExpression): TypeFlags.Nullable */ TODO)
							if !keysRemapped && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nonNullComponent.flags & TypeFlags.IndexedAccess */ TODO && /* TODO(PropertyAccessExpression): (nonNullComponent as IndexedAccessType).indexType */ TODO == typeParameter {
								if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
									return result
								}
							} else {
								indexingType := /* TODO(ConditionalExpression): keysRemapped                                     ? (filteredByApplicability || targetKeys)                                     : filteredByApplicability                                     ? getIntersectionType([filteredByApplicability, typeParameter])                                     : typeParameter */ TODO
								indexedAccessType := getIndexedAccessType(source, indexingType)
								if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
									return result
								}
							}
						}
						/* TODO(ExpressionStatement): originalErrorInfo = errorInfo; */
						resetErrorInfo(saveErrorInfo)
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.Conditional */ TODO {
				if isDeeplyNestedType(target, targetStack, targetDepth, 10) {
					return /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
				}
				c := target /* as */ /* TODO(TypeReference): ConditionalType */
				if ! /* TODO(PropertyAccessExpression): c.root.inferTypeParameters */ TODO && !isDistributionDependent( /* TODO(PropertyAccessExpression): c.root */ TODO) && ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Conditional && (source as ConditionalType).root === c.root) */ TODO {
					skipTrue := !isTypeAssignableTo(getPermissiveInstantiation( /* TODO(PropertyAccessExpression): c.checkType */ TODO), getPermissiveInstantiation( /* TODO(PropertyAccessExpression): c.extendsType */ TODO))
					skipFalse := !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation( /* TODO(PropertyAccessExpression): c.checkType */ TODO), getRestrictiveInstantiation( /* TODO(PropertyAccessExpression): c.extendsType */ TODO))
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						/* TODO(ExpressionStatement): result &= skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState); */
						if result {
							return result
						}
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.TemplateLiteral */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.TemplateLiteral */ TODO {
					if relation == comparableRelation {
						return /* TODO(ConditionalExpression): templateLiteralTypesDefinitelyUnrelated(source as TemplateLiteralType, target as TemplateLiteralType) ? Ternary.False : Ternary.True */ TODO
					}
					instantiateType(source, reportUnreliableMapper)
				}
				if isTypeMatchedByTemplateLiteralType(source, target /* as */ /* TODO(TypeReference): TemplateLiteralType */) {
					return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.StringMapping */ TODO {
				if ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.StringMapping) */ TODO {
					if isMemberOfStringMapping(source, target) {
						return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
					}
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.TypeVariable */ TODO {
				if ! /* TODO(ParenthesizedExpression): (sourceFlags & TypeFlags.IndexedAccess && targetFlags & TypeFlags.IndexedAccess) */ TODO {
					constraint := getConstraintOfType(source /* as */ /* TODO(TypeReference): TypeVariable */) || unknownType
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					} else if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					}
					if isMappedTypeGenericIndexedAccess(source) {
						indexConstraint := getConstraintOfType( /* TODO(PropertyAccessExpression): (source as IndexedAccessType).indexType */ TODO)
						if indexConstraint {
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
								return result
							}
						}
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.Index */ TODO {
				isDeferredMappedIndex := shouldDeferIndexType( /* TODO(PropertyAccessExpression): (source as IndexType).type */ TODO /* TODO(PropertyAccessExpression): (source as IndexType).indexFlags */, TODO) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags((source as IndexType).type) & ObjectFlags.Mapped */ TODO
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
					return result
				}
				if isDeferredMappedIndex {
					mappedType := /* TODO(PropertyAccessExpression): (source as IndexType).type */ TODO /* as */ /* TODO(TypeReference): MappedType */
					nameType := getNameTypeFromMappedType(mappedType)
					sourceMappedKeys := /* TODO(ConditionalExpression): nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) : (nameType || getConstraintTypeFromMappedType(mappedType)) */ TODO
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.TemplateLiteral */ TODO && ! /* TODO(ParenthesizedExpression): (targetFlags & TypeFlags.Object) */ TODO {
				if ! /* TODO(ParenthesizedExpression): (targetFlags & TypeFlags.TemplateLiteral) */ TODO {
					constraint := getBaseConstraintOfType(source)
					if constraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== source */ TODO && /* TODO(ParenthesizedExpression): (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors)) */ TODO {
						return result
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.StringMapping */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.StringMapping */ TODO {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (source as StringMappingType).symbol !== (target as StringMappingType).symbol */ TODO {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getBaseConstraintOfType(source)
					if constraint && /* TODO(ParenthesizedExpression): (result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors)) */ TODO {
						return result
					}
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & TypeFlags.Conditional */ TODO {
				if isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
					return /* TODO(PropertyAccessExpression): Ternary.Maybe */ TODO
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.Conditional */ TODO {
					sourceParams := /* TODO(PropertyAccessExpression): (source as ConditionalType).root.inferTypeParameters */ TODO
					sourceExtends := /* TODO(PropertyAccessExpression): (source as ConditionalType).extendsType */ TODO
					var mapper *TypeMapper
					if sourceParams {
						ctx := createInferenceContext(sourceParams, nil /* TODO(PropertyAccessExpression): InferenceFlags.None */, TODO, isRelatedToWorker)
						inferTypes( /* TODO(PropertyAccessExpression): ctx.inferences */ TODO /* TODO(PropertyAccessExpression): (target as ConditionalType).extendsType */, TODO, sourceExtends /* TODO(BarToken): | */ /* TODO(BinaryExpression): InferencePriority.NoConstraints | InferencePriority.AlwaysStrict */, TODO)
						/* TODO(ExpressionStatement): sourceExtends = instantiateType(sourceExtends, ctx.mapper); */
						/* TODO(ExpressionStatement): mapper = ctx.mapper; */
					}
					if isTypeIdenticalTo(sourceExtends /* TODO(PropertyAccessExpression): (target as ConditionalType).extendsType */, TODO) && /* TODO(ParenthesizedExpression): (isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both) || isRelatedTo((target as ConditionalType).checkType, (source as ConditionalType).checkType, RecursionFlags.Both)) */ TODO {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
							/* TODO(ExpressionStatement): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors); */
						}
						if result {
							return result
						}
					}
				}
				defaultConstraint := getDefaultConstraintOfConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */)
				if defaultConstraint {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
				distributiveConstraint := /* TODO(ConditionalExpression): !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined */ TODO
				if distributiveConstraint {
					resetErrorInfo(saveErrorInfo)
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== subtypeRelation */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== strictSubtypeRelation */ TODO && isPartialMappedType(target) && isEmptyObjectType(source) {
					return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
				}
				if isGenericMappedType(target) {
					if isGenericMappedType(source) {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
							return result
						}
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				sourceIsPrimitive := !! /* TODO(ParenthesizedExpression): (sourceFlags & TypeFlags.Primitive) */ TODO
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
					/* TODO(ExpressionStatement): source = getApparentType(source); */
					/* TODO(ExpressionStatement): sourceFlags = source.flags; */
				} else if isGenericMappedType(source) {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Reference */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Reference */ TODO && /* TODO(PropertyAccessExpression): (source as TypeReference).target */ TODO == /* TODO(PropertyAccessExpression): (target as TypeReference).target */ TODO && !isTupleType(source) && ! /* TODO(ParenthesizedExpression): (isMarkerType(source) || isMarkerType(target)) */ TODO {
					if isEmptyArrayLiteralType(source) {
						return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
					}
					variances := getVariances( /* TODO(PropertyAccessExpression): (source as TypeReference).target */ TODO)
					if variances == emptyArray {
						return /* TODO(PropertyAccessExpression): Ternary.Unknown */ TODO
					}
					varianceResult := relateVariances(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), variances, intersectionState)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): varianceResult !== undefined */ TODO {
						return varianceResult
					}
				} else if /* TODO(ConditionalExpression): isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly) */ TODO {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
						return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors)
					} else {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
				} else if isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target) {
					constraint := getBaseConstraintOrType(source)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== source */ TODO {
						return isRelatedTo(constraint, target /* TODO(PropertyAccessExpression): RecursionFlags.Source */, TODO, reportErrors)
					}
				} else if /* TODO(ParenthesizedExpression): (relation === subtypeRelation || relation === strictSubtypeRelation) */ TODO && isEmptyObjectType(target) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.FreshLiteral */ TODO && !isEmptyObjectType(source) {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.Object */ TODO {
					reportStructuralErrors := reportErrors && errorInfo == /* TODO(PropertyAccessExpression): saveErrorInfo.errorInfo */ TODO && !sourceIsPrimitive
					/* TODO(ExpressionStatement): result = propertiesRelatedTo(source, target, reportStructuralErrors, /*excludedProperties* / undefined, /*optionalsOnly* / false, intersectionState); */
					if result {
						/* TODO(ExpressionStatement): result &= signaturesRelatedTo(source, target, SignatureKind.Call, reportStructuralErrors, intersectionState); */
						if result {
							/* TODO(ExpressionStatement): result &= signaturesRelatedTo(source, target, SignatureKind.Construct, reportStructuralErrors, intersectionState); */
							if result {
								/* TODO(ExpressionStatement): result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState); */
							}
						}
					}
					if varianceCheckFailed && result {
						/* TODO(ExpressionStatement): errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo; */
					} else if result {
						return result
					}
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceFlags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.Union */ TODO {
					objectOnlyTarget := extractTypesOfKind(target /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.Object | TypeFlags.Intersection | TypeFlags.Substitution */, TODO)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectOnlyTarget.flags & TypeFlags.Union */ TODO {
						result := typeRelatedToDiscriminatedType(source, objectOnlyTarget /* as */ /* TODO(TypeReference): UnionType */)
						if result {
							return result
						}
					}
				}
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			countMessageChainBreadth := func(info /* TODO(ArrayType): DiagnosticMessageChain[] */ any) number {
				if !info {
					/* TODO(NumericLiteral): 0 */
				}
				return reduceLeft(info /* TODO(ArrowFunction): (value, chain) => value + 1 + countMessageChainBreadth(chain.next) */, TODO, 0)
			}
			relateVariances := func(sourceTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, targetTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, variances []VarianceFlags, intersectionState IntersectionState) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary | undefined */ TODO {
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
					return result
				}
				if some(variances /* TODO(ArrowFunction): v => !!(v & VarianceFlags.AllowsStructuralFallback) */, TODO) {
					/* TODO(ExpressionStatement): originalErrorInfo = undefined; */
					resetErrorInfo(saveErrorInfo)
					return nil
				}
				allowStructuralFallback := targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances)
				/* TODO(ExpressionStatement): varianceCheckFailed = !allowStructuralFallback; */
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): variances !== emptyArray */ TODO && !allowStructuralFallback {
					if varianceCheckFailed && ! /* TODO(ParenthesizedExpression): (reportErrors && some(variances, v => (v & VarianceFlags.VarianceMask) === VarianceFlags.Invariant)) */ TODO {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					/* TODO(ExpressionStatement): originalErrorInfo = errorInfo; */
					resetErrorInfo(saveErrorInfo)
				}
			}
		}
		mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
			modifiersRelated := relation == comparableRelation || /* TODO(ParenthesizedExpression): (relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :                 getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target)) */ TODO
			if modifiersRelated {
				var result Ternary
				targetConstraint := getConstraintTypeFromMappedType(target)
				sourceConstraint := instantiateType(getConstraintTypeFromMappedType(source) /* TODO(ConditionalExpression): getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper */, TODO)
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
					mapper := createTypeMapper( /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(source)] */ TODO /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(target)] */, TODO)
					if instantiateType(getNameTypeFromMappedType(source), mapper) == instantiateType(getNameTypeFromMappedType(target), mapper) {
						return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlags.Both, reportErrors) */ TODO
					}
				}
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		typeRelatedToDiscriminatedType := func(source Type, target UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			sourceProperties := getPropertiesOfType(source)
			sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
			if !sourcePropertiesFiltered {
				/* TODO(PropertyAccessExpression): Ternary.False */
			}
			numCombinations := 1
			for _, sourceProperty := range sourcePropertiesFiltered {
				/* TODO(ExpressionStatement): numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty)); */
				if numCombinations > 25 {
					/* TODO(PropertyAccessExpression): tracing?.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "typeRelatedToDiscriminatedType_DepthLimit" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, numCombinations } */, TODO)
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			var sourceDiscriminantTypes [][]Type = /* TODO(NewExpression): new Array<Type[]>(sourcePropertiesFiltered.length) */ TODO
			excludedProperties := /* TODO(NewExpression): new Set<__String>() */ TODO
			/* TODO(ForStatement): for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                 const sourceProperty = sourcePropertiesFiltered[i];                 const sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);                 sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union                     ? (sourcePropertyType as UnionType).types                     : [sourcePropertyType];                 excludedProperties.add(sourceProperty.escapedName);             } */
			discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
			var matchingTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, combination := range discriminantCombinations {
				hasMatch := /* TODO(FalseKeyword): false */ TODO
				/* TODO(LabeledStatement): outer:                 for (const type of target.types) {                     for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                         const sourceProperty = sourcePropertiesFiltered[i];                         const targetProperty = getPropertyOfType(type, sourceProperty.escapedName);                         if (!targetProperty) continue outer;                         if (sourceProperty === targetProperty) continue;                         // We compare the source property to the target in the context of a single discriminant type.                         const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors* / false, IntersectionState.None, /*skipOptional* / strictNullChecks || relation === comparableRelation);                         // If the target property could not be found, or if the properties were not related,                         // then this constituent is not a match.                         if (!related) {                             continue outer;                         }                     }                     pushIfUnique(matchingTypes, type, equateValues);                     hasMatch = true;                 } */
				if !hasMatch {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			for _, type_ := range matchingTypes {
				/* TODO(ExpressionStatement): result &= propertiesRelatedTo(source, type, /*reportErrors* / false, excludedProperties, /*optionalsOnly* / false, IntersectionState.None); */
				if result {
					/* TODO(ExpressionStatement): result &= signaturesRelatedTo(source, type, SignatureKind.Call, /*reportErrors* / false, IntersectionState.None); */
					if result {
						/* TODO(ExpressionStatement): result &= signaturesRelatedTo(source, type, SignatureKind.Construct, /*reportErrors* / false, IntersectionState.None); */
						if result && ! /* TODO(ParenthesizedExpression): (isTupleType(source) && isTupleType(type)) */ TODO {
							/* TODO(ExpressionStatement): result &= indexSignaturesRelatedTo(source, type, /*sourceIsPrimitive* / false, /*reportErrors* / false, IntersectionState.None); */
						}
					}
				}
				if !result {
					return result
				}
			}
			return result
		}
		excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			if !excludedProperties || /* TODO(PropertyAccessExpression): properties.length */ TODO == 0 {
				/* TODO(Identifier): properties */
			}
			var result /* TODO(ArrayType): Symbol[] */ any
			/* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {                 if (!excludedProperties.has(properties[i].escapedName)) {                     if (result) {                         result.push(properties[i]);                     }                 }                 else if (!result) {                     result = properties.slice(0, i);                 }             } */
			return result || properties
		}
		isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetIsOptional := strictNullChecks && !! /* TODO(ParenthesizedExpression): (getCheckFlags(targetProp) & CheckFlags.Partial) */ TODO
			effectiveTarget := addOptionality(getNonMissingTypeOfSymbol(targetProp) /* TODO(FalseKeyword): false */, TODO, targetIsOptional)
			effectiveSource := getTypeOfSourceProperty(sourceProp)
			return isRelatedTo(effectiveSource, effectiveTarget /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors, nil, intersectionState)
		}
		propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
			sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
			targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourcePropFlags & ModifierFlags.Private */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetPropFlags & ModifierFlags.Private */ TODO {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceProp.valueDeclaration !== targetProp.valueDeclaration */ TODO {
					if reportErrors {
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourcePropFlags & ModifierFlags.Private */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetPropFlags & ModifierFlags.Private */ TODO {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Types_have_separate_declarations_of_a_private_property_0 */ TODO, symbolToString(targetProp))
						} else {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2 */ TODO, symbolToString(targetProp), typeToString( /* TODO(ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? source : target */ TODO), typeToString( /* TODO(ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? target : source */ TODO))
						}
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetPropFlags & ModifierFlags.Protected */ TODO {
				if !isValidOverrideOf(sourceProp, targetProp) {
					if reportErrors {
						reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2 */ TODO, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target))
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourcePropFlags & ModifierFlags.Protected */ TODO {
				if reportErrors {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2 */ TODO, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			if relation == strictSubtypeRelation && isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp) {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
			if !related {
				if reportErrors {
					reportIncompatibleError( /* TODO(PropertyAccessExpression): Diagnostics.Types_of_property_0_are_incompatible */ TODO, symbolToString(targetProp))
				}
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			if !skipOptional && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceProp.flags & SymbolFlags.Optional */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetProp.flags & SymbolFlags.ClassMember */ TODO && ! /* TODO(ParenthesizedExpression): (targetProp.flags & SymbolFlags.Optional) */ TODO {
				if reportErrors {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2 */ TODO, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			return related
		}
		reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
			shouldSkipElaboration := /* TODO(FalseKeyword): false */ TODO
			if /* TODO(PropertyAccessExpression): unmatchedProperty.valueDeclaration */ TODO && isNamedDeclaration( /* TODO(PropertyAccessExpression): unmatchedProperty.valueDeclaration */ TODO) && isPrivateIdentifier( /* TODO(PropertyAccessExpression): unmatchedProperty.valueDeclaration.name */ TODO) && /* TODO(PropertyAccessExpression): source.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.symbol.flags & SymbolFlags.Class */ TODO {
				privateIdentifierDescription := /* TODO(PropertyAccessExpression): unmatchedProperty.valueDeclaration.name.escapedText */ TODO
				symbolTableKey := getSymbolNameForPrivateIdentifier( /* TODO(PropertyAccessExpression): source.symbol */ TODO, privateIdentifierDescription)
				if symbolTableKey && getPropertyOfType(source, symbolTableKey) {
					sourceName := /* TODO(PropertyAccessExpression): factory.getDeclarationName */ TODO( /* TODO(PropertyAccessExpression): source.symbol.valueDeclaration */ TODO)
					targetName := /* TODO(PropertyAccessExpression): factory.getDeclarationName */ TODO( /* TODO(PropertyAccessExpression): target.symbol.valueDeclaration */ TODO)
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2 */ TODO, diagnosticName(privateIdentifierDescription), diagnosticName( /* TODO(ConditionalExpression): sourceName.escapedText === "" ? anon : sourceName */ TODO), diagnosticName( /* TODO(ConditionalExpression): targetName.escapedText === "" ? anon : targetName */ TODO))
					return
				}
			}
			props := arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties /* TODO(FalseKeyword): false */, TODO))
			if !headMessage || /* TODO(ParenthesizedExpression): (headMessage.code !== Diagnostics.Class_0_incorrectly_implements_interface_1.code &&                     headMessage.code !== Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code) */ TODO {
				/* TODO(ExpressionStatement): shouldSkipElaboration = true; */
			}
			if /* TODO(PropertyAccessExpression): props.length */ TODO == 1 {
				propName := symbolToString(unmatchedProperty, nil /* TODO(PropertyAccessExpression): SymbolFlags.None */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFormatFlags.AllowAnyNodeKind | SymbolFormatFlags.WriteComputedProps */, TODO)
				reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2 */ TODO, propName /* TODO(SpreadElement): ...getTypeNamesForErrorDisplay(source, target) */, TODO)
				if length( /* TODO(PropertyAccessExpression): unmatchedProperty.declarations */ TODO) {
					associateRelatedInfo(createDiagnosticForNode( /* TODO(ElementAccessExpression): unmatchedProperty.declarations![0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_here */, TODO, propName))
				}
				if shouldSkipElaboration && errorInfo {
					/* TODO(ExpressionStatement): overrideNextErrorInfo++; */
				}
			} else if tryElaborateArrayLikeErrors(source, target /* TODO(FalseKeyword): false */, TODO) {
				if /* TODO(PropertyAccessExpression): props.length */ TODO > 5 {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more */ TODO, typeToString(source), typeToString(target) /* TODO(PropertyAccessExpression): map(props.slice(0, 4), p => symbolToString(p)).join */, TODO(", ") /* TODO(MinusToken): - */ /* TODO(BinaryExpression): props.length - 4 */, TODO)
				} else {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2 */ TODO, typeToString(source), typeToString(target) /* TODO(PropertyAccessExpression): map(props, p => symbolToString(p)).join */, TODO(", "))
				}
				if shouldSkipElaboration && errorInfo {
					/* TODO(ExpressionStatement): overrideNextErrorInfo++; */
				}
			}
		}
		propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return propertiesIdenticalTo(source, target, excludedProperties)
			}
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			if isTupleType(target) {
				if isArrayOrTupleType(source) {
					if ! /* TODO(PropertyAccessExpression): target.target.readonly */ TODO && /* TODO(ParenthesizedExpression): (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly) */ TODO {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					sourceArity := getTypeReferenceArity(source)
					targetArity := getTypeReferenceArity(target)
					sourceRestFlag := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest */ TODO
					targetHasRestElement := !! /* TODO(ParenthesizedExpression): (target.target.combinedFlags & ElementFlags.Variable) */ TODO
					sourceMinLength := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.minLength : 0 */ TODO
					targetMinLength := /* TODO(PropertyAccessExpression): target.target.minLength */ TODO
					if !sourceRestFlag && sourceArity < targetMinLength {
						if reportErrors {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Source_has_0_element_s_but_target_requires_1 */ TODO, sourceArity, targetMinLength)
						}
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					if !targetHasRestElement && targetArity < sourceMinLength {
						if reportErrors {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Source_has_0_element_s_but_target_allows_only_1 */ TODO, sourceMinLength, targetArity)
						}
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					if !targetHasRestElement && /* TODO(ParenthesizedExpression): (sourceRestFlag || targetArity < sourceArity) */ TODO {
						if reportErrors {
							if sourceMinLength < targetMinLength {
								reportError( /* TODO(PropertyAccessExpression): Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer */ TODO, targetMinLength)
							} else {
								reportError( /* TODO(PropertyAccessExpression): Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more */ TODO, targetArity)
							}
						}
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					sourceTypeArguments := getTypeArguments(source)
					targetTypeArguments := getTypeArguments(target)
					targetStartCount := getStartElementCount( /* TODO(PropertyAccessExpression): target.target */ TODO /* TODO(PropertyAccessExpression): ElementFlags.NonRest */, TODO)
					targetEndCount := getEndElementCount( /* TODO(PropertyAccessExpression): target.target */ TODO /* TODO(PropertyAccessExpression): ElementFlags.NonRest */, TODO)
					canExcludeDiscriminants := !!excludedProperties
					/* TODO(ForStatement): for (let sourcePosition = 0; sourcePosition < sourceArity; sourcePosition++) {                         const sourceFlags = isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest;                         const sourcePositionFromEnd = sourceArity - 1 - sourcePosition;                          const targetPosition = targetHasRestElement && sourcePosition >= targetStartCount                             ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)                             : sourcePosition;                          const targetFlags = target.target.elementFlags[targetPosition];                          if (targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         if (sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)) {                             if (reportErrors) {                                 reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition);                             }                             return Ternary.False;                         }                         if (targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         // We can only exclude discriminant properties if we have not yet encountered a variable-length element.                         if (canExcludeDiscriminants) {                             if (sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable) {                                 canExcludeDiscriminants = false;                             }                             if (canExcludeDiscriminants && excludedProperties?.has(("" + sourcePosition) as __String)) {                                 continue;                             }                         }                          const sourceType = removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlags.Optional));                         const targetType = targetTypeArguments[targetPosition];                          const targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) :                             removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional));                         const related = isRelatedTo(sourceType, targetCheckType, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (!related) {                             if (reportErrors && (targetArity > 1 || sourceArity > 1)) {                                 if (targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount !== sourceArity - targetEndCount - 1) {                                     reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity - targetEndCount - 1, targetPosition);                                 }                                 else {                                     reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition);                                 }                             }                             return Ternary.False;                         }                         result &= related;                     } */
					return result
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.target.combinedFlags & ElementFlags.Variable */ TODO {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			requireOptionalProperties := /* TODO(ParenthesizedExpression): (relation === subtypeRelation || relation === strictSubtypeRelation) */ TODO && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source)
			unmatchedProperty := getUnmatchedProperty(source, target, requireOptionalProperties /* TODO(FalseKeyword): false */, TODO)
			if unmatchedProperty {
				if reportErrors && shouldReportUnmatchedPropertyError(source, target) {
					reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties)
				}
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			if isObjectLiteralType(target) {
				for _, sourceProp := range excludeProperties(getPropertiesOfType(source), excludedProperties) {
					if !getPropertyOfObjectType(target /* TODO(PropertyAccessExpression): sourceProp.escapedName */, TODO) {
						sourceType := getTypeOfSymbol(sourceProp)
						if ! /* TODO(ParenthesizedExpression): (sourceType.flags & TypeFlags.Undefined) */ TODO {
							if reportErrors {
								reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO, symbolToString(sourceProp), typeToString(target))
							}
							return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
						}
					}
				}
			}
			properties := getPropertiesOfType(target)
			numericNamesOnly := isTupleType(source) && isTupleType(target)
			for _, targetProp := range excludeProperties(properties, excludedProperties) {
				name := /* TODO(PropertyAccessExpression): targetProp.escapedName */ TODO
				if ! /* TODO(ParenthesizedExpression): (targetProp.flags & SymbolFlags.Prototype) */ TODO && /* TODO(ParenthesizedExpression): (!numericNamesOnly || isNumericLiteralName(name) || name === "length") */ TODO && /* TODO(ParenthesizedExpression): (!optionalsOnly || targetProp.flags & SymbolFlags.Optional) */ TODO {
					sourceProp := getPropertyOfType(source, name)
					if sourceProp && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceProp !== targetProp */ TODO {
						related := propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation == comparableRelation)
						if !related {
							return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
						}
						/* TODO(ExpressionStatement): result &= related; */
					}
				}
			}
			return result
		}
		propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
			if ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Object && target.flags & TypeFlags.Object) */ TODO {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			sourceProperties := excludeProperties(getPropertiesOfObjectType(source), excludedProperties)
			targetProperties := excludeProperties(getPropertiesOfObjectType(target), excludedProperties)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceProperties.length !== targetProperties.length */ TODO {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			for _, sourceProp := range sourceProperties {
				targetProp := getPropertyOfObjectType(target /* TODO(PropertyAccessExpression): sourceProp.escapedName */, TODO)
				if !targetProp {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				related := compareProperties(sourceProp, targetProp, isRelatedTo)
				if !related {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				/* TODO(ExpressionStatement): result &= related; */
			}
			return result
		}
		signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return signaturesIdenticalTo(source, target, kind)
			}
			if target == anyFunctionType || source == anyFunctionType {
				return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			}
			sourceIsJSConstructor := /* TODO(PropertyAccessExpression): source.symbol */ TODO && isJSConstructor( /* TODO(PropertyAccessExpression): source.symbol.valueDeclaration */ TODO)
			targetIsJSConstructor := /* TODO(PropertyAccessExpression): target.symbol */ TODO && isJSConstructor( /* TODO(PropertyAccessExpression): target.symbol.valueDeclaration */ TODO)
			sourceSignatures := getSignaturesOfType(source /* TODO(ConditionalExpression): (sourceIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */, TODO)
			targetSignatures := getSignaturesOfType(target /* TODO(ConditionalExpression): (targetIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */, TODO)
			if kind == /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO && /* TODO(PropertyAccessExpression): sourceSignatures.length */ TODO && /* TODO(PropertyAccessExpression): targetSignatures.length */ TODO {
				sourceIsAbstract := !! /* TODO(ParenthesizedExpression): (sourceSignatures[0].flags & SignatureFlags.Abstract) */ TODO
				targetIsAbstract := !! /* TODO(ParenthesizedExpression): (targetSignatures[0].flags & SignatureFlags.Abstract) */ TODO
				if sourceIsAbstract && !targetIsAbstract {
					if reportErrors {
						reportError( /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type */ TODO)
					}
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				if !constructorVisibilitiesAreCompatible( /* TODO(ElementAccessExpression): sourceSignatures[0] */ TODO /* TODO(ElementAccessExpression): targetSignatures[0] */, TODO, reportErrors) {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			incompatibleReporter := /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn */ TODO
			sourceObjectFlags := getObjectFlags(source)
			targetObjectFlags := getObjectFlags(target)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceObjectFlags & ObjectFlags.Instantiated */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetObjectFlags & ObjectFlags.Instantiated */ TODO && /* TODO(PropertyAccessExpression): source.symbol */ TODO == /* TODO(PropertyAccessExpression): target.symbol */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceObjectFlags & ObjectFlags.Reference */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetObjectFlags & ObjectFlags.Reference */ TODO && /* TODO(PropertyAccessExpression): (source as TypeReference).target */ TODO == /* TODO(PropertyAccessExpression): (target as TypeReference).target */ TODO {
				/* TODO(PropertyAccessExpression): Debug.assertEqual */ TODO( /* TODO(PropertyAccessExpression): sourceSignatures.length */ TODO /* TODO(PropertyAccessExpression): targetSignatures.length */, TODO)
				/* TODO(ForStatement): for (let i = 0; i < targetSignatures.length; i++) {                     const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase* / true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 } */
			} else if /* TODO(PropertyAccessExpression): sourceSignatures.length */ TODO == 1 && /* TODO(PropertyAccessExpression): targetSignatures.length */ TODO == 1 {
				eraseGenerics := relation == comparableRelation
				sourceSignature := first(sourceSignatures)
				targetSignature := first(targetSignatures)
				/* TODO(ExpressionStatement): result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature)); */
				if !result && reportErrors && kind == /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO && /* TODO(ParenthesizedExpression): (sourceObjectFlags & targetObjectFlags) */ TODO && /* TODO(ParenthesizedExpression): (targetSignature.declaration?.kind === SyntaxKind.Constructor || sourceSignature.declaration?.kind === SyntaxKind.Constructor) */ TODO {
					constructSignatureToString := /* TODO(ArrowFunction): (signature: Signature) => signatureToString(signature, /*enclosingDeclaration* / undefined, TypeFormatFlags.WriteArrowStyleSignature, kind) */ TODO
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_assignable_to_type_1 */ TODO, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature))
					reportError( /* TODO(PropertyAccessExpression): Diagnostics.Types_of_construct_signatures_are_incompatible */ TODO)
					return result
				}
			} else {
				/* TODO(LabeledStatement): outer:                 for (const t of targetSignatures) {                     const saveErrorInfo = captureErrorCalculationState();                     // Only elaborate errors from the first failure                     let shouldElaborateErrors = reportErrors;                     for (const s of sourceSignatures) {                         const related = signatureRelatedTo(s, t, /*erase* / true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t));                         if (related) {                             result &= related;                             resetErrorInfo(saveErrorInfo);                             continue outer;                         }                         shouldElaborateErrors = false;                     }                     if (shouldElaborateErrors) {                         reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration* / undefined, /*flags* / undefined, kind));                     }                     return Ternary.False;                 } */
			}
			return result
		}
		shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
			typeCallSignatures := getSignaturesOfStructuredType(source /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			typeConstructSignatures := getSignaturesOfStructuredType(source /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
			typeProperties := getPropertiesOfObjectType(source)
			if /* TODO(ParenthesizedExpression): (typeCallSignatures.length || typeConstructSignatures.length) */ TODO && ! /* TODO(PropertyAccessExpression): typeProperties.length */ TODO {
				if /* TODO(ParenthesizedExpression): (getSignaturesOfType(target, SignatureKind.Call).length && typeCallSignatures.length) */ TODO || /* TODO(ParenthesizedExpression): (getSignaturesOfType(target, SignatureKind.Construct).length && typeConstructSignatures.length) */ TODO {
					return /* TODO(TrueKeyword): true */ TODO
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
			if /* TODO(PropertyAccessExpression): siga.parameters.length */ TODO == 0 && /* TODO(PropertyAccessExpression): sigb.parameters.length */ TODO == 0 {
				return /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target)) */ TODO
			}
			return /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target)) */ TODO
		}
		reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
			if /* TODO(PropertyAccessExpression): siga.parameters.length */ TODO == 0 && /* TODO(PropertyAccessExpression): sigb.parameters.length */ TODO == 0 {
				return /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target)) */ TODO
			}
			return /* TODO(ArrowFunction): (source: Type, target: Type) => reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target)) */ TODO
		}
		signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type)) Ternary {
			checkMode := /* TODO(ConditionalExpression): relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature :                 relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity :                 SignatureCheckMode.None */ TODO
			return compareSignaturesRelated( /* TODO(ConditionalExpression): erase ? getErasedSignature(source) : source */ TODO /* TODO(ConditionalExpression): erase ? getErasedSignature(target) : target */, TODO, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper)
			isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
				return isRelatedTo(source, target /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors, nil, intersectionState)
			}
		}
		signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
			sourceSignatures := getSignaturesOfType(source, kind)
			targetSignatures := getSignaturesOfType(target, kind)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSignatures.length !== targetSignatures.length */ TODO {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			/* TODO(ForStatement): for (let i = 0; i < sourceSignatures.length; i++) {                 const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, isRelatedTo);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
			return result
		}
		membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			keyType := /* TODO(PropertyAccessExpression): targetInfo.keyType */ TODO
			props := /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source) */ TODO
			for _, prop := range props {
				if isIgnoredJsxProperty(source, prop) {
					/* TODO(ContinueStatement): continue; */
				}
				if isApplicableIndexType(getLiteralTypeFromProperty(prop /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO), keyType) {
					propType := getNonMissingTypeOfSymbol(prop)
					type_ := /* TODO(ConditionalExpression): exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional)                         ? propType                         : getTypeWithFacts(propType, TypeFacts.NEUndefined) */ TODO
					related := isRelatedTo(type_ /* TODO(PropertyAccessExpression): targetInfo.type */, TODO /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors, nil, intersectionState)
					if !related {
						if reportErrors {
							reportError( /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_incompatible_with_index_signature */ TODO, symbolToString(prop))
						}
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					/* TODO(ExpressionStatement): result &= related; */
				}
			}
			for _, info := range getIndexInfosOfType(source) {
				if isApplicableIndexType( /* TODO(PropertyAccessExpression): info.keyType */ TODO, keyType) {
					related := indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState)
					if !related {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					/* TODO(ExpressionStatement): result &= related; */
				}
			}
			return result
		}
		indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			related := isRelatedTo( /* TODO(PropertyAccessExpression): sourceInfo.type */ TODO /* TODO(PropertyAccessExpression): targetInfo.type */, TODO /* TODO(PropertyAccessExpression): RecursionFlags.Both */, TODO, reportErrors, nil, intersectionState)
			if !related && reportErrors {
				if /* TODO(PropertyAccessExpression): sourceInfo.keyType */ TODO == /* TODO(PropertyAccessExpression): targetInfo.keyType */ TODO {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics._0_index_signatures_are_incompatible */ TODO, typeToString( /* TODO(PropertyAccessExpression): sourceInfo.keyType */ TODO))
				} else {
					reportError( /* TODO(PropertyAccessExpression): Diagnostics._0_and_1_index_signatures_are_incompatible */ TODO, typeToString( /* TODO(PropertyAccessExpression): sourceInfo.keyType */ TODO), typeToString( /* TODO(PropertyAccessExpression): targetInfo.keyType */ TODO))
				}
			}
			return related
		}
		indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return indexSignaturesIdenticalTo(source, target)
			}
			indexInfos := getIndexInfosOfType(target)
			targetHasStringIndex := some(indexInfos /* TODO(ArrowFunction): info => info.keyType === stringType */, TODO)
			result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
			for _, targetInfo := range indexInfos {
				related := /* TODO(ConditionalExpression): relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True :                     isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) :                     typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState) */ TODO
				if !related {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
				/* TODO(ExpressionStatement): result &= related; */
			}
			return result
		}
		typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceInfo := getApplicableIndexInfo(source /* TODO(PropertyAccessExpression): targetInfo.keyType */, TODO)
			if sourceInfo {
				return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
			}
			if ! /* TODO(ParenthesizedExpression): (intersectionState & IntersectionState.Source) */ TODO && /* TODO(ParenthesizedExpression): (relation !== strictSubtypeRelation || getObjectFlags(source) & ObjectFlags.FreshLiteral) */ TODO && isObjectTypeWithInferableIndex(source) {
				return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
			}
			if reportErrors {
				reportError( /* TODO(PropertyAccessExpression): Diagnostics.Index_signature_for_type_0_is_missing_in_type_1 */ TODO, typeToString( /* TODO(PropertyAccessExpression): targetInfo.keyType */ TODO), typeToString(source))
			}
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
			sourceInfos := getIndexInfosOfType(source)
			targetInfos := getIndexInfosOfType(target)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceInfos.length !== targetInfos.length */ TODO {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
			for _, targetInfo := range targetInfos {
				sourceInfo := getIndexInfoOfType(source /* TODO(PropertyAccessExpression): targetInfo.keyType */, TODO)
				if ! /* TODO(ParenthesizedExpression): (sourceInfo && isRelatedTo(sourceInfo.type, targetInfo.type, RecursionFlags.Both) && sourceInfo.isReadonly === targetInfo.isReadonly) */ TODO {
					return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
				}
			}
			return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		}
		constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) /* TODO(undefined): boolean */ TODO {
			if ! /* TODO(PropertyAccessExpression): sourceSignature.declaration */ TODO || ! /* TODO(PropertyAccessExpression): targetSignature.declaration */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
			sourceAccessibility := getSelectedEffectiveModifierFlags( /* TODO(PropertyAccessExpression): sourceSignature.declaration */ TODO /* TODO(PropertyAccessExpression): ModifierFlags.NonPublicAccessibilityModifier */, TODO)
			targetAccessibility := getSelectedEffectiveModifierFlags( /* TODO(PropertyAccessExpression): targetSignature.declaration */ TODO /* TODO(PropertyAccessExpression): ModifierFlags.NonPublicAccessibilityModifier */, TODO)
			if targetAccessibility == /* TODO(PropertyAccessExpression): ModifierFlags.Private */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if targetAccessibility == /* TODO(PropertyAccessExpression): ModifierFlags.Protected */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceAccessibility !== ModifierFlags.Private */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetAccessibility !== ModifierFlags.Protected */ TODO && !sourceAccessibility {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if reportErrors {
				reportError( /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type */ TODO, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility))
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	typeCouldHaveTopLevelSingletonTypes := func(type_ Type) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Boolean */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.UnionOrIntersection */ TODO {
			return !!forEach( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, typeCouldHaveTopLevelSingletonTypes)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Instantiable */ TODO {
			constraint := getConstraintOfType(type_)
			if constraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== type */ TODO {
				return typeCouldHaveTopLevelSingletonTypes(constraint)
			}
		}
		return isUnitType(type_) || !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.TemplateLiteral) */ TODO || !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.StringMapping) */ TODO
	}
	getExactOptionalUnassignableProperties := func(source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		if isTupleType(source) && isTupleType(target) {
			/* TODO(Identifier): emptyArray */
		}
		return /* TODO(PropertyAccessExpression): getPropertiesOfType(target)             .filter */ TODO( /* TODO(ArrowFunction): targetProp => isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp)) */ TODO)
	}
	isExactOptionalPropertyMismatch := func(source *Type, target *Type) /* TODO(undefined): boolean */ TODO {
		return !!source && !!target && maybeTypeOfKind(source /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, TODO) && !!containsMissingType(target)
	}
	getExactOptionalProperties := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		return /* TODO(PropertyAccessExpression): getPropertiesOfType(type).filter */ TODO( /* TODO(ArrowFunction): targetProp => containsMissingType(getTypeOfSymbol(targetProp)) */ TODO)
	}
	getBestMatchingType := func(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO /* = */ /* TODO(Identifier): compareTypesAssignable */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return findMatchingDiscriminantType(source, target, isRelatedTo) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target) || findBestTypeForInvokable(source, target) || findMostOverlappyType(source, target)
	}
	discriminateTypeByDiscriminableItems := func(target UnionType, discriminators [] /* TODO(TupleType): [() => Type, __String] */ TODO, related func(source Type, target Type) /* TODO(UnionType): boolean | Ternary */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		types := /* TODO(PropertyAccessExpression): target.types */ TODO
		var include []Ternary = /* TODO(PropertyAccessExpression): types.map */ TODO( /* TODO(ArrowFunction): t => t.flags & TypeFlags.Primitive ? Ternary.False : Ternary.True */ TODO)
		for _, TODO_IDENTIFIER := range discriminators {
			matched := /* TODO(FalseKeyword): false */ TODO
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 if (include[i]) {                     const targetType = getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName);                     if (targetType && someType(getDiscriminatingType(), t => !!related(t, targetType))) {                         matched = true;                     }                     else {                         include[i] = Ternary.Maybe;                     }                 }             } */
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 if (include[i] === Ternary.Maybe) {                     include[i] = matched ? Ternary.False : Ternary.True;                 }             } */
		}
		filtered := /* TODO(ConditionalExpression): contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target */ TODO
		return /* TODO(ConditionalExpression): filtered.flags & TypeFlags.Never ? target : filtered */ TODO
	}
	isWeakType := func(type_ Type) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			return /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO == 0 && /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO == 0 && /* TODO(PropertyAccessExpression): resolved.indexInfos.length */ TODO == 0 && /* TODO(PropertyAccessExpression): resolved.properties.length */ TODO > 0 && every( /* TODO(PropertyAccessExpression): resolved.properties */ TODO /* TODO(ArrowFunction): p => !!(p.flags & SymbolFlags.Optional) */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Substitution */ TODO {
			return isWeakType( /* TODO(PropertyAccessExpression): (type as SubstitutionType).baseType */ TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			return every( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, isWeakType)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	hasCommonProperties := func(source Type, target Type, isComparingJsxAttributes bool) /* TODO(undefined): boolean */ TODO {
		for _, prop := range getPropertiesOfType(source) {
			if isKnownProperty(target /* TODO(PropertyAccessExpression): prop.escapedName */, TODO, isComparingJsxAttributes) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getVariances := func(type_ GenericType) []VarianceFlags {
		return /* TODO(ConditionalExpression): type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple ?             arrayVariances :             getVariancesWorker(type.symbol, type.typeParameters) */ TODO
	}
	getAliasVariances := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags[] */ TODO {
		return getVariancesWorker(symbol /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */, TODO)
	}
	getVariancesWorker := func(symbol Symbol, typeParameters []TypeParameter /* = */ /* TODO(Identifier): emptyArray */) []VarianceFlags {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.variances */ TODO {
			/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "getVariancesWorker" /* TODO(ObjectLiteralExpression): { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) } */, TODO)
			oldVarianceComputation := inVarianceComputation
			saveResolutionStart := resolutionStart
			if !inVarianceComputation {
				/* TODO(ExpressionStatement): inVarianceComputation = true; */
				/* TODO(ExpressionStatement): resolutionStart = resolutionTargets.length; */
			}
			/* TODO(ExpressionStatement): links.variances = emptyArray; */
			variances := /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, tp := range typeParameters {
				modifiers := getTypeParameterModifiers(tp)
				variance := /* TODO(ConditionalExpression): modifiers & ModifierFlags.Out ?                     modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant :                     modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined */ TODO
				if variance == nil {
					unmeasurable := /* TODO(FalseKeyword): false */ TODO
					unreliable := /* TODO(FalseKeyword): false */ TODO
					oldHandler := outofbandVarianceMarkerHandler
					/* TODO(ExpressionStatement): outofbandVarianceMarkerHandler = onlyUnreliable => onlyUnreliable ? unreliable = true : unmeasurable = true; */
					typeWithSuper := createMarkerType(symbol, tp, markerSuperType)
					typeWithSub := createMarkerType(symbol, tp, markerSubType)
					/* TODO(ExpressionStatement): variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0) |                         (isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0); */
					if variance == /* TODO(PropertyAccessExpression): VarianceFlags.Bivariant */ TODO && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper) {
						/* TODO(ExpressionStatement): variance = VarianceFlags.Independent; */
					}
					/* TODO(ExpressionStatement): outofbandVarianceMarkerHandler = oldHandler; */
					if unmeasurable || unreliable {
						if unmeasurable {
							/* TODO(ExpressionStatement): variance |= VarianceFlags.Unmeasurable; */
						}
						if unreliable {
							/* TODO(ExpressionStatement): variance |= VarianceFlags.Unreliable; */
						}
					}
				}
				/* TODO(PropertyAccessExpression): variances.push */ TODO(variance)
			}
			if !oldVarianceComputation {
				/* TODO(ExpressionStatement): inVarianceComputation = false; */
				/* TODO(ExpressionStatement): resolutionStart = saveResolutionStart; */
			}
			/* TODO(ExpressionStatement): links.variances = variances; */
			/* TODO(PropertyAccessExpression): tracing?.pop */
			TODO( /* TODO(ObjectLiteralExpression): { variances: variances.map(Debug.formatVariance) } */ TODO)
		}
		return /* TODO(PropertyAccessExpression): links.variances */ TODO
	}
	createMarkerType := func(symbol Symbol, source TypeParameter, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		mapper := makeUnaryTypeMapper(source, target)
		type_ := getDeclaredTypeOfSymbol(symbol)
		if isErrorType(type_) {
			return type_
		}
		result := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.TypeAlias ?             getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) :             createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper)) */ TODO
		/* TODO(PropertyAccessExpression): markerTypes.add */ TODO(getTypeId(result))
		return result
	}
	isMarkerType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): markerTypes.has */ TODO(getTypeId(type_))
	}
	getTypeParameterModifiers := func(tp TypeParameter) ModifierFlags {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): reduceLeft(tp.symbol?.declarations, (modifiers, d) => modifiers | getEffectiveModifierFlags(d), ModifierFlags.None) & (ModifierFlags.In | ModifierFlags.Out | ModifierFlags.Const) */ TODO
	}
	hasCovariantVoidArgument := func(typeArguments []Type, variances []VarianceFlags) bool {
		/* TODO(ForStatement): for (let i = 0; i < variances.length; i++) {             if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) {                 return true;             }         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	isUnconstrainedTypeParameter := func(type_ Type) /* TODO(undefined): boolean | 0 */ TODO {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO && !getConstraintOfTypeParameter(type_ /* as */ /* TODO(TypeReference): TypeParameter */)
	}
	isNonDeferredTypeReference := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO && ! /* TODO(PropertyAccessExpression): (type as TypeReference).node */ TODO
	}
	isTypeReferenceWithGenericArguments := func(type_ Type) bool {
		return isNonDeferredTypeReference(type_) && some(getTypeArguments(type_) /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.TypeParameter) || isTypeReferenceWithGenericArguments(t) */, TODO)
	}
	getGenericTypeReferenceRelationKey := func(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) /* TODO(undefined): string */ TODO {
		var typeParameters []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		constraintMarker := ""
		sourceId := getTypeReferenceId(source, 0)
		targetId := getTypeReferenceId(target, 0)
		return /* TODO(TemplateExpression): `${constraintMarker}${sourceId},${targetId}${postFix}` */ TODO
		getTypeReferenceId := func(type_ TypeReference, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(undefined): string */ TODO {
			result := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + type.target.id */ TODO
			for _, t := range getTypeArguments(type_) {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */ TODO {
					if ignoreConstraints || isUnconstrainedTypeParameter(t) {
						index := /* TODO(PropertyAccessExpression): typeParameters.indexOf */ TODO(t)
						if index < 0 {
							/* TODO(ExpressionStatement): index = typeParameters.length; */
							/* TODO(PropertyAccessExpression): typeParameters.push */
							TODO(t)
						}
						/* TODO(ExpressionStatement): result += "=" + index; */
						/* TODO(ContinueStatement): continue; */
					}
					/* TODO(ExpressionStatement): constraintMarker = "*"; */
				} else if depth < 4 && isTypeReferenceWithGenericArguments(t) {
					/* TODO(ExpressionStatement): result += "<" + getTypeReferenceId(t as TypeReference, depth + 1) + ">"; */
					/* TODO(ContinueStatement): continue; */
				}
				/* TODO(ExpressionStatement): result += "-" + t.id; */
			}
			return result
		}
	}
	getRelationKey := func(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) /* TODO(undefined): string */ TODO {
		if relation == identityRelation && /* TODO(PropertyAccessExpression): source.id */ TODO > /* TODO(PropertyAccessExpression): target.id */ TODO {
			temp := source
			/* TODO(ExpressionStatement): source = target; */
			/* TODO(ExpressionStatement): target = temp; */
		}
		postFix := /* TODO(ConditionalExpression): intersectionState ? ":" + intersectionState : "" */ TODO
		return /* TODO(ConditionalExpression): isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ?             getGenericTypeReferenceRelationKey(source as TypeReference, target as TypeReference, postFix, ignoreConstraints) :             `${source.id},${target.id}${postFix}` */ TODO
	}
	forEachProperty := func(prop Symbol, callback func(p Symbol) T) *T {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(prop) & CheckFlags.Synthetic */ TODO {
			for _, t := range /* TODO(PropertyAccessExpression): (prop as TransientSymbol).links.containingType!.types */ TODO {
				p := getPropertyOfType(t /* TODO(PropertyAccessExpression): prop.escapedName */, TODO)
				result := p && forEachProperty(p, callback)
				if result {
					return result
				}
			}
			return nil
		}
		return callback(prop)
	}
	getDeclaringClass := func(prop Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ TODO {
		return /* TODO(ConditionalExpression): prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) as InterfaceType : undefined */ TODO
	}
	getTypeOfPropertyInBaseClass := func(property Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		classType := getDeclaringClass(property)
		baseClassType := classType && /* TODO(ElementAccessExpression): getBaseTypes(classType)[0] */ TODO
		return baseClassType && getTypeOfPropertyOfType(baseClassType /* TODO(PropertyAccessExpression): property.escapedName */, TODO)
	}
	isPropertyInClassDerivedFrom := func(prop Symbol, baseClass *Type) /* TODO(undefined): boolean | undefined */ TODO {
		return forEachProperty(prop /* TODO(ArrowFunction): sp => {             const sourceClass = getDeclaringClass(sp);             return sourceClass ? hasBaseType(sourceClass, baseClass) : false;         } */, TODO)
	}
	isValidOverrideOf := func(sourceProp Symbol, targetProp Symbol) /* TODO(undefined): boolean */ TODO {
		return !forEachProperty(targetProp /* TODO(ArrowFunction): tp =>             getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ?                 !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false */, TODO)
	}
	isClassDerivedFromDeclaringClasses := func(checkClass T, prop Symbol, writing bool) /* TODO(undefined): T | undefined */ TODO {
		return /* TODO(ConditionalExpression): forEachProperty(prop, p =>                 getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ?                     !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? undefined : checkClass */ TODO
	}
	isDeeplyNestedType := func(type_ Type, stack []Type, depth number, maxDepth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 3 */) bool {
		if depth >= maxDepth {
			if /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) */ TODO == /* TODO(PropertyAccessExpression): ObjectFlags.InstantiatedMapped */ TODO {
				/* TODO(ExpressionStatement): type = getMappedTargetWithSymbol(type); */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
				return some( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => isDeeplyNestedType(t, stack, depth, maxDepth) */, TODO)
			}
			identity := getRecursionIdentity(type_)
			count := 0
			lastTypeId := 0
			/* TODO(ForStatement): for (let i = 0; i < depth; i++) {                 const t = stack[i];                 if (hasMatchingRecursionIdentity(t, identity)) {                     // We only count occurrences with a higher type id than the previous occurrence, since higher                     // type ids are an indicator of newer instantiations caused by recursion.                     if (t.id >= lastTypeId) {                         count++;                         if (count >= maxDepth) {                             return true;                         }                     }                     lastTypeId = t.id;                 }             } */
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getMappedTargetWithSymbol := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var target TODO
		/* TODO(WhileStatement): while (             (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped &&             (target = getModifiersTypeFromMappedType(type as MappedType)) &&             (target.symbol || target.flags & TypeFlags.Intersection && some((target as IntersectionType).types, t => !!t.symbol))         ) {             type = target;         } */
		return type_
	}
	hasMatchingRecursionIdentity := func(type_ Type, identity /* TODO(ObjectKeyword): object */ TODO) bool {
		if /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) */ TODO == /* TODO(PropertyAccessExpression): ObjectFlags.InstantiatedMapped */ TODO {
			/* TODO(ExpressionStatement): type = getMappedTargetWithSymbol(type); */
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			return some( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => hasMatchingRecursionIdentity(t, identity) */, TODO)
		}
		return getRecursionIdentity(type_) == identity
	}
	getRecursionIdentity := func(type_ Type) /* TODO(ObjectKeyword): object */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO && !isObjectOrArrayLiteralType(type_) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.Reference */ TODO && /* TODO(PropertyAccessExpression): (type as TypeReference).node */ TODO {
				return /* TODO(NonNullExpression): (type as TypeReference).node! */ TODO
			}
			if /* TODO(PropertyAccessExpression): type.symbol */ TODO && ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Anonymous && type.symbol.flags & SymbolFlags.Class) */ TODO {
				return /* TODO(PropertyAccessExpression): type.symbol */ TODO
			}
			if isTupleType(type_) {
				return /* TODO(PropertyAccessExpression): type.target */ TODO
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
			return /* TODO(PropertyAccessExpression): type.symbol */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.IndexedAccess */ TODO {
			/* TODO(DoStatement): do {                 type = (type as IndexedAccessType).objectType;             }             while (type.flags & TypeFlags.IndexedAccess); */
			return type_
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
			return /* TODO(PropertyAccessExpression): (type as ConditionalType).root */ TODO
		}
		return type_
	}
	isPropertyIdenticalTo := func(sourceProp Symbol, targetProp Symbol) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): compareProperties(sourceProp, targetProp, compareTypesIdentical) !== Ternary.False */ TODO
	}
	compareProperties := func(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
		if sourceProp == targetProp {
			return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		}
		sourcePropAccessibility := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlags.NonPublicAccessibilityModifier */ TODO
		targetPropAccessibility := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlags.NonPublicAccessibilityModifier */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourcePropAccessibility !== targetPropAccessibility */ TODO {
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		if sourcePropAccessibility {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp) */ TODO {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
		} else {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional) */ TODO {
				return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp) */ TODO {
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp))
	}
	isMatchingSignature := func(source Signature, target Signature, partialMatch bool) /* TODO(undefined): boolean */ TODO {
		sourceParameterCount := getParameterCount(source)
		targetParameterCount := getParameterCount(target)
		sourceMinArgumentCount := getMinArgumentCount(source)
		targetMinArgumentCount := getMinArgumentCount(target)
		sourceHasRestParameter := hasEffectiveRestParameter(source)
		targetHasRestParameter := hasEffectiveRestParameter(target)
		if sourceParameterCount == targetParameterCount && sourceMinArgumentCount == targetMinArgumentCount && sourceHasRestParameter == targetHasRestParameter {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	compareSignaturesIdentical := func(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
		if source == target {
			return /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		}
		if ! /* TODO(ParenthesizedExpression): (isMatchingSignature(source, target, partialMatch)) */ TODO {
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(source.typeParameters) !== length(target.typeParameters) */ TODO {
			return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
		}
		if /* TODO(PropertyAccessExpression): target.typeParameters */ TODO {
			mapper := createTypeMapper( /* TODO(NonNullExpression): source.typeParameters! */ TODO /* TODO(PropertyAccessExpression): target.typeParameters */, TODO)
			/* TODO(ForStatement): for (let i = 0; i < target.typeParameters.length; i++) {                 const s = source.typeParameters![i];                 const t = target.typeParameters[i];                 if (                     !(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&                             compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))                 ) {                     return Ternary.False;                 }             } */
			/* TODO(ExpressionStatement): source = instantiateSignature(source, mapper, /*eraseTypeParameters* / true); */
		}
		result := /* TODO(PropertyAccessExpression): Ternary.True */ TODO
		if !ignoreThisTypes {
			sourceThisType := getThisTypeOfSignature(source)
			if sourceThisType {
				targetThisType := getThisTypeOfSignature(target)
				if targetThisType {
					related := compareTypes(sourceThisType, targetThisType)
					if !related {
						return /* TODO(PropertyAccessExpression): Ternary.False */ TODO
					}
					/* TODO(ExpressionStatement): result &= related; */
				}
			}
		}
		targetLen := getParameterCount(target)
		/* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {             const s = getTypeAtPosition(source, i);             const t = getTypeAtPosition(target, i);             const related = compareTypes(t, s);             if (!related) {                 return Ternary.False;             }             result &= related;         } */
		if !ignoreReturnTypes {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			targetTypePredicate := getTypePredicateOfSignature(target)
			/* TODO(ExpressionStatement): result &= sourceTypePredicate || targetTypePredicate ?                 compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :                 compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target)); */
		}
		return result
	}
	compareTypePredicatesIdentical := func(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
		return /* TODO(ConditionalExpression): !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False :             source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type) :             Ternary.False */ TODO
	}
	literalTypesWithSameBaseType := func(types []Type) bool {
		var commonBaseType *Type
		for _, t := range types {
			if ! /* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Never) */ TODO {
				baseType := getBaseTypeOfLiteralType(t)
				/* TODO(ExpressionStatement): commonBaseType ??= baseType; */
				if baseType == t || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseType !== commonBaseType */ TODO {
					return /* TODO(FalseKeyword): false */ TODO
				}
			}
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getCombinedTypeFlags := func(types []Type) TypeFlags {
		return reduceLeft(types /* TODO(ArrowFunction): (flags, t) => flags | (t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags) */, TODO, 0 /* as */ /* TODO(TypeReference): TypeFlags */)
	}
	getCommonSupertype := func(types []Type) Type {
		if /* TODO(PropertyAccessExpression): types.length */ TODO == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		primaryTypes := /* TODO(ConditionalExpression): strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types */ TODO
		superTypeOrUnion := /* TODO(ConditionalExpression): literalTypesWithSameBaseType(primaryTypes) ?             getUnionType(primaryTypes) :             reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s)! */ TODO
		return /* TODO(ConditionalExpression): primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & TypeFlags.Nullable) */ TODO
	}
	getCommonSubtype := func(types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(NonNullExpression): reduceLeft(types, (s, t) => isTypeSubtypeOf(t, s) ? t : s)! */ TODO
	}
	isArrayType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO && /* TODO(ParenthesizedExpression): ((type as TypeReference).target === globalArrayType || (type as TypeReference).target === globalReadonlyArrayType) */ TODO
	}
	isReadonlyArrayType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO && /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO == globalReadonlyArrayType
	}
	isArrayOrTupleType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
		return isArrayType(type_) || isTupleType(type_)
	}
	isMutableArrayOrTuple := func(type_ Type) bool {
		return isArrayType(type_) && !isReadonlyArrayType(type_) || isTupleType(type_) && ! /* TODO(PropertyAccessExpression): type.target.readonly */ TODO
	}
	getElementTypeOfArrayType := func(type_ Type) *Type {
		return /* TODO(ConditionalExpression): isArrayType(type) ? getTypeArguments(type)[0] : undefined */ TODO
	}
	isArrayLikeType := func(type_ Type) bool {
		return isArrayType(type_) || ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Nullable) */ TODO && isTypeAssignableTo(type_, anyReadonlyArrayType)
	}
	isMutableArrayLikeType := func(type_ Type) bool {
		return isMutableArrayOrTuple(type_) || ! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.Any | TypeFlags.Nullable)) */ TODO && isTypeAssignableTo(type_, anyArrayType)
	}
	getSingleBaseForNonAugmentingSubtype := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO || ! /* TODO(ParenthesizedExpression): (getObjectFlags((type as TypeReference).target) & ObjectFlags.ClassOrInterface) */ TODO {
			return nil
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeCalculated */ TODO {
			return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? (type as TypeReference).cachedEquivalentBaseType : undefined */ TODO
		}
		/* TODO(ExpressionStatement): (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeCalculated; */
		target := /* TODO(PropertyAccessExpression): (type as TypeReference).target */ TODO /* as */ /* TODO(TypeReference): InterfaceType */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Class */ TODO {
			baseTypeNode := getBaseTypeNodeOfClass(target)
			if baseTypeNode && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseTypeNode.expression.kind !== SyntaxKind.Identifier */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseTypeNode.expression.kind !== SyntaxKind.PropertyAccessExpression */ TODO {
				return nil
			}
		}
		bases := getBaseTypes(target)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): bases.length !== 1 */ TODO {
			return nil
		}
		if /* TODO(PropertyAccessExpression): getMembersOfSymbol(type.symbol).size */ TODO {
			return nil
		}
		instantiatedBase := /* TODO(ConditionalExpression): !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length))) */ TODO
		if length(getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)) > length( /* TODO(PropertyAccessExpression): target.typeParameters */ TODO) {
			/* TODO(ExpressionStatement): instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type as TypeReference))); */
		}
		/* TODO(ExpressionStatement): (type as TypeReference).objectFlags |= ObjectFlags.IdenticalBaseTypeExists; */
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as TypeReference).cachedEquivalentBaseType = instantiatedBase */ TODO
	}
	isEmptyLiteralType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): strictNullChecks ? type === implicitNeverType : type === undefinedWideningType */ TODO
	}
	isEmptyArrayLiteralType := func(type_ Type) bool {
		elementType := getElementTypeOfArrayType(type_)
		return !!elementType && isEmptyLiteralType(elementType)
	}
	isTupleLikeType := func(type_ Type) bool {
		var lengthType TODO
		return isTupleType(type_) || !!getPropertyOfType(type_, "0" /* as */ /* TODO(TypeReference): __String */) || isArrayLikeType(type_) && !! /* TODO(ParenthesizedExpression): (lengthType = getTypeOfPropertyOfType(type, "length" as __String)) */ TODO && everyType(lengthType /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.NumberLiteral) */, TODO)
	}
	isArrayOrTupleLikeType := func(type_ Type) bool {
		return isArrayLikeType(type_) || isTupleLikeType(type_)
	}
	getTupleElementType := func(type_ Type, index number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		propType := getTypeOfPropertyOfType(type_ /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + index */, TODO /* as */ /* TODO(TypeReference): __String */)
		if propType {
			return propType
		}
		if everyType(type_, isTupleType) {
			return getTupleElementTypeOutOfStartCount(type_, index /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined */, TODO)
		}
		return nil
	}
	isNeitherUnitTypeNorNever := func(type_ Type) bool {
		return ! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.Unit | TypeFlags.Never)) */ TODO
	}
	isUnitType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Unit) */ TODO
	}
	isUnitLikeType := func(type_ Type) bool {
		t := getBaseConstraintOrType(type_)
		return /* TODO(ConditionalExpression): t.flags & TypeFlags.Intersection ? some((t as IntersectionType).types, isUnitType) : isUnitType(t) */ TODO
	}
	extractUnitType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ? find((type as IntersectionType).types, isUnitType) || type : type */ TODO
	}
	isLiteralType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Boolean ? true :             type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every((type as UnionType).types, isUnitType) :             isUnitType(type) */ TODO
	}
	getBaseTypeOfLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & TypeFlags.NumberLiteral ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? getBaseTypeOfLiteralTypeUnion(type as UnionType) :             type */ TODO
	}
	getBaseTypeOfLiteralTypeUnion := func(type_ UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `B${getTypeId(type)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
	}
	getBaseTypeOfLiteralTypeForComparison := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & (TypeFlags.NumberLiteral | TypeFlags.Enum) ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? mapType(type, getBaseTypeOfLiteralTypeForComparison) :             type */ TODO
	}
	getWidenedLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && isFreshLiteralType(type) ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType :             type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(type) ? numberType :             type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(type) ? bigintType :             type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type) ? booleanType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedLiteralType) :             type */ TODO
	}
	getWidenedUniqueESSymbolType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedUniqueESSymbolType) :             type */ TODO
	}
	getWidenedLiteralLikeTypeForContextualType := func(type_ Type, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !isLiteralOfContextualType(type_, contextualType) {
			/* TODO(ExpressionStatement): type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type)); */
		}
		return getRegularTypeOfLiteralType(type_)
	}
	getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, isAsync bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :                 contextualSignatureReturnType */ TODO
			/* TODO(ExpressionStatement): type = getWidenedLiteralLikeTypeForContextualType(type, contextualType); */
		}
		return type_
	}
	getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, kind IterationTypeKind, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator) */ TODO
			/* TODO(ExpressionStatement): type = getWidenedLiteralLikeTypeForContextualType(type, contextualType); */
		}
		return type_
	}
	isTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target.objectFlags & ObjectFlags.Tuple) */ TODO
	}
	isGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
		return isTupleType(type_) && !! /* TODO(ParenthesizedExpression): (type.target.combinedFlags & ElementFlags.Variadic) */ TODO
	}
	isSingleElementGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
		return isGenericTupleType(type_) && /* TODO(PropertyAccessExpression): type.target.elementFlags.length */ TODO == 1
	}
	getRestTypeOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return getElementTypeOfSliceOfTupleType(type_ /* TODO(PropertyAccessExpression): type.target.fixedLength */, TODO)
	}
	getTupleElementTypeOutOfStartCount := func(type_ Type, index number, undefinedOrMissingType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return mapType(type_ /* TODO(ArrowFunction): t => {             const tupleType = t as TupleTypeReference;             const restType = getRestTypeOfTupleType(tupleType);             if (!restType) {                 return undefinedType;             }             if (undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target)) {                 return getUnionType([restType, undefinedOrMissingType]);             }             return restType;         } */, TODO)
	}
	getRestArrayTypeOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | undefined */ TODO {
		restType := getRestTypeOfTupleType(type_)
		return restType && createArrayType(restType)
	}
	getElementTypeOfSliceOfTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */, writing /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, noReductions /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		length := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
		if index < length {
			typeArguments := getTypeArguments(type_)
			var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ForStatement): for (let i = index; i < length; i++) {                 const t = typeArguments[i];                 elementTypes.push(type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);             } */
			return /* TODO(ConditionalExpression): writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) */ TODO
		}
		return nil
	}
	isTupleTypeStructureMatching := func(t1 TupleTypeReference, t2 TupleTypeReference) /* TODO(undefined): boolean */ TODO {
		return getTypeReferenceArity(t1) == getTypeReferenceArity(t2) && every( /* TODO(PropertyAccessExpression): t1.target.elementFlags */ TODO /* TODO(ArrowFunction): (f, i) => (f & ElementFlags.Variable) === (t2.target.elementFlags[i] & ElementFlags.Variable) */, TODO)
	}
	isZeroBigInt := func(TODO_IDENTIFIER BigIntLiteralType) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): value.base10Value */ TODO == "0"
	}
	removeDefinitelyFalsyTypes := func(type_ Type) Type {
		return filterType(type_ /* TODO(ArrowFunction): t => hasTypeFacts(t, TypeFacts.Truthy) */, TODO)
	}
	extractDefinitelyFalsyTypes := func(type_ Type) Type {
		return mapType(type_, getDefinitelyFalsyPartOfType)
	}
	getDefinitelyFalsyPartOfType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? emptyStringType :             type.flags & TypeFlags.Number ? zeroType :             type.flags & TypeFlags.BigInt ? zeroBigIntType :             type === regularFalseType ||                 type === falseType ||                 type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) ||                 type.flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" ||                 type.flags & TypeFlags.NumberLiteral && (type as NumberLiteralType).value === 0 ||                 type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(type as BigIntLiteralType) ? type :             neverType */ TODO
	}
	getNullableType := func(type_ Type, flags TypeFlags) Type {
		missing := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (flags & ~type.flags) & (TypeFlags.Undefined | TypeFlags.Null) */ TODO
		return /* TODO(ConditionalExpression): missing === 0 ? type :             missing === TypeFlags.Undefined ? getUnionType([type, undefinedType]) :             missing === TypeFlags.Null ? getUnionType([type, nullType]) :             getUnionType([type, undefinedType, nullType]) */ TODO
	}
	getOptionalType := func(type_ Type, isProperty /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Type {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(strictNullChecks)
		missingOrUndefined := /* TODO(ConditionalExpression): isProperty ? undefinedOrMissingType : undefinedType */ TODO
		return /* TODO(ConditionalExpression): type === missingOrUndefined || type.flags & TypeFlags.Union && (type as UnionType).types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]) */ TODO
	}
	getGlobalNonNullableTypeInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !deferredGlobalNonNullableTypeAlias {
			/* TODO(ExpressionStatement): deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable" as __String, SymbolFlags.TypeAlias, /*diagnostic* / undefined) || unknownSymbol; */
		}
		return /* TODO(ConditionalExpression): deferredGlobalNonNullableTypeAlias !== unknownSymbol ?             getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :             getIntersectionType([type, emptyObjectType]) */ TODO
	}
	getNonNullableType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): strictNullChecks ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
	}
	addOptionalTypeMarker := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([type, optionalType]) : type */ TODO
	}
	removeOptionalTypeMarker := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): strictNullChecks ? removeType(type, optionalType) : type */ TODO
	}
	propagateOptionalTypeMarker := func(type_ Type, node OptionalChain, wasOptional bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type */ TODO
	}
	getOptionalExpressionType := func(exprType Type, expression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :             isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :             exprType */ TODO
	}
	removeMissingType := func(type_ Type, isOptional bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type */ TODO
	}
	containsMissingType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return type_ == missingType || !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union) */ TODO && /* TODO(ElementAccessExpression): (type as UnionType).types[0] */ TODO == missingType
	}
	removeMissingOrUndefinedType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, TypeFacts.NEUndefined) */ TODO
	}
	isCoercibleUnderDoubleEquals := func(source Type, target Type) bool {
		return /* TODO(ParenthesizedExpression): ((source.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.BooleanLiteral)) !== 0) */ TODO && /* TODO(ParenthesizedExpression): ((target.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.Boolean)) !== 0) */ TODO
	}
	isObjectTypeWithInferableIndex := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection             ? every((type as IntersectionType).types, isObjectTypeWithInferableIndex)             : !!(                 type.symbol                 && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0                 && !(type.symbol.flags & SymbolFlags.Class)                 && !typeHasCallOrConstructSignatures(type)             ) || !!(                 objectFlags & ObjectFlags.ObjectRestType             ) || !!(objectFlags & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source)) */ TODO
	}
	createSymbolWithType := func(source Symbol, type_ *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol( /* TODO(PropertyAccessExpression): source.flags */ TODO /* TODO(PropertyAccessExpression): source.escapedName */, TODO /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(source) & CheckFlags.Readonly */, TODO)
		/* TODO(ExpressionStatement): symbol.declarations = source.declarations; */
		/* TODO(ExpressionStatement): symbol.parent = source.parent; */
		/* TODO(ExpressionStatement): symbol.links.type = type; */
		/* TODO(ExpressionStatement): symbol.links.target = source; */
		if /* TODO(PropertyAccessExpression): source.valueDeclaration */ TODO {
			/* TODO(ExpressionStatement): symbol.valueDeclaration = source.valueDeclaration; */
		}
		nameType := /* TODO(PropertyAccessExpression): getSymbolLinks(source).nameType */ TODO
		if nameType {
			/* TODO(ExpressionStatement): symbol.links.nameType = nameType; */
		}
		return symbol
	}
	transformTypeOfMembers := func(type_ Type, f func(propertyType Type) Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
		members := createSymbolTable()
		for _, property := range getPropertiesOfObjectType(type_) {
			original := getTypeOfSymbol(property)
			updated := f(original)
			/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): property.escapedName */ TODO /* TODO(ConditionalExpression): updated === original ? property : createSymbolWithType(property, updated) */, TODO)
		}
		return members
	}
	getRegularTypeOfObjectLiteral := func(type_ Type) Type {
		if ! /* TODO(ParenthesizedExpression): (isObjectLiteralType(type) && getObjectFlags(type) & ObjectFlags.FreshLiteral) */ TODO {
			return type_
		}
		regularType := /* TODO(PropertyAccessExpression): (type as FreshObjectLiteralType).regularType */ TODO
		if regularType {
			return regularType
		}
		resolved := type_ /* as */ /* TODO(TypeReference): ResolvedType */
		members := transformTypeOfMembers(type_, getRegularTypeOfObjectLiteral)
		regularNew := createAnonymousType( /* TODO(PropertyAccessExpression): resolved.symbol */ TODO, members /* TODO(PropertyAccessExpression): resolved.callSignatures */, TODO /* TODO(PropertyAccessExpression): resolved.constructSignatures */, TODO /* TODO(PropertyAccessExpression): resolved.indexInfos */, TODO)
		/* TODO(ExpressionStatement): regularNew.flags = resolved.flags; */
		/* TODO(ExpressionStatement): regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlags.FreshLiteral; */
		/* TODO(ExpressionStatement): (type as FreshObjectLiteralType).regularType = regularNew; */
		return regularNew
	}
	createWideningContext := func(parent *WideningContext, propertyName *__String, siblings /* TODO(ArrayType): Type[] */ any) WideningContext {
		return /* TODO(ObjectLiteralExpression): { parent, propertyName, siblings, resolvedProperties: undefined } */ TODO
	}
	getSiblingsOfContext := func(context WideningContext) []Type {
		if ! /* TODO(PropertyAccessExpression): context.siblings */ TODO {
			var siblings []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, type_ := range getSiblingsOfContext( /* TODO(NonNullExpression): context.parent! */ TODO) {
				if isObjectLiteralType(type_) {
					prop := getPropertyOfObjectType(type_ /* TODO(NonNullExpression): context.propertyName! */, TODO)
					if prop {
						forEachType(getTypeOfSymbol(prop) /* TODO(ArrowFunction): t => {                             siblings.push(t);                         } */, TODO)
					}
				}
			}
			/* TODO(ExpressionStatement): context.siblings = siblings; */
		}
		return /* TODO(PropertyAccessExpression): context.siblings */ TODO
	}
	getPropertiesOfContext := func(context WideningContext) []Symbol {
		if ! /* TODO(PropertyAccessExpression): context.resolvedProperties */ TODO {
			names := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
			for _, t := range getSiblingsOfContext(context) {
				if isObjectLiteralType(t) && ! /* TODO(ParenthesizedExpression): (getObjectFlags(t) & ObjectFlags.ContainsSpread) */ TODO {
					for _, prop := range getPropertiesOfType(t) {
						/* TODO(PropertyAccessExpression): names.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, prop)
					}
				}
			}
			/* TODO(ExpressionStatement): context.resolvedProperties = arrayFrom(names.values()); */
		}
		return /* TODO(PropertyAccessExpression): context.resolvedProperties */ TODO
	}
	getWidenedProperty := func(prop Symbol, context *WideningContext) Symbol {
		if ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.Property) */ TODO {
			return prop
		}
		original := getTypeOfSymbol(prop)
		propContext := context && createWideningContext(context /* TODO(PropertyAccessExpression): prop.escapedName */, TODO, nil)
		widened := getWidenedTypeWithContext(original, propContext)
		return /* TODO(ConditionalExpression): widened === original ? prop : createSymbolWithType(prop, widened) */ TODO
	}
	getUndefinedProperty := func(prop Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		cached := /* TODO(PropertyAccessExpression): undefinedProperties.get */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO)
		if cached {
			return cached
		}
		result := createSymbolWithType(prop, undefinedOrMissingType)
		/* TODO(ExpressionStatement): result.flags |= SymbolFlags.Optional; */
		/* TODO(PropertyAccessExpression): undefinedProperties.set */
		TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, result)
		return result
	}
	getWidenedTypeOfObjectLiteral := func(type_ Type, context *WideningContext) Type {
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, getWidenedProperty(prop, context))
		}
		if context {
			for _, prop := range getPropertiesOfContext(context) {
				if ! /* TODO(PropertyAccessExpression): members.has */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO) {
					/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, getUndefinedProperty(prop))
				}
			}
		}
		result := createAnonymousType( /* TODO(PropertyAccessExpression): type.symbol */ TODO, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type_) /* TODO(ArrowFunction): info => createIndexInfo(info.keyType, getWidenedType(info.type), info.isReadonly) */, TODO))
		/* TODO(ExpressionStatement): result.objectFlags |= getObjectFlags(type) & (ObjectFlags.JSLiteral | ObjectFlags.NonInferrableType); */
		return result
	}
	getWidenedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getWidenedTypeWithContext(type_, nil)
	}
	getWidenedTypeWithContext := func(type_ Type, context *WideningContext) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.RequiresWidening */ TODO {
			if context == nil && /* TODO(PropertyAccessExpression): type.widened */ TODO {
				return /* TODO(PropertyAccessExpression): type.widened */ TODO
			}
			var result *Type
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.Any | TypeFlags.Nullable) */ TODO {
				/* TODO(ExpressionStatement): result = anyType; */
			} else if isObjectLiteralType(type_) {
				/* TODO(ExpressionStatement): result = getWidenedTypeOfObjectLiteral(type, context); */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
				unionContext := context || createWideningContext(nil, nil /* TODO(PropertyAccessExpression): (type as UnionType).types */, TODO)
				widenedTypes := sameMap( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO /* TODO(ArrowFunction): t => t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext) */, TODO)
				/* TODO(ExpressionStatement): result = getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal); */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
				/* TODO(ExpressionStatement): result = getIntersectionType(sameMap((type as IntersectionType).types, getWidenedType)); */
			} else if isArrayOrTupleType(type_) {
				/* TODO(ExpressionStatement): result = createTypeReference(type.target, sameMap(getTypeArguments(type), getWidenedType)); */
			}
			if result && context == nil {
				/* TODO(ExpressionStatement): type.widened = result; */
			}
			return result || type_
		}
		return type_
	}
	reportWideningErrorsInType := func(type_ Type) bool {
		errorReported := /* TODO(FalseKeyword): false */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.ContainsWideningType */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
				if some( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO, isEmptyObjectType) {
					/* TODO(ExpressionStatement): errorReported = true; */
				} else {
					for _, t := range /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO {
						/* TODO(ExpressionStatement): errorReported ||= reportWideningErrorsInType(t); */
					}
				}
			} else if isArrayOrTupleType(type_) {
				for _, t := range getTypeArguments(type_) {
					/* TODO(ExpressionStatement): errorReported ||= reportWideningErrorsInType(t); */
				}
			} else if isObjectLiteralType(type_) {
				for _, p := range getPropertiesOfObjectType(type_) {
					t := getTypeOfSymbol(p)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(t) & ObjectFlags.ContainsWideningType */ TODO {
						/* TODO(ExpressionStatement): errorReported = reportWideningErrorsInType(t); */
						if !errorReported {
							valueDeclaration := /* TODO(PropertyAccessExpression): p.declarations?.find */ TODO( /* TODO(ArrowFunction): d => d.symbol.valueDeclaration?.parent === type.symbol.valueDeclaration */ TODO)
							if valueDeclaration {
								error(valueDeclaration /* TODO(PropertyAccessExpression): Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type */, TODO, symbolToString(p), typeToString(getWidenedType(t)))
								/* TODO(ExpressionStatement): errorReported = true; */
							}
						}
					}
				}
			}
		}
		return errorReported
	}
	reportImplicitAny := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		typeAsString := typeToString(getWidenedType(type_))
		if isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions) {
			return
		}
		var diagnostic DiagnosticMessage
		/* TODO(SwitchStatement): switch (declaration.kind) {             case SyntaxKind.BinaryExpression:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:                 diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;                 break;             case SyntaxKind.Parameter:                 const param = declaration as ParameterDeclaration;                 if (isIdentifier(param.name)) {                     const originalKeywordKind = identifierToKeywordKind(param.name);                     if (                         (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) &&                         param.parent.parameters.includes(param) &&                         (resolveName(param, param.name.escapedText, SymbolFlags.Type, /*nameNotFoundMessage* / undefined, /*isUse* / true) ||                             originalKeywordKind && isTypeNodeKind(originalKeywordKind))                     ) {                         const newName = "arg" + param.parent.parameters.indexOf(param);                         const typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");                         errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);                         return;                     }                 }                 diagnostic = (declaration as ParameterDeclaration).dotDotDotToken ?                     noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage :                     noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;                 break;             case SyntaxKind.BindingElement:                 diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;                 if (!noImplicitAny) {                     // Don't issue a suggestion for binding elements since the codefix doesn't yet support them.                     return;                 }                 break;             case SyntaxKind.JSDocFunctionType:                 error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);                 return;             case SyntaxKind.JSDocSignature:                 if (noImplicitAny && isJSDocOverloadTag(declaration.parent)) {                     error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString);                 }                 return;             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 if (noImplicitAny && !(declaration as NamedDeclaration).name) {                     if (wideningKind === WideningKind.GeneratorYield) {                         error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);                     }                     else {                         error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);                     }                     return;                 }                 diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage :                     wideningKind === WideningKind.GeneratorYield ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type :                     Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;                 break;             case SyntaxKind.MappedType:                 if (noImplicitAny) {                     error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);                 }                 return;             default:                 diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;         } */
		errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString)
	}
	reportErrorsFromWidening := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		addLazyDiagnostic( /* TODO(ArrowFunction): () => {             if (noImplicitAny && getObjectFlags(type) & ObjectFlags.ContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration as FunctionLikeDeclaration))) {                 // Report implicit any error within type if possible, otherwise report error on declaration                 if (!reportWideningErrorsInType(type)) {                     reportImplicitAny(declaration, type, wideningKind);                 }             }         } */ TODO)
	}
	applyToParameterTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		sourceCount := getParameterCount(source)
		targetCount := getParameterCount(target)
		sourceRestType := getEffectiveRestType(source)
		targetRestType := getEffectiveRestType(target)
		targetNonRestCount := /* TODO(ConditionalExpression): targetRestType ? targetCount - 1 : targetCount */ TODO
		paramCount := /* TODO(ConditionalExpression): sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount) */ TODO
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				callback(sourceThisType, targetThisType)
			}
		}
		/* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));         } */
		if targetRestType {
			callback(getRestTypeAtPosition(source, paramCount, isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType)
		}
	}
	applyToReturnTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		targetTypePredicate := getTypePredicateOfSignature(target)
		if targetTypePredicate {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			if sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && /* TODO(PropertyAccessExpression): sourceTypePredicate.type */ TODO && /* TODO(PropertyAccessExpression): targetTypePredicate.type */ TODO {
				callback( /* TODO(PropertyAccessExpression): sourceTypePredicate.type */ TODO /* TODO(PropertyAccessExpression): targetTypePredicate.type */, TODO)
				return
			}
		}
		targetReturnType := getReturnTypeOfSignature(target)
		if couldContainTypeVariables(targetReturnType) {
			callback(getReturnTypeOfSignature(source), targetReturnType)
		}
	}
	createInferenceContext := func(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		return createInferenceContextWorker( /* TODO(PropertyAccessExpression): typeParameters.map */ TODO(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable)
	}
	cloneInferenceContext := func(context T, extraFlags InferenceFlags /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(UnionType): InferenceContext | T & undefined */ any {
		return context && createInferenceContextWorker(map_( /* TODO(PropertyAccessExpression): context.inferences */ TODO, cloneInferenceInfo) /* TODO(PropertyAccessExpression): context.signature */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): context.flags | extraFlags */, TODO /* TODO(PropertyAccessExpression): context.compareTypes */, TODO)
	}
	createInferenceContextWorker := func(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		var context InferenceContext = /* TODO(ObjectLiteralExpression): {             inferences,             signature,             flags,             compareTypes,             mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction             nonFixingMapper: reportUnmeasurableMapper,         } */ TODO
		/* TODO(ExpressionStatement): context.mapper = makeFixingMapperForContext(context); */
		/* TODO(ExpressionStatement): context.nonFixingMapper = makeNonFixingMapperForContext(context); */
		return context
	}
	makeFixingMapperForContext := func(context InferenceContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return makeDeferredTypeMapper(map_( /* TODO(PropertyAccessExpression): context.inferences */ TODO /* TODO(ArrowFunction): i => i.typeParameter */, TODO), map_( /* TODO(PropertyAccessExpression): context.inferences */ TODO /* TODO(ArrowFunction): (inference, i) => () => {                 if (!inference.isFixed) {                     // Before we commit to a particular inference (and thus lock out any further inferences),                     // we infer from any intra-expression inference sites we have collected.                     inferFromIntraExpressionSites(context);                     clearCachedInferences(context.inferences);                     inference.isFixed = true;                 }                 return getInferredType(context, i);             } */, TODO))
	}
	makeNonFixingMapperForContext := func(context InferenceContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return makeDeferredTypeMapper(map_( /* TODO(PropertyAccessExpression): context.inferences */ TODO /* TODO(ArrowFunction): i => i.typeParameter */, TODO), map_( /* TODO(PropertyAccessExpression): context.inferences */ TODO /* TODO(ArrowFunction): (_, i) => () => {                 return getInferredType(context, i);             } */, TODO))
	}
	clearCachedInferences := func(inferences []InferenceInfo) {
		for _, inference := range inferences {
			if ! /* TODO(PropertyAccessExpression): inference.isFixed */ TODO {
				/* TODO(ExpressionStatement): inference.inferredType = undefined; */
			}
		}
	}
	addIntraExpressionInferenceSite := func(context InferenceContext, node /* TODO(UnionType): Expression | MethodDeclaration */ any, type_ Type) {
		/* TODO(PropertyAccessExpression): (context.intraExpressionInferenceSites ??= []).push */ TODO( /* TODO(ObjectLiteralExpression): { node, type } */ TODO)
	}
	inferFromIntraExpressionSites := func(context InferenceContext) {
		if /* TODO(PropertyAccessExpression): context.intraExpressionInferenceSites */ TODO {
			for _, TODO_IDENTIFIER := range /* TODO(PropertyAccessExpression): context.intraExpressionInferenceSites */ TODO {
				contextualType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodDeclaration ?                     getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) :                     getContextualType(node, ContextFlags.NoConstraints) */ TODO
				if contextualType {
					inferTypes( /* TODO(PropertyAccessExpression): context.inferences */ TODO, type_, contextualType)
				}
			}
			/* TODO(ExpressionStatement): context.intraExpressionInferenceSites = undefined; */
		}
	}
	createInferenceInfo := func(typeParameter TypeParameter) InferenceInfo {
		return /* TODO(ObjectLiteralExpression): {             typeParameter,             candidates: undefined,             contraCandidates: undefined,             inferredType: undefined,             priority: undefined,             topLevel: true,             isFixed: false,             impliedArity: undefined,         } */ TODO
	}
	cloneInferenceInfo := func(inference InferenceInfo) InferenceInfo {
		return /* TODO(ObjectLiteralExpression): {             typeParameter: inference.typeParameter,             candidates: inference.candidates && inference.candidates.slice(),             contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),             inferredType: inference.inferredType,             priority: inference.priority,             topLevel: inference.topLevel,             isFixed: inference.isFixed,             impliedArity: inference.impliedArity,         } */ TODO
	}
	cloneInferredPartOfContext := func(context InferenceContext) *InferenceContext {
		inferences := filter( /* TODO(PropertyAccessExpression): context.inferences */ TODO, hasInferenceCandidates)
		return /* TODO(ConditionalExpression): inferences.length ?             createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) :             undefined */ TODO
	}
	getMapperFromContext := func(context T) /* TODO(UnionType): TypeMapper | T & undefined */ any {
		return context && /* TODO(PropertyAccessExpression): context.mapper */ TODO
	}
	couldContainTypeVariables := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): objectFlags & ObjectFlags.CouldContainTypeVariablesComputed */ TODO {
			return !! /* TODO(ParenthesizedExpression): (objectFlags & ObjectFlags.CouldContainTypeVariables) */ TODO
		}
		result := !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Instantiable ||             type.flags & TypeFlags.Object && !isNonGenericTopLevelType(type) && (                     objectFlags & ObjectFlags.Reference && ((type as TypeReference).node || some(getTypeArguments(type as TypeReference), couldContainTypeVariables)) ||                     objectFlags & ObjectFlags.SingleSignatureType && !!length((type as SingleSignatureType).outerTypeParameters) ||                     objectFlags & ObjectFlags.Anonymous && type.symbol && type.symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.TypeLiteral | SymbolFlags.ObjectLiteral) && type.symbol.declarations ||                     objectFlags & (ObjectFlags.Mapped | ObjectFlags.ReverseMapped | ObjectFlags.ObjectRestType | ObjectFlags.InstantiationExpressionType)                 ) ||             type.flags & TypeFlags.UnionOrIntersection && !(type.flags & TypeFlags.EnumLiteral) && !isNonGenericTopLevelType(type) && some((type as UnionOrIntersectionType).types, couldContainTypeVariables)) */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.ObjectFlagsType */ TODO {
			/* TODO(ExpressionStatement): (type as ObjectFlagsType).objectFlags |= ObjectFlags.CouldContainTypeVariablesComputed | (result ? ObjectFlags.CouldContainTypeVariables : 0); */
		}
		return result
	}
	isNonGenericTopLevelType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO && ! /* TODO(PropertyAccessExpression): type.aliasTypeArguments */ TODO {
			declaration := getDeclarationOfKind( /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO /* TODO(PropertyAccessExpression): SyntaxKind.TypeAliasDeclaration */, TODO)
			return !! /* TODO(ParenthesizedExpression): (declaration && findAncestor(declaration.parent, n => n.kind === SyntaxKind.SourceFile ? true : n.kind === SyntaxKind.ModuleDeclaration ? false : "quit")) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isTypeParameterAtTopLevel := func(type_ Type, tp TypeParameter, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) bool {
		return !! /* TODO(ParenthesizedExpression): (type === tp ||             type.flags & TypeFlags.UnionOrIntersection && some((type as UnionOrIntersectionType).types, t => isTypeParameterAtTopLevel(t, tp, depth)) ||             depth < 3 && type.flags & TypeFlags.Conditional && (                     isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type as ConditionalType), tp, depth + 1) ||                     isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type as ConditionalType), tp, depth + 1)                 )) */ TODO
	}
	isTypeParameterAtTopLevelInReturnType := func(signature Signature, typeParameter TypeParameter) /* TODO(undefined): boolean */ TODO {
		typePredicate := getTypePredicateOfSignature(signature)
		return /* TODO(ConditionalExpression): typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) :             isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter) */ TODO
	}
	createEmptyObjectTypeFromStringLiteral := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
		members := createSymbolTable()
		forEachType(type_ /* TODO(ArrowFunction): t => {             if (!(t.flags & TypeFlags.StringLiteral)) {                 return;             }             const name = escapeLeadingUnderscores((t as StringLiteralType).value);             const literalProp = createSymbol(SymbolFlags.Property, name);             literalProp.links.type = anyType;             if (t.symbol) {                 literalProp.declarations = t.symbol.declarations;                 literalProp.valueDeclaration = t.symbol.valueDeclaration;             }             members.set(name, literalProp);         } */, TODO)
		indexInfos := /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly* / false)] : emptyArray */ TODO
		return createAnonymousType(nil, members, emptyArray, emptyArray, indexInfos)
	}
	inferTypeForHomomorphicMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
		if /* TODO(PropertyAccessExpression): reverseHomomorphicMappedCache.has */ TODO(cacheKey) {
			return /* TODO(PropertyAccessExpression): reverseHomomorphicMappedCache.get */ TODO(cacheKey)
		}
		type_ := createReverseMappedType(source, target, constraint)
		/* TODO(PropertyAccessExpression): reverseHomomorphicMappedCache.set */ TODO(cacheKey, type_)
		return type_
	}
	isPartiallyInferableType := func(type_ Type) bool {
		return ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.NonInferrableType) */ TODO || isObjectLiteralType(type_) && some(getPropertiesOfType(type_) /* TODO(ArrowFunction): prop => isPartiallyInferableType(getTypeOfSymbol(prop)) */, TODO) || isTupleType(type_) && some(getElementTypes(type_), isPartiallyInferableType)
	}
	createReverseMappedType := func(source Type, target MappedType, constraint IndexType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if ! /* TODO(ParenthesizedExpression): (getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(source)) */ TODO {
			return nil
		}
		if isArrayType(source) {
			elementType := inferReverseMappedType( /* TODO(ElementAccessExpression): getTypeArguments(source)[0] */ TODO, target, constraint)
			if !elementType {
				return nil
			}
			return createArrayType(elementType, isReadonlyArrayType(source))
		}
		if isTupleType(source) {
			elementTypes := map_(getElementTypes(source) /* TODO(ArrowFunction): t => inferReverseMappedType(t, target, constraint) */, TODO)
			if !every(elementTypes /* TODO(ArrowFunction): (t): t is Type => !!t */, TODO) {
				return nil
			}
			elementFlags := /* TODO(ConditionalExpression): getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ?                 sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :                 source.target.elementFlags */ TODO
			return createTupleType(elementTypes, elementFlags /* TODO(PropertyAccessExpression): source.target.readonly */, TODO /* TODO(PropertyAccessExpression): source.target.labeledElementDeclarations */, TODO)
		}
		reversed := createObjectType( /* TODO(BarToken): | */ /* TODO(BinaryExpression): ObjectFlags.ReverseMapped | ObjectFlags.Anonymous */ TODO, nil) /* as */ /* TODO(TypeReference): ReverseMappedType */
		/* TODO(ExpressionStatement): reversed.source = source; */
		/* TODO(ExpressionStatement): reversed.mappedType = target; */
		/* TODO(ExpressionStatement): reversed.constraintType = constraint; */
		return reversed
	}
	getTypeOfReverseMappedSymbol := func(symbol ReverseMappedSymbol) Type {
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			/* TODO(ExpressionStatement): links.type = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType; */
		}
		return /* TODO(PropertyAccessExpression): links.type */ TODO
	}
	inferReverseMappedTypeWorker := func(sourceType Type, target MappedType, constraint IndexType) Type {
		typeParameter := getIndexedAccessType( /* TODO(PropertyAccessExpression): constraint.type */ TODO, getTypeParameterFromMappedType(target)) /* as */ /* TODO(TypeReference): TypeParameter */
		templateType := getTemplateTypeFromMappedType(target)
		inference := createInferenceInfo(typeParameter)
		inferTypes( /* TODO(ArrayLiteralExpression): [inference] */ TODO, sourceType, templateType)
		return getTypeFromInference(inference) || unknownType
	}
	inferReverseMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
		if /* TODO(PropertyAccessExpression): reverseMappedCache.has */ TODO(cacheKey) {
			return /* TODO(PropertyAccessExpression): reverseMappedCache.get */ TODO(cacheKey) || unknownType
		}
		/* TODO(PropertyAccessExpression): reverseMappedSourceStack.push */ TODO(source)
		/* TODO(PropertyAccessExpression): reverseMappedTargetStack.push */ TODO(target)
		saveExpandingFlags := reverseExpandingFlags
		if isDeeplyNestedType(source, reverseMappedSourceStack /* TODO(PropertyAccessExpression): reverseMappedSourceStack.length */, TODO, 2) {
			/* TODO(BinaryExpression): reverseExpandingFlags |= ExpandingFlags.Source */
		}
		if isDeeplyNestedType(target, reverseMappedTargetStack /* TODO(PropertyAccessExpression): reverseMappedTargetStack.length */, TODO, 2) {
			/* TODO(BinaryExpression): reverseExpandingFlags |= ExpandingFlags.Target */
		}
		var type_ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): reverseExpandingFlags !== ExpandingFlags.Both */ TODO {
			/* TODO(ExpressionStatement): type = inferReverseMappedTypeWorker(source, target, constraint); */
		}
		/* TODO(PropertyAccessExpression): reverseMappedSourceStack.pop */ TODO()
		/* TODO(PropertyAccessExpression): reverseMappedTargetStack.pop */ TODO()
		/* TODO(ExpressionStatement): reverseExpandingFlags = saveExpandingFlags; */
		/* TODO(PropertyAccessExpression): reverseMappedCache.set */
		TODO(cacheKey, type_)
		return type_
	}
	getUnmatchedProperties := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
		properties := getPropertiesOfType(target)
		for _, targetProp := range properties {
			if isStaticPrivateIdentifierProperty(targetProp) {
				/* TODO(ContinueStatement): continue; */
			}
			if requireOptionalProperties || ! /* TODO(ParenthesizedExpression): (targetProp.flags & SymbolFlags.Optional || getCheckFlags(targetProp) & CheckFlags.Partial) */ TODO {
				sourceProp := getPropertyOfType(source /* TODO(PropertyAccessExpression): targetProp.escapedName */, TODO)
				if !sourceProp {
					/* TODO(ExpressionStatement): yield targetProp; */
				} else if matchDiscriminantProperties {
					targetType := getTypeOfSymbol(targetProp)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetType.flags & TypeFlags.Unit */ TODO {
						sourceType := getTypeOfSymbol(sourceProp)
						if ! /* TODO(ParenthesizedExpression): (sourceType.flags & TypeFlags.Any || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType)) */ TODO {
							/* TODO(ExpressionStatement): yield targetProp; */
						}
					}
				}
			}
		}
	}
	getUnmatchedProperty := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) *Symbol {
		return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
	}
	tupleTypesDefinitelyUnrelated := func(source TupleTypeReference, target TupleTypeReference) /* TODO(undefined): boolean */ TODO {
		return ! /* TODO(ParenthesizedExpression): (target.target.combinedFlags & ElementFlags.Variadic) */ TODO && /* TODO(PropertyAccessExpression): target.target.minLength */ TODO > /* TODO(PropertyAccessExpression): source.target.minLength */ TODO || ! /* TODO(ParenthesizedExpression): (target.target.combinedFlags & ElementFlags.Variable) */ TODO && /* TODO(ParenthesizedExpression): (!!(source.target.combinedFlags & ElementFlags.Variable) || target.target.fixedLength < source.target.fixedLength) */ TODO
	}
	typesDefinitelyUnrelated := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) :             !!getUnmatchedProperty(source, target, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / true) &&             !!getUnmatchedProperty(target, source, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / false) */ TODO
	}
	getTypeFromInference := func(inference InferenceInfo) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) :             inference.contraCandidates ? getIntersectionType(inference.contraCandidates) :             undefined */ TODO
	}
	hasSkipDirectInferenceFlag := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(PropertyAccessExpression): getNodeLinks(node).skipDirectInference */ TODO
	}
	isFromInferenceBlockedSource := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (type.symbol && some(type.symbol.declarations, hasSkipDirectInferenceFlag)) */ TODO
	}
	templateLiteralTypesDefinitelyUnrelated := func(source TemplateLiteralType, target TemplateLiteralType) /* TODO(undefined): boolean */ TODO {
		sourceStart := /* TODO(ElementAccessExpression): source.texts[0] */ TODO
		targetStart := /* TODO(ElementAccessExpression): target.texts[0] */ TODO
		sourceEnd := /* TODO(ElementAccessExpression): source.texts[source.texts.length - 1] */ TODO
		targetEnd := /* TODO(ElementAccessExpression): target.texts[target.texts.length - 1] */ TODO
		startLen := /* TODO(PropertyAccessExpression): Math.min */ TODO( /* TODO(PropertyAccessExpression): sourceStart.length */ TODO /* TODO(PropertyAccessExpression): targetStart.length */, TODO)
		endLen := /* TODO(PropertyAccessExpression): Math.min */ TODO( /* TODO(PropertyAccessExpression): sourceEnd.length */ TODO /* TODO(PropertyAccessExpression): targetEnd.length */, TODO)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceStart.slice(0, startLen) !== targetStart.slice(0, startLen) */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceEnd.slice(sourceEnd.length - endLen) !== targetEnd.slice(targetEnd.length - endLen) */ TODO
	}
	isValidNumberString := func(s string, roundTripOnly bool) bool {
		if s == "" {
			/* TODO(FalseKeyword): false */
		}
		n := +s
		return isFinite(n) && /* TODO(ParenthesizedExpression): (!roundTripOnly || "" + n === s) */ TODO
	}
	parseBigIntLiteralType := func(text string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BigIntLiteralType */ TODO {
		return getBigIntLiteralType(parseValidBigInt(text))
	}
	isMemberOfStringMapping := func(source Type, target Type) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Any */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & (TypeFlags.String | TypeFlags.TemplateLiteral) */ TODO {
			return isTypeAssignableTo(source, target)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.StringMapping */ TODO {
			mappingStack := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(WhileStatement): while (target.flags & TypeFlags.StringMapping) {                 mappingStack.unshift(target.symbol);                 target = (target as StringMappingType).type;             } */
			mappedSource := reduceLeft(mappingStack /* TODO(ArrowFunction): (memo, value) => getStringMappingType(value, memo) */, TODO, source)
			return mappedSource == source && isMemberOfStringMapping(source, target)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isValidTypeForTemplateLiteralPlaceholder := func(source Type, target Type) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO {
			return every( /* TODO(PropertyAccessExpression): (target as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => t === emptyTypeLiteralType || isValidTypeForTemplateLiteralPlaceholder(source, t) */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.String */ TODO || isTypeAssignableTo(source, target) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.StringLiteral */ TODO {
			value := /* TODO(PropertyAccessExpression): (source as StringLiteralType).value */ TODO
			return !! /* TODO(ParenthesizedExpression): (target.flags & TypeFlags.Number && isValidNumberString(value, /*roundTripOnly* / false) ||                 target.flags & TypeFlags.BigInt && isValidBigIntString(value, /*roundTripOnly* / false) ||                 target.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) && value === (target as IntrinsicType).intrinsicName ||                 target.flags & TypeFlags.StringMapping && isMemberOfStringMapping(getStringLiteralType(value), target) ||                 target.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target as TemplateLiteralType)) */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.TemplateLiteral */ TODO {
			texts := /* TODO(PropertyAccessExpression): (source as TemplateLiteralType).texts */ TODO
			return /* TODO(PropertyAccessExpression): texts.length */ TODO == 2 && /* TODO(ElementAccessExpression): texts[0] */ TODO == "" && /* TODO(ElementAccessExpression): texts[1] */ TODO == "" && isTypeAssignableTo( /* TODO(ElementAccessExpression): (source as TemplateLiteralType).types[0] */ TODO, target)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	inferTypesFromTemplateLiteralType := func(source Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? inferFromLiteralPartsToTemplateLiteral([(source as StringLiteralType).value], emptyArray, target) :             source.flags & TypeFlags.TemplateLiteral ?             arrayIsEqualTo((source as TemplateLiteralType).texts, target.texts) ? map((source as TemplateLiteralType).types, (s, i) => {                 return isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])) ? s : getStringLikeTypeForType(s);             }) :                 inferFromLiteralPartsToTemplateLiteral((source as TemplateLiteralType).texts, (source as TemplateLiteralType).types, target) :             undefined */ TODO
	}
	isTypeMatchedByTemplateLiteralType := func(source Type, target TemplateLiteralType) bool {
		inferences := inferTypesFromTemplateLiteralType(source, target)
		return !!inferences && every(inferences /* TODO(ArrowFunction): (r, i) => isValidTypeForTemplateLiteralPlaceholder(r, target.types[i]) */, TODO)
	}
	getStringLikeTypeForType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Any | TypeFlags.StringLike) ? type : getTemplateLiteralType(["", ""], [type]) */ TODO
	}
	inferFromLiteralPartsToTemplateLiteral := func(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
		lastSourceIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceTexts.length - 1 */ TODO
		sourceStartText := /* TODO(ElementAccessExpression): sourceTexts[0] */ TODO
		sourceEndText := /* TODO(ElementAccessExpression): sourceTexts[lastSourceIndex] */ TODO
		targetTexts := /* TODO(PropertyAccessExpression): target.texts */ TODO
		lastTargetIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetTexts.length - 1 */ TODO
		targetStartText := /* TODO(ElementAccessExpression): targetTexts[0] */ TODO
		targetEndText := /* TODO(ElementAccessExpression): targetTexts[lastTargetIndex] */ TODO
		if lastSourceIndex == 0 && /* TODO(PropertyAccessExpression): sourceStartText.length */ TODO < /* TODO(PlusToken): + */ /* TODO(BinaryExpression): targetStartText.length + targetEndText.length */ TODO || ! /* TODO(PropertyAccessExpression): sourceStartText.startsWith */ TODO(targetStartText) || ! /* TODO(PropertyAccessExpression): sourceEndText.endsWith */ TODO(targetEndText) {
			/* TODO(Identifier): undefined */
		}
		remainingEndText := /* TODO(PropertyAccessExpression): sourceEndText.slice */ TODO(0 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceEndText.length - targetEndText.length */, TODO)
		var matches []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		seg := 0
		pos := /* TODO(PropertyAccessExpression): targetStartText.length */ TODO
		/* TODO(ForStatement): for (let i = 1; i < lastTargetIndex; i++) {             const delim = targetTexts[i];             if (delim.length > 0) {                 let s = seg;                 let p = pos;                 while (true) {                     p = getSourceText(s).indexOf(delim, p);                     if (p >= 0) break;                     s++;                     if (s === sourceTexts.length) return undefined;                     p = 0;                 }                 addMatch(s, p);                 pos += delim.length;             }             else if (pos < getSourceText(seg).length) {                 addMatch(seg, pos + 1);             }             else if (seg < lastSourceIndex) {                 addMatch(seg + 1, 0);             }             else {                 return undefined;             }         } */
		addMatch(lastSourceIndex /* TODO(PropertyAccessExpression): getSourceText(lastSourceIndex).length */, TODO)
		return matches
		getSourceText := func(index number) /* TODO(undefined): string */ TODO {
			return /* TODO(ConditionalExpression): index < lastSourceIndex ? sourceTexts[index] : remainingEndText */ TODO
		}
		addMatch := func(s number, p number) {
			matchType := /* TODO(ConditionalExpression): s === seg ?                 getStringLiteralType(getSourceText(s).slice(pos, p)) :                 getTemplateLiteralType(                     [sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)],                     sourceTypes.slice(seg, s),                 ) */ TODO
			/* TODO(PropertyAccessExpression): matches.push */ TODO(matchType)
			/* TODO(ExpressionStatement): seg = s; */
			/* TODO(ExpressionStatement): pos = p; */
		}
	}
	isTupleOfSelf := func(typeParameter TypeParameter, type_ Type) /* TODO(undefined): boolean */ TODO {
		return isTupleType(type_) && getTupleElementType(type_, 0) == getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type_, "1" /* as */ /* TODO(TypeReference): __String */)
	}
	inferTypes := func(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferencePriority */ TODO /* = */ /* TODO(PropertyAccessExpression): InferencePriority.None */, contravariant /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) {
		bivariant := /* TODO(FalseKeyword): false */ TODO
		var propagationType Type
		var inferencePriority number = /* TODO(PropertyAccessExpression): InferencePriority.MaxValue */ TODO
		var visited Map[string, number]
		var sourceStack []Type
		var targetStack []Type
		expandingFlags := /* TODO(PropertyAccessExpression): ExpandingFlags.None */ TODO
		inferFromTypes(originalSource, originalTarget)
		inferFromTypes := func(source Type, target Type) {
			if !couldContainTypeVariables(target) || isNoInferType(target) {
				return
			}
			if source == wildcardType || source == blockedStringType {
				savePropagationType := propagationType
				/* TODO(ExpressionStatement): propagationType = source; */
				inferFromTypes(target, target)
				/* TODO(ExpressionStatement): propagationType = savePropagationType; */
				return
			}
			if /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO && /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO == /* TODO(PropertyAccessExpression): target.aliasSymbol */ TODO {
				if /* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO {
					params := /* TODO(NonNullExpression): getSymbolLinks(source.aliasSymbol).typeParameters! */ TODO
					minParams := getMinTypeArgumentCount(params)
					sourceTypes := fillMissingTypeArguments( /* TODO(PropertyAccessExpression): source.aliasTypeArguments */ TODO, params, minParams, isInJSFile( /* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
					targetTypes := fillMissingTypeArguments( /* TODO(PropertyAccessExpression): target.aliasTypeArguments */ TODO, params, minParams, isInJSFile( /* TODO(PropertyAccessExpression): source.aliasSymbol.valueDeclaration */ TODO))
					inferFromTypeArguments(sourceTypes /* TODO(NonNullExpression): targetTypes! */, TODO, getAliasVariances( /* TODO(PropertyAccessExpression): source.aliasSymbol */ TODO))
				}
				return
			}
			if source == target && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.UnionOrIntersection */ TODO {
				for _, t := range /* TODO(PropertyAccessExpression): (source as UnionOrIntersectionType).types */ TODO {
					inferFromTypes(t, t)
				}
				return
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO {
				TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO /* TODO(PropertyAccessExpression): (target as UnionType).types */, TODO, isTypeOrBaseIdenticalTo)
				TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy)
				if /* TODO(PropertyAccessExpression): targets.length */ TODO == 0 {
					return
				}
				/* TODO(ExpressionStatement): target = getUnionType(targets); */
				if /* TODO(PropertyAccessExpression): sources.length */ TODO == 0 {
					inferWithPriority(source, target /* TODO(PropertyAccessExpression): InferencePriority.NakedTypeVariable */, TODO)
					return
				}
				/* TODO(ExpressionStatement): source = getUnionType(sources); */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Intersection */ TODO && !every( /* TODO(PropertyAccessExpression): (target as IntersectionType).types */ TODO, isNonGenericObjectType) {
				if ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Union) */ TODO {
					TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO /* TODO(PropertyAccessExpression): (target as IntersectionType).types */, TODO, isTypeIdenticalTo)
					if /* TODO(PropertyAccessExpression): sources.length */ TODO == 0 || /* TODO(PropertyAccessExpression): targets.length */ TODO == 0 {
						return
					}
					/* TODO(ExpressionStatement): source = getIntersectionType(sources); */
					/* TODO(ExpressionStatement): target = getIntersectionType(targets); */
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & (TypeFlags.IndexedAccess | TypeFlags.Substitution) */ TODO {
				if isNoInferType(target) {
					return
				}
				/* TODO(ExpressionStatement): target = getActualTypeVariable(target); */
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.TypeVariable */ TODO {
				if isFromInferenceBlockedSource(source) {
					return
				}
				inference := getInferenceInfoForType(target)
				if inference {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.NonInferrableType */ TODO || source == nonInferrableAnyType {
						return
					}
					if ! /* TODO(PropertyAccessExpression): inference.isFixed */ TODO {
						candidate := propagationType || source
						if candidate == blockedStringType {
							return
						}
						if /* TODO(PropertyAccessExpression): inference.priority */ TODO == nil || priority < /* TODO(PropertyAccessExpression): inference.priority */ TODO {
							/* TODO(ExpressionStatement): inference.candidates = undefined; */
							/* TODO(ExpressionStatement): inference.contraCandidates = undefined; */
							/* TODO(ExpressionStatement): inference.topLevel = true; */
							/* TODO(ExpressionStatement): inference.priority = priority; */
						}
						if priority == /* TODO(PropertyAccessExpression): inference.priority */ TODO {
							if isTupleOfSelf( /* TODO(PropertyAccessExpression): inference.typeParameter */ TODO, candidate) {
								return
							}
							if contravariant && !bivariant {
								if !contains( /* TODO(PropertyAccessExpression): inference.contraCandidates */ TODO, candidate) {
									/* TODO(ExpressionStatement): inference.contraCandidates = append(inference.contraCandidates, candidate); */
									clearCachedInferences(inferences)
								}
							} else if !contains( /* TODO(PropertyAccessExpression): inference.candidates */ TODO, candidate) {
								/* TODO(ExpressionStatement): inference.candidates = append(inference.candidates, candidate); */
								clearCachedInferences(inferences)
							}
						}
						if ! /* TODO(ParenthesizedExpression): (priority & InferencePriority.ReturnType) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.TypeParameter */ TODO && /* TODO(PropertyAccessExpression): inference.topLevel */ TODO && !isTypeParameterAtTopLevel(originalTarget, target /* as */ /* TODO(TypeReference): TypeParameter */) {
							/* TODO(ExpressionStatement): inference.topLevel = false; */
							clearCachedInferences(inferences)
						}
					}
					/* TODO(ExpressionStatement): inferencePriority = Math.min(inferencePriority, priority); */
					return
				}
				simplified := getSimplifiedType(target /* TODO(FalseKeyword): false */, TODO)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): simplified !== target */ TODO {
					inferFromTypes(source, simplified)
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.IndexedAccess */ TODO {
					indexType := getSimplifiedType( /* TODO(PropertyAccessExpression): (target as IndexedAccessType).indexType */ TODO /* TODO(FalseKeyword): false */, TODO)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): indexType.flags & TypeFlags.Instantiable */ TODO {
						simplified := distributeIndexOverObjectType(getSimplifiedType( /* TODO(PropertyAccessExpression): (target as IndexedAccessType).objectType */ TODO /* TODO(FalseKeyword): false */, TODO), indexType /* TODO(FalseKeyword): false */, TODO)
						if simplified && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): simplified !== target */ TODO {
							inferFromTypes(source, simplified)
						}
					}
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Reference */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Reference */ TODO && /* TODO(ParenthesizedExpression): (                     (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)                 ) */ TODO && ! /* TODO(ParenthesizedExpression): ((source as TypeReference).node && (target as TypeReference).node) */ TODO {
				inferFromTypeArguments(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), getVariances( /* TODO(PropertyAccessExpression): (source as TypeReference).target */ TODO))
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Index */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Index */ TODO {
				inferFromContravariantTypes( /* TODO(PropertyAccessExpression): (source as IndexType).type */ TODO /* TODO(PropertyAccessExpression): (target as IndexType).type */, TODO)
			} else if /* TODO(ParenthesizedExpression): (isLiteralType(source) || source.flags & TypeFlags.String) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Index */ TODO {
				empty := createEmptyObjectTypeFromStringLiteral(source)
				inferFromContravariantTypesWithPriority(empty /* TODO(PropertyAccessExpression): (target as IndexType).type */, TODO /* TODO(PropertyAccessExpression): InferencePriority.LiteralKeyof */, TODO)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.IndexedAccess */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.IndexedAccess */ TODO {
				inferFromTypes( /* TODO(PropertyAccessExpression): (source as IndexedAccessType).objectType */ TODO /* TODO(PropertyAccessExpression): (target as IndexedAccessType).objectType */, TODO)
				inferFromTypes( /* TODO(PropertyAccessExpression): (source as IndexedAccessType).indexType */ TODO /* TODO(PropertyAccessExpression): (target as IndexedAccessType).indexType */, TODO)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.StringMapping */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.StringMapping */ TODO {
				if /* TODO(PropertyAccessExpression): (source as StringMappingType).symbol */ TODO == /* TODO(PropertyAccessExpression): (target as StringMappingType).symbol */ TODO {
					inferFromTypes( /* TODO(PropertyAccessExpression): (source as StringMappingType).type */ TODO /* TODO(PropertyAccessExpression): (target as StringMappingType).type */, TODO)
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Substitution */ TODO {
				inferFromTypes( /* TODO(PropertyAccessExpression): (source as SubstitutionType).baseType */ TODO, target)
				inferWithPriority(getSubstitutionIntersection(source /* as */ /* TODO(TypeReference): SubstitutionType */), target /* TODO(PropertyAccessExpression): InferencePriority.SubstituteSource */, TODO)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Conditional */ TODO {
				invokeOnce(source, target /* as */ /* TODO(TypeReference): ConditionalType */, inferToConditionalType)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.UnionOrIntersection */ TODO {
				inferToMultipleTypes(source /* TODO(PropertyAccessExpression): (target as UnionOrIntersectionType).types */, TODO /* TODO(PropertyAccessExpression): target.flags */, TODO)
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
				sourceTypes := /* TODO(PropertyAccessExpression): (source as UnionOrIntersectionType).types */ TODO
				for _, sourceType := range sourceTypes {
					inferFromTypes(sourceType, target)
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.TemplateLiteral */ TODO {
				inferToTemplateLiteralType(source, target /* as */ /* TODO(TypeReference): TemplateLiteralType */)
			} else {
				/* TODO(ExpressionStatement): source = getReducedType(source); */
				if isGenericMappedType(source) && isGenericMappedType(target) {
					invokeOnce(source, target, inferFromGenericMappedTypes)
				}
				if ! /* TODO(ParenthesizedExpression): (priority & InferencePriority.NoConstraints && source.flags & (TypeFlags.Intersection | TypeFlags.Instantiable)) */ TODO {
					apparentSource := getApparentType(source)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): apparentSource !== source */ TODO && ! /* TODO(ParenthesizedExpression): (apparentSource.flags & (TypeFlags.Object | TypeFlags.Intersection)) */ TODO {
						return inferFromTypes(apparentSource, target)
					}
					/* TODO(ExpressionStatement): source = apparentSource; */
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & (TypeFlags.Object | TypeFlags.Intersection) */ TODO {
					invokeOnce(source, target, inferFromObjectTypes)
				}
			}
		}
		inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			/* TODO(ExpressionStatement): priority |= newPriority; */
			inferFromTypes(source, target)
			/* TODO(ExpressionStatement): priority = savePriority; */
		}
		inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			/* TODO(ExpressionStatement): priority |= newPriority; */
			inferFromContravariantTypes(source, target)
			/* TODO(ExpressionStatement): priority = savePriority; */
		}
		inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
			savePriority := priority
			/* TODO(ExpressionStatement): priority |= newPriority; */
			inferToMultipleTypes(source, targets, targetFlags)
			/* TODO(ExpressionStatement): priority = savePriority; */
		}
		invokeOnce := func(source Source, target Target, action func(source Source, target Target)) {
			key := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id */ TODO
			status := visited && /* TODO(PropertyAccessExpression): visited.get */ TODO(key)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): status !== undefined */ TODO {
				/* TODO(ExpressionStatement): inferencePriority = Math.min(inferencePriority, status); */
				return
			}
			/* TODO(PropertyAccessExpression): (visited || (visited = new Map<string, number>())).set */ TODO(key /* TODO(PropertyAccessExpression): InferencePriority.Circularity */, TODO)
			saveInferencePriority := inferencePriority
			/* TODO(ExpressionStatement): inferencePriority = InferencePriority.MaxValue; */
			saveExpandingFlags := expandingFlags
			/* TODO(PropertyAccessExpression): (sourceStack ??= []).push */ TODO(source)
			/* TODO(PropertyAccessExpression): (targetStack ??= []).push */ TODO(target)
			if isDeeplyNestedType(source, sourceStack /* TODO(PropertyAccessExpression): sourceStack.length */, TODO, 2) {
				/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Source */
			}
			if isDeeplyNestedType(target, targetStack /* TODO(PropertyAccessExpression): targetStack.length */, TODO, 2) {
				/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Target */
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): expandingFlags !== ExpandingFlags.Both */ TODO {
				action(source, target)
			} else {
				/* TODO(ExpressionStatement): inferencePriority = InferencePriority.Circularity; */
			}
			/* TODO(PropertyAccessExpression): targetStack.pop */ TODO()
			/* TODO(PropertyAccessExpression): sourceStack.pop */ TODO()
			/* TODO(ExpressionStatement): expandingFlags = saveExpandingFlags; */
			/* TODO(PropertyAccessExpression): visited.set */
			TODO(key, inferencePriority)
			/* TODO(ExpressionStatement): inferencePriority = Math.min(inferencePriority, saveInferencePriority); */
		}
		inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TupleType): [Type[], Type[]] */ TODO {
			var matchedSources /* TODO(ArrayType): Type[] */ any
			var matchedTargets /* TODO(ArrayType): Type[] */ any
			for _, t := range targets {
				for _, s := range sources {
					if matches(s, t) {
						inferFromTypes(s, t)
						/* TODO(ExpressionStatement): matchedSources = appendIfUnique(matchedSources, s); */
						/* TODO(ExpressionStatement): matchedTargets = appendIfUnique(matchedTargets, t); */
					}
				}
			}
			return /* TODO(ArrayLiteralExpression): [                 matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,                 matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,             ] */ TODO
		}
		inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
			count := /* TODO(ConditionalExpression): sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length */ TODO
			/* TODO(ForStatement): for (let i = 0; i < count; i++) {                 if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {                     inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);                 }                 else {                     inferFromTypes(sourceTypes[i], targetTypes[i]);                 }             } */
		}
		inferFromContravariantTypes := func(source Type, target Type) {
			/* TODO(ExpressionStatement): contravariant = !contravariant; */
			inferFromTypes(source, target)
			/* TODO(ExpressionStatement): contravariant = !contravariant; */
		}
		inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
			if strictFunctionTypes || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): priority & InferencePriority.AlwaysStrict */ TODO {
				inferFromContravariantTypes(source, target)
			} else {
				inferFromTypes(source, target)
			}
		}
		getInferenceInfoForType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo | undefined */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeVariable */ TODO {
				for _, inference := range inferences {
					if type_ == /* TODO(PropertyAccessExpression): inference.typeParameter */ TODO {
						return inference
					}
				}
			}
			return nil
		}
		getSingleTypeVariableFromIntersectionTypes := func(types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			var typeVariable *Type
			for _, type_ := range types {
				t := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO && find( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => !!getInferenceInfoForType(t) */, TODO)
				if !t || typeVariable && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): t !== typeVariable */ TODO {
					return nil
				}
				/* TODO(ExpressionStatement): typeVariable = t; */
			}
			return typeVariable
		}
		inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
			typeVariableCount := 0
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & TypeFlags.Union */ TODO {
				var nakedTypeVariable *Type
				sources := /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO
				matched := /* TODO(NewExpression): new Array<boolean>(sources.length) */ TODO
				inferenceCircularity := /* TODO(FalseKeyword): false */ TODO
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						/* TODO(ExpressionStatement): nakedTypeVariable = t; */
						/* TODO(ExpressionStatement): typeVariableCount++; */
					} else {
						/* TODO(ForStatement): for (let i = 0; i < sources.length; i++) {                             const saveInferencePriority = inferencePriority;                             inferencePriority = InferencePriority.MaxValue;                             inferFromTypes(sources[i], t);                             if (inferencePriority === priority) matched[i] = true;                             inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;                             inferencePriority = Math.min(inferencePriority, saveInferencePriority);                         } */
					}
				}
				if typeVariableCount == 0 {
					intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
					if intersectionTypeVariable {
						inferWithPriority(source, intersectionTypeVariable /* TODO(PropertyAccessExpression): InferencePriority.NakedTypeVariable */, TODO)
					}
					return
				}
				if typeVariableCount == 1 && !inferenceCircularity {
					unmatched := flatMap(sources /* TODO(ArrowFunction): (s, i) => matched[i] ? undefined : s */, TODO)
					if /* TODO(PropertyAccessExpression): unmatched.length */ TODO {
						inferFromTypes(getUnionType(unmatched) /* TODO(NonNullExpression): nakedTypeVariable! */, TODO)
						return
					}
				}
			} else {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						/* TODO(ExpressionStatement): typeVariableCount++; */
					} else {
						inferFromTypes(source, t)
					}
				}
			}
			if /* TODO(ConditionalExpression): targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0 */ TODO {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						inferWithPriority(source, t /* TODO(PropertyAccessExpression): InferencePriority.NakedTypeVariable */, TODO)
					}
				}
			}
		}
		inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
			if /* TODO(ParenthesizedExpression): (constraintType.flags & TypeFlags.Union) */ TODO || /* TODO(ParenthesizedExpression): (constraintType.flags & TypeFlags.Intersection) */ TODO {
				result := /* TODO(FalseKeyword): false */ TODO
				for _, type_ := range /* TODO(PropertyAccessExpression): (constraintType as (UnionType | IntersectionType)).types */ TODO {
					/* TODO(ExpressionStatement): result = inferToMappedType(source, target, type) || result; */
				}
				return result
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constraintType.flags & TypeFlags.Index */ TODO {
				inference := getInferenceInfoForType( /* TODO(PropertyAccessExpression): (constraintType as IndexType).type */ TODO)
				if inference && ! /* TODO(PropertyAccessExpression): inference.isFixed */ TODO && !isFromInferenceBlockedSource(source) {
					inferredType := inferTypeForHomomorphicMappedType(source, target, constraintType /* as */ /* TODO(TypeReference): IndexType */)
					if inferredType {
						inferWithPriority(inferredType /* TODO(PropertyAccessExpression): inference.typeParameter */, TODO /* TODO(ConditionalExpression): getObjectFlags(source) & ObjectFlags.NonInferrableType ?                                 InferencePriority.PartialHomomorphicMappedType :                                 InferencePriority.HomomorphicMappedType */, TODO)
					}
				}
				return /* TODO(TrueKeyword): true */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constraintType.flags & TypeFlags.TypeParameter */ TODO {
				inferWithPriority(getIndexType(source /* TODO(ConditionalExpression): !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None */, TODO), constraintType /* TODO(PropertyAccessExpression): InferencePriority.MappedTypeConstraint */, TODO)
				extendedConstraint := getConstraintOfType(constraintType)
				if extendedConstraint && inferToMappedType(source, target, extendedConstraint) {
					return /* TODO(TrueKeyword): true */ TODO
				}
				propTypes := map_(getPropertiesOfType(source), getTypeOfSymbol)
				indexTypes := map_(getIndexInfosOfType(source) /* TODO(ArrowFunction): info => info !== enumNumberIndexInfo ? info.type : neverType */, TODO)
				inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target))
				return /* TODO(TrueKeyword): true */ TODO
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		inferToConditionalType := func(source Type, target ConditionalType) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Conditional */ TODO {
				inferFromTypes( /* TODO(PropertyAccessExpression): (source as ConditionalType).checkType */ TODO /* TODO(PropertyAccessExpression): target.checkType */, TODO)
				inferFromTypes( /* TODO(PropertyAccessExpression): (source as ConditionalType).extendsType */ TODO /* TODO(PropertyAccessExpression): target.extendsType */, TODO)
				inferFromTypes(getTrueTypeFromConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */), getTrueTypeFromConditionalType(target))
				inferFromTypes(getFalseTypeFromConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */), getFalseTypeFromConditionalType(target))
			} else {
				targetTypes := /* TODO(ArrayLiteralExpression): [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)] */ TODO
				inferToMultipleTypesWithPriority(source, targetTypes /* TODO(PropertyAccessExpression): target.flags */, TODO /* TODO(ConditionalExpression): contravariant ? InferencePriority.ContravariantConditional : 0 */, TODO)
			}
		}
		inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
			matches := inferTypesFromTemplateLiteralType(source, target)
			types := /* TODO(PropertyAccessExpression): target.types */ TODO
			if matches || every( /* TODO(PropertyAccessExpression): target.texts */ TODO /* TODO(ArrowFunction): s => s.length === 0 */, TODO) {
				/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                     const source = matches ? matches[i] : neverType;                     const target = types[i];                      // If we are inferring from a string literal type to a type variable whose constraint includes one of the                     // allowed template literal placeholder types, infer from a literal type corresponding to the constraint.                     if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.TypeVariable) {                         const inferenceContext = getInferenceInfoForType(target);                         const constraint = inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : undefined;                         if (constraint && !isTypeAny(constraint)) {                             const constraintTypes = constraint.flags & TypeFlags.Union ? (constraint as UnionType).types : [constraint];                             let allTypeFlags: TypeFlags = reduceLeft(constraintTypes, (flags, t) => flags | t.flags, 0 as TypeFlags);                              // If the constraint contains `string`, we don't need to look for a more preferred type                             if (!(allTypeFlags & TypeFlags.String)) {                                 const str = (source as StringLiteralType).value;                                  // If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers                                 if (allTypeFlags & TypeFlags.NumberLike && !isValidNumberString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.NumberLike;                                 }                                  // If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints                                 if (allTypeFlags & TypeFlags.BigIntLike && !isValidBigIntString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.BigIntLike;                                 }                                  // for each type in the constraint, find the highest priority matching type                                 const matchingType = reduceLeft(constraintTypes, (left, right) =>                                     !(right.flags & allTypeFlags) ? left :                                         left.flags & TypeFlags.String ? left : right.flags & TypeFlags.String ? source :                                         left.flags & TypeFlags.TemplateLiteral ? left : right.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right as TemplateLiteralType) ? source :                                         left.flags & TypeFlags.StringMapping ? left : right.flags & TypeFlags.StringMapping && str === applyStringMapping(right.symbol, str) ? source :                                         left.flags & TypeFlags.StringLiteral ? left : right.flags & TypeFlags.StringLiteral && (right as StringLiteralType).value === str ? right :                                         left.flags & TypeFlags.Number ? left : right.flags & TypeFlags.Number ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.Enum ? left : right.flags & TypeFlags.Enum ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.NumberLiteral ? left : right.flags & TypeFlags.NumberLiteral && (right as NumberLiteralType).value === +str ? right :                                         left.flags & TypeFlags.BigInt ? left : right.flags & TypeFlags.BigInt ? parseBigIntLiteralType(str) :                                         left.flags & TypeFlags.BigIntLiteral ? left : right.flags & TypeFlags.BigIntLiteral && pseudoBigIntToString((right as BigIntLiteralType).value) === str ? right :                                         left.flags & TypeFlags.Boolean ? left : right.flags & TypeFlags.Boolean ? str === "true" ? trueType : str === "false" ? falseType : booleanType :                                         left.flags & TypeFlags.BooleanLiteral ? left : right.flags & TypeFlags.BooleanLiteral && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Undefined ? left : right.flags & TypeFlags.Undefined && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Null ? left : right.flags & TypeFlags.Null && (right as IntrinsicType).intrinsicName === str ? right :                                         left, neverType as Type);                                  if (!(matchingType.flags & TypeFlags.Never)) {                                     inferFromTypes(matchingType, target);                                     continue;                                 }                             }                         }                     }                      inferFromTypes(source, target);                 } */
			}
		}
		inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
			inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target))
			inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target))
			sourceNameType := getNameTypeFromMappedType(source)
			targetNameType := getNameTypeFromMappedType(target)
			if sourceNameType && targetNameType {
				/* TODO(CallExpression): inferFromTypes(sourceNameType, targetNameType) */
			}
		}
		inferFromObjectTypes := func(source Type, target Type) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Reference */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Reference */ TODO && /* TODO(ParenthesizedExpression): (                     (source as TypeReference).target === (target as TypeReference).target || isArrayType(source) && isArrayType(target)                 ) */ TODO {
				inferFromTypeArguments(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), getVariances( /* TODO(PropertyAccessExpression): (source as TypeReference).target */ TODO))
				return
			}
			if isGenericMappedType(source) && isGenericMappedType(target) {
				inferFromGenericMappedTypes(source, target)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Mapped */ TODO && ! /* TODO(PropertyAccessExpression): (target as MappedType).declaration.nameType */ TODO {
				constraintType := getConstraintTypeFromMappedType(target /* as */ /* TODO(TypeReference): MappedType */)
				if inferToMappedType(source, target /* as */ /* TODO(TypeReference): MappedType */, constraintType) {
					return
				}
			}
			if !typesDefinitelyUnrelated(source, target) {
				if isArrayOrTupleType(source) {
					if isTupleType(target) {
						sourceArity := getTypeReferenceArity(source)
						targetArity := getTypeReferenceArity(target)
						elementTypes := getTypeArguments(target)
						elementFlags := /* TODO(PropertyAccessExpression): target.target.elementFlags */ TODO
						if isTupleType(source) && isTupleTypeStructureMatching(source, target) {
							/* TODO(ForStatement): for (let i = 0; i < targetArity; i++) {                                 inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                             } */
							return
						}
						startLength := /* TODO(ConditionalExpression): isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0 */ TODO
						endLength := /* TODO(PropertyAccessExpression): Math.min */ TODO( /* TODO(ConditionalExpression): isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0 */ TODO /* TODO(ConditionalExpression): target.target.combinedFlags & ElementFlags.Variable ? getEndElementCount(target.target, ElementFlags.Fixed) : 0 */, TODO)
						/* TODO(ForStatement): for (let i = 0; i < startLength; i++) {                             inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                         } */
						if !isTupleType(source) || /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - startLength - endLength */ TODO == 1 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.target.elementFlags[startLength] & ElementFlags.Rest */ TODO {
							restType := /* TODO(ElementAccessExpression): getTypeArguments(source)[startLength] */ TODO
							/* TODO(ForStatement): for (let i = startLength; i < targetArity - endLength; i++) {                                 inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);                             } */
						} else {
							middleLength := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetArity - startLength - endLength */ TODO
							if middleLength == 2 {
								if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength] & elementFlags[startLength + 1] & ElementFlags.Variadic */ TODO {
									targetInfo := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength] */ TODO)
									if targetInfo && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetInfo.impliedArity !== undefined */ TODO {
										inferFromTypes(sliceTupleType(source, startLength /* TODO(MinusToken): - */ /* TODO(BinaryExpression): endLength + sourceArity - targetInfo.impliedArity */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(sliceTupleType(source /* TODO(PlusToken): + */ /* TODO(BinaryExpression): startLength + targetInfo.impliedArity */, TODO, endLength) /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength] & ElementFlags.Variadic */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength + 1] & ElementFlags.Rest */ TODO {
									param := /* TODO(PropertyAccessExpression): getInferenceInfoForType(elementTypes[startLength])?.typeParameter */ TODO
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && ! /* TODO(ParenthesizedExpression): (constraint.target.combinedFlags & ElementFlags.Variable) */ TODO {
										impliedArity := /* TODO(PropertyAccessExpression): constraint.target.fixedLength */ TODO
										inferFromTypes(sliceTupleType(source, startLength /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - (startLength + impliedArity) */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes( /* TODO(NonNullExpression): getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength)! */ TODO /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength] & ElementFlags.Rest */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength + 1] & ElementFlags.Variadic */ TODO {
									param := /* TODO(PropertyAccessExpression): getInferenceInfoForType(elementTypes[startLength + 1])?.typeParameter */ TODO
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && ! /* TODO(ParenthesizedExpression): (constraint.target.combinedFlags & ElementFlags.Variable) */ TODO {
										impliedArity := /* TODO(PropertyAccessExpression): constraint.target.fixedLength */ TODO
										endIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - getEndElementCount(target.target, ElementFlags.Fixed) */ TODO
										startIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): endIndex - impliedArity */ TODO
										trailingSlice := createTupleType( /* TODO(PropertyAccessExpression): getTypeArguments(source).slice */ TODO(startIndex, endIndex) /* TODO(PropertyAccessExpression): source.target.elementFlags.slice */, TODO(startIndex, endIndex) /* TODO(FalseKeyword): false */, TODO /* TODO(PropertyAccessExpression): source.target.labeledElementDeclarations */, TODO && /* TODO(PropertyAccessExpression): source.target.labeledElementDeclarations.slice */ TODO(startIndex, endIndex))
										inferFromTypes( /* TODO(NonNullExpression): getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity)! */ TODO /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(trailingSlice /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								}
							} else if middleLength == 1 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength] & ElementFlags.Variadic */ TODO {
								endsInOptional := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.target.elementFlags[targetArity - 1] & ElementFlags.Optional */ TODO
								sourceSlice := sliceTupleType(source, startLength, endLength)
								inferWithPriority(sourceSlice /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO /* TODO(ConditionalExpression): endsInOptional ? InferencePriority.SpeculativeTuple : 0 */, TODO)
							} else if middleLength == 1 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementFlags[startLength] & ElementFlags.Rest */ TODO {
								restType := getElementTypeOfSliceOfTupleType(source, startLength, endLength)
								if restType {
									inferFromTypes(restType /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
								}
							}
						}
						/* TODO(ForStatement): for (let i = 0; i < endLength; i++) {                             inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);                         } */
						return
					}
					if isArrayType(target) {
						inferFromIndexTypes(source, target)
						return
					}
				}
				inferFromProperties(source, target)
				inferFromSignatures(source, target /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
				inferFromSignatures(source, target /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
				inferFromIndexTypes(source, target)
			}
		}
		inferFromProperties := func(source Type, target Type) {
			properties := getPropertiesOfObjectType(target)
			for _, targetProp := range properties {
				sourceProp := getPropertyOfType(source /* TODO(PropertyAccessExpression): targetProp.escapedName */, TODO)
				if sourceProp && !some( /* TODO(PropertyAccessExpression): sourceProp.declarations */ TODO, hasSkipDirectInferenceFlag) {
					inferFromTypes(removeMissingType(getTypeOfSymbol(sourceProp), !! /* TODO(ParenthesizedExpression): (sourceProp.flags & SymbolFlags.Optional) */ TODO), removeMissingType(getTypeOfSymbol(targetProp), !! /* TODO(ParenthesizedExpression): (targetProp.flags & SymbolFlags.Optional) */ TODO))
				}
			}
		}
		inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
			sourceSignatures := getSignaturesOfType(source, kind)
			sourceLen := /* TODO(PropertyAccessExpression): sourceSignatures.length */ TODO
			if sourceLen > 0 {
				targetSignatures := getSignaturesOfType(target, kind)
				targetLen := /* TODO(PropertyAccessExpression): targetSignatures.length */ TODO
				/* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {                     const sourceIndex = Math.max(sourceLen - targetLen + i, 0);                     inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));                 } */
			}
		}
		inferFromSignature := func(source Signature, target Signature) {
			if ! /* TODO(ParenthesizedExpression): (source.flags & SignatureFlags.IsNonInferrable) */ TODO {
				saveBivariant := bivariant
				kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
				/* TODO(ExpressionStatement): bivariant = bivariant || kind === SyntaxKind.MethodDeclaration || kind === SyntaxKind.MethodSignature || kind === SyntaxKind.Constructor; */
				applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes)
				/* TODO(ExpressionStatement): bivariant = saveBivariant; */
			}
			applyToReturnTypes(source, target, inferFromTypes)
		}
		inferFromIndexTypes := func(source Type, target Type) {
			priority := /* TODO(ConditionalExpression): (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0 */ TODO
			indexInfos := getIndexInfosOfType(target)
			if isObjectTypeWithInferableIndex(source) {
				for _, targetInfo := range indexInfos {
					var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
					for _, prop := range getPropertiesOfType(source) {
						if isApplicableIndexType(getLiteralTypeFromProperty(prop /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO) /* TODO(PropertyAccessExpression): targetInfo.keyType */, TODO) {
							propType := getTypeOfSymbol(prop)
							/* TODO(PropertyAccessExpression): propTypes.push */ TODO( /* TODO(ConditionalExpression): prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType */ TODO)
						}
					}
					for _, info := range getIndexInfosOfType(source) {
						if isApplicableIndexType( /* TODO(PropertyAccessExpression): info.keyType */ TODO /* TODO(PropertyAccessExpression): targetInfo.keyType */, TODO) {
							/* TODO(PropertyAccessExpression): propTypes.push */ TODO( /* TODO(PropertyAccessExpression): info.type */ TODO)
						}
					}
					if /* TODO(PropertyAccessExpression): propTypes.length */ TODO {
						inferWithPriority(getUnionType(propTypes) /* TODO(PropertyAccessExpression): targetInfo.type */, TODO, priority)
					}
				}
			}
			for _, targetInfo := range indexInfos {
				sourceInfo := getApplicableIndexInfo(source /* TODO(PropertyAccessExpression): targetInfo.keyType */, TODO)
				if sourceInfo {
					inferWithPriority( /* TODO(PropertyAccessExpression): sourceInfo.type */ TODO /* TODO(PropertyAccessExpression): targetInfo.type */, TODO, priority)
				}
			}
		}
	}
	isTypeOrBaseIdenticalTo := func(s Type, t Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): t === missingType ? s === t :             (isTypeIdenticalTo(s, t) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral)) */ TODO
	}
	isTypeCloselyMatchedBy := func(s Type, t Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (s.flags & TypeFlags.Object && t.flags & TypeFlags.Object && s.symbol && s.symbol === t.symbol ||             s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol) */ TODO
	}
	hasPrimitiveConstraint := func(type_ TypeParameter) bool {
		constraint := getConstraintOfTypeParameter(type_)
		return !!constraint && maybeTypeOfKind( /* TODO(ConditionalExpression): constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint */ TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping */, TODO)
	}
	isObjectLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.ObjectLiteral) */ TODO
	}
	isObjectOrArrayLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & (ObjectFlags.ObjectLiteral | ObjectFlags.ArrayLiteral)) */ TODO
	}
	unionObjectAndArrayLiteralCandidates := func(candidates []Type) []Type {
		if /* TODO(PropertyAccessExpression): candidates.length */ TODO > 1 {
			objectLiterals := filter(candidates, isObjectOrArrayLiteralType)
			if /* TODO(PropertyAccessExpression): objectLiterals.length */ TODO {
				literalsType := getUnionType(objectLiterals /* TODO(PropertyAccessExpression): UnionReduction.Subtype */, TODO)
				return concatenate(filter(candidates /* TODO(ArrowFunction): t => !isObjectOrArrayLiteralType(t) */, TODO) /* TODO(ArrayLiteralExpression): [literalsType] */, TODO)
			}
		}
		return candidates
	}
	getContravariantInference := func(inference InferenceInfo) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!) */ TODO
	}
	getCovariantInference := func(inference InferenceInfo, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		candidates := unionObjectAndArrayLiteralCandidates( /* TODO(NonNullExpression): inference.candidates! */ TODO)
		primitiveConstraint := hasPrimitiveConstraint( /* TODO(PropertyAccessExpression): inference.typeParameter */ TODO) || isConstTypeVariable( /* TODO(PropertyAccessExpression): inference.typeParameter */ TODO)
		widenLiteralTypes := !primitiveConstraint && /* TODO(PropertyAccessExpression): inference.topLevel */ TODO && /* TODO(ParenthesizedExpression): (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter)) */ TODO
		baseCandidates := /* TODO(ConditionalExpression): primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) :             widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) :             candidates */ TODO
		unwidenedType := /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ?             getUnionType(baseCandidates, UnionReduction.Subtype) :             getCommonSupertype(baseCandidates) */ TODO
		return getWidenedType(unwidenedType)
	}
	getInferredType := func(context InferenceContext, index number) Type {
		inference := /* TODO(ElementAccessExpression): context.inferences[index] */ TODO
		if ! /* TODO(PropertyAccessExpression): inference.inferredType */ TODO {
			var inferredType *Type
			var fallbackType *Type
			if /* TODO(PropertyAccessExpression): context.signature */ TODO {
				inferredCovariantType := /* TODO(ConditionalExpression): inference.candidates ? getCovariantInference(inference, context.signature) : undefined */ TODO
				inferredContravariantType := /* TODO(ConditionalExpression): inference.contraCandidates ? getContravariantInference(inference) : undefined */ TODO
				if inferredCovariantType || inferredContravariantType {
					preferCovariantType := inferredCovariantType && /* TODO(ParenthesizedExpression): (!inferredContravariantType ||                         !(inferredCovariantType.flags & (TypeFlags.Never | TypeFlags.Any)) &&                             some(inference.contraCandidates, t => isTypeAssignableTo(inferredCovariantType, t)) &&                             every(context.inferences, other =>                                 other !== inference && getConstraintOfTypeParameter(other.typeParameter) !== inference.typeParameter ||                                 every(other.candidates, t => isTypeAssignableTo(t, inferredCovariantType)))) */ TODO
					/* TODO(ExpressionStatement): inferredType = preferCovariantType ? inferredCovariantType : inferredContravariantType; */
					/* TODO(ExpressionStatement): fallbackType = preferCovariantType ? inferredContravariantType : inferredCovariantType; */
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): context.flags & InferenceFlags.NoDefault */ TODO {
					/* TODO(ExpressionStatement): inferredType = silentNeverType; */
				} else {
					defaultType := getDefaultFromTypeParameter( /* TODO(PropertyAccessExpression): inference.typeParameter */ TODO)
					if defaultType {
						/* TODO(ExpressionStatement): inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper)); */
					}
				}
			} else {
				/* TODO(ExpressionStatement): inferredType = getTypeFromInference(inference); */
			}
			/* TODO(ExpressionStatement): inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlags.AnyDefault)); */
			constraint := getConstraintOfTypeParameter( /* TODO(PropertyAccessExpression): inference.typeParameter */ TODO)
			if constraint {
				instantiatedConstraint := instantiateType(constraint /* TODO(PropertyAccessExpression): context.nonFixingMapper */, TODO)
				if !inferredType || ! /* TODO(PropertyAccessExpression): context.compareTypes */ TODO(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType)) {
					/* TODO(ExpressionStatement): inference.inferredType = fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint; */
				}
			}
		}
		return /* TODO(PropertyAccessExpression): inference.inferredType */ TODO
	}
	getDefaultTypeArgumentType := func(isInJavaScriptFile bool) Type {
		return /* TODO(ConditionalExpression): isInJavaScriptFile ? anyType : unknownType */ TODO
	}
	getInferredTypes := func(context InferenceContext) []Type {
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < context.inferences.length; i++) {             result.push(getInferredType(context, i));         } */
		return result
	}
	getCannotFindNameDiagnosticForName := func(node Identifier) DiagnosticMessage {
		/* TODO(SwitchStatement): switch (node.escapedText) {             case "document":             case "console":                 return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;             case "$":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;             case "describe":             case "suite":             case "it":             case "test":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;             case "process":             case "require":             case "Buffer":             case "module":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;             case "Bun":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun;             case "Map":             case "Set":             case "Promise":             case "Symbol":             case "WeakMap":             case "WeakSet":             case "Iterator":             case "AsyncIterator":             case "SharedArrayBuffer":             case "Atomics":             case "AsyncIterable":             case "AsyncIterableIterator":             case "AsyncGenerator":             case "AsyncGeneratorFunction":             case "BigInt":             case "Reflect":             case "BigInt64Array":             case "BigUint64Array":                 return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;             case "await":                 if (isCallExpression(node.parent)) {                     return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;                 }                 // falls through             default:                 if (node.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {                     return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;                 }                 else {                     return Diagnostics.Cannot_find_name_0;                 }         } */
	}
	getResolvedSymbol := func(node Identifier) Symbol {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO {
			/* TODO(ExpressionStatement): links.resolvedSymbol = !nodeIsMissing(node) &&                     resolveName(                         node,                         node,                         SymbolFlags.Value | SymbolFlags.ExportValue,                         getCannotFindNameDiagnosticForName(node),                         !isWriteOnlyAccess(node),                         /*excludeGlobals* / false,                     ) || unknownSymbol; */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
	}
	isInAmbientOrTypeNode := func(node Node) bool {
		return !! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient || findAncestor(node, n => isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n))) */ TODO
	}
	getFlowCacheKey := func(node Node, declaredType Type, initialType Type, flowContainer Node) /* TODO(StringKeyword): string */ any {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 if (!isThisInTypeQuery(node)) {                     const symbol = getResolvedSymbol(node as Identifier);                     return symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : undefined;                 }                 // falls through             case SyntaxKind.ThisKeyword:                 return `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}`;             case SyntaxKind.NonNullExpression:             case SyntaxKind.ParenthesizedExpression:                 return getFlowCacheKey((node as NonNullExpression | ParenthesizedExpression).expression, declaredType, initialType, flowContainer);             case SyntaxKind.QualifiedName:                 const left = getFlowCacheKey((node as QualifiedName).left, declaredType, initialType, flowContainer);                 return left && `${left}.${(node as QualifiedName).right.escapedText}`;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const propName = getAccessedPropertyName(node as AccessExpression);                 if (propName !== undefined) {                     const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);                     return key && `${key}.${propName}`;                 }                 if (isElementAccessExpression(node) && isIdentifier(node.argumentExpression)) {                     const symbol = getResolvedSymbol(node.argumentExpression);                     if (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {                         const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);                         return key && `${key}.@${getSymbolId(symbol)}`;                     }                 }                 break;             case SyntaxKind.ObjectBindingPattern:             case SyntaxKind.ArrayBindingPattern:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:                 // Handle pseudo-references originating in getNarrowedTypeOfSymbol.                 return `${getNodeId(node)}#${getTypeId(declaredType)}`;         } */
		return nil
	}
	isMatchingReference := func(source Node, target Node) bool {
		/* TODO(SwitchStatement): switch (target.kind) {             case SyntaxKind.ParenthesizedExpression:             case SyntaxKind.NonNullExpression:                 return isMatchingReference(source, (target as NonNullExpression | ParenthesizedExpression).expression);             case SyntaxKind.BinaryExpression:                 return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) ||                     (isBinaryExpression(target) && target.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source, target.right));         } */
		/* TODO(SwitchStatement): switch (source.kind) {             case SyntaxKind.MetaProperty:                 return target.kind === SyntaxKind.MetaProperty                     && (source as MetaProperty).keywordToken === (target as MetaProperty).keywordToken                     && (source as MetaProperty).name.escapedText === (target as MetaProperty).name.escapedText;             case SyntaxKind.Identifier:             case SyntaxKind.PrivateIdentifier:                 return isThisInTypeQuery(source) ?                     target.kind === SyntaxKind.ThisKeyword :                     target.kind === SyntaxKind.Identifier && getResolvedSymbol(source as Identifier) === getResolvedSymbol(target as Identifier) ||                     (isVariableDeclaration(target) || isBindingElement(target)) &&                         getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source as Identifier)) === getSymbolOfDeclaration(target);             case SyntaxKind.ThisKeyword:                 return target.kind === SyntaxKind.ThisKeyword;             case SyntaxKind.SuperKeyword:                 return target.kind === SyntaxKind.SuperKeyword;             case SyntaxKind.NonNullExpression:             case SyntaxKind.ParenthesizedExpression:                 return isMatchingReference((source as NonNullExpression | ParenthesizedExpression).expression, target);             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const sourcePropertyName = getAccessedPropertyName(source as AccessExpression);                 if (sourcePropertyName !== undefined) {                     const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : undefined;                     if (targetPropertyName !== undefined) {                         return targetPropertyName === sourcePropertyName && isMatchingReference((source as AccessExpression).expression, (target as AccessExpression).expression);                     }                 }                 if (isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression)) {                     const symbol = getResolvedSymbol(source.argumentExpression);                     if (symbol === getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol))) {                         return isMatchingReference(source.expression, target.expression);                     }                 }                 break;             case SyntaxKind.QualifiedName:                 return isAccessExpression(target) &&                     (source as QualifiedName).right.escapedText === getAccessedPropertyName(target) &&                     isMatchingReference((source as QualifiedName).left, target.expression);             case SyntaxKind.BinaryExpression:                 return (isBinaryExpression(source) && source.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source.right, target));         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	getAccessedPropertyName := func(access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
		if isPropertyAccessExpression(access) {
			return /* TODO(PropertyAccessExpression): access.name.escapedText */ TODO
		}
		if isElementAccessExpression(access) {
			return tryGetElementAccessExpressionName(access)
		}
		if isBindingElement(access) {
			name := getDestructuringPropertyName(access)
			return /* TODO(ConditionalExpression): name ? escapeLeadingUnderscores(name) : undefined */ TODO
		}
		if isParameter(access) {
			return /* TODO(ParenthesizedExpression): ("" + access.parent.parameters.indexOf(access)) */ TODO /* as */ /* TODO(TypeReference): __String */
		}
		return nil
	}
	tryGetNameFromType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? (type as UniqueESSymbolType).escapedName :             type.flags & TypeFlags.StringOrNumberLiteral ? escapeLeadingUnderscores("" + (type as StringLiteralType | NumberLiteralType).value) : undefined */ TODO
	}
	tryGetElementAccessExpressionName := func(node ElementAccessExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): isStringOrNumericLiteralLike(node.argumentExpression) ? escapeLeadingUnderscores(node.argumentExpression.text) :             isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : undefined */ TODO
	}
	tryGetNameFromEntityNameExpression := func(node EntityNameOrEntityNameExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		symbol := resolveEntityName(node /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO)
		if !symbol || ! /* TODO(ParenthesizedExpression): (isConstantVariable(symbol) || (symbol.flags & SymbolFlags.EnumMember)) */ TODO {
			/* TODO(Identifier): undefined */
		}
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if declaration == nil {
			/* TODO(Identifier): undefined */
		}
		type_ := tryGetTypeFromEffectiveTypeNode(declaration)
		if type_ {
			name := tryGetNameFromType(type_)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== undefined */ TODO {
				return name
			}
		}
		if hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node) {
			initializer := getEffectiveInitializer(declaration)
			if initializer {
				initializerType := /* TODO(ConditionalExpression): isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer) */ TODO
				return initializerType && tryGetNameFromType(initializerType)
			}
			if isEnumMember(declaration) {
				return getTextOfPropertyName( /* TODO(PropertyAccessExpression): declaration.name */ TODO)
			}
		}
		return nil
	}
	containsMatchingReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(WhileStatement): while (isAccessExpression(source)) {             source = source.expression;             if (isMatchingReference(source, target)) {                 return true;             }         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	optionalChainContainsReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(WhileStatement): while (isOptionalChain(source)) {             source = source.expression;             if (isMatchingReference(source, target)) {                 return true;             }         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	isDiscriminantProperty := func(type_ *Type, name __String) /* TODO(undefined): boolean */ TODO {
		if type_ && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			prop := getUnionOrIntersectionProperty(type_ /* as */ /* TODO(TypeReference): UnionType */, name)
			if prop && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(prop) & CheckFlags.SyntheticProperty */ TODO {
				if /* TODO(PropertyAccessExpression): (prop as TransientSymbol).links.isDiscriminantProperty */ TODO == nil {
					/* TODO(ExpressionStatement): (prop as TransientSymbol).links.isDiscriminantProperty = ((prop as TransientSymbol).links.checkFlags & CheckFlags.Discriminant) === CheckFlags.Discriminant &&                         !isGenericType(getTypeOfSymbol(prop)); */
				}
				return !! /* TODO(PropertyAccessExpression): (prop as TransientSymbol).links.isDiscriminantProperty */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	findDiscriminantProperties := func(sourceProperties []Symbol, target Type) /* TODO(ArrayType): Symbol[] */ any {
		var result /* TODO(ArrayType): Symbol[] */ any
		for _, sourceProperty := range sourceProperties {
			if isDiscriminantProperty(target /* TODO(PropertyAccessExpression): sourceProperty.escapedName */, TODO) {
				if result {
					/* TODO(PropertyAccessExpression): result.push */ TODO(sourceProperty)
					/* TODO(ContinueStatement): continue; */
				}
				/* TODO(ExpressionStatement): result = [sourceProperty]; */
			}
		}
		return result
	}
	mapTypesByKeyProperty := func(types []Type, name __String) /* TODO(undefined): Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").Type> | undefined */ TODO {
		map_ := /* TODO(NewExpression): new Map<TypeId, Type>() */ TODO
		count := 0
		for _, type_ := range types {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) */ TODO {
				discriminant := getTypeOfPropertyOfType(type_, name)
				if discriminant {
					if !isLiteralType(discriminant) {
						return nil
					}
					duplicate := /* TODO(FalseKeyword): false */ TODO
					forEachType(discriminant /* TODO(ArrowFunction): t => {                         const id = getTypeId(getRegularTypeOfLiteralType(t));                         const existing = map.get(id);                         if (!existing) {                             map.set(id, type);                         }                         else if (existing !== unknownType) {                             map.set(id, unknownType);                             duplicate = true;                         }                     } */, TODO)
					if !duplicate {
						/* TODO(PostfixUnaryExpression): count++ */
					}
				}
			}
		}
		return /* TODO(ConditionalExpression): count >= 10 && count * 2 >= types.length ? map : undefined */ TODO
	}
	getKeyPropertyName := func(unionType UnionType) *__String {
		types := /* TODO(PropertyAccessExpression): unionType.types */ TODO
		if /* TODO(PropertyAccessExpression): types.length */ TODO < 10 || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(unionType) & ObjectFlags.PrimitiveUnion */ TODO || countWhere(types /* TODO(ArrowFunction): t => !!(t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive)) */, TODO) < 10 {
			return nil
		}
		if /* TODO(PropertyAccessExpression): unionType.keyPropertyName */ TODO == nil {
			keyPropertyName := forEach(types /* TODO(ArrowFunction): t =>                 t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ?                     forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined) :                     undefined */, TODO)
			mapByKeyProperty := keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName)
			/* TODO(ExpressionStatement): unionType.keyPropertyName = mapByKeyProperty ? keyPropertyName : "" as __String; */
			/* TODO(ExpressionStatement): unionType.constituentMap = mapByKeyProperty; */
		}
		return /* TODO(ConditionalExpression): (unionType.keyPropertyName as string).length ? unionType.keyPropertyName : undefined */ TODO
	}
	getConstituentTypeForKeyType := func(unionType UnionType, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		result := /* TODO(PropertyAccessExpression): unionType.constituentMap?.get */ TODO(getTypeId(getRegularTypeOfLiteralType(keyType)))
		return /* TODO(ConditionalExpression): result !== unknownType ? result : undefined */ TODO
	}
	getMatchingUnionConstituentForType := func(unionType UnionType, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		keyPropertyName := getKeyPropertyName(unionType)
		propType := keyPropertyName && getTypeOfPropertyOfType(type_, keyPropertyName)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	getMatchingUnionConstituentForObjectLiteral := func(unionType UnionType, node ObjectLiteralExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		keyPropertyName := getKeyPropertyName(unionType)
		propNode := keyPropertyName && find( /* TODO(PropertyAccessExpression): node.properties */ TODO /* TODO(ArrowFunction): p =>             p.symbol && p.kind === SyntaxKind.PropertyAssignment &&             p.symbol.escapedName === keyPropertyName && isPossiblyDiscriminantValue(p.initializer) */, TODO)
		propType := propNode && getContextFreeTypeOfExpression( /* TODO(PropertyAccessExpression): (propNode as PropertyAssignment).initializer */ TODO)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	isOrContainsMatchingReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
		return isMatchingReference(source, target) || containsMatchingReference(source, target)
	}
	hasMatchingArgument := func(expression /* TODO(UnionType): CallExpression | NewExpression */ any, reference Node) /* TODO(undefined): boolean */ TODO {
		if /* TODO(PropertyAccessExpression): expression.arguments */ TODO {
			for _, argument := range /* TODO(PropertyAccessExpression): expression.arguments */ TODO {
				if isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		if /* TODO(PropertyAccessExpression): expression.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO && isOrContainsMatchingReference(reference /* TODO(PropertyAccessExpression): (expression.expression as PropertyAccessExpression).expression */, TODO) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getFlowNodeId := func(flow FlowNode) number {
		if /* TODO(PropertyAccessExpression): flow.id */ TODO <= 0 {
			/* TODO(ExpressionStatement): flow.id = nextFlowId; */
			/* TODO(ExpressionStatement): nextFlowId++; */
		}
		return /* TODO(PropertyAccessExpression): flow.id */ TODO
	}
	typeMaybeAssignableTo := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		if ! /* TODO(ParenthesizedExpression): (source.flags & TypeFlags.Union) */ TODO {
			return isTypeAssignableTo(source, target)
		}
		for _, t := range /* TODO(PropertyAccessExpression): (source as UnionType).types */ TODO {
			if isTypeAssignableTo(t, target) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getAssignmentReducedType := func(declaredType UnionType, assignedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if declaredType == assignedType {
			return declaredType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): assignedType.flags & TypeFlags.Never */ TODO {
			return assignedType
		}
		key := /* TODO(TemplateExpression): `A${getTypeId(declaredType)},${getTypeId(assignedType)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
	}
	getAssignmentReducedTypeWorker := func(declaredType UnionType, assignedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		filteredType := filterType(declaredType /* TODO(ArrowFunction): t => typeMaybeAssignableTo(assignedType, t) */, TODO)
		reducedType := /* TODO(ConditionalExpression): assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType */ TODO
		return /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType */ TODO
	}
	isFunctionObjectType := func(type_ ObjectType) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		resolved := resolveStructuredTypeMembers(type_)
		return !! /* TODO(ParenthesizedExpression): (resolved.callSignatures.length || resolved.constructSignatures.length ||             resolved.members.get("bind" as __String) && isTypeSubtypeOf(type, globalFunctionType)) */ TODO
	}
	getTypeFacts := func(type_ Type, mask TypeFacts) TypeFacts {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getTypeFactsWorker(type, mask) & mask */ TODO
	}
	hasTypeFacts := func(type_ Type, mask TypeFacts) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getTypeFacts(type, mask) !== 0 */ TODO
	}
	getTypeFactsWorker := func(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & (TypeFlags.Intersection | TypeFlags.Instantiable) */ TODO {
			/* TODO(ExpressionStatement): type = getBaseConstraintOfType(type) || unknownType; */
		}
		flags := /* TODO(PropertyAccessExpression): type.flags */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & (TypeFlags.String | TypeFlags.StringMapping) */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral) */ TODO {
			isEmpty := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.StringLiteral */ TODO && /* TODO(PropertyAccessExpression): (type as StringLiteralType).value */ TODO == ""
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts :                 isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & (TypeFlags.Number | TypeFlags.Enum) */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.NumberLiteral */ TODO {
			isZero := /* TODO(PropertyAccessExpression): (type as NumberLiteralType).value */ TODO == 0
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts :                 isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.BigInt */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.BigIntLiteral */ TODO {
			isZero := isZeroBigInt(type_ /* as */ /* TODO(TypeReference): BigIntLiteralType */)
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts :                 isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Boolean */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.BooleanLike */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ?                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseStrictFacts : TypeFacts.TrueStrictFacts :                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseFacts : TypeFacts.TrueFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Object */ TODO {
			possibleFacts := /* TODO(ConditionalExpression): strictNullChecks                 ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts                 : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts */ TODO
			if /* TODO(ParenthesizedExpression): (callerOnlyNeeds & possibleFacts) */ TODO == 0 {
				return 0
			}
			return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.EmptyObjectStrictFacts : TypeFacts.EmptyObjectFacts :                 isFunctionObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.FunctionStrictFacts : TypeFacts.FunctionFacts :                 strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Void */ TODO {
			return /* TODO(PropertyAccessExpression): TypeFacts.VoidFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Undefined */ TODO {
			return /* TODO(PropertyAccessExpression): TypeFacts.UndefinedFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Null */ TODO {
			return /* TODO(PropertyAccessExpression): TypeFacts.NullFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.ESSymbolLike */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.SymbolStrictFacts : TypeFacts.SymbolFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.NonPrimitive */ TODO {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Never */ TODO {
			return /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Union */ TODO {
			return reduceLeft( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO /* TODO(ArrowFunction): (facts, t) => facts | getTypeFactsWorker(t, callerOnlyNeeds) */, TODO /* TODO(PropertyAccessExpression): TypeFacts.None */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & TypeFlags.Intersection */ TODO {
			return getIntersectionTypeFacts(type_ /* as */ /* TODO(TypeReference): IntersectionType */, callerOnlyNeeds)
		}
		return /* TODO(PropertyAccessExpression): TypeFacts.UnknownFacts */ TODO
	}
	getIntersectionTypeFacts := func(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
		ignoreObjects := maybeTypeOfKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.Primitive */, TODO)
		oredFacts := /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO
		andedFacts := /* TODO(PropertyAccessExpression): TypeFacts.All */ TODO
		for _, t := range /* TODO(PropertyAccessExpression): type.types */ TODO {
			if ! /* TODO(ParenthesizedExpression): (ignoreObjects && t.flags & TypeFlags.Object) */ TODO {
				f := getTypeFactsWorker(t, callerOnlyNeeds)
				/* TODO(ExpressionStatement): oredFacts |= f; */
				/* TODO(ExpressionStatement): andedFacts &= f; */
			}
		}
		return /* TODO(BarToken): | */ /* TODO(BinaryExpression): oredFacts & TypeFacts.OrFactsMask | andedFacts & TypeFacts.AndFactsMask */ TODO
	}
	getTypeWithFacts := func(type_ Type, include TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_ /* TODO(ArrowFunction): t => hasTypeFacts(t, include) */, TODO)
	}
	getAdjustedTypeWithFacts := func(type_ Type, facts TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reduced := recombineUnknownType(getTypeWithFacts( /* TODO(ConditionalExpression): strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type */ TODO, facts))
		if strictNullChecks {
			/* TODO(SwitchStatement): switch (facts) {                 case TypeFacts.NEUndefined:                     return removeNullableByIntersection(reduced, TypeFacts.EQUndefined, TypeFacts.EQNull, TypeFacts.IsNull, nullType);                 case TypeFacts.NENull:                     return removeNullableByIntersection(reduced, TypeFacts.EQNull, TypeFacts.EQUndefined, TypeFacts.IsUndefined, undefinedType);                 case TypeFacts.NEUndefinedOrNull:                 case TypeFacts.Truthy:                     return mapType(reduced, t => hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t);             } */
		}
		return reduced
	}
	removeNullableByIntersection := func(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		facts := getTypeFacts(type_ /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFacts.EQUndefined | TypeFacts.EQNull | TypeFacts.IsUndefined | TypeFacts.IsNull */, TODO)
		if ! /* TODO(ParenthesizedExpression): (facts & targetFacts) */ TODO {
			return type_
		}
		emptyAndOtherUnion := getUnionType( /* TODO(ArrayLiteralExpression): [emptyObjectType, otherType] */ TODO)
		return mapType(type_ /* TODO(ArrowFunction): t => hasTypeFacts(t, targetFacts) ? getIntersectionType([t, !(facts & otherIncludesFacts) && hasTypeFacts(t, otherFacts) ? emptyAndOtherUnion : emptyObjectType]) : t */, TODO)
	}
	recombineUnknownType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type === unknownUnionType ? unknownType : type */ TODO
	}
	getTypeWithDefault := func(type_ Type, defaultExpression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): defaultExpression ?             getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) :             type */ TODO
	}
	getTypeOfDestructuredProperty := func(type_ Type, name PropertyName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		nameType := getLiteralTypeFromPropertyName(name)
		if !isTypeUsableAsPropertyName(nameType) {
			/* TODO(Identifier): errorType */
		}
		text := getPropertyNameFromType(nameType)
		return getTypeOfPropertyOfType(type_, text) || includeUndefinedInIndexSignature( /* TODO(PropertyAccessExpression): getApplicableIndexInfoForName(type, text)?.type */ TODO) || errorType
	}
	getTypeOfDestructuredArrayElement := func(type_ Type, index number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return everyType(type_, isTupleLikeType) && getTupleElementType(type_, index) || includeUndefinedInIndexSignature(checkIteratedTypeOrElementType( /* TODO(PropertyAccessExpression): IterationUse.Destructuring */ TODO, type_, undefinedType, nil)) || errorType
	}
	includeUndefinedInIndexSignature := func(type_ *Type) *Type {
		if !type_ {
			/* TODO(Identifier): type */
		}
		return /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ?             getUnionType([type, missingType]) :             type */ TODO
	}
	getTypeOfDestructuredSpreadExpression := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return createArrayType(checkIteratedTypeOrElementType( /* TODO(PropertyAccessExpression): IterationUse.Destructuring */ TODO, type_, undefinedType, nil) || errorType)
	}
	getAssignedTypeOfBinaryExpression := func(node BinaryExpression) Type {
		isDestructuringDefaultAssignment := /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayLiteralExpression */ TODO && isDestructuringAssignmentTarget( /* TODO(PropertyAccessExpression): node.parent */ TODO) || /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO && isDestructuringAssignmentTarget( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
		return /* TODO(ConditionalExpression): isDestructuringDefaultAssignment ?             getTypeWithDefault(getAssignedType(node), node.right) :             getTypeOfExpression(node.right) */ TODO
	}
	isDestructuringAssignmentTarget := func(parent Node) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (parent.parent as BinaryExpression).left */ TODO == parent || /* TODO(PropertyAccessExpression): parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForOfStatement */ TODO && /* TODO(PropertyAccessExpression): (parent.parent as ForOfStatement).initializer */ TODO == parent
	}
	getAssignedTypeOfArrayLiteralElement := func(node ArrayLiteralExpression, element Expression) Type {
		return getTypeOfDestructuredArrayElement(getAssignedType(node) /* TODO(PropertyAccessExpression): node.elements.indexOf */, TODO(element))
	}
	getAssignedTypeOfSpreadExpression := func(node SpreadElement) Type {
		return getTypeOfDestructuredSpreadExpression(getAssignedType( /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): ArrayLiteralExpression */))
	}
	getAssignedTypeOfPropertyAssignment := func(node /* TODO(UnionType): PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
		return getTypeOfDestructuredProperty(getAssignedType( /* TODO(PropertyAccessExpression): node.parent */ TODO) /* TODO(PropertyAccessExpression): node.name */, TODO)
	}
	getAssignedTypeOfShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) Type {
		return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node) /* TODO(NonNullExpression): node.objectAssignmentInitializer! */, TODO)
	}
	getAssignedType := func(node Expression) Type {
		TODO_IDENTIFIER := node
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.ForInStatement:                 return stringType;             case SyntaxKind.ForOfStatement:                 return checkRightHandSideOfForOf(parent as ForOfStatement) || errorType;             case SyntaxKind.BinaryExpression:                 return getAssignedTypeOfBinaryExpression(parent as BinaryExpression);             case SyntaxKind.DeleteExpression:                 return undefinedType;             case SyntaxKind.ArrayLiteralExpression:                 return getAssignedTypeOfArrayLiteralElement(parent as ArrayLiteralExpression, node);             case SyntaxKind.SpreadElement:                 return getAssignedTypeOfSpreadExpression(parent as SpreadElement);             case SyntaxKind.PropertyAssignment:                 return getAssignedTypeOfPropertyAssignment(parent as PropertyAssignment);             case SyntaxKind.ShorthandPropertyAssignment:                 return getAssignedTypeOfShorthandPropertyAssignment(parent as ShorthandPropertyAssignment);         } */
		return errorType
	}
	getInitialTypeOfBindingElement := func(node BindingElement) Type {
		pattern := /* TODO(PropertyAccessExpression): node.parent */ TODO
		parentType := getInitialType( /* TODO(PropertyAccessExpression): pattern.parent */ TODO /* as */ /* TODO(UnionType): VariableDeclaration | BindingElement */)
		type_ := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern ?             getTypeOfDestructuredProperty(parentType, node.propertyName || node.name as Identifier) :             !node.dotDotDotToken ?             getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) :             getTypeOfDestructuredSpreadExpression(parentType) */ TODO
		return getTypeWithDefault(type_ /* TODO(NonNullExpression): node.initializer! */, TODO)
	}
	getTypeOfInitializer := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO || getTypeOfExpression(node)
	}
	getInitialTypeOfVariableDeclaration := func(node VariableDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
			return getTypeOfInitializer( /* TODO(PropertyAccessExpression): node.initializer */ TODO)
		}
		if /* TODO(PropertyAccessExpression): node.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForInStatement */ TODO {
			return stringType
		}
		if /* TODO(PropertyAccessExpression): node.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForOfStatement */ TODO {
			return checkRightHandSideOfForOf( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO) || errorType
		}
		return errorType
	}
	getInitialType := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration ?             getInitialTypeOfVariableDeclaration(node) :             getInitialTypeOfBindingElement(node) */ TODO
	}
	isEmptyArrayAssignment := func(node /* TODO(UnionType): VariableDeclaration | BindingElement | Expression */ any) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO && /* TODO(PropertyAccessExpression): (node as VariableDeclaration).initializer */ TODO && isEmptyArrayLiteral( /* TODO(NonNullExpression): (node as VariableDeclaration).initializer! */ TODO) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.BindingElement */ TODO && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && isEmptyArrayLiteral( /* TODO(PropertyAccessExpression): (node.parent as BinaryExpression).right */ TODO)
	}
	getReferenceCandidate := func(node Expression) Expression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ParenthesizedExpression:                 return getReferenceCandidate((node as ParenthesizedExpression).expression);             case SyntaxKind.BinaryExpression:                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.BarBarEqualsToken:                     case SyntaxKind.AmpersandAmpersandEqualsToken:                     case SyntaxKind.QuestionQuestionEqualsToken:                         return getReferenceCandidate((node as BinaryExpression).left);                     case SyntaxKind.CommaToken:                         return getReferenceCandidate((node as BinaryExpression).right);                 }         } */
		return node
	}
	getReferenceRoot := func(node Node) Node {
		TODO_IDENTIFIER := node
		return /* TODO(ConditionalExpression): parent.kind === SyntaxKind.ParenthesizedExpression ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken && (parent as BinaryExpression).left === node ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken && (parent as BinaryExpression).right === node ?             getReferenceRoot(parent) : node */ TODO
	}
	getTypeOfSwitchClause := func(clause /* TODO(UnionType): CaseClause | DefaultClause */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if /* TODO(PropertyAccessExpression): clause.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CaseClause */ TODO {
			return getRegularTypeOfLiteralType(getTypeOfExpression( /* TODO(PropertyAccessExpression): clause.expression */ TODO))
		}
		return neverType
	}
	getSwitchClauseTypes := func(switchStatement SwitchStatement) []Type {
		links := getNodeLinks(switchStatement)
		if ! /* TODO(PropertyAccessExpression): links.switchTypes */ TODO {
			/* TODO(ExpressionStatement): links.switchTypes = []; */
			for _, clause := range /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO {
				/* TODO(PropertyAccessExpression): links.switchTypes.push */ TODO(getTypeOfSwitchClause(clause))
			}
		}
		return /* TODO(PropertyAccessExpression): links.switchTypes */ TODO
	}
	getSwitchClauseTypeOfWitnesses := func(switchStatement SwitchStatement) /* TODO(ArrayType): (string | undefined)[] */ any {
		if some( /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.CaseClause && !isStringLiteralLike(clause.expression) */, TODO) {
			return nil
		}
		var witnesses [] /* TODO(StringKeyword): string */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, clause := range /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO {
			text := /* TODO(ConditionalExpression): clause.kind === SyntaxKind.CaseClause ? (clause.expression as StringLiteralLike).text : undefined */ TODO
			/* TODO(PropertyAccessExpression): witnesses.push */ TODO( /* TODO(ConditionalExpression): text && !contains(witnesses, text) ? text : undefined */ TODO)
		}
		return witnesses
	}
	eachTypeContainedIn := func(source Type, types []Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? !forEach((source as UnionType).types, t => !contains(types, t)) : contains(types, source) */ TODO
	}
	isTypeSubsetOf := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (source === target || source.flags & TypeFlags.Never || target.flags & TypeFlags.Union && isTypeSubsetOfUnion(source, target as UnionType)) */ TODO
	}
	isTypeSubsetOfUnion := func(source Type, target UnionType) /* TODO(undefined): boolean */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Union */ TODO {
			for _, t := range /* TODO(PropertyAccessExpression): (source as UnionType).types */ TODO {
				if !containsType( /* TODO(PropertyAccessExpression): target.types */ TODO, t) {
					return /* TODO(FalseKeyword): false */ TODO
				}
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.EnumLike */ TODO && getBaseTypeOfEnumLikeType(source /* as */ /* TODO(TypeReference): LiteralType */) == target {
			return /* TODO(TrueKeyword): true */ TODO
		}
		return containsType( /* TODO(PropertyAccessExpression): target.types */ TODO, source)
	}
	forEachType := func(type_ Type, f func(t Type) *T) *T {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? forEach((type as UnionType).types, f) : f(type) */ TODO
	}
	someType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? some((type as UnionType).types, f) : f(type) */ TODO
	}
	everyType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? every((type as UnionType).types, f) : f(type) */ TODO
	}
	everyContainedType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? every((type as UnionOrIntersectionType).types, f) : f(type) */ TODO
	}
	filterType := func(type_ Type, f func(t Type) bool) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			types := /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO
			filtered := filter(types, f)
			if filtered == types {
				return type_
			}
			origin := /* TODO(PropertyAccessExpression): (type as UnionType).origin */ TODO
			var newOrigin *Type
			if origin && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): origin.flags & TypeFlags.Union */ TODO {
				originTypes := /* TODO(PropertyAccessExpression): (origin as UnionType).types */ TODO
				originFiltered := filter(originTypes /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.Union) || f(t) */, TODO)
				if /* TODO(MinusToken): - */ /* TODO(BinaryExpression): originTypes.length - originFiltered.length */ TODO == /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - filtered.length */ TODO {
					if /* TODO(PropertyAccessExpression): originFiltered.length */ TODO == 1 {
						return /* TODO(ElementAccessExpression): originFiltered[0] */ TODO
					}
					/* TODO(ExpressionStatement): newOrigin = createOriginUnionOrIntersectionType(TypeFlags.Union, originFiltered); */
				}
			}
			return getUnionTypeFromSortedList(filtered /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (type as UnionType).objectFlags & (ObjectFlags.PrimitiveUnion | ObjectFlags.ContainsIntersections) */, TODO, nil, nil, newOrigin)
		}
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Never || f(type) ? type : neverType */ TODO
	}
	removeType := func(type_ Type, targetType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_ /* TODO(ArrowFunction): t => t !== targetType */, TODO)
	}
	countTypes := func(type_ Type) /* TODO(undefined): number */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1 */ TODO
	}
	// OVERLOAD: mapType := func(type_ Type, mapper func(t Type) Type, noReductions bool) Type
	// OVERLOAD: mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type
	mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
			return type_
		}
		if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union) */ TODO {
			return mapper(type_)
		}
		origin := /* TODO(PropertyAccessExpression): (type as UnionType).origin */ TODO
		types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types */ TODO
		var mappedTypes /* TODO(ArrayType): Type[] */ any
		changed := /* TODO(FalseKeyword): false */ TODO
		for _, t := range types {
			mapped := /* TODO(ConditionalExpression): t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t) */ TODO
			/* TODO(ExpressionStatement): changed ||= t !== mapped; */
			if mapped {
				if !mappedTypes {
					/* TODO(ExpressionStatement): mappedTypes = [mapped]; */
				} else {
					/* TODO(PropertyAccessExpression): mappedTypes.push */ TODO(mapped)
				}
			}
		}
		return /* TODO(ConditionalExpression): changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) : type */ TODO
	}
	mapTypeWithAlias := func(type_ Type, mapper func(t Type) Type, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && aliasSymbol ?             getUnionType(map((type as UnionType).types, mapper), UnionReduction.Literal, aliasSymbol, aliasTypeArguments) :             mapType(type, mapper) */ TODO
	}
	extractTypesOfKind := func(type_ Type, kind TypeFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_ /* TODO(ArrowFunction): t => (t.flags & kind) !== 0 */, TODO)
	}
	replacePrimitivesWithLiterals := func(typeWithPrimitives Type, typeWithLiterals Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if maybeTypeOfKind(typeWithPrimitives /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.Number | TypeFlags.BigInt */, TODO) && maybeTypeOfKind(typeWithLiterals /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping | TypeFlags.NumberLiteral | TypeFlags.BigIntLiteral */, TODO) {
			return mapType(typeWithPrimitives /* TODO(ArrowFunction): t =>                 t.flags & TypeFlags.String ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) :                     isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) :                     t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral) :                     t.flags & TypeFlags.BigInt ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral) : t */, TODO)
		}
		return typeWithPrimitives
	}
	isIncomplete := func(flowType FlowType) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): flowType.flags */ TODO == 0
	}
	getTypeFromFlowType := func(flowType FlowType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): flowType.flags === 0 ? flowType.type : flowType as Type */ TODO
	}
	createFlowType := func(type_ Type, incomplete bool) FlowType {
		return /* TODO(ConditionalExpression): incomplete ? { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } : type */ TODO
	}
	createEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		result := createObjectType( /* TODO(PropertyAccessExpression): ObjectFlags.EvolvingArray */ TODO) /* as */ /* TODO(TypeReference): EvolvingArrayType */
		/* TODO(ExpressionStatement): result.elementType = elementType; */
		return result
	}
	getEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		return /* TODO(ElementAccessExpression): evolvingArrayTypes[elementType.id] */ TODO || /* TODO(ParenthesizedExpression): (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType)) */ TODO
	}
	addEvolvingArrayElementType := func(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
		elementType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)))
		return /* TODO(ConditionalExpression): isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType])) */ TODO
	}
	createFinalArrayType := func(elementType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): elementType.flags & TypeFlags.Never ?             autoArrayType :             createArrayType(                 elementType.flags & TypeFlags.Union ?                     getUnionType((elementType as UnionType).types, UnionReduction.Subtype) :                     elementType,             ) */ TODO
	}
	getFinalArrayType := func(evolvingArrayType EvolvingArrayType) Type {
		return /* TODO(PropertyAccessExpression): evolvingArrayType.finalArrayType */ TODO || /* TODO(ParenthesizedExpression): (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType)) */ TODO
	}
	finalizeEvolvingArrayType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(type as EvolvingArrayType) : type */ TODO
	}
	getElementTypeOfEvolvingArrayType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? (type as EvolvingArrayType).elementType : neverType */ TODO
	}
	isEvolvingArrayTypeList := func(types []Type) /* TODO(undefined): boolean */ TODO {
		hasEvolvingArrayType := /* TODO(FalseKeyword): false */ TODO
		for _, t := range types {
			if ! /* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Never) */ TODO {
				if ! /* TODO(ParenthesizedExpression): (getObjectFlags(t) & ObjectFlags.EvolvingArray) */ TODO {
					return /* TODO(FalseKeyword): false */ TODO
				}
				/* TODO(ExpressionStatement): hasEvolvingArrayType = true; */
			}
		}
		return hasEvolvingArrayType
	}
	isEvolvingArrayOperationTarget := func(node Node) /* TODO(undefined): boolean */ TODO {
		root := getReferenceRoot(node)
		parent := /* TODO(PropertyAccessExpression): root.parent */ TODO
		isLengthPushOrUnshift := isPropertyAccessExpression(parent) && /* TODO(ParenthesizedExpression): (             parent.name.escapedText === "length" ||             parent.parent.kind === SyntaxKind.CallExpression                 && isIdentifier(parent.name)                 && isPushOrUnshiftIdentifier(parent.name)         ) */ TODO
		isElementAssignment := /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ElementAccessExpression */ TODO && /* TODO(PropertyAccessExpression): (parent as ElementAccessExpression).expression */ TODO == root && /* TODO(PropertyAccessExpression): parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (parent.parent as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO && /* TODO(PropertyAccessExpression): (parent.parent as BinaryExpression).left */ TODO == parent && !isAssignmentTarget( /* TODO(PropertyAccessExpression): parent.parent */ TODO) && isTypeAssignableToKind(getTypeOfExpression( /* TODO(PropertyAccessExpression): (parent as ElementAccessExpression).argumentExpression */ TODO) /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */, TODO)
		return isLengthPushOrUnshift || isElementAssignment
	}
	isDeclarationWithExplicitTypeAnnotation := func(node Declaration) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ParenthesizedExpression): (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) */ TODO && !! /* TODO(ParenthesizedExpression): (getEffectiveTypeAnnotationNode(node) ||                 isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer)) */ TODO
	}
	getExplicitTypeOfSymbol := func(symbol Symbol, diagnostic Diagnostic) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		/* TODO(ExpressionStatement): symbol = resolveSymbol(symbol); */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Function | SymbolFlags.Method | SymbolFlags.Class | SymbolFlags.ValueModule) */ TODO {
			return getTypeOfSymbol(symbol)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Variable | SymbolFlags.Property) */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Mapped */ TODO {
				origin := /* TODO(PropertyAccessExpression): (symbol as MappedSymbol).links.syntheticOrigin */ TODO
				if origin && getExplicitTypeOfSymbol(origin) {
					return getTypeOfSymbol(symbol)
				}
			}
			declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
			if declaration {
				if isDeclarationWithExplicitTypeAnnotation(declaration) {
					return getTypeOfSymbol(symbol)
				}
				if isVariableDeclaration(declaration) && /* TODO(PropertyAccessExpression): declaration.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForOfStatement */ TODO {
					statement := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
					expressionType := getTypeOfDottedName( /* TODO(PropertyAccessExpression): statement.expression */ TODO, nil)
					if expressionType {
						use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
						return checkIteratedTypeOrElementType(use, expressionType, undefinedType, nil)
					}
				}
				if diagnostic {
					addRelatedInfo(diagnostic, createDiagnosticForNode(declaration /* TODO(PropertyAccessExpression): Diagnostics._0_needs_an_explicit_type_annotation */, TODO, symbolToString(symbol)))
				}
			}
		}
	}
	getTypeOfDottedName := func(node Expression, diagnostic *Diagnostic) *Type {
		if ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.InWithStatement) */ TODO {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.Identifier:                     const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node as Identifier));                     return getExplicitTypeOfSymbol(symbol, diagnostic);                 case SyntaxKind.ThisKeyword:                     return getExplicitThisType(node);                 case SyntaxKind.SuperKeyword:                     return checkSuperExpression(node);                 case SyntaxKind.PropertyAccessExpression: {                     const type = getTypeOfDottedName((node as PropertyAccessExpression).expression, diagnostic);                     if (type) {                         const name = (node as PropertyAccessExpression).name;                         let prop: Symbol | undefined;                         if (isPrivateIdentifier(name)) {                             if (!type.symbol) {                                 return undefined;                             }                             prop = getPropertyOfType(type, getSymbolNameForPrivateIdentifier(type.symbol, name.escapedText));                         }                         else {                             prop = getPropertyOfType(type, name.escapedText);                         }                         return prop && getExplicitTypeOfSymbol(prop, diagnostic);                     }                     return undefined;                 }                 case SyntaxKind.ParenthesizedExpression:                     return getTypeOfDottedName((node as ParenthesizedExpression).expression, diagnostic);             } */
		}
	}
	getEffectsSignature := func(node /* TODO(UnionType): CallExpression | InstanceofExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		links := getNodeLinks(node)
		signature := /* TODO(PropertyAccessExpression): links.effectsSignature */ TODO
		if signature == nil {
			var funcType *Type
			if isBinaryExpression(node) {
				rightType := checkNonNullExpression( /* TODO(PropertyAccessExpression): node.right */ TODO)
				/* TODO(ExpressionStatement): funcType = getSymbolHasInstanceMethodOfObjectType(rightType); */
			} else if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExpressionStatement */ TODO {
				/* TODO(ExpressionStatement): funcType = getTypeOfDottedName(node.expression, /*diagnostic* / undefined); */
			} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.expression.kind !== SyntaxKind.SuperKeyword */ TODO {
				if isOptionalChain(node) {
					/* TODO(ExpressionStatement): funcType = checkNonNullType(                         getOptionalExpressionType(checkExpression(node.expression), node.expression),                         node.expression,                     ); */
				} else {
					/* TODO(ExpressionStatement): funcType = checkNonNullExpression(node.expression); */
				}
			}
			signatures := getSignaturesOfType(funcType && getApparentType(funcType) || unknownType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			candidate := /* TODO(ConditionalExpression): signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] :                 some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) :                 undefined */ TODO
			/* TODO(ExpressionStatement): signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature; */
		}
		return /* TODO(ConditionalExpression): signature === unknownSignature ? undefined : signature */ TODO
	}
	hasTypePredicateOrNeverReturnType := func(signature Signature) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getTypePredicateOfSignature(signature) ||             signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags & TypeFlags.Never) */ TODO
	}
	getTypePredicateArgument := func(predicate TypePredicate, callExpression CallExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): predicate.kind */ TODO == /* TODO(PropertyAccessExpression): TypePredicateKind.Identifier */ TODO || /* TODO(PropertyAccessExpression): predicate.kind */ TODO == /* TODO(PropertyAccessExpression): TypePredicateKind.AssertsIdentifier */ TODO {
			return /* TODO(ElementAccessExpression): callExpression.arguments[predicate.parameterIndex] */ TODO
		}
		invokedExpression := skipParentheses( /* TODO(PropertyAccessExpression): callExpression.expression */ TODO)
		return /* TODO(ConditionalExpression): isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined */ TODO
	}
	reportFlowControlError := func(node Node) {
		block := findAncestor(node, isFunctionOrModuleBlock) /* as */ /* TODO(UnionType): Block | ModuleBlock | SourceFile */
		sourceFile := getSourceFileOfNode(node)
		span := getSpanOfTokenAtPosition(sourceFile /* TODO(PropertyAccessExpression): block.statements.pos */, TODO)
		/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createFileDiagnostic(sourceFile /* TODO(PropertyAccessExpression): span.start */, TODO /* TODO(PropertyAccessExpression): span.length */, TODO /* TODO(PropertyAccessExpression): Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis */, TODO))
	}
	isReachableFlowNode := func(flow FlowNode) /* TODO(undefined): boolean */ TODO {
		result := isReachableFlowNodeWorker(flow /* TODO(FalseKeyword): false */, TODO)
		/* TODO(ExpressionStatement): lastFlowNode = flow; */
		/* TODO(ExpressionStatement): lastFlowNodeReachable = result; */
		return result
	}
	isFalseExpression := func(expr Expression) bool {
		node := skipParentheses(expr /* TODO(TrueKeyword): true */, TODO)
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FalseKeyword */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(ParenthesizedExpression): (                     (node as BinaryExpression).operatorToken.kind === SyntaxKind.AmpersandAmpersandToken && (isFalseExpression((node as BinaryExpression).left) || isFalseExpression((node as BinaryExpression).right)) ||                     (node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken && isFalseExpression((node as BinaryExpression).left) && isFalseExpression((node as BinaryExpression).right)                 ) */ TODO
	}
	isReachableFlowNodeWorker := func(flow FlowNode, noCacheCheck bool) bool {
		/* TODO(WhileStatement): while (true) {             if (flow === lastFlowNode) {                 return lastFlowNodeReachable;             }             const flags = flow.flags;             if (flags & FlowFlags.Shared) {                 if (!noCacheCheck) {                     const id = getFlowNodeId(flow);                     const reachable = flowNodeReachable[id];                     return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true));                 }                 noCacheCheck = false;             }             if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)) {                 flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation).antecedent;             }             else if (flags & FlowFlags.Call) {                 const signature = getEffectsSignature((flow as FlowCall).node);                 if (signature) {                     const predicate = getTypePredicateOfSignature(signature);                     if (predicate && predicate.kind === TypePredicateKind.AssertsIdentifier && !predicate.type) {                         const predicateArgument = (flow as FlowCall).node.arguments[predicate.parameterIndex];                         if (predicateArgument && isFalseExpression(predicateArgument)) {                             return false;                         }                     }                     if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {                         return false;                     }                 }                 flow = (flow as FlowCall).antecedent;             }             else if (flags & FlowFlags.BranchLabel) {                 // A branching point is reachable if any branch is reachable.                 return some((flow as FlowLabel).antecedent, f => isReachableFlowNodeWorker(f, /*noCacheCheck* / false));             }             else if (flags & FlowFlags.LoopLabel) {                 const antecedents = (flow as FlowLabel).antecedent;                 if (antecedents === undefined || antecedents.length === 0) {                     return false;                 }                 // A loop is reachable if the control flow path that leads to the top is reachable.                 flow = antecedents[0];             }             else if (flags & FlowFlags.SwitchClause) {                 // The control flow path representing an unmatched value in a switch statement with                 // no default clause is unreachable if the switch statement is exhaustive.                 const data = (flow as FlowSwitchClause).node;                 if (data.clauseStart === data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement)) {                     return false;                 }                 flow = (flow as FlowSwitchClause).antecedent;             }             else if (flags & FlowFlags.ReduceLabel) {                 // Cache is unreliable once we start adjusting labels                 lastFlowNode = undefined;                 const target = (flow as FlowReduceLabel).node.target;                 const saveAntecedents = target.antecedent;                 target.antecedent = (flow as FlowReduceLabel).node.antecedents;                 const result = isReachableFlowNodeWorker((flow as FlowReduceLabel).antecedent, /*noCacheCheck* / false);                 target.antecedent = saveAntecedents;                 return result;             }             else {                 return !(flags & FlowFlags.Unreachable);             }         } */
	}
	isPostSuperFlowNode := func(flow FlowNode, noCacheCheck bool) bool {
		/* TODO(WhileStatement): while (true) {             const flags = flow.flags;             if (flags & FlowFlags.Shared) {                 if (!noCacheCheck) {                     const id = getFlowNodeId(flow);                     const postSuper = flowNodePostSuper[id];                     return postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true));                 }                 noCacheCheck = false;             }             if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation | FlowFlags.SwitchClause)) {                 flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause).antecedent;             }             else if (flags & FlowFlags.Call) {                 if ((flow as FlowCall).node.expression.kind === SyntaxKind.SuperKeyword) {                     return true;                 }                 flow = (flow as FlowCall).antecedent;             }             else if (flags & FlowFlags.BranchLabel) {                 // A branching point is post-super if every branch is post-super.                 return every((flow as FlowLabel).antecedent, f => isPostSuperFlowNode(f, /*noCacheCheck* / false));             }             else if (flags & FlowFlags.LoopLabel) {                 // A loop is post-super if the control flow path that leads to the top is post-super.                 flow = (flow as FlowLabel).antecedent![0];             }             else if (flags & FlowFlags.ReduceLabel) {                 const target = (flow as FlowReduceLabel).node.target;                 const saveAntecedents = target.antecedent;                 target.antecedent = (flow as FlowReduceLabel).node.antecedents;                 const result = isPostSuperFlowNode((flow as FlowReduceLabel).antecedent, /*noCacheCheck* / false);                 target.antecedent = saveAntecedents;                 return result;             }             else {                 // Unreachable nodes are considered post-super to silence errors                 return !!(flags & FlowFlags.Unreachable);             }         } */
	}
	isConstantReference := func(node Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ThisKeyword:                 return true;             case SyntaxKind.Identifier:                 if (!isThisInTypeQuery(node)) {                     const symbol = getResolvedSymbol(node as Identifier);                     return isConstantVariable(symbol)                         || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)                         || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration);                 }                 break;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 // The resolvedSymbol property is initialized by checkPropertyAccess or checkElementAccess before we get here.                 return isConstantReference((node as AccessExpression).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol);             case SyntaxKind.ObjectBindingPattern:             case SyntaxKind.ArrayBindingPattern:                 const rootDeclaration = getRootDeclaration(node.parent);                 return isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration)                     ? !isSomeSymbolAssigned(rootDeclaration)                     : isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration);         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	getFlowTypeOfReference := func(reference Node, declaredType Type, initialType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO /* = */ /* TODO(Identifier): declaredType */, flowContainer Node, flowNode /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode | undefined */ TODO /* = */ /* TODO(PropertyAccessExpression): tryCast(reference, canHaveFlowNode)?.flowNode */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var key /* TODO(StringKeyword): string */ any
		isKeySet := /* TODO(FalseKeyword): false */ TODO
		flowDepth := 0
		if flowAnalysisDisabled {
			return errorType
		}
		if !flowNode {
			return declaredType
		}
		/* TODO(ExpressionStatement): flowInvocationCount++; */
		sharedFlowStart := sharedFlowCount
		evolvedType := getTypeFromFlowType(getTypeAtFlowNode(flowNode))
		/* TODO(ExpressionStatement): sharedFlowCount = sharedFlowStart; */
		resultType := /* TODO(ConditionalExpression): getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType) */ TODO
		if resultType == unreachableNeverType || /* TODO(PropertyAccessExpression): reference.parent */ TODO && /* TODO(PropertyAccessExpression): reference.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NonNullExpression */ TODO && ! /* TODO(ParenthesizedExpression): (resultType.flags & TypeFlags.Never) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getTypeWithFacts(resultType, TypeFacts.NEUndefinedOrNull).flags & TypeFlags.Never */ TODO {
			return declaredType
		}
		return resultType
		getOrSetCacheKey := func() /* TODO(undefined): string | undefined */ TODO {
			if isKeySet {
				return key
			}
			/* TODO(ExpressionStatement): isKeySet = true; */
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): key = getFlowCacheKey(reference, declaredType, initialType, flowContainer) */ TODO
		}
		getTypeAtFlowNode := func(flow FlowNode) FlowType {
			if flowDepth == 2000 {
				/* TODO(PropertyAccessExpression): tracing?.instant */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "getTypeAtFlowNode_DepthLimit" /* TODO(ObjectLiteralExpression): { flowId: flow.id } */, TODO)
				/* TODO(ExpressionStatement): flowAnalysisDisabled = true; */
				reportFlowControlError(reference)
				return errorType
			}
			/* TODO(ExpressionStatement): flowDepth++; */
			var sharedFlow *FlowNode
			/* TODO(WhileStatement): while (true) {                 const flags = flow.flags;                 if (flags & FlowFlags.Shared) {                     // We cache results of flow type resolution for shared nodes that were previously visited in                     // the same getFlowTypeOfReference invocation. A node is considered shared when it is the                     // antecedent of more than one node.                     for (let i = sharedFlowStart; i < sharedFlowCount; i++) {                         if (sharedFlowNodes[i] === flow) {                             flowDepth--;                             return sharedFlowTypes[i];                         }                     }                     sharedFlow = flow;                 }                 let type: FlowType | undefined;                 if (flags & FlowFlags.Assignment) {                     type = getTypeAtFlowAssignment(flow as FlowAssignment);                     if (!type) {                         flow = (flow as FlowAssignment).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.Call) {                     type = getTypeAtFlowCall(flow as FlowCall);                     if (!type) {                         flow = (flow as FlowCall).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.Condition) {                     type = getTypeAtFlowCondition(flow as FlowCondition);                 }                 else if (flags & FlowFlags.SwitchClause) {                     type = getTypeAtSwitchClause(flow as FlowSwitchClause);                 }                 else if (flags & FlowFlags.Label) {                     if ((flow as FlowLabel).antecedent!.length === 1) {                         flow = (flow as FlowLabel).antecedent![0];                         continue;                     }                     type = flags & FlowFlags.BranchLabel ?                         getTypeAtFlowBranchLabel(flow as FlowLabel) :                         getTypeAtFlowLoopLabel(flow as FlowLabel);                 }                 else if (flags & FlowFlags.ArrayMutation) {                     type = getTypeAtFlowArrayMutation(flow as FlowArrayMutation);                     if (!type) {                         flow = (flow as FlowArrayMutation).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.ReduceLabel) {                     const target = (flow as FlowReduceLabel).node.target;                     const saveAntecedents = target.antecedent;                     target.antecedent = (flow as FlowReduceLabel).node.antecedents;                     type = getTypeAtFlowNode((flow as FlowReduceLabel).antecedent);                     target.antecedent = saveAntecedents;                 }                 else if (flags & FlowFlags.Start) {                     // Check if we should continue with the control flow of the containing function.                     const container = (flow as FlowStart).node;                     if (                         container && container !== flowContainer &&                         reference.kind !== SyntaxKind.PropertyAccessExpression &&                         reference.kind !== SyntaxKind.ElementAccessExpression &&                         !(reference.kind === SyntaxKind.ThisKeyword && container.kind !== SyntaxKind.ArrowFunction)                     ) {                         flow = container.flowNode!;                         continue;                     }                     // At the top of the flow we have the initial type.                     type = initialType;                 }                 else {                     // Unreachable code errors are reported in the binding phase. Here we                     // simply return the non-auto declared type to reduce follow-on errors.                     type = convertAutoToAny(declaredType);                 }                 if (sharedFlow) {                     // Record visited node and the associated type in the cache.                     sharedFlowNodes[sharedFlowCount] = sharedFlow;                     sharedFlowTypes[sharedFlowCount] = type;                     sharedFlowCount++;                 }                 flowDepth--;                 return type;             } */
		}
		getInitialOrAssignedType := func(flow FlowAssignment) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			node := /* TODO(PropertyAccessExpression): flow.node */ TODO
			return getNarrowableTypeForReference( /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ?                     getInitialType(node as VariableDeclaration | BindingElement) :                     getAssignedType(node) */ TODO, reference)
		}
		getTypeAtFlowAssignment := func(flow FlowAssignment) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FlowType | undefined */ TODO {
			node := /* TODO(PropertyAccessExpression): flow.node */ TODO
			if isMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if getAssignmentTargetKind(node) == /* TODO(PropertyAccessExpression): AssignmentKind.Compound */ TODO {
					flowType := getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
					return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType))
				}
				if declaredType == autoType || declaredType == autoArrayType {
					if isEmptyArrayAssignment(node) {
						return getEvolvingArrayType(neverType)
					}
					assignedType := getWidenedLiteralType(getInitialOrAssignedType(flow))
					return /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType */ TODO
				}
				t := /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType */ TODO
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): t.flags & TypeFlags.Union */ TODO {
					return getAssignmentReducedType(t /* as */ /* TODO(TypeReference): UnionType */, getInitialOrAssignedType(flow))
				}
				return t
			}
			if containsMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if isVariableDeclaration(node) && /* TODO(ParenthesizedExpression): (isInJSFile(node) || isVarConstLike(node)) */ TODO {
					init := getDeclaredExpandoInitializer(node)
					if init && /* TODO(ParenthesizedExpression): (init.kind === SyntaxKind.FunctionExpression || init.kind === SyntaxKind.ArrowFunction) */ TODO {
						return getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
					}
				}
				return declaredType
			}
			if isVariableDeclaration(node) && /* TODO(PropertyAccessExpression): node.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForInStatement */ TODO && /* TODO(ParenthesizedExpression): (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference)) */ TODO {
				return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO))))
			}
			return nil
		}
		narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
			node := skipParentheses(expr /* TODO(TrueKeyword): true */, TODO)
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FalseKeyword */ TODO {
				return unreachableNeverType
			}
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO {
				if /* TODO(PropertyAccessExpression): (node as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.AmpersandAmpersandToken */ TODO {
					return narrowTypeByAssertion(narrowTypeByAssertion(type_ /* TODO(PropertyAccessExpression): (node as BinaryExpression).left */, TODO) /* TODO(PropertyAccessExpression): (node as BinaryExpression).right */, TODO)
				}
				if /* TODO(PropertyAccessExpression): (node as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BarBarToken */ TODO {
					return getUnionType( /* TODO(ArrayLiteralExpression): [narrowTypeByAssertion(type, (node as BinaryExpression).left), narrowTypeByAssertion(type, (node as BinaryExpression).right)] */ TODO)
				}
			}
			return narrowType(type_, node /* TODO(TrueKeyword): true */, TODO)
		}
		getTypeAtFlowCall := func(flow FlowCall) *FlowType {
			signature := getEffectsSignature( /* TODO(PropertyAccessExpression): flow.node */ TODO)
			if signature {
				predicate := getTypePredicateOfSignature(signature)
				if predicate && /* TODO(ParenthesizedExpression): (predicate.kind === TypePredicateKind.AssertsThis || predicate.kind === TypePredicateKind.AssertsIdentifier) */ TODO {
					flowType := getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
					type_ := finalizeEvolvingArrayType(getTypeFromFlowType(flowType))
					narrowedType := /* TODO(ConditionalExpression): predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue* / true) :                         predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) :                         type */ TODO
					return /* TODO(ConditionalExpression): narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType)) */ TODO
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getReturnTypeOfSignature(signature).flags & TypeFlags.Never */ TODO {
					return unreachableNeverType
				}
			}
			return nil
		}
		getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
			if declaredType == autoType || declaredType == autoArrayType {
				node := /* TODO(PropertyAccessExpression): flow.node */ TODO
				expr := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ?                     (node.expression as PropertyAccessExpression).expression :                     (node.left as ElementAccessExpression).expression */ TODO
				if isMatchingReference(reference, getReferenceCandidate(expr)) {
					flowType := getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
					type_ := getTypeFromFlowType(flowType)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray */ TODO {
						evolvedType := type_ /* as */ /* TODO(TypeReference): EvolvingArrayType */
						if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CallExpression */ TODO {
							for _, arg := range /* TODO(PropertyAccessExpression): node.arguments */ TODO {
								/* TODO(ExpressionStatement): evolvedType = addEvolvingArrayElementType(evolvedType, arg); */
							}
						} else {
							indexType := getContextFreeTypeOfExpression( /* TODO(PropertyAccessExpression): (node.left as ElementAccessExpression).argumentExpression */ TODO)
							if isTypeAssignableToKind(indexType /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */, TODO) {
								/* TODO(ExpressionStatement): evolvedType = addEvolvingArrayElementType(evolvedType, node.right); */
							}
						}
						return /* TODO(ConditionalExpression): evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType)) */ TODO
					}
					return flowType
				}
			}
			return nil
		}
		getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
			flowType := getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
			type_ := getTypeFromFlowType(flowType)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
				return flowType
			}
			assumeTrue := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (flow.flags & FlowFlags.TrueCondition) !== 0 */ TODO
			nonEvolvingType := finalizeEvolvingArrayType(type_)
			narrowedType := narrowType(nonEvolvingType /* TODO(PropertyAccessExpression): flow.node */, TODO, assumeTrue)
			if narrowedType == nonEvolvingType {
				return flowType
			}
			return createFlowType(narrowedType, isIncomplete(flowType))
		}
		getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
			expr := skipParentheses( /* TODO(PropertyAccessExpression): flow.node.switchStatement.expression */ TODO)
			flowType := getTypeAtFlowNode( /* TODO(PropertyAccessExpression): flow.antecedent */ TODO)
			type_ := getTypeFromFlowType(flowType)
			if isMatchingReference(reference, expr) {
				/* TODO(ExpressionStatement): type = narrowTypeBySwitchOnDiscriminant(type, flow.node); */
			} else if /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeOfExpression */ TODO && isMatchingReference(reference /* TODO(PropertyAccessExpression): (expr as TypeOfExpression).expression */, TODO) {
				/* TODO(ExpressionStatement): type = narrowTypeBySwitchOnTypeOf(type, flow.node); */
			} else if /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TrueKeyword */ TODO {
				/* TODO(ExpressionStatement): type = narrowTypeBySwitchOnTrue(type, flow.node); */
			} else {
				if strictNullChecks {
					if optionalChainContainsReference(expr, reference) {
						/* TODO(ExpressionStatement): type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & (TypeFlags.Undefined | TypeFlags.Never))); */
					} else if /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeOfExpression */ TODO && optionalChainContainsReference( /* TODO(PropertyAccessExpression): (expr as TypeOfExpression).expression */ TODO, reference) {
						/* TODO(ExpressionStatement): type = narrowTypeBySwitchOptionalChainContainment(type, flow.node, t => !(t.flags & TypeFlags.Never || t.flags & TypeFlags.StringLiteral && (t as StringLiteralType).value === "undefined")); */
					}
				}
				access := getDiscriminantPropertyAccess(expr, type_)
				if access {
					/* TODO(ExpressionStatement): type = narrowTypeBySwitchOnDiscriminantProperty(type, access, flow.node); */
				}
			}
			return createFlowType(type_, isIncomplete(flowType))
		}
		getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
			var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			subtypeReduction := /* TODO(FalseKeyword): false */ TODO
			seenIncomplete := /* TODO(FalseKeyword): false */ TODO
			var bypassFlow *FlowSwitchClause
			for _, antecedent := range /* TODO(NonNullExpression): flow.antecedent! */ TODO {
				if !bypassFlow && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): antecedent.flags & FlowFlags.SwitchClause */ TODO && /* TODO(PropertyAccessExpression): (antecedent as FlowSwitchClause).node.clauseStart */ TODO == /* TODO(PropertyAccessExpression): (antecedent as FlowSwitchClause).node.clauseEnd */ TODO {
					/* TODO(ExpressionStatement): bypassFlow = antecedent as FlowSwitchClause; */
					/* TODO(ContinueStatement): continue; */
				}
				flowType := getTypeAtFlowNode(antecedent)
				type_ := getTypeFromFlowType(flowType)
				if type_ == declaredType && declaredType == initialType {
					return type_
				}
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					/* TODO(ExpressionStatement): subtypeReduction = true; */
				}
				if isIncomplete(flowType) {
					/* TODO(ExpressionStatement): seenIncomplete = true; */
				}
			}
			if bypassFlow {
				flowType := getTypeAtFlowNode(bypassFlow)
				type_ := getTypeFromFlowType(flowType)
				if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Never) */ TODO && !contains(antecedentTypes, type_) && !isExhaustiveSwitchStatement( /* TODO(PropertyAccessExpression): bypassFlow.node.switchStatement */ TODO) {
					if type_ == declaredType && declaredType == initialType {
						return type_
					}
					/* TODO(PropertyAccessExpression): antecedentTypes.push */ TODO(type_)
					if !isTypeSubsetOf(type_, initialType) {
						/* TODO(ExpressionStatement): subtypeReduction = true; */
					}
					if isIncomplete(flowType) {
						/* TODO(ExpressionStatement): seenIncomplete = true; */
					}
				}
			}
			return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO), seenIncomplete)
		}
		getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
			id := getFlowNodeId(flow)
			cache := /* TODO(ElementAccessExpression): flowLoopCaches[id] */ TODO || /* TODO(ParenthesizedExpression): (flowLoopCaches[id] = new Map<string, Type>()) */ TODO
			key := getOrSetCacheKey()
			if !key {
				return declaredType
			}
			cached := /* TODO(PropertyAccessExpression): cache.get */ TODO(key)
			if cached {
				return cached
			}
			/* TODO(ForStatement): for (let i = flowLoopStart; i < flowLoopCount; i++) {                 if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {                     return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), /*incomplete* / true);                 }             } */
			var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			subtypeReduction := /* TODO(FalseKeyword): false */ TODO
			var firstAntecedentType *FlowType
			for _, antecedent := range /* TODO(NonNullExpression): flow.antecedent! */ TODO {
				var flowType TODO
				if !firstAntecedentType {
					/* TODO(ExpressionStatement): flowType = firstAntecedentType = getTypeAtFlowNode(antecedent); */
				} else {
					/* TODO(ExpressionStatement): flowLoopNodes[flowLoopCount] = flow; */
					/* TODO(ExpressionStatement): flowLoopKeys[flowLoopCount] = key; */
					/* TODO(ExpressionStatement): flowLoopTypes[flowLoopCount] = antecedentTypes; */
					/* TODO(ExpressionStatement): flowLoopCount++; */
					saveFlowTypeCache := flowTypeCache
					/* TODO(ExpressionStatement): flowTypeCache = undefined; */
					/* TODO(ExpressionStatement): flowType = getTypeAtFlowNode(antecedent); */
					/* TODO(ExpressionStatement): flowTypeCache = saveFlowTypeCache; */
					/* TODO(ExpressionStatement): flowLoopCount--; */
					cached := /* TODO(PropertyAccessExpression): cache.get */ TODO(key)
					if cached {
						return cached
					}
				}
				type_ := getTypeFromFlowType(flowType)
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					/* TODO(ExpressionStatement): subtypeReduction = true; */
				}
				if type_ == declaredType {
					/* TODO(BreakStatement): break; */
				}
			}
			result := getUnionOrEvolvingArrayType(antecedentTypes /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			if isIncomplete( /* TODO(NonNullExpression): firstAntecedentType! */ TODO) {
				return createFlowType(result /* TODO(TrueKeyword): true */, TODO)
			}
			/* TODO(PropertyAccessExpression): cache.set */ TODO(key, result)
			return result
		}
		getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if isEvolvingArrayTypeList(types) {
				return getEvolvingArrayType(getUnionType(map_(types, getElementTypeOfEvolvingArrayType)))
			}
			result := recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction))
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== declaredType */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): result.flags & declaredType.flags & TypeFlags.Union */ TODO && arrayIsEqualTo( /* TODO(PropertyAccessExpression): (result as UnionType).types */ TODO /* TODO(PropertyAccessExpression): (declaredType as UnionType).types */, TODO) {
				return declaredType
			}
			return result
		}
		getCandidateDiscriminantPropertyAccess := func(expr Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
			if isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) {
				if isIdentifier(expr) {
					symbol := getResolvedSymbol(expr)
					declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
					if declaration && /* TODO(ParenthesizedExpression): (isBindingElement(declaration) || isParameter(declaration)) */ TODO && reference == /* TODO(PropertyAccessExpression): declaration.parent */ TODO && ! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && ! /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO {
						return declaration
					}
				}
			} else if isAccessExpression(expr) {
				if isMatchingReference(reference /* TODO(PropertyAccessExpression): expr.expression */, TODO) {
					return expr
				}
			} else if isIdentifier(expr) {
				symbol := getResolvedSymbol(expr)
				if isConstantVariable(symbol) {
					declaration := /* TODO(NonNullExpression): symbol.valueDeclaration! */ TODO
					if isVariableDeclaration(declaration) && ! /* TODO(PropertyAccessExpression): declaration.type */ TODO && /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && isAccessExpression( /* TODO(PropertyAccessExpression): declaration.initializer */ TODO) && isMatchingReference(reference /* TODO(PropertyAccessExpression): declaration.initializer.expression */, TODO) {
						return /* TODO(PropertyAccessExpression): declaration.initializer */ TODO
					}
					if isBindingElement(declaration) && ! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO {
						parent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
						if isVariableDeclaration(parent) && ! /* TODO(PropertyAccessExpression): parent.type */ TODO && /* TODO(PropertyAccessExpression): parent.initializer */ TODO && /* TODO(ParenthesizedExpression): (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) */ TODO && isMatchingReference(reference /* TODO(PropertyAccessExpression): parent.initializer */, TODO) {
							return declaration
						}
					}
				}
			}
			return nil
		}
		getDiscriminantPropertyAccess := func(expr Expression, computedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declaredType.flags & TypeFlags.Union */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): computedType.flags & TypeFlags.Union */ TODO {
				access := getCandidateDiscriminantPropertyAccess(expr)
				if access {
					name := getAccessedPropertyName(access)
					if name {
						type_ := /* TODO(ConditionalExpression): declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType */ TODO
						if isDiscriminantProperty(type_, name) {
							return access
						}
					}
				}
			}
			return nil
		}
		narrowTypeByDiscriminant := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
			propName := getAccessedPropertyName(access)
			if propName == nil {
				return type_
			}
			optionalChain := isOptionalChain(access)
			removeNullable := strictNullChecks && /* TODO(ParenthesizedExpression): (optionalChain || isNonNullAccess(access)) */ TODO && maybeTypeOfKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.Nullable */, TODO)
			propType := getTypeOfPropertyOfType( /* TODO(ConditionalExpression): removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO, propName)
			if !propType {
				return type_
			}
			/* TODO(ExpressionStatement): propType = removeNullable && optionalChain ? getOptionalType(propType) : propType; */
			narrowedPropType := narrowType(propType)
			return filterType(type_ /* TODO(ArrowFunction): t => {                 const discriminantType = getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType;                 return !(discriminantType.flags & TypeFlags.Never) && !(narrowedPropType.flags & TypeFlags.Never) && areTypesComparable(narrowedPropType, discriminantType);             } */, TODO)
		}
		narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if /* TODO(ParenthesizedExpression): (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
				keyPropertyName := getKeyPropertyName(type_ /* as */ /* TODO(TypeReference): UnionType */)
				if keyPropertyName && keyPropertyName == getAccessedPropertyName(access) {
					candidate := getConstituentTypeForKeyType(type_ /* as */ /* TODO(TypeReference): UnionType */, getTypeOfExpression(value))
					if candidate {
						return /* TODO(ConditionalExpression): operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate :                             isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :                             type */ TODO
					}
				}
			}
			return narrowTypeByDiscriminant(type_, access /* TODO(ArrowFunction): t => narrowTypeByEquality(t, operator, value, assumeTrue) */, TODO)
		}
		narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if /* TODO(PropertyAccessExpression): data.clauseStart */ TODO < /* TODO(PropertyAccessExpression): data.clauseEnd */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO && getKeyPropertyName(type_ /* as */ /* TODO(TypeReference): UnionType */) == getAccessedPropertyName(access) {
				clauseTypes := /* TODO(PropertyAccessExpression): getSwitchClauseTypes(data.switchStatement).slice */ TODO( /* TODO(PropertyAccessExpression): data.clauseStart */ TODO /* TODO(PropertyAccessExpression): data.clauseEnd */, TODO)
				candidate := getUnionType(map_(clauseTypes /* TODO(ArrowFunction): t => getConstituentTypeForKeyType(type as UnionType, t) || unknownType */, TODO))
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): candidate !== unknownType */ TODO {
					return candidate
				}
			}
			return narrowTypeByDiscriminant(type_, access /* TODO(ArrowFunction): t => narrowTypeBySwitchOnDiscriminant(t, data) */, TODO)
		}
		narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */, TODO)
			}
			if strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference) {
				/* TODO(ExpressionStatement): type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull); */
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access /* TODO(ArrowFunction): t => getTypeWithFacts(t, assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy) */, TODO)
			}
			return type_
		}
		isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) /* TODO(undefined): boolean */ TODO {
			prop := getPropertyOfType(type_, propName)
			return /* TODO(ConditionalExpression): prop ?                 !!(prop.flags & SymbolFlags.Optional || getCheckFlags(prop) & CheckFlags.Partial) || assumeTrue :                 !!getApplicableIndexInfoForName(type, propName) || !assumeTrue */ TODO
		}
		narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(UnionType): StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			name := getPropertyNameFromType(nameType)
			isKnownProperty := someType(type_ /* TODO(ArrowFunction): t => isTypePresencePossible(t, name, /*assumeTrue* / true) */, TODO)
			if isKnownProperty {
				return filterType(type_ /* TODO(ArrowFunction): t => isTypePresencePossible(t, name, assumeTrue) */, TODO)
			}
			if assumeTrue {
				recordSymbol := getGlobalRecordSymbol()
				if recordSymbol {
					return getIntersectionType( /* TODO(ArrayLiteralExpression): [type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])] */ TODO)
				}
			}
			return type_
		}
		narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
			/* TODO(ExpressionStatement): assumeTrue = (assumeTrue !== (bool.kind === SyntaxKind.TrueKeyword)) !== (operator !== SyntaxKind.ExclamationEqualsEqualsToken && operator !== SyntaxKind.ExclamationEqualsToken); */
			return narrowType(type_, expr, assumeTrue)
		}
		narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			/* TODO(SwitchStatement): switch (expr.operatorToken.kind) {                 case SyntaxKind.EqualsToken:                 case SyntaxKind.BarBarEqualsToken:                 case SyntaxKind.AmpersandAmpersandEqualsToken:                 case SyntaxKind.QuestionQuestionEqualsToken:                     return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);                 case SyntaxKind.EqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsToken:                 case SyntaxKind.EqualsEqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsEqualsToken:                     const operator = expr.operatorToken.kind;                     const left = getReferenceCandidate(expr.left);                     const right = getReferenceCandidate(expr.right);                     if (left.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(right)) {                         return narrowTypeByTypeof(type, left as TypeOfExpression, operator, right, assumeTrue);                     }                     if (right.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(left)) {                         return narrowTypeByTypeof(type, right as TypeOfExpression, operator, left, assumeTrue);                     }                     if (isMatchingReference(reference, left)) {                         return narrowTypeByEquality(type, operator, right, assumeTrue);                     }                     if (isMatchingReference(reference, right)) {                         return narrowTypeByEquality(type, operator, left, assumeTrue);                     }                     if (strictNullChecks) {                         if (optionalChainContainsReference(left, reference)) {                             type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);                         }                         else if (optionalChainContainsReference(right, reference)) {                             type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);                         }                     }                     const leftAccess = getDiscriminantPropertyAccess(left, type);                     if (leftAccess) {                         return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);                     }                     const rightAccess = getDiscriminantPropertyAccess(right, type);                     if (rightAccess) {                         return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);                     }                     if (isMatchingConstructorReference(left)) {                         return narrowTypeByConstructor(type, operator, right, assumeTrue);                     }                     if (isMatchingConstructorReference(right)) {                         return narrowTypeByConstructor(type, operator, left, assumeTrue);                     }                     if (isBooleanLiteral(right) && !isAccessExpression(left)) {                         return narrowTypeByBooleanComparison(type, left, right, operator, assumeTrue);                     }                     if (isBooleanLiteral(left) && !isAccessExpression(right)) {                         return narrowTypeByBooleanComparison(type, right, left, operator, assumeTrue);                     }                     break;                 case SyntaxKind.InstanceOfKeyword:                     return narrowTypeByInstanceof(type, expr as InstanceofExpression, assumeTrue);                 case SyntaxKind.InKeyword:                     if (isPrivateIdentifier(expr.left)) {                         return narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue);                     }                     const target = getReferenceCandidate(expr.right);                     if (containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(reference.expression, target)) {                         const leftType = getTypeOfExpression(expr.left);                         if (isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) === getPropertyNameFromType(leftType)) {                             return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);                         }                     }                     if (isMatchingReference(reference, target)) {                         const leftType = getTypeOfExpression(expr.left);                         if (isTypeUsableAsPropertyName(leftType)) {                             return narrowTypeByInKeyword(type, leftType, assumeTrue);                         }                     }                     break;                 case SyntaxKind.CommaToken:                     return narrowType(type, expr.right, assumeTrue);                 // Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those                 // expressions down to individual conditional control flows. However, we may encounter them when analyzing                 // aliased conditional expressions.                 case SyntaxKind.AmpersandAmpersandToken:                     return assumeTrue ?                         narrowType(narrowType(type, expr.left, /*assumeTrue* / true), expr.right, /*assumeTrue* / true) :                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / false), narrowType(type, expr.right, /*assumeTrue* / false)]);                 case SyntaxKind.BarBarToken:                     return assumeTrue ?                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / true), narrowType(type, expr.right, /*assumeTrue* / true)]) :                         narrowType(narrowType(type, expr.left, /*assumeTrue* / false), expr.right, /*assumeTrue* / false);             } */
			return type_
		}
		narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			target := getReferenceCandidate( /* TODO(PropertyAccessExpression): expr.right */ TODO)
			if !isMatchingReference(reference, target) {
				return type_
			}
			/* TODO(PropertyAccessExpression): Debug.assertNode */ TODO( /* TODO(PropertyAccessExpression): expr.left */ TODO, isPrivateIdentifier)
			symbol := getSymbolForPrivateIdentifierExpression( /* TODO(PropertyAccessExpression): expr.left */ TODO)
			if symbol == nil {
				return type_
			}
			classSymbol := /* TODO(NonNullExpression): symbol.parent! */ TODO
			targetType := /* TODO(ConditionalExpression): hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration"))                 ? getTypeOfSymbol(classSymbol) as InterfaceType                 : getDeclaredTypeOfSymbol(classSymbol) */ TODO
			return getNarrowedType(type_, targetType, assumeTrue /* TODO(TrueKeyword): true */, TODO)
		}
		narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			equalsOperator := operator == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsEqualsToken */ TODO || operator == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsEqualsEqualsToken */ TODO
			nullableFlags := /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined */ TODO
			valueType := getTypeOfExpression(value)
			removeNullable := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): equalsOperator !== assumeTrue */ TODO && everyType(valueType /* TODO(ArrowFunction): t => !!(t.flags & nullableFlags) */, TODO) || equalsOperator == assumeTrue && everyType(valueType /* TODO(ArrowFunction): t => !(t.flags & (TypeFlags.AnyOrUnknown | nullableFlags)) */, TODO)
			return /* TODO(ConditionalExpression): removeNullable ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
		}
		narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Any */ TODO {
				return type_
			}
			if operator == /* TODO(PropertyAccessExpression): SyntaxKind.ExclamationEqualsToken */ TODO || operator == /* TODO(PropertyAccessExpression): SyntaxKind.ExclamationEqualsEqualsToken */ TODO {
				/* TODO(ExpressionStatement): assumeTrue = !assumeTrue; */
			}
			valueType := getTypeOfExpression(value)
			doubleEquals := operator == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsEqualsToken */ TODO || operator == /* TODO(PropertyAccessExpression): SyntaxKind.ExclamationEqualsToken */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): valueType.flags & TypeFlags.Nullable */ TODO {
				if !strictNullChecks {
					return type_
				}
				facts := /* TODO(ConditionalExpression): doubleEquals ?                     assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull :                     valueType.flags & TypeFlags.Null ?                     assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull :                     assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined */ TODO
				return getAdjustedTypeWithFacts(type_, facts)
			}
			if assumeTrue {
				if !doubleEquals && /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Unknown || someType(type, isEmptyAnonymousObjectType)) */ TODO {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): valueType.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive) */ TODO || isEmptyAnonymousObjectType(valueType) {
						return valueType
					}
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): valueType.flags & TypeFlags.Object */ TODO {
						return nonPrimitiveType
					}
				}
				filteredType := filterType(type_ /* TODO(ArrowFunction): t => areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType) */, TODO)
				return replacePrimitivesWithLiterals(filteredType, valueType)
			}
			if isUnitType(valueType) {
				return filterType(type_ /* TODO(ArrowFunction): t => !(isUnitLikeType(t) && areTypesComparable(t, valueType)) */, TODO)
			}
			return type_
		}
		narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
			if operator == /* TODO(PropertyAccessExpression): SyntaxKind.ExclamationEqualsToken */ TODO || operator == /* TODO(PropertyAccessExpression): SyntaxKind.ExclamationEqualsEqualsToken */ TODO {
				/* TODO(ExpressionStatement): assumeTrue = !assumeTrue; */
			}
			target := getReferenceCandidate( /* TODO(PropertyAccessExpression): typeOfExpr.expression */ TODO)
			if !isMatchingReference(reference, target) {
				if strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue == /* TODO(ParenthesizedExpression): (literal.text !== "undefined") */ TODO {
					/* TODO(ExpressionStatement): type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull); */
				}
				propertyAccess := getDiscriminantPropertyAccess(target, type_)
				if propertyAccess {
					return narrowTypeByDiscriminant(type_, propertyAccess /* TODO(ArrowFunction): t => narrowTypeByLiteralExpression(t, literal, assumeTrue) */, TODO)
				}
				return type_
			}
			return narrowTypeByLiteralExpression(type_, literal, assumeTrue)
		}
		narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): assumeTrue ?                 narrowTypeByTypeName(type, literal.text) :                 getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject) */ TODO
		}
		narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			everyClauseChecks := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): clauseStart !== clauseEnd */ TODO && every( /* TODO(PropertyAccessExpression): getSwitchClauseTypes(switchStatement).slice */ TODO(clauseStart, clauseEnd), clauseCheck)
			return /* TODO(ConditionalExpression): everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
		}
		narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			switchTypes := getSwitchClauseTypes(switchStatement)
			if ! /* TODO(PropertyAccessExpression): switchTypes.length */ TODO {
				return type_
			}
			clauseTypes := /* TODO(PropertyAccessExpression): switchTypes.slice */ TODO(clauseStart, clauseEnd)
			hasDefaultClause := clauseStart == clauseEnd || contains(clauseTypes, neverType)
			if /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Unknown) */ TODO && !hasDefaultClause {
				var groundClauseTypes /* TODO(ArrayType): Type[] */ any
				/* TODO(ForStatement): for (let i = 0; i < clauseTypes.length; i += 1) {                     const t = clauseTypes[i];                     if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {                         if (groundClauseTypes !== undefined) {                             groundClauseTypes.push(t);                         }                     }                     else if (t.flags & TypeFlags.Object) {                         if (groundClauseTypes === undefined) {                             groundClauseTypes = clauseTypes.slice(0, i);                         }                         groundClauseTypes.push(nonPrimitiveType);                     }                     else {                         return type;                     }                 } */
				return getUnionType( /* TODO(ConditionalExpression): groundClauseTypes === undefined ? clauseTypes : groundClauseTypes */ TODO)
			}
			discriminantType := getUnionType(clauseTypes)
			caseType := /* TODO(ConditionalExpression): discriminantType.flags & TypeFlags.Never ? neverType :                 replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType) */ TODO
			if !hasDefaultClause {
				return caseType
			}
			defaultType := filterType(type_ /* TODO(ArrowFunction): t => !(isUnitLikeType(t) && contains(switchTypes, t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)))) */, TODO)
			return /* TODO(ConditionalExpression): caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]) */ TODO
		}
		narrowTypeByTypeName := func(type_ Type, typeName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(SwitchStatement): switch (typeName) {                 case "string":                     return narrowTypeByTypeFacts(type, stringType, TypeFacts.TypeofEQString);                 case "number":                     return narrowTypeByTypeFacts(type, numberType, TypeFacts.TypeofEQNumber);                 case "bigint":                     return narrowTypeByTypeFacts(type, bigintType, TypeFacts.TypeofEQBigInt);                 case "boolean":                     return narrowTypeByTypeFacts(type, booleanType, TypeFacts.TypeofEQBoolean);                 case "symbol":                     return narrowTypeByTypeFacts(type, esSymbolType, TypeFacts.TypeofEQSymbol);                 case "object":                     return type.flags & TypeFlags.Any ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQObject), narrowTypeByTypeFacts(type, nullType, TypeFacts.EQNull)]);                 case "function":                     return type.flags & TypeFlags.Any ? type : narrowTypeByTypeFacts(type, globalFunctionType, TypeFacts.TypeofEQFunction);                 case "undefined":                     return narrowTypeByTypeFacts(type, undefinedType, TypeFacts.EQUndefined);             } */
			return narrowTypeByTypeFacts(type_, nonPrimitiveType /* TODO(PropertyAccessExpression): TypeFacts.TypeofEQHostObject */, TODO)
		}
		narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return mapType(type_ /* TODO(ArrowFunction): t =>                 // We first check if a constituent is a subtype of the implied type. If so, we either keep or eliminate                 // the constituent based on its type facts. We use the strict subtype relation because it treats `object`                 // as a subtype of `{}`, and we need the type facts check because function types are subtypes of `object`,                 // but are classified as "function" according to `typeof`.                 isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? hasTypeFacts(t, facts) ? t : neverType :                     // We next check if the consituent is a supertype of the implied type. If so, we substitute the implied                     // type. This handles top types like `unknown` and `{}`, and supertypes like `{ toString(): string }`.                     isTypeSubtypeOf(impliedType, t) ? impliedType :                     // Neither the constituent nor the implied type is a subtype of the other, however their domains may still                     // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate                     // possible overlap, we form an intersection. Otherwise, we eliminate the constituent.                     hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) :                     neverType */, TODO)
		}
		narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			witnesses := getSwitchClauseTypeOfWitnesses(switchStatement)
			if !witnesses {
				return type_
			}
			defaultIndex := findIndex( /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.DefaultClause */, TODO)
			hasDefaultClause := clauseStart == clauseEnd || /* TODO(ParenthesizedExpression): (defaultIndex >= clauseStart && defaultIndex < clauseEnd) */ TODO
			if hasDefaultClause {
				notEqualFacts := getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
				return filterType(type_ /* TODO(ArrowFunction): t => getTypeFacts(t, notEqualFacts) === notEqualFacts */, TODO)
			}
			clauseWitnesses := /* TODO(PropertyAccessExpression): witnesses.slice */ TODO(clauseStart, clauseEnd)
			return getUnionType(map_(clauseWitnesses /* TODO(ArrowFunction): text => text ? narrowTypeByTypeName(type, text) : neverType */, TODO))
		}
		narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			defaultIndex := findIndex( /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses */ TODO /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.DefaultClause */, TODO)
			hasDefaultClause := clauseStart == clauseEnd || /* TODO(ParenthesizedExpression): (defaultIndex >= clauseStart && defaultIndex < clauseEnd) */ TODO
			/* TODO(ForStatement): for (let i = 0; i < clauseStart; i++) {                 const clause = switchStatement.caseBlock.clauses[i];                 if (clause.kind === SyntaxKind.CaseClause) {                     type = narrowType(type, clause.expression, /*assumeTrue* / false);                 }             } */
			if hasDefaultClause {
				/* TODO(ForStatement): for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {                     const clause = switchStatement.caseBlock.clauses[i];                     if (clause.kind === SyntaxKind.CaseClause) {                         type = narrowType(type, clause.expression, /*assumeTrue* / false);                     }                 } */
				return type_
			}
			clauses := /* TODO(PropertyAccessExpression): switchStatement.caseBlock.clauses.slice */ TODO(clauseStart, clauseEnd)
			return getUnionType(map_(clauses /* TODO(ArrowFunction): clause => clause.kind === SyntaxKind.CaseClause ? narrowType(type, clause.expression, /*assumeTrue* / true) : neverType */, TODO))
		}
		isMatchingConstructorReference := func(expr Expression) /* TODO(undefined): boolean */ TODO {
			return /* TODO(ParenthesizedExpression): (isPropertyAccessExpression(expr) && idText(expr.name) === "constructor" ||                 isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") */ TODO && isMatchingReference(reference /* TODO(PropertyAccessExpression): expr.expression */, TODO)
		}
		narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
			if /* TODO(ConditionalExpression): assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken) */ TODO {
				return type_
			}
			identifierType := getTypeOfExpression(identifier)
			if !isFunctionType(identifierType) && !isConstructorType(identifierType) {
				return type_
			}
			prototypeProperty := getPropertyOfType(identifierType, "prototype" /* as */ /* TODO(TypeReference): __String */)
			if !prototypeProperty {
				return type_
			}
			prototypeType := getTypeOfSymbol(prototypeProperty)
			candidate := /* TODO(ConditionalExpression): !isTypeAny(prototypeType) ? prototypeType : undefined */ TODO
			if !candidate || candidate == globalObjectType || candidate == globalFunctionType {
				return type_
			}
			if isTypeAny(type_) {
				return candidate
			}
			return filterType(type_ /* TODO(ArrowFunction): t => isConstructedBy(t, candidate) */, TODO)
			isConstructedBy := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.Class */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Object */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(target) & ObjectFlags.Class */ TODO {
					return /* TODO(PropertyAccessExpression): source.symbol */ TODO == /* TODO(PropertyAccessExpression): target.symbol */ TODO
				}
				return isTypeSubtypeOf(source, target)
			}
		}
		narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
			left := getReferenceCandidate( /* TODO(PropertyAccessExpression): expr.left */ TODO)
			if !isMatchingReference(reference, left) {
				if assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference) {
					return getAdjustedTypeWithFacts(type_ /* TODO(PropertyAccessExpression): TypeFacts.NEUndefinedOrNull */, TODO)
				}
				return type_
			}
			right := /* TODO(PropertyAccessExpression): expr.right */ TODO
			rightType := getTypeOfExpression(right)
			if !isTypeDerivedFrom(rightType, globalObjectType) {
				return type_
			}
			signature := getEffectsSignature(expr)
			predicate := signature && getTypePredicateOfSignature(signature)
			if predicate && /* TODO(PropertyAccessExpression): predicate.kind */ TODO == /* TODO(PropertyAccessExpression): TypePredicateKind.Identifier */ TODO && /* TODO(PropertyAccessExpression): predicate.parameterIndex */ TODO == 0 {
				return getNarrowedType(type_ /* TODO(PropertyAccessExpression): predicate.type */, TODO, assumeTrue /* TODO(TrueKeyword): true */, TODO)
			}
			if !isTypeDerivedFrom(rightType, globalFunctionType) {
				return type_
			}
			instanceType := mapType(rightType, getInstanceType)
			if isTypeAny(type_) && /* TODO(ParenthesizedExpression): (instanceType === globalObjectType || instanceType === globalFunctionType) */ TODO || !assumeTrue && ! /* TODO(ParenthesizedExpression): (instanceType.flags & TypeFlags.Object && !isEmptyAnonymousObjectType(instanceType)) */ TODO {
				return type_
			}
			return getNarrowedType(type_, instanceType, assumeTrue /* TODO(TrueKeyword): true */, TODO)
		}
		getInstanceType := func(constructorType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			prototypePropertyType := getTypeOfPropertyOfType(constructorType, "prototype" /* as */ /* TODO(TypeReference): __String */)
			if prototypePropertyType && !isTypeAny(prototypePropertyType) {
				return prototypePropertyType
			}
			constructSignatures := getSignaturesOfType(constructorType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
			if /* TODO(PropertyAccessExpression): constructSignatures.length */ TODO {
				return getUnionType(map_(constructSignatures /* TODO(ArrowFunction): signature => getReturnTypeOfSignature(getErasedSignature(signature)) */, TODO))
			}
			return emptyObjectType
		}
		getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
			key := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined */ TODO
			return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
		}
		getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if !assumeTrue {
				if type_ == candidate {
					return neverType
				}
				if checkDerived {
					return filterType(type_ /* TODO(ArrowFunction): t => !isTypeDerivedFrom(t, candidate) */, TODO)
				}
				trueType := getNarrowedType(type_, candidate /* TODO(TrueKeyword): true */, TODO /* TODO(FalseKeyword): false */, TODO)
				return filterType(type_ /* TODO(ArrowFunction): t => !isTypeSubsetOf(t, trueType) */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.AnyOrUnknown */ TODO {
				return candidate
			}
			if type_ == candidate {
				return candidate
			}
			isRelated := /* TODO(ConditionalExpression): checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf */ TODO
			keyPropertyName := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined */ TODO
			narrowedType := mapType(candidate /* TODO(ArrowFunction): c => {                 // If a discriminant property is available, use that to reduce the type.                 const discriminant = keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName);                 const matching = discriminant && getConstituentTypeForKeyType(type as UnionType, discriminant);                 // For each constituent t in the current type, if t and and c are directly related, pick the most                 // specific of the two. When t and c are related in both directions, we prefer c for type predicates                 // because that is the asserted type, but t for `instanceof` because generics aren't reflected in                 // prototype object types.                 const directlyRelated = mapType(                     matching || type,                     checkDerived ?                         t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType :                         t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType,                 );                 // If no constituents are directly related, create intersections for any generic constituents that                 // are related by constraint.                 return directlyRelated.flags & TypeFlags.Never ?                     mapType(type, t => maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) :                     directlyRelated;             } */, TODO)
			return /* TODO(ConditionalExpression): !(narrowedType.flags & TypeFlags.Never) ? narrowedType :                 isTypeSubtypeOf(candidate, type) ? candidate :                 isTypeAssignableTo(type, candidate) ? type :                 isTypeAssignableTo(candidate, type) ? candidate :                 getIntersectionType([type, candidate]) */ TODO
		}
		narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
			if hasMatchingArgument(callExpression, reference) {
				signature := /* TODO(ConditionalExpression): assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined */ TODO
				predicate := signature && getTypePredicateOfSignature(signature)
				if predicate && /* TODO(ParenthesizedExpression): (predicate.kind === TypePredicateKind.This || predicate.kind === TypePredicateKind.Identifier) */ TODO {
					return narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
				}
			}
			if containsMissingType(type_) && isAccessExpression(reference) && isPropertyAccessExpression( /* TODO(PropertyAccessExpression): callExpression.expression */ TODO) {
				callAccess := /* TODO(PropertyAccessExpression): callExpression.expression */ TODO
				if isMatchingReference( /* TODO(PropertyAccessExpression): reference.expression */ TODO, getReferenceCandidate( /* TODO(PropertyAccessExpression): callAccess.expression */ TODO)) && isIdentifier( /* TODO(PropertyAccessExpression): callAccess.name */ TODO) && /* TODO(PropertyAccessExpression): callAccess.name.escapedText */ TODO == "hasOwnProperty" && /* TODO(PropertyAccessExpression): callExpression.arguments.length */ TODO == 1 {
					argument := /* TODO(ElementAccessExpression): callExpression.arguments[0] */ TODO
					if isStringLiteralLike(argument) && getAccessedPropertyName(reference) == escapeLeadingUnderscores( /* TODO(PropertyAccessExpression): argument.text */ TODO) {
						return getTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */, TODO)
					}
				}
			}
			return type_
		}
		narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
			if /* TODO(PropertyAccessExpression): predicate.type */ TODO && ! /* TODO(ParenthesizedExpression): (isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType)) */ TODO {
				predicateArgument := getTypePredicateArgument(predicate, callExpression)
				if predicateArgument {
					if isMatchingReference(reference, predicateArgument) {
						return getNarrowedType(type_ /* TODO(PropertyAccessExpression): predicate.type */, TODO, assumeTrue /* TODO(FalseKeyword): false */, TODO)
					}
					if strictNullChecks && optionalChainContainsReference(predicateArgument, reference) && /* TODO(ParenthesizedExpression): (                             assumeTrue && !(hasTypeFacts(predicate.type, TypeFacts.EQUndefined)) ||                             !assumeTrue && everyType(predicate.type, isNullableType)                         ) */ TODO {
						/* TODO(ExpressionStatement): type = getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull); */
					}
					access := getDiscriminantPropertyAccess(predicateArgument, type_)
					if access {
						return narrowTypeByDiscriminant(type_, access /* TODO(ArrowFunction): t => getNarrowedType(t, predicate.type!, assumeTrue, /*checkDerived* / false) */, TODO)
					}
				}
			}
			return type_
		}
		narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isExpressionOfOptionalChainRoot(expr) || isBinaryExpression( /* TODO(PropertyAccessExpression): expr.parent */ TODO) && /* TODO(ParenthesizedExpression): (expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionToken || expr.parent.operatorToken.kind === SyntaxKind.QuestionQuestionEqualsToken) */ TODO && /* TODO(PropertyAccessExpression): expr.parent.left */ TODO == expr {
				return narrowTypeByOptionality(type_, expr, assumeTrue)
			}
			/* TODO(SwitchStatement): switch (expr.kind) {                 case SyntaxKind.Identifier:                     // When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline                     // up to five levels of aliased conditional expressions that are themselves declared as const variables.                     if (!isMatchingReference(reference, expr) && inlineLevel < 5) {                         const symbol = getResolvedSymbol(expr as Identifier);                         if (isConstantVariable(symbol)) {                             const declaration = symbol.valueDeclaration;                             if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {                                 inlineLevel++;                                 const result = narrowType(type, declaration.initializer, assumeTrue);                                 inlineLevel--;                                 return result;                             }                         }                     }                     // falls through                 case SyntaxKind.ThisKeyword:                 case SyntaxKind.SuperKeyword:                 case SyntaxKind.PropertyAccessExpression:                 case SyntaxKind.ElementAccessExpression:                     return narrowTypeByTruthiness(type, expr, assumeTrue);                 case SyntaxKind.CallExpression:                     return narrowTypeByCallExpression(type, expr as CallExpression, assumeTrue);                 case SyntaxKind.ParenthesizedExpression:                 case SyntaxKind.NonNullExpression:                     return narrowType(type, (expr as ParenthesizedExpression | NonNullExpression).expression, assumeTrue);                 case SyntaxKind.BinaryExpression:                     return narrowTypeByBinaryExpression(type, expr as BinaryExpression, assumeTrue);                 case SyntaxKind.PrefixUnaryExpression:                     if ((expr as PrefixUnaryExpression).operator === SyntaxKind.ExclamationToken) {                         return narrowType(type, (expr as PrefixUnaryExpression).operand, !assumeTrue);                     }                     break;             } */
			return type_
		}
		narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */, TODO)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access /* TODO(ArrowFunction): t => getTypeWithFacts(t, assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull) */, TODO)
			}
			return type_
		}
	}
	getTypeOfSymbolAtLocation := func(symbol Symbol, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		/* TODO(ExpressionStatement): symbol = getExportSymbolOfValueSymbolIfExported(symbol); */
		if /* TODO(PropertyAccessExpression): location.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO || /* TODO(PropertyAccessExpression): location.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PrivateIdentifier */ TODO {
			if isRightSideOfQualifiedNameOrPropertyAccess(location) {
				/* TODO(ExpressionStatement): location = location.parent; */
			}
			if isExpressionNode(location) && /* TODO(ParenthesizedExpression): (!isAssignmentTarget(location) || isWriteAccess(location)) */ TODO {
				type_ := removeOptionalTypeMarker( /* TODO(ConditionalExpression): isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ?                         checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true) :                         getTypeOfExpression(location as Expression) */ TODO)
				if getExportSymbolOfValueSymbolIfExported( /* TODO(PropertyAccessExpression): getNodeLinks(location).resolvedSymbol */ TODO) == symbol {
					return type_
				}
			}
		}
		if isDeclarationName(location) && isSetAccessor( /* TODO(PropertyAccessExpression): location.parent */ TODO) && getAnnotatedAccessorTypeNode( /* TODO(PropertyAccessExpression): location.parent */ TODO) {
			return getWriteTypeOfAccessors( /* TODO(PropertyAccessExpression): location.parent.symbol */ TODO)
		}
		return /* TODO(ConditionalExpression): isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) ? getWriteTypeOfSymbol(symbol) : getNonMissingTypeOfSymbol(symbol) */ TODO
	}
	getControlFlowContainer := func(node Node) Node {
		return /* TODO(NonNullExpression): findAncestor(node.parent, node =>             isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) ||             node.kind === SyntaxKind.ModuleBlock ||             node.kind === SyntaxKind.SourceFile ||             node.kind === SyntaxKind.PropertyDeclaration)! */ TODO
	}
	isSymbolAssignedDefinitely := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.lastAssignmentPos !== undefined */ TODO {
			return /* TODO(PropertyAccessExpression): symbol.lastAssignmentPos */ TODO < 0
		}
		return isSymbolAssigned(symbol) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.lastAssignmentPos !== undefined */ TODO && /* TODO(PropertyAccessExpression): symbol.lastAssignmentPos */ TODO < 0
	}
	isSymbolAssigned := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		return !isPastLastAssignment(symbol, nil)
	}
	isPastLastAssignment := func(symbol Symbol, location Node) /* TODO(undefined): boolean | undefined */ TODO {
		parent := findAncestor( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, isFunctionOrSourceFile)
		if !parent {
			return /* TODO(FalseKeyword): false */ TODO
		}
		links := getNodeLinks(parent)
		if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.AssignmentsMarked) */ TODO {
			/* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.AssignmentsMarked; */
			if !hasParentWithAssignmentsMarked(parent) {
				markNodeAssignments(parent)
			}
		}
		return ! /* TODO(PropertyAccessExpression): symbol.lastAssignmentPos */ TODO || location && /* TODO(PropertyAccessExpression): Math.abs */ TODO( /* TODO(PropertyAccessExpression): symbol.lastAssignmentPos */ TODO) < /* TODO(PropertyAccessExpression): location.pos */ TODO
	}
	isSomeSymbolAssigned := func(rootDeclaration Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration))
		return isSomeSymbolAssignedWorker( /* TODO(PropertyAccessExpression): rootDeclaration.name */ TODO)
	}
	isSomeSymbolAssignedWorker := func(node BindingName) bool {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			return isSymbolAssigned(getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): Declaration */))
		}
		return some( /* TODO(PropertyAccessExpression): node.elements */ TODO /* TODO(ArrowFunction): e => e.kind !== SyntaxKind.OmittedExpression && isSomeSymbolAssignedWorker(e.name) */, TODO)
	}
	hasParentWithAssignmentsMarked := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !!findAncestor( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): node => isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlags.AssignmentsMarked) */, TODO)
	}
	isFunctionOrSourceFile := func(node Node) /* TODO(undefined): boolean */ TODO {
		return isFunctionLikeDeclaration(node) || isSourceFile(node)
	}
	markNodeAssignments := func(node Node) {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 const assigmentTarget = getAssignmentTargetKind(node);                 if (assigmentTarget !== AssignmentKind.None) {                     const symbol = getResolvedSymbol(node as Identifier);                     const hasDefiniteAssignment = assigmentTarget === AssignmentKind.Definite || (symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0);                     if (isParameterOrMutableLocalVariable(symbol)) {                         if (symbol.lastAssignmentPos === undefined || Math.abs(symbol.lastAssignmentPos) !== Number.MAX_VALUE) {                             const referencingFunction = findAncestor(node, isFunctionOrSourceFile);                             const declaringFunction = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);                             symbol.lastAssignmentPos = referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE;                         }                         if (hasDefiniteAssignment && symbol.lastAssignmentPos > 0) {                             symbol.lastAssignmentPos *= -1;                         }                     }                 }                 return;             case SyntaxKind.ExportSpecifier:                 const exportDeclaration = (node as ExportSpecifier).parent.parent;                 const name = (node as ExportSpecifier).propertyName || (node as ExportSpecifier).name;                 if (!(node as ExportSpecifier).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind !== SyntaxKind.StringLiteral) {                     const symbol = resolveEntityName(name, SymbolFlags.Value, /*ignoreErrors* / true, /*dontResolveAlias* / true);                     if (symbol && isParameterOrMutableLocalVariable(symbol)) {                         const sign = symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 ? -1 : 1;                         symbol.lastAssignmentPos = sign * Number.MAX_VALUE;                     }                 }                 return;             case SyntaxKind.InterfaceDeclaration:             case SyntaxKind.TypeAliasDeclaration:             case SyntaxKind.EnumDeclaration:                 return;         } */
		if isTypeNode(node) {
			return
		}
		forEachChild(node, markNodeAssignments)
	}
	extendAssignmentPosition := func(node Node, declaration Declaration) /* TODO(undefined): number */ TODO {
		pos := /* TODO(PropertyAccessExpression): node.pos */ TODO
		/* TODO(WhileStatement): while (node && node.pos > declaration.pos) {             switch (node.kind) {                 case SyntaxKind.VariableStatement:                 case SyntaxKind.ExpressionStatement:                 case SyntaxKind.IfStatement:                 case SyntaxKind.DoStatement:                 case SyntaxKind.WhileStatement:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForInStatement:                 case SyntaxKind.ForOfStatement:                 case SyntaxKind.WithStatement:                 case SyntaxKind.SwitchStatement:                 case SyntaxKind.TryStatement:                 case SyntaxKind.ClassDeclaration:                     pos = node.end;             }             node = node.parent;         } */
		return pos
	}
	isConstantVariable := func(symbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Variable */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant) !== 0 */ TODO
	}
	isParameterOrMutableLocalVariable := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && getRootDeclaration( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
		return !!declaration && /* TODO(ParenthesizedExpression): (             isParameter(declaration) ||             isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration))         ) */ TODO
	}
	isMutableLocalVariableDeclaration := func(declaration VariableDeclaration) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (declaration.parent.flags & NodeFlags.Let) */ TODO && ! /* TODO(ParenthesizedExpression): (             getCombinedModifierFlags(declaration) & ModifierFlags.Export ||             declaration.parent.parent.kind === SyntaxKind.VariableStatement && isGlobalSourceFile(declaration.parent.parent.parent)         ) */ TODO
	}
	parameterInitializerContainsUndefined := func(declaration ParameterDeclaration) bool {
		links := getNodeLinks(declaration)
		if /* TODO(PropertyAccessExpression): links.parameterInitializerContainsUndefined */ TODO == nil {
			if !pushTypeResolution(declaration /* TODO(PropertyAccessExpression): TypeSystemPropertyName.ParameterInitializerContainsUndefined */, TODO) {
				reportCircularityError( /* TODO(PropertyAccessExpression): declaration.symbol */ TODO)
				return /* TODO(TrueKeyword): true */ TODO
			}
			containsUndefined := !! /* TODO(ParenthesizedExpression): (hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) */ TODO
			if !popTypeResolution() {
				reportCircularityError( /* TODO(PropertyAccessExpression): declaration.symbol */ TODO)
				return /* TODO(TrueKeyword): true */ TODO
			}
			/* TODO(ExpressionStatement): links.parameterInitializerContainsUndefined ??= containsUndefined; */
		}
		return /* TODO(PropertyAccessExpression): links.parameterInitializerContainsUndefined */ TODO
	}
	removeOptionalityFromDeclaredType := func(declaredType Type, declaration VariableLikeDeclaration) Type {
		removeUndefined := strictNullChecks && /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO && /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && hasTypeFacts(declaredType /* TODO(PropertyAccessExpression): TypeFacts.IsUndefined */, TODO) && !parameterInitializerContainsUndefined(declaration)
		return /* TODO(ConditionalExpression): removeUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType */ TODO
	}
	isConstraintPosition := func(type_ Type, node Node) /* TODO(undefined): boolean */ TODO {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		return /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO || /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.QualifiedName */ TODO || /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CallExpression */ TODO && /* TODO(PropertyAccessExpression): (parent as CallExpression).expression */ TODO == node || /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NewExpression */ TODO && /* TODO(PropertyAccessExpression): (parent as NewExpression).expression */ TODO == node || /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ElementAccessExpression */ TODO && /* TODO(PropertyAccessExpression): (parent as ElementAccessExpression).expression */ TODO == node && ! /* TODO(ParenthesizedExpression): (someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent as ElementAccessExpression).argumentExpression))) */ TODO
	}
	isGenericTypeWithUnionConstraint := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithUnionConstraint) :             !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(type).flags & (TypeFlags.Nullable | TypeFlags.Union)) */ TODO
	}
	isGenericTypeWithoutNullableConstraint := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithoutNullableConstraint) :             !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(getBaseConstraintOrType(type), TypeFlags.Nullable)) */ TODO
	}
	hasContextualTypeWithNoGenericTypes := func(node Node, checkMode *CheckMode) /* TODO(undefined): boolean | undefined */ TODO {
		contextualType := /* TODO(ParenthesizedExpression): (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) */ TODO && ! /* TODO(ParenthesizedExpression): ((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) */ TODO && /* TODO(ParenthesizedExpression): (checkMode && checkMode & CheckMode.RestBindingElement ?                 getContextualType(node, ContextFlags.SkipBindingPatterns)                 : getContextualType(node, /*contextFlags* / undefined)) */ TODO
		return contextualType && !isGenericType(contextualType)
	}
	getNarrowableTypeForReference := func(type_ Type, reference Node, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isNoInferType(type_) {
			/* TODO(ExpressionStatement): type = (type as SubstitutionType).baseType; */
		}
		substituteConstraints := ! /* TODO(ParenthesizedExpression): (checkMode && checkMode & CheckMode.Inferential) */ TODO && someType(type_, isGenericTypeWithUnionConstraint) && /* TODO(ParenthesizedExpression): (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode)) */ TODO
		return /* TODO(ConditionalExpression): substituteConstraints ? mapType(type, getBaseConstraintOrType) : type */ TODO
	}
	isExportOrExportExpression := func(location Node) /* TODO(undefined): boolean */ TODO {
		return !!findAncestor(location /* TODO(ArrowFunction): n => {             const parent = n.parent;             if (parent === undefined) {                 return "quit";             }             if (isExportAssignment(parent)) {                 return parent.expression === n && isEntityNameExpression(n);             }             if (isExportSpecifier(parent)) {                 return parent.name === n || parent.propertyName === n;             }             return false;         } */, TODO)
	}
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, hint /* TODO(QualifiedName): ReferenceHint.Property */ TODO, propSymbol *Symbol, parentType Type)
	// OVERLOAD: markLinkedReferences := func(location Identifier, hint /* TODO(QualifiedName): ReferenceHint.Identifier */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ExportAssignment, hint /* TODO(QualifiedName): ReferenceHint.ExportAssignment */ TODO)
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any, hint /* TODO(QualifiedName): ReferenceHint.Jsx */ TODO)
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, hint /* TODO(QualifiedName): ReferenceHint.AsyncFunction */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ImportEqualsDeclaration, hint /* TODO(QualifiedName): ReferenceHint.ExportImportEquals */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ExportSpecifier, hint /* TODO(QualifiedName): ReferenceHint.ExportSpecifier */ TODO)
	// OVERLOAD: markLinkedReferences := func(location HasDecorators, hint /* TODO(QualifiedName): ReferenceHint.Decorator */ TODO)
	// OVERLOAD: markLinkedReferences := func(location Node, hint /* TODO(QualifiedName): ReferenceHint.Unspecified */ TODO, propSymbol Symbol, parentType Type)
	markLinkedReferences := func(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): location.flags & NodeFlags.Ambient */ TODO && !isPropertySignature(location) && !isPropertyDeclaration(location) {
			return
		}
		/* TODO(SwitchStatement): switch (hint) {             case ReferenceHint.Identifier:                 return markIdentifierAliasReferenced(location as Identifier);             case ReferenceHint.Property:                 return markPropertyAliasReferenced(location as PropertyAccessExpression | QualifiedName, propSymbol, parentType);             case ReferenceHint.ExportAssignment:                 return markExportAssignmentAliasReferenced(location as ExportAssignment);             case ReferenceHint.Jsx:                 return markJsxAliasReferenced(location as JsxOpeningLikeElement | JsxOpeningFragment);             case ReferenceHint.AsyncFunction:                 return markAsyncFunctionAliasReferenced(location as FunctionLikeDeclaration | MethodSignature);             case ReferenceHint.ExportImportEquals:                 return markImportEqualsAliasReferenced(location as ImportEqualsDeclaration);             case ReferenceHint.ExportSpecifier:                 return markExportSpecifierAliasReferenced(location as ExportSpecifier);             case ReferenceHint.Decorator:                 return markDecoratorAliasReferenced(location as HasDecorators);             case ReferenceHint.Unspecified: {                 // Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used                 // Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`                 // This is the exception, rather than the rule - most non-expression identifiers are declaration names.                 if (isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference === location)) && shouldMarkIdentifierAliasReferenced(location)) {                     if (isPropertyAccessOrQualifiedName(location.parent)) {                         const left = isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left;                         if (left !== location) return; // Only mark the LHS (the RHS is a property lookup)                     }                     markIdentifierAliasReferenced(location);                     return;                 }                 if (isPropertyAccessOrQualifiedName(location)) {                     let topProp: Node | undefined = location;                     while (isPropertyAccessOrQualifiedName(topProp)) {                         if (isPartOfTypeNode(topProp)) return;                         topProp = topProp.parent;                     }                     return markPropertyAliasReferenced(location);                 }                 if (isExportAssignment(location)) {                     return markExportAssignmentAliasReferenced(location);                 }                 if (isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location)) {                     return markJsxAliasReferenced(location);                 }                 if (isImportEqualsDeclaration(location)) {                     if (isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location)) {                         return markImportEqualsAliasReferenced(location);                     }                     return;                 }                 if (isExportSpecifier(location)) {                     return markExportSpecifierAliasReferenced(location);                 }                 if (isFunctionLikeDeclaration(location) || isMethodSignature(location)) {                     markAsyncFunctionAliasReferenced(location);                     // Might be decorated, fall through to decorator final case                 }                 if (!compilerOptions.emitDecoratorMetadata) {                     return;                 }                 if (!canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent)) {                     return;                 }                  return markDecoratorAliasReferenced(location);             }             default:                 Debug.assertNever(hint, `Unhandled reference hint: ${hint}`);         } */
	}
	markIdentifierAliasReferenced := func(location Identifier) {
		symbol := getResolvedSymbol(location)
		if symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol !== argumentsSymbol */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol !== unknownSymbol */ TODO && !isThisInTypeQuery(location) {
			markAliasReferenced(symbol, location)
		}
	}
	markPropertyAliasReferenced := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
		left := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.expression : location.left */ TODO
		if isThisIdentifier(left) || !isIdentifier(left) {
			return
		}
		parentSymbol := getResolvedSymbol(left)
		if !parentSymbol || parentSymbol == unknownSymbol {
			return
		}
		if getIsolatedModules(compilerOptions) || /* TODO(ParenthesizedExpression): (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location)) */ TODO {
			markAliasReferenced(parentSymbol, location)
			return
		}
		leftType := parentType || checkExpressionCached(left)
		if isTypeAny(leftType) || leftType == silentNeverType {
			markAliasReferenced(parentSymbol, location)
			return
		}
		prop := propSymbol
		if !prop && !parentType {
			right := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.name : location.right */ TODO
			lexicallyScopedSymbol := isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration( /* TODO(PropertyAccessExpression): right.escapedText */ TODO, right)
			assignmentKind := getAssignmentTargetKind(location)
			apparentType := getApparentType( /* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(location) ? getWidenedType(leftType) : leftType */ TODO)
			/* TODO(ExpressionStatement): prop = isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined : getPropertyOfType(apparentType, right.escapedText); */
		}
		if ! /* TODO(ParenthesizedExpression): (prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags & SymbolFlags.EnumMember && location.parent.kind === SyntaxKind.EnumMember)) */ TODO {
			markAliasReferenced(parentSymbol, location)
		}
		return
	}
	markExportAssignmentAliasReferenced := func(location ExportAssignment) {
		if isIdentifier( /* TODO(PropertyAccessExpression): location.expression */ TODO) {
			id := /* TODO(PropertyAccessExpression): location.expression */ TODO
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id /* TODO(PropertyAccessExpression): SymbolFlags.All */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, location))
			if sym {
				markAliasReferenced(sym, id)
			}
		}
	}
	markJsxAliasReferenced := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		if !getJsxNamespaceContainerForImplicitImport(node) {
			jsxFactoryRefErr := /* TODO(ConditionalExpression): diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.Cannot_find_name_0 : undefined */ TODO
			jsxFactoryNamespace := getJsxNamespace(node)
			jsxFactoryLocation := /* TODO(ConditionalExpression): isJsxOpeningLikeElement(node) ? node.tagName : node */ TODO
			var jsxFactorySym *Symbol
			if ! /* TODO(ParenthesizedExpression): (isJsxOpeningFragment(node) && jsxFactoryNamespace === "null") */ TODO {
				/* TODO(ExpressionStatement): jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlags.Value, jsxFactoryRefErr, /*isUse* / true); */
			}
			if jsxFactorySym {
				/* TODO(ExpressionStatement): jsxFactorySym.isReferenced = SymbolFlags.All; */
				if canCollectSymbolAliasAccessabilityData && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): jsxFactorySym.flags & SymbolFlags.Alias */ TODO && !getTypeOnlyAliasDeclaration(jsxFactorySym) {
					markAliasSymbolAsReferenced(jsxFactorySym)
				}
			}
			if isJsxOpeningFragment(node) {
				file := getSourceFileOfNode(node)
				localJsxNamespace := getLocalJsxNamespace(file)
				if localJsxNamespace {
					resolveName(jsxFactoryLocation, localJsxNamespace /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO, jsxFactoryRefErr /* TODO(TrueKeyword): true */, TODO)
				}
			}
		}
		return
	}
	markAsyncFunctionAliasReferenced := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) {
		if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getFunctionFlags(location) & FunctionFlags.Async */ TODO {
				returnTypeNode := getEffectiveReturnTypeNode(location)
				markTypeNodeAsReferenced(returnTypeNode)
			}
		}
	}
	markImportEqualsAliasReferenced := func(location ImportEqualsDeclaration) {
		if hasSyntacticModifier(location /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) {
			markExportAsReferenced(location)
		}
	}
	markExportSpecifierAliasReferenced := func(location ExportSpecifier) {
		if ! /* TODO(PropertyAccessExpression): location.parent.parent.moduleSpecifier */ TODO && ! /* TODO(PropertyAccessExpression): location.isTypeOnly */ TODO && ! /* TODO(PropertyAccessExpression): location.parent.parent.isTypeOnly */ TODO {
			exportedName := /* TODO(PropertyAccessExpression): location.propertyName */ TODO || /* TODO(PropertyAccessExpression): location.name */ TODO
			if /* TODO(PropertyAccessExpression): exportedName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.StringLiteral */ TODO {
				return
			}
			symbol := resolveName(exportedName /* TODO(PropertyAccessExpression): exportedName.escapedText */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */, TODO, nil /* TODO(TrueKeyword): true */, TODO)
			if symbol && /* TODO(ParenthesizedExpression): (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) */ TODO {
			} else {
				target := symbol && /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol) */ TODO
				if !target || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getSymbolFlags(target) & SymbolFlags.Value */ TODO {
					markExportAsReferenced(location)
					markIdentifierAliasReferenced(exportedName)
				}
			}
			return
		}
	}
	markDecoratorAliasReferenced := func(node HasDecorators) {
		if /* TODO(PropertyAccessExpression): compilerOptions.emitDecoratorMetadata */ TODO {
			firstDecorator := find( /* TODO(PropertyAccessExpression): node.modifiers */ TODO, isDecorator)
			if !firstDecorator {
				return
			}
			checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Metadata */, TODO)
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ClassDeclaration:                     const constructor = getFirstConstructorWithBody(node);                     if (constructor) {                         for (const parameter of constructor.parameters) {                             markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                         }                     }                     break;                  case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     const otherKind = node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;                     const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(node), otherKind);                     markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));                     break;                 case SyntaxKind.MethodDeclaration:                     for (const parameter of node.parameters) {                         markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                     }                      markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node));                     break;                  case SyntaxKind.PropertyDeclaration:                     markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node));                     break;                  case SyntaxKind.Parameter:                     markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));                     const containingSignature = node.parent;                     for (const parameter of containingSignature.parameters) {                         markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                     }                     markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature));                     break;             } */
		}
	}
	markAliasReferenced := func(symbol Symbol, location Node) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if isNonLocalAlias(symbol /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO) && !isInTypeQuery(location) {
			target := resolveAlias(symbol)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getSymbolFlags(symbol, /*excludeTypeOnlyMeanings* / true) & (SymbolFlags.Value | SymbolFlags.ExportValue) */ TODO {
				if getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target)) {
					markAliasSymbolAsReferenced(symbol)
				}
			}
		}
	}
	markAliasSymbolAsReferenced := func(symbol Symbol) /* TODO(undefined): undefined */ TODO {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(canCollectSymbolAliasAccessabilityData)
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.referenced */ TODO {
			/* TODO(ExpressionStatement): links.referenced = true; */
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				/* TODO(CallExpression): Debug.fail() */
			}
			if isInternalModuleImportEqualsDeclaration(node) {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getSymbolFlags(resolveSymbol(symbol)) & SymbolFlags.Value */ TODO {
					left := getFirstIdentifier( /* TODO(PropertyAccessExpression): node.moduleReference */ TODO /* as */ /* TODO(TypeReference): EntityNameExpression */)
					markIdentifierAliasReferenced(left)
				}
			}
		}
	}
	markExportAsReferenced := func(node /* TODO(UnionType): ImportEqualsDeclaration | ExportSpecifier */ any) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target {
			markAlias := target == unknownSymbol || /* TODO(ParenthesizedExpression): ((getSymbolFlags(symbol, /*excludeTypeOnlyMeanings* / true) & SymbolFlags.Value) && !isConstEnumOrConstEnumOnlyModule(target)) */ TODO
			if markAlias {
				markAliasSymbolAsReferenced(symbol)
			}
		}
	}
	markEntityNameOrEntityExpressionAsReference := func(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
		if !typeName {
		}
		rootName := getFirstIdentifier(typeName)
		meaning := /* TODO(BarToken): | */ /* TODO(BinaryExpression): (typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace) | SymbolFlags.Alias */ TODO
		rootSymbol := resolveName(rootName /* TODO(PropertyAccessExpression): rootName.escapedText */, TODO, meaning, nil /* TODO(TrueKeyword): true */, TODO)
		if rootSymbol && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): rootSymbol.flags & SymbolFlags.Alias */ TODO {
			if canCollectSymbolAliasAccessabilityData && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol) {
				markAliasSymbolAsReferenced(rootSymbol)
			} else if forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO && !symbolIsValue(rootSymbol) && !some( /* TODO(PropertyAccessExpression): rootSymbol.declarations */ TODO, isTypeOnlyImportOrExportDeclaration) {
				diag := error(typeName /* TODO(PropertyAccessExpression): Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled */, TODO)
				aliasDeclaration := find( /* TODO(PropertyAccessExpression): rootSymbol.declarations */ TODO || emptyArray, isAliasSymbolDeclaration)
				if aliasDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration /* TODO(PropertyAccessExpression): Diagnostics._0_was_imported_here */, TODO, idText(rootName)))
				}
			}
		}
	}
	markTypeNodeAsReferenced := func(node *TypeNode) {
		markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node) /* TODO(FalseKeyword): false */, TODO)
	}
	markDecoratorMedataDataTypeNodeAsReferenced := func(node *TypeNode) {
		entityName := getEntityNameForDecoratorMetadata(node)
		if entityName && isEntityName(entityName) {
			markEntityNameOrEntityExpressionAsReference(entityName /* TODO(TrueKeyword): true */, TODO)
		}
	}
	getNarrowedTypeOfSymbol := func(symbol Symbol, location Identifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type_ := getTypeOfSymbol(symbol)
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if declaration {
			if isBindingElement(declaration) && ! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && ! /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO && /* TODO(PropertyAccessExpression): declaration.parent.elements.length */ TODO >= 2 {
				parent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
				rootDeclaration := getRootDeclaration(parent)
				if /* TODO(PropertyAccessExpression): rootDeclaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCombinedNodeFlagsCached(rootDeclaration) & NodeFlags.Constant */ TODO || /* TODO(PropertyAccessExpression): rootDeclaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO {
					links := getNodeLinks(parent)
					if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.InCheckIdentifier) */ TODO {
						/* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.InCheckIdentifier; */
						parentType := getTypeForBindingElementParent(parent /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO)
						parentTypeConstraint := parentType && mapType(parentType, getBaseConstraintOrType)
						/* TODO(ExpressionStatement): links.flags &= ~NodeCheckFlags.InCheckIdentifier; */
						if parentTypeConstraint && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): parentTypeConstraint.flags & TypeFlags.Union */ TODO && ! /* TODO(ParenthesizedExpression): (rootDeclaration.kind === SyntaxKind.Parameter && isSomeSymbolAssigned(rootDeclaration)) */ TODO {
							pattern := /* TODO(PropertyAccessExpression): declaration.parent */ TODO
							narrowedType := getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, nil /* TODO(PropertyAccessExpression): location.flowNode */, TODO)
							if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): narrowedType.flags & TypeFlags.Never */ TODO {
								return neverType
							}
							return getBindingElementTypeFromParentType(declaration, narrowedType /* TODO(TrueKeyword): true */, TODO)
						}
					}
				}
			}
			if isParameter(declaration) && ! /* TODO(PropertyAccessExpression): declaration.type */ TODO && ! /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && ! /* TODO(PropertyAccessExpression): declaration.dotDotDotToken */ TODO {
				func_ := /* TODO(PropertyAccessExpression): declaration.parent */ TODO
				if /* TODO(PropertyAccessExpression): func.parameters.length */ TODO >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
					contextualSignature := getContextualSignature(func_)
					if contextualSignature && /* TODO(PropertyAccessExpression): contextualSignature.parameters.length */ TODO == 1 && signatureHasRestParameter(contextualSignature) {
						restType := getReducedApparentType(instantiateType(getTypeOfSymbol( /* TODO(ElementAccessExpression): contextualSignature.parameters[0] */ TODO) /* TODO(PropertyAccessExpression): getInferenceContext(func)?.nonFixingMapper */, TODO))
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): restType.flags & TypeFlags.Union */ TODO && everyType(restType, isTupleType) && !some( /* TODO(PropertyAccessExpression): func.parameters */ TODO, isSomeSymbolAssigned) {
							narrowedType := getFlowTypeOfReference(func_, restType, restType, nil /* TODO(PropertyAccessExpression): location.flowNode */, TODO)
							index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0) */ TODO
							return getIndexedAccessType(narrowedType, getNumberLiteralType(index))
						}
					}
				}
			}
		}
		return type_
	}
	checkIdentifierCalculateNodeCheckFlags := func(node Identifier, symbol Symbol) {
		if isThisInTypeQuery(node) {
		}
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.arguments_cannot_be_referenced_in_property_initializers */, TODO)
				return
			}
			container := getContainingFunction(node)
			if container {
				if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO {
					if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrowFunction */ TODO {
						error(node /* TODO(PropertyAccessExpression): Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression */, TODO)
					} else if hasSyntacticModifier(container /* TODO(PropertyAccessExpression): ModifierFlags.Async */, TODO) {
						error(node /* TODO(PropertyAccessExpression): Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method */, TODO)
					}
				}
				/* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments; */
				/* TODO(WhileStatement): while (container && isArrowFunction(container)) {                     container = getContainingFunction(container);                     if (container) {                         getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;                     }                 } */
			}
			return
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		targetSymbol := resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
		if isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && /* TODO(PropertyAccessExpression): targetSymbol.declarations */ TODO {
			addDeprecatedSuggestion(node /* TODO(PropertyAccessExpression): targetSymbol.declarations */, TODO /* TODO(PropertyAccessExpression): node.escapedText */, TODO /* as */ /* TODO(StringKeyword): string */)
		}
		declaration := /* TODO(PropertyAccessExpression): localOrExportSymbol.valueDeclaration */ TODO
		if declaration && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Class */ TODO {
			if isClassLike(declaration) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.name !== node */ TODO {
				container := getThisContainer(node /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
				/* TODO(WhileStatement): while (container.kind !== SyntaxKind.SourceFile && container.parent !== declaration) {                     container = getThisContainer(container, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);                 } */
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): container.kind !== SyntaxKind.SourceFile */ TODO {
					/* TODO(ExpressionStatement): getNodeLinks(declaration).flags |= NodeCheckFlags.ContainsConstructorReference; */
					/* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.ContainsConstructorReference; */
					/* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.ConstructorReference; */
				}
			}
		}
		checkNestedBlockScopedBinding(node, symbol)
	}
	checkIdentifier := func(node Identifier, checkMode *CheckMode) Type {
		if isThisInTypeQuery(node) {
			return checkThisExpression(node)
		}
		symbol := getResolvedSymbol(node)
		if symbol == unknownSymbol {
			return errorType
		}
		checkIdentifierCalculateNodeCheckFlags(node, symbol)
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				return errorType
			}
			return getTypeOfSymbol(symbol)
		}
		if shouldMarkIdentifierAliasReferenced(node) {
			markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.Identifier */, TODO)
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		declaration := /* TODO(PropertyAccessExpression): localOrExportSymbol.valueDeclaration */ TODO
		immediateDeclaration := declaration
		if declaration && /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO && contains(contextualBindingPatterns /* TODO(PropertyAccessExpression): declaration.parent */, TODO) && findAncestor(node /* TODO(ArrowFunction): parent => parent === declaration!.parent */, TODO) {
			return nonInferrableAnyType
		}
		type_ := getNarrowedTypeOfSymbol(localOrExportSymbol, node)
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind {
			if ! /* TODO(ParenthesizedExpression): (localOrExportSymbol.flags & SymbolFlags.Variable) */ TODO && ! /* TODO(ParenthesizedExpression): (isInJSFile(node) && localOrExportSymbol.flags & SymbolFlags.ValueModule) */ TODO {
				assignmentError := /* TODO(ConditionalExpression): localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum                     : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class                     : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace                     : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function                     : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import                     : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable */ TODO
				error(node, assignmentError, symbolToString(symbol))
				return errorType
			}
			if isReadonlySymbol(localOrExportSymbol) {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Variable */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_to_0_because_it_is_a_constant */, TODO, symbolToString(symbol))
				} else {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property */, TODO, symbolToString(symbol))
				}
				return errorType
			}
		}
		isAlias := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Alias */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): localOrExportSymbol.flags & SymbolFlags.Variable */ TODO {
			if assignmentKind == /* TODO(PropertyAccessExpression): AssignmentKind.Definite */ TODO {
				return /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(type) : type */ TODO
			}
		} else if isAlias {
			/* TODO(ExpressionStatement): declaration = getDeclarationOfAliasSymbol(symbol); */
		} else {
			return type_
		}
		if !declaration {
			return type_
		}
		/* TODO(ExpressionStatement): type = getNarrowableTypeForReference(type, node, checkMode); */
		isParameter := /* TODO(PropertyAccessExpression): getRootDeclaration(declaration).kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO
		declarationContainer := getControlFlowContainer(declaration)
		flowContainer := getControlFlowContainer(node)
		isOuterVariable := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): flowContainer !== declarationContainer */ TODO
		isSpreadDestructuringAssignmentTarget := /* TODO(PropertyAccessExpression): node.parent */ TODO && /* TODO(PropertyAccessExpression): node.parent.parent */ TODO && isSpreadAssignment( /* TODO(PropertyAccessExpression): node.parent */ TODO) && isDestructuringAssignmentTarget( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
		isModuleExports := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ModuleExports */ TODO
		typeIsAutomatic := type_ == autoType || type_ == autoArrayType
		isAutomaticTypeInNonNull := typeIsAutomatic && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NonNullExpression */ TODO
		/* TODO(WhileStatement): while (             flowContainer !== declarationContainer && (                 flowContainer.kind === SyntaxKind.FunctionExpression ||                 flowContainer.kind === SyntaxKind.ArrowFunction ||                 isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)             ) && (                 isConstantVariable(localOrExportSymbol) && type !== autoArrayType ||                 isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)             )         ) {             flowContainer = getControlFlowContainer(flowContainer);         } */
		isNeverInitialized := immediateDeclaration && isVariableDeclaration(immediateDeclaration) && ! /* TODO(PropertyAccessExpression): immediateDeclaration.initializer */ TODO && ! /* TODO(PropertyAccessExpression): immediateDeclaration.exclamationToken */ TODO && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol)
		assumeInitialized := isParameter || isAlias || /* TODO(ParenthesizedExpression): (isOuterVariable && !isNeverInitialized) */ TODO || isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== autoType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== autoArrayType */ TODO && /* TODO(ParenthesizedExpression): (!strictNullChecks || (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0 ||                     isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind === SyntaxKind.ExportSpecifier) */ TODO || /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NonNullExpression */ TODO || /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO && /* TODO(PropertyAccessExpression): (declaration as VariableDeclaration).exclamationToken */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declaration.flags & NodeFlags.Ambient */ TODO
		initialType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? undefinedType :             assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) :             typeIsAutomatic ? undefinedType : getOptionalType(type) */ TODO
		flowType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? getNonNullableType(getFlowTypeOfReference(node, type, initialType, flowContainer)) :             getFlowTypeOfReference(node, type, initialType, flowContainer) */ TODO
		if !isEvolvingArrayOperationTarget(node) && /* TODO(ParenthesizedExpression): (type === autoType || type === autoArrayType) */ TODO {
			if flowType == autoType || flowType == autoArrayType {
				if noImplicitAny {
					error(getNameOfDeclaration(declaration) /* TODO(PropertyAccessExpression): Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined */, TODO, symbolToString(symbol), typeToString(flowType))
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Variable_0_implicitly_has_an_1_type */, TODO, symbolToString(symbol), typeToString(flowType))
				}
				return convertAutoToAny(flowType)
			}
		} else if !assumeInitialized && !containsUndefinedType(type_) && containsUndefinedType(flowType) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Variable_0_is_used_before_being_assigned */, TODO, symbolToString(symbol))
			return type_
		}
		return /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
	}
	isSameScopedBindingElement := func(node Identifier, declaration Declaration) /* TODO(undefined): boolean | undefined */ TODO {
		if isBindingElement(declaration) {
			bindingElement := findAncestor(node, isBindingElement)
			return bindingElement && getRootDeclaration(bindingElement) == getRootDeclaration(declaration)
		}
	}
	shouldMarkIdentifierAliasReferenced := func(node Identifier) bool {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		if parent {
			if isPropertyAccessExpression(parent) && /* TODO(PropertyAccessExpression): parent.expression */ TODO == node {
				return /* TODO(FalseKeyword): false */ TODO
			}
			if isExportSpecifier(parent) && /* TODO(PropertyAccessExpression): parent.isTypeOnly */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
			greatGrandparent := /* TODO(PropertyAccessExpression): parent.parent?.parent */ TODO
			if greatGrandparent && isExportDeclaration(greatGrandparent) && /* TODO(PropertyAccessExpression): greatGrandparent.isTypeOnly */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	isInsideFunctionOrInstancePropertyInitializer := func(node Node, threshold Node) bool {
		return !!findAncestor(node /* TODO(ArrowFunction): n =>             n === threshold ? "quit" : isFunctionLike(n) || (                 n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n             ) */, TODO)
	}
	getPartOfForStatementContainingNode := func(node Node, container ForStatement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
		return findAncestor(node /* TODO(ArrowFunction): n => n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement */, TODO)
	}
	getEnclosingIterationStatement := func(node Node) Node {
		return findAncestor(node /* TODO(ArrowFunction): n => (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(n, /*lookInLabeledStatements* / false) */, TODO)
	}
	checkNestedBlockScopedBinding := func(node Identifier, symbol Symbol) {
		if languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO || /* TODO(ParenthesizedExpression): (symbol.flags & (SymbolFlags.BlockScopedVariable | SymbolFlags.Class)) */ TODO == 0 || ! /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO || isSourceFile( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) || /* TODO(PropertyAccessExpression): symbol.valueDeclaration.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CatchClause */ TODO {
			return
		}
		container := getEnclosingBlockScopeContainer( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
		isCaptured := isInsideFunctionOrInstancePropertyInitializer(node, container)
		enclosingIterationStatement := getEnclosingIterationStatement(container)
		if enclosingIterationStatement {
			if isCaptured {
				capturesBlockScopeBindingInLoopBody := /* TODO(TrueKeyword): true */ TODO
				if isForStatement(container) {
					varDeclList := getAncestor( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */, TODO)
					if varDeclList && /* TODO(PropertyAccessExpression): varDeclList.parent */ TODO == container {
						part := getPartOfForStatementContainingNode( /* TODO(PropertyAccessExpression): node.parent */ TODO, container)
						if part {
							links := getNodeLinks(part)
							/* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.ContainsCapturedBlockScopeBinding; */
							capturedBindings := /* TODO(PropertyAccessExpression): links.capturedBlockScopeBindings */ TODO || /* TODO(ParenthesizedExpression): (links.capturedBlockScopeBindings = []) */ TODO
							pushIfUnique(capturedBindings, symbol)
							if part == /* TODO(PropertyAccessExpression): container.initializer */ TODO {
								/* TODO(ExpressionStatement): capturesBlockScopeBindingInLoopBody = false; */
							}
						}
					}
				}
				if capturesBlockScopeBindingInLoopBody {
					/* TODO(ExpressionStatement): getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding; */
				}
			}
			if isForStatement(container) {
				varDeclList := getAncestor( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */, TODO)
				if varDeclList && /* TODO(PropertyAccessExpression): varDeclList.parent */ TODO == container && isAssignedInBodyOfForStatement(node, container) {
					/* TODO(ExpressionStatement): getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.NeedsLoopOutParameter; */
				}
			}
			/* TODO(ExpressionStatement): getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
		}
		if isCaptured {
			/* TODO(ExpressionStatement): getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlags.CapturedBlockScopedBinding; */
		}
	}
	isBindingCapturedByNode := func(node Node, decl /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): boolean */ TODO {
		links := getNodeLinks(node)
		return !!links && contains( /* TODO(PropertyAccessExpression): links.capturedBlockScopeBindings */ TODO, getSymbolOfDeclaration(decl))
	}
	isAssignedInBodyOfForStatement := func(node Identifier, container ForStatement) bool {
		var current Node = node
		/* TODO(WhileStatement): while (current.parent.kind === SyntaxKind.ParenthesizedExpression) {             current = current.parent;         } */
		isAssigned := /* TODO(FalseKeyword): false */ TODO
		if isAssignmentTarget(current) {
			/* TODO(ExpressionStatement): isAssigned = true; */
		} else if /* TODO(ParenthesizedExpression): (current.parent.kind === SyntaxKind.PrefixUnaryExpression || current.parent.kind === SyntaxKind.PostfixUnaryExpression) */ TODO {
			expr := /* TODO(PropertyAccessExpression): current.parent */ TODO /* as */ /* TODO(UnionType): PrefixUnaryExpression | PostfixUnaryExpression */
			/* TODO(ExpressionStatement): isAssigned = expr.operator === SyntaxKind.PlusPlusToken || expr.operator === SyntaxKind.MinusMinusToken; */
		}
		if !isAssigned {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return !!findAncestor(current /* TODO(ArrowFunction): n => n === container ? "quit" : n === container.statement */, TODO)
	}
	captureLexicalThis := func(node Node, container Node) {
		/* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.LexicalThis; */
		if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
			classNode := /* TODO(PropertyAccessExpression): container.parent */ TODO
			/* TODO(ExpressionStatement): getNodeLinks(classNode).flags |= NodeCheckFlags.CaptureThis; */
		} else {
			/* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.CaptureThis; */
		}
	}
	findFirstSuperCall := func(node Node) *SuperCall {
		return /* TODO(ConditionalExpression): isSuperCall(node) ? node :             isFunctionLike(node) ? undefined :             forEachChild(node, findFirstSuperCall) */ TODO
	}
	classDeclarationExtendsNull := func(classDecl ClassLikeDeclaration) bool {
		classSymbol := getSymbolOfDeclaration(classDecl)
		classInstanceType := getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */
		baseConstructorType := getBaseConstructorTypeOfClass(classInstanceType)
		return baseConstructorType == nullWideningType
	}
	checkThisBeforeSuper := func(node Node, container Node, diagnosticMessage DiagnosticMessage) {
		containingClassDecl := /* TODO(PropertyAccessExpression): container.parent */ TODO /* as */ /* TODO(TypeReference): ClassDeclaration */
		baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)
		if baseTypeNode && !classDeclarationExtendsNull(containingClassDecl) {
			if canHaveFlowNode(node) && /* TODO(PropertyAccessExpression): node.flowNode */ TODO && !isPostSuperFlowNode( /* TODO(PropertyAccessExpression): node.flowNode */ TODO /* TODO(FalseKeyword): false */, TODO) {
				error(node, diagnosticMessage)
			}
		}
	}
	checkThisInStaticClassFieldInitializerInDecoratedClass := func(thisExpression Node, container Node) {
		if isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators && /* TODO(PropertyAccessExpression): container.initializer */ TODO && textRangeContainsPositionInclusive( /* TODO(PropertyAccessExpression): container.initializer */ TODO /* TODO(PropertyAccessExpression): thisExpression.pos */, TODO) && hasDecorators( /* TODO(PropertyAccessExpression): container.parent */ TODO) {
			error(thisExpression /* TODO(PropertyAccessExpression): Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class */, TODO)
		}
	}
	checkThisExpression := func(node Node) Type {
		isNodeInTypeQuery := isInTypeQuery(node)
		container := getThisContainer(node /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO)
		capturedByArrowFunction := /* TODO(FalseKeyword): false */ TODO
		thisInComputedPropertyName := /* TODO(FalseKeyword): false */ TODO
		if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
			checkThisBeforeSuper(node, container /* TODO(PropertyAccessExpression): Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class */, TODO)
		}
		/* TODO(WhileStatement): while (true) {             // Now skip arrow functions to get the "real" owner of 'this'.             if (container.kind === SyntaxKind.ArrowFunction) {                 container = getThisContainer(container, /*includeArrowFunctions* / false, !thisInComputedPropertyName);                 capturedByArrowFunction = true;             }              if (container.kind === SyntaxKind.ComputedPropertyName) {                 container = getThisContainer(container, !capturedByArrowFunction, /*includeClassComputedPropertyName* / false);                 thisInComputedPropertyName = true;                 continue;             }              break;         } */
		checkThisInStaticClassFieldInitializerInDecoratedClass(node, container)
		if thisInComputedPropertyName {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.this_cannot_be_referenced_in_a_computed_property_name */, TODO)
		} else {
			/* TODO(SwitchStatement): switch (container.kind) {                 case SyntaxKind.ModuleDeclaration:                     error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);                     // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks                     break;                 case SyntaxKind.EnumDeclaration:                     error(node, Diagnostics.this_cannot_be_referenced_in_current_location);                     // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks                     break;             } */
		}
		if !isNodeInTypeQuery && capturedByArrowFunction && languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO {
			captureLexicalThis(node, container)
		}
		type_ := tryGetThisTypeAt(node /* TODO(TrueKeyword): true */, TODO, container)
		if noImplicitThis {
			globalThisType := getTypeOfSymbol(globalThisSymbol)
			if type_ == globalThisType && capturedByArrowFunction {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this */, TODO)
			} else if !type_ {
				diag := error(node /* TODO(PropertyAccessExpression): Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation */, TODO)
				if !isSourceFile(container) {
					outsideThis := tryGetThisTypeAt(container)
					if outsideThis && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): outsideThis !== globalThisType */ TODO {
						addRelatedInfo(diag, createDiagnosticForNode(container /* TODO(PropertyAccessExpression): Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container */, TODO))
					}
				}
			}
		}
		return type_ || anyType
	}
	tryGetThisTypeAt := func(node Node, includeGlobalThis /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */, container /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/utilities").ThisContainer */ TODO /* = */ /* TODO(CallExpression): getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) *Type {
		isInJS := isInJSFile(node)
		if isFunctionLike(container) && /* TODO(ParenthesizedExpression): (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) */ TODO {
			thisType := getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container)
			if !thisType {
				className := getClassNameFromPrototypeMethod(container)
				if isInJS && className {
					classSymbol := /* TODO(PropertyAccessExpression): checkExpression(className).symbol */ TODO
					if classSymbol && /* TODO(PropertyAccessExpression): classSymbol.members */ TODO && /* TODO(ParenthesizedExpression): (classSymbol.flags & SymbolFlags.Function) */ TODO {
						/* TODO(ExpressionStatement): thisType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType; */
					}
				} else if isJSConstructor(container) {
					/* TODO(ExpressionStatement): thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)) as InterfaceType).thisType; */
				}
				/* TODO(ExpressionStatement): thisType ||= getContextualThisParameterType(container); */
			}
			if thisType {
				return getFlowTypeOfReference(node, thisType)
			}
		}
		if isClassLike( /* TODO(PropertyAccessExpression): container.parent */ TODO) {
			symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): container.parent */ TODO)
			type_ := /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
			return getFlowTypeOfReference(node, type_)
		}
		if isSourceFile(container) {
			if /* TODO(PropertyAccessExpression): container.commonJsModuleIndicator */ TODO {
				fileSymbol := getSymbolOfDeclaration(container)
				return fileSymbol && getTypeOfSymbol(fileSymbol)
			} else if /* TODO(PropertyAccessExpression): container.externalModuleIndicator */ TODO {
				return undefinedType
			} else if includeGlobalThis {
				return getTypeOfSymbol(globalThisSymbol)
			}
		}
	}
	getExplicitThisType := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		container := getThisContainer(node /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		if isFunctionLike(container) {
			signature := getSignatureFromDeclaration(container)
			if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
				return getExplicitTypeOfSymbol( /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO)
			}
		}
		if isClassLike( /* TODO(PropertyAccessExpression): container.parent */ TODO) {
			symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): container.parent */ TODO)
			return /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
		}
	}
	getClassNameFromPrototypeMethod := func(container Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").LeftHandSideExpression | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionExpression */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): container.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): container.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.PrototypeProperty */ TODO {
			return /* TODO(PropertyAccessExpression): ((container.parent // x.prototype.y = container                 .left as PropertyAccessExpression) // x.prototype.y                 .expression as PropertyAccessExpression) // x.prototype                 .expression */ TODO
		} else if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO && /* TODO(PropertyAccessExpression): container.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): container.parent.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): container.parent.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.Prototype */ TODO {
			return /* TODO(PropertyAccessExpression): (container.parent.parent.left as PropertyAccessExpression).expression */ TODO
		} else if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionExpression */ TODO && /* TODO(PropertyAccessExpression): container.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO && /* TODO(PropertyAccessExpression): container.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): container.parent.parent.parent */ TODO) && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): container.parent.parent.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.Prototype */ TODO {
			return /* TODO(PropertyAccessExpression): (container.parent.parent.parent.left as PropertyAccessExpression).expression */ TODO
		} else if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionExpression */ TODO && isPropertyAssignment( /* TODO(PropertyAccessExpression): container.parent */ TODO) && isIdentifier( /* TODO(PropertyAccessExpression): container.parent.name */ TODO) && /* TODO(ParenthesizedExpression): (container.parent.name.escapedText === "value" || container.parent.name.escapedText === "get" || container.parent.name.escapedText === "set") */ TODO && isObjectLiteralExpression( /* TODO(PropertyAccessExpression): container.parent.parent */ TODO) && isCallExpression( /* TODO(PropertyAccessExpression): container.parent.parent.parent */ TODO) && /* TODO(ElementAccessExpression): container.parent.parent.parent.arguments[2] */ TODO == /* TODO(PropertyAccessExpression): container.parent.parent */ TODO && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): container.parent.parent.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ObjectDefinePrototypeProperty */ TODO {
			return /* TODO(PropertyAccessExpression): (container.parent.parent.parent.arguments[0] as PropertyAccessExpression).expression */ TODO
		} else if isMethodDeclaration(container) && isIdentifier( /* TODO(PropertyAccessExpression): container.name */ TODO) && /* TODO(ParenthesizedExpression): (container.name.escapedText === "value" || container.name.escapedText === "get" || container.name.escapedText === "set") */ TODO && isObjectLiteralExpression( /* TODO(PropertyAccessExpression): container.parent */ TODO) && isCallExpression( /* TODO(PropertyAccessExpression): container.parent.parent */ TODO) && /* TODO(ElementAccessExpression): container.parent.parent.arguments[2] */ TODO == /* TODO(PropertyAccessExpression): container.parent */ TODO && getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): container.parent.parent */ TODO) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ObjectDefinePrototypeProperty */ TODO {
			return /* TODO(PropertyAccessExpression): (container.parent.parent.arguments[0] as PropertyAccessExpression).expression */ TODO
		}
	}
	getTypeForThisExpressionFromJSDoc := func(node SignatureDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		thisTag := getJSDocThisTag(node)
		if thisTag && /* TODO(PropertyAccessExpression): thisTag.typeExpression */ TODO {
			return getTypeFromTypeNode( /* TODO(PropertyAccessExpression): thisTag.typeExpression */ TODO)
		}
		signature := getSignatureOfTypeTag(node)
		if signature {
			return getThisTypeOfSignature(signature)
		}
	}
	isInConstructorArgumentInitializer := func(node Node, constructorDecl Node) bool {
		return !!findAncestor(node /* TODO(ArrowFunction): n => isFunctionLikeDeclaration(n) ? "quit" : n.kind === SyntaxKind.Parameter && n.parent === constructorDecl */, TODO)
	}
	checkSuperExpression := func(node Node) Type {
		isCallExpression := /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CallExpression */ TODO && /* TODO(PropertyAccessExpression): (node.parent as CallExpression).expression */ TODO == node
		immediateContainer := getSuperContainer(node /* TODO(TrueKeyword): true */, TODO)
		container := immediateContainer
		needToCaptureLexicalThis := /* TODO(FalseKeyword): false */ TODO
		inAsyncFunction := /* TODO(FalseKeyword): false */ TODO
		if !isCallExpression {
			/* TODO(WhileStatement): while (container && container.kind === SyntaxKind.ArrowFunction) {                 if (hasSyntacticModifier(container, ModifierFlags.Async)) inAsyncFunction = true;                 container = getSuperContainer(container, /*stopOnFunctions* / true);                 needToCaptureLexicalThis = languageVersion < ScriptTarget.ES2015;             } */
			if container && hasSyntacticModifier(container /* TODO(PropertyAccessExpression): ModifierFlags.Async */, TODO) {
				/* TODO(BinaryExpression): inAsyncFunction = true */
			}
		}
		var nodeCheckFlag NodeCheckFlags = 0
		if !container || !isLegalUsageOfSuperExpression(container) {
			current := findAncestor(node /* TODO(ArrowFunction): n => n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName */, TODO)
			if current && /* TODO(PropertyAccessExpression): current.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.super_cannot_be_referenced_in_a_computed_property_name */, TODO)
			} else if isCallExpression {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors */, TODO)
			} else if !container || ! /* TODO(PropertyAccessExpression): container.parent */ TODO || ! /* TODO(ParenthesizedExpression): (isClassLike(container.parent) || container.parent.kind === SyntaxKind.ObjectLiteralExpression) */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions */, TODO)
			} else {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class */, TODO)
			}
			return errorType
		}
		if !isCallExpression && /* TODO(PropertyAccessExpression): immediateContainer!.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
			checkThisBeforeSuper(node, container /* TODO(PropertyAccessExpression): Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class */, TODO)
		}
		if isStatic(container) || isCallExpression {
			/* TODO(ExpressionStatement): nodeCheckFlag = NodeCheckFlags.SuperStatic; */
			if !isCallExpression && languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO && languageVersion <= /* TODO(PropertyAccessExpression): ScriptTarget.ES2021 */ TODO && /* TODO(ParenthesizedExpression): (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) */ TODO {
				forEachEnclosingBlockScopeContainer( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): current => {                     if (!isSourceFile(current) || isExternalOrCommonJsModule(current)) {                         getNodeLinks(current).flags |= NodeCheckFlags.ContainsSuperPropertyInStaticInitializer;                     }                 } */, TODO)
			}
		} else {
			/* TODO(ExpressionStatement): nodeCheckFlag = NodeCheckFlags.SuperInstance; */
		}
		/* TODO(ExpressionStatement): getNodeLinks(node).flags |= nodeCheckFlag; */
		if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO && inAsyncFunction {
			if isSuperProperty( /* TODO(PropertyAccessExpression): node.parent */ TODO) && isAssignmentTarget( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
				/* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync; */
			} else {
				/* TODO(ExpressionStatement): getNodeLinks(container).flags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync; */
			}
		}
		if needToCaptureLexicalThis {
			captureLexicalThis( /* TODO(PropertyAccessExpression): node.parent */ TODO, container)
		}
		if /* TODO(PropertyAccessExpression): container.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO {
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher */, TODO)
				return errorType
			} else {
				return anyType
			}
		}
		classLikeDeclaration := /* TODO(PropertyAccessExpression): container.parent */ TODO /* as */ /* TODO(TypeReference): ClassLikeDeclaration */
		if !getClassExtendsHeritageElement(classLikeDeclaration) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.super_can_only_be_referenced_in_a_derived_class */, TODO)
			return errorType
		}
		if classDeclarationExtendsNull(classLikeDeclaration) {
			return /* TODO(ConditionalExpression): isCallExpression ? errorType : nullWideningType */ TODO
		}
		classType := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration)) /* as */ /* TODO(TypeReference): InterfaceType */
		baseClassType := classType && /* TODO(ElementAccessExpression): getBaseTypes(classType)[0] */ TODO
		if !baseClassType {
			return errorType
		}
		if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO && isInConstructorArgumentInitializer(node, container) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.super_cannot_be_referenced_in_constructor_arguments */, TODO)
			return errorType
		}
		return /* TODO(ConditionalExpression): nodeCheckFlag === NodeCheckFlags.SuperStatic             ? getBaseConstructorTypeOfClass(classType)             : getTypeWithThisArgument(baseClassType, classType.thisType) */ TODO
		isLegalUsageOfSuperExpression := func(container Node) bool {
			if isCallExpression {
				return /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO
			} else {
				if isClassLike( /* TODO(PropertyAccessExpression): container.parent */ TODO) || /* TODO(PropertyAccessExpression): container.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO {
					if isStatic(container) {
						return /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ClassStaticBlockDeclaration */ TODO
					} else {
						return /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertySignature */ TODO || /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO
					}
				}
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	getContainingObjectLiteral := func(func_ SignatureDeclaration) *ObjectLiteralExpression {
		return /* TODO(ConditionalExpression): (func.kind === SyntaxKind.MethodDeclaration ||                 func.kind === SyntaxKind.GetAccessor ||                 func.kind === SyntaxKind.SetAccessor) && func.parent.kind === SyntaxKind.ObjectLiteralExpression ? func.parent :             func.kind === SyntaxKind.FunctionExpression && func.parent.kind === SyntaxKind.PropertyAssignment ? func.parent.parent as ObjectLiteralExpression :             undefined */ TODO
	}
	getThisTypeArgument := func(type_ Type) *Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target === globalThisType ? getTypeArguments(type as TypeReference)[0] : undefined */ TODO
	}
	getThisTypeFromContextualType := func(type_ Type) *Type {
		return mapType(type_ /* TODO(ArrowFunction): t => {             return t.flags & TypeFlags.Intersection ? forEach((t as IntersectionType).types, getThisTypeArgument) : getThisTypeArgument(t);         } */, TODO)
	}
	getThisTypeOfObjectLiteralFromContextualType := func(containingLiteral ObjectLiteralExpression, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		literal := containingLiteral
		type_ := contextualType
		/* TODO(WhileStatement): while (type) {             const thisType = getThisTypeFromContextualType(type);             if (thisType) {                 return thisType;             }             if (literal.parent.kind !== SyntaxKind.PropertyAssignment) {                 break;             }             literal = literal.parent.parent as ObjectLiteralExpression;             type = getApparentTypeOfContextualType(literal, /*contextFlags* / undefined);         } */
	}
	getContextualThisParameterType := func(func_ SignatureDeclaration) *Type {
		if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrowFunction */ TODO {
			return nil
		}
		if isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			contextualSignature := getContextualSignature(func_)
			if contextualSignature {
				thisParameter := /* TODO(PropertyAccessExpression): contextualSignature.thisParameter */ TODO
				if thisParameter {
					return getTypeOfSymbol(thisParameter)
				}
			}
		}
		inJs := isInJSFile(func_)
		if noImplicitThis || inJs {
			containingLiteral := getContainingObjectLiteral(func_)
			if containingLiteral {
				contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
				thisType := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
				if thisType {
					return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)))
				}
				return getWidenedType( /* TODO(ConditionalExpression): contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral) */ TODO)
			}
			parent := walkUpParenthesizedExpressions( /* TODO(PropertyAccessExpression): func.parent */ TODO)
			if isAssignmentExpression(parent) {
				target := /* TODO(PropertyAccessExpression): parent.left */ TODO
				if isAccessExpression(target) {
					TODO_IDENTIFIER := target
					if inJs && isIdentifier(expression) {
						sourceFile := getSourceFileOfNode(parent)
						if /* TODO(PropertyAccessExpression): sourceFile.commonJsModuleIndicator */ TODO && getResolvedSymbol(expression) == /* TODO(PropertyAccessExpression): sourceFile.symbol */ TODO {
							return nil
						}
					}
					return getWidenedType(checkExpressionCached(expression))
				}
			}
		}
		return nil
	}
	getContextuallyTypedParameterType := func(parameter ParameterDeclaration) *Type {
		func_ := /* TODO(PropertyAccessExpression): parameter.parent */ TODO
		if !isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			return nil
		}
		iife := getImmediatelyInvokedFunctionExpression(func_)
		if iife && /* TODO(PropertyAccessExpression): iife.arguments */ TODO {
			args := getEffectiveCallArguments(iife)
			indexOfParameter := /* TODO(PropertyAccessExpression): func.parameters.indexOf */ TODO(parameter)
			if /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO {
				return getSpreadArgumentType(args, indexOfParameter /* TODO(PropertyAccessExpression): args.length */, TODO, anyType, nil /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO)
			}
			links := getNodeLinks(iife)
			cached := /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO
			/* TODO(ExpressionStatement): links.resolvedSignature = anySignature; */
			type_ := /* TODO(ConditionalExpression): indexOfParameter < args.length ?                 getWidenedLiteralType(checkExpression(args[indexOfParameter])) :                 parameter.initializer ? undefined : undefinedWideningType */ TODO
			/* TODO(ExpressionStatement): links.resolvedSignature = cached; */
			return type_
		}
		contextualSignature := getContextualSignature(func_)
		if contextualSignature {
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0) */ TODO
			return /* TODO(ConditionalExpression): parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ?                 getRestTypeAtPosition(contextualSignature, index) :                 tryGetTypeAtPosition(contextualSignature, index) */ TODO
		}
	}
	getContextualTypeForVariableLikeDeclaration := func(declaration VariableLikeDeclaration, contextFlags *ContextFlags) *Type {
		typeNode := getEffectiveTypeAnnotationNode(declaration) || /* TODO(ParenthesizedExpression): (isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined) */ TODO
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		/* TODO(SwitchStatement): switch (declaration.kind) {             case SyntaxKind.Parameter:                 return getContextuallyTypedParameterType(declaration);             case SyntaxKind.BindingElement:                 return getContextualTypeForBindingElement(declaration, contextFlags);             case SyntaxKind.PropertyDeclaration:                 if (isStatic(declaration)) {                     return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags);                 }                 // By default, do nothing and return undefined - only the above cases have context implied by a parent         } */
	}
	getContextualTypeForBindingElement := func(declaration BindingElement, contextFlags *ContextFlags) *Type {
		parent := /* TODO(PropertyAccessExpression): declaration.parent.parent */ TODO
		name := /* TODO(PropertyAccessExpression): declaration.propertyName */ TODO || /* TODO(PropertyAccessExpression): declaration.name */ TODO
		parentType := getContextualTypeForVariableLikeDeclaration(parent, contextFlags) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): parent.kind !== SyntaxKind.BindingElement */ TODO && /* TODO(PropertyAccessExpression): parent.initializer */ TODO && checkDeclarationInitializer(parent /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */, TODO)
		if !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) {
			/* TODO(Identifier): undefined */
		}
		if /* TODO(PropertyAccessExpression): parent.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayBindingPattern */ TODO {
			index := indexOfNode( /* TODO(PropertyAccessExpression): declaration.parent.elements */ TODO, declaration)
			if index < 0 {
				/* TODO(Identifier): undefined */
			}
			return getContextualTypeForElementExpression(parentType, index)
		}
		nameType := getLiteralTypeFromPropertyName(name)
		if isTypeUsableAsPropertyName(nameType) {
			text := getPropertyNameFromType(nameType)
			return getTypeOfPropertyOfType(parentType, text)
		}
	}
	getContextualTypeForStaticPropertyDeclaration := func(declaration PropertyDeclaration, contextFlags *ContextFlags) *Type {
		parentType := isExpression( /* TODO(PropertyAccessExpression): declaration.parent */ TODO) && getContextualType( /* TODO(PropertyAccessExpression): declaration.parent */ TODO, contextFlags)
		if !parentType {
			/* TODO(Identifier): undefined */
		}
		return getTypeOfPropertyOfContextualType(parentType /* TODO(PropertyAccessExpression): getSymbolOfDeclaration(declaration).escapedName */, TODO)
	}
	getContextualTypeForInitializerExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		declaration := /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): VariableLikeDeclaration */
		if hasInitializer(declaration) && node == /* TODO(PropertyAccessExpression): declaration.initializer */ TODO {
			result := getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
			if result {
				return result
			}
			if ! /* TODO(ParenthesizedExpression): (contextFlags! & ContextFlags.SkipBindingPatterns) */ TODO && isBindingPattern( /* TODO(PropertyAccessExpression): declaration.name */ TODO) && /* TODO(PropertyAccessExpression): declaration.name.elements.length */ TODO > 0 {
				return getTypeFromBindingPattern( /* TODO(PropertyAccessExpression): declaration.name */ TODO /* TODO(TrueKeyword): true */, TODO /* TODO(FalseKeyword): false */, TODO)
			}
		}
		return nil
	}
	getContextualTypeForReturnExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				functionFlags := getFunctionFlags(func_)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): functionFlags & FunctionFlags.Generator */ TODO {
					isAsyncGenerator := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): contextualReturnType.flags & TypeFlags.Union */ TODO {
						/* TODO(ExpressionStatement): contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator)); */
					}
					iterationReturnType := getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Return */ TODO, contextualReturnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO)
					if !iterationReturnType {
						return nil
					}
					/* TODO(ExpressionStatement): contextualReturnType = iterationReturnType; */
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): functionFlags & FunctionFlags.Async */ TODO {
					contextualAwaitedType := mapType(contextualReturnType, getAwaitedTypeNoAlias)
					return contextualAwaitedType && getUnionType( /* TODO(ArrayLiteralExpression): [contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)] */ TODO)
				}
				return contextualReturnType
			}
		}
		return nil
	}
	getContextualTypeForAwaitOperand := func(node AwaitExpression, contextFlags *ContextFlags) *Type {
		contextualType := getContextualType(node, contextFlags)
		if contextualType {
			contextualAwaitedType := getAwaitedTypeNoAlias(contextualType)
			return contextualAwaitedType && getUnionType( /* TODO(ArrayLiteralExpression): [contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)] */ TODO)
		}
		return nil
	}
	getContextualTypeForYieldOperand := func(node YieldExpression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			functionFlags := getFunctionFlags(func_)
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				isAsyncGenerator := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
				if ! /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): contextualReturnType.flags & TypeFlags.Union */ TODO {
					/* TODO(ExpressionStatement): contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator)); */
				}
				if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
					iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
					yieldType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): iterationTypes?.yieldType ?? silentNeverType */ TODO
					returnType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getContextualType(node, contextFlags) ?? silentNeverType */ TODO
					nextType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): iterationTypes?.nextType ?? unknownType */ TODO
					generatorType := createGeneratorType(yieldType, returnType, nextType /* TODO(FalseKeyword): false */, TODO)
					if isAsyncGenerator {
						asyncGeneratorType := createGeneratorType(yieldType, returnType, nextType /* TODO(TrueKeyword): true */, TODO)
						return getUnionType( /* TODO(ArrayLiteralExpression): [generatorType, asyncGeneratorType] */ TODO)
					}
					return generatorType
				}
				return getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Yield */ TODO, contextualReturnType, isAsyncGenerator)
			}
		}
		return nil
	}
	isInParameterInitializerBeforeContainingFunction := func(node Node) /* TODO(undefined): boolean */ TODO {
		inBindingInitializer := /* TODO(FalseKeyword): false */ TODO
		/* TODO(WhileStatement): while (node.parent && !isFunctionLike(node.parent)) {             if (isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {                 return true;             }             if (isBindingElement(node.parent) && node.parent.initializer === node) {                 inBindingInitializer = true;             }              node = node.parent;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	getContextualIterationType := func(kind IterationTypeKind, functionDecl SignatureDeclaration) *Type {
		isAsync := !! /* TODO(ParenthesizedExpression): (getFunctionFlags(functionDecl) & FunctionFlags.Async) */ TODO
		contextualReturnType := getContextualReturnType(functionDecl, nil)
		if contextualReturnType {
			return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || nil
		}
		return nil
	}
	getContextualReturnType := func(functionDecl SignatureDeclaration, contextFlags *ContextFlags) *Type {
		returnType := getReturnTypeFromAnnotation(functionDecl)
		if returnType {
			return returnType
		}
		signature := getContextualSignatureForFunctionLikeDeclaration(functionDecl /* as */ /* TODO(TypeReference): FunctionExpression */)
		if signature && !isResolvingReturnTypeOfSignature(signature) {
			returnType := getReturnTypeOfSignature(signature)
			functionFlags := getFunctionFlags(functionDecl)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): functionFlags & FunctionFlags.Generator */ TODO {
				return filterType(returnType /* TODO(ArrowFunction): t => {                     return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode* / undefined);                 } */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): functionFlags & FunctionFlags.Async */ TODO {
				return filterType(returnType /* TODO(ArrowFunction): t => {                     return !!(t.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.InstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t);                 } */, TODO)
			}
			return returnType
		}
		iife := getImmediatelyInvokedFunctionExpression(functionDecl)
		if iife {
			return getContextualType(iife, contextFlags)
		}
		return nil
	}
	getContextualTypeForArgument := func(callTarget CallLikeExpression, arg Expression) *Type {
		args := getEffectiveCallArguments(callTarget)
		argIndex := /* TODO(PropertyAccessExpression): args.indexOf */ TODO(arg)
		return /* TODO(ConditionalExpression): argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex) */ TODO
	}
	getContextualTypeForArgumentAtIndex := func(callTarget CallLikeExpression, argIndex number) Type {
		if isImportCall(callTarget) {
			return /* TODO(ConditionalExpression): argIndex === 0 ? stringType :                 argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors* / false) :                 anyType */ TODO
		}
		signature := /* TODO(ConditionalExpression): getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget) */ TODO
		if isJsxOpeningLikeElement(callTarget) && argIndex == 0 {
			return getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
		}
		restIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO
		return /* TODO(ConditionalExpression): signatureHasRestParameter(signature) && argIndex >= restIndex ?             getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), AccessFlags.Contextual) :             getTypeAtPosition(signature, argIndex) */ TODO
	}
	getContextualTypeForDecorator := func(decorator Decorator) *Type {
		signature := getDecoratorCallSignature(decorator)
		return /* TODO(ConditionalExpression): signature ? getOrCreateTypeFromSignature(signature) : undefined */ TODO
	}
	getContextualTypeForSubstitutionExpression := func(template TemplateExpression, substitutionExpression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): template.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TaggedTemplateExpression */ TODO {
			return getContextualTypeForArgument( /* TODO(PropertyAccessExpression): template.parent */ TODO /* as */ /* TODO(TypeReference): TaggedTemplateExpression */, substitutionExpression)
		}
		return nil
	}
	getContextualTypeForBinaryOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		binaryExpression := /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): BinaryExpression */
		TODO_IDENTIFIER := binaryExpression
		/* TODO(SwitchStatement): switch (operatorToken.kind) {             case SyntaxKind.EqualsToken:             case SyntaxKind.AmpersandAmpersandEqualsToken:             case SyntaxKind.BarBarEqualsToken:             case SyntaxKind.QuestionQuestionEqualsToken:                 return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined;             case SyntaxKind.BarBarToken:             case SyntaxKind.QuestionQuestionToken:                 // When an || expression has a contextual type, the operands are contextually typed by that type, except                 // when that type originates in a binding pattern, the right operand is contextually typed by the type of                 // the left operand. When an || expression has no contextual type, the right operand is contextually typed                 // by the type of the left operand, except for the special case of Javascript declarations of the form                 // `namespace.prop = namespace.prop || {}`.                 const type = getContextualType(binaryExpression, contextFlags);                 return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ?                     getTypeOfExpression(left) : type;             case SyntaxKind.AmpersandAmpersandToken:             case SyntaxKind.CommaToken:                 return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;             default:                 return undefined;         } */
	}
	getSymbolForExpression := func(e Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if canHaveSymbol(e) && /* TODO(PropertyAccessExpression): e.symbol */ TODO {
			return /* TODO(PropertyAccessExpression): e.symbol */ TODO
		}
		if isIdentifier(e) {
			return getResolvedSymbol(e)
		}
		if isPropertyAccessExpression(e) {
			lhsType := getTypeOfExpression( /* TODO(PropertyAccessExpression): e.expression */ TODO)
			return /* TODO(ConditionalExpression): isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText) */ TODO
		}
		if isElementAccessExpression(e) {
			propType := checkExpressionCached( /* TODO(PropertyAccessExpression): e.argumentExpression */ TODO)
			if !isTypeUsableAsPropertyName(propType) {
				return nil
			}
			lhsType := getTypeOfExpression( /* TODO(PropertyAccessExpression): e.expression */ TODO)
			return getPropertyOfType(lhsType, getPropertyNameFromType(propType))
		}
		return nil
		tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration( /* TODO(PropertyAccessExpression): id.escapedText */ TODO, id)
			return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type_, lexicallyScopedSymbol)
		}
	}
	getContextualTypeForAssignmentDeclaration := func(binaryExpression BinaryExpression) *Type {
		kind := getAssignmentDeclarationKind(binaryExpression)
		/* TODO(SwitchStatement): switch (kind) {             case AssignmentDeclarationKind.None:             case AssignmentDeclarationKind.ThisProperty:                 const lhsSymbol = getSymbolForExpression(binaryExpression.left);                 const decl = lhsSymbol && lhsSymbol.valueDeclaration;                 // Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.                 // We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.                 if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {                     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);                     return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) ||                         (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined);                 }                 if (kind === AssignmentDeclarationKind.None) {                     return getTypeOfExpression(binaryExpression.left);                 }                 return getContextualTypeForThisPropertyAssignment(binaryExpression);             case AssignmentDeclarationKind.Property:                 if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {                     return getContextualTypeForThisPropertyAssignment(binaryExpression);                 }                 // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.                 // See `bindStaticPropertyAssignment` in `binder.ts`.                 else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {                     return getTypeOfExpression(binaryExpression.left);                 }                 else {                     const decl = binaryExpression.left.symbol.valueDeclaration;                     if (!decl) {                         return undefined;                     }                     const lhs = cast(binaryExpression.left, isAccessExpression);                     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);                     if (overallAnnotation) {                         return getTypeFromTypeNode(overallAnnotation);                     }                     else if (isIdentifier(lhs.expression)) {                         const id = lhs.expression;                         const parentSymbol = resolveName(id, id.escapedText, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / true);                         if (parentSymbol) {                             const annotated = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);                             if (annotated) {                                 const nameStr = getElementOrPropertyAccessName(lhs);                                 if (nameStr !== undefined) {                                     return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr);                                 }                             }                             return undefined;                         }                     }                     return isInJSFile(decl) || decl === binaryExpression.left ? undefined : getTypeOfExpression(binaryExpression.left);                 }             case AssignmentDeclarationKind.ExportsProperty:             case AssignmentDeclarationKind.Prototype:             case AssignmentDeclarationKind.PrototypeProperty:             case AssignmentDeclarationKind.ModuleExports:                 let valueDeclaration: Declaration | undefined;                 if (kind !== AssignmentDeclarationKind.ModuleExports) {                     valueDeclaration = canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined;                 }                 valueDeclaration ||= binaryExpression.symbol?.valueDeclaration;                 const annotated = valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration);                 return annotated ? getTypeFromTypeNode(annotated) : undefined;             case AssignmentDeclarationKind.ObjectDefinePropertyValue:             case AssignmentDeclarationKind.ObjectDefinePropertyExports:             case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:                 return Debug.fail("Does not apply");             default:                 return Debug.assertNever(kind);         } */
	}
	isPossiblyAliasedThisProperty := func(declaration BinaryExpression, kind /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AssignmentDeclarationKind */ TODO /* = */ /* TODO(CallExpression): getAssignmentDeclarationKind(declaration) */) /* TODO(undefined): boolean */ TODO {
		if kind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ThisProperty */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if !isInJSFile(declaration) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== AssignmentDeclarationKind.Property */ TODO || !isIdentifier( /* TODO(PropertyAccessExpression): (declaration.left as AccessExpression).expression */ TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		name := /* TODO(PropertyAccessExpression): ((declaration.left as AccessExpression).expression as Identifier).escapedText */ TODO
		symbol := resolveName( /* TODO(PropertyAccessExpression): declaration.left */ TODO, name /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO, nil /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO)
		return isThisInitializedDeclaration( /* TODO(PropertyAccessExpression): symbol?.valueDeclaration */ TODO)
	}
	getContextualTypeForThisPropertyAssignment := func(binaryExpression BinaryExpression) *Type {
		if ! /* TODO(PropertyAccessExpression): binaryExpression.symbol */ TODO {
			/* TODO(CallExpression): getTypeOfExpression(binaryExpression.left) */
		}
		if /* TODO(PropertyAccessExpression): binaryExpression.symbol.valueDeclaration */ TODO {
			annotated := getEffectiveTypeAnnotationNode( /* TODO(PropertyAccessExpression): binaryExpression.symbol.valueDeclaration */ TODO)
			if annotated {
				type_ := getTypeFromTypeNode(annotated)
				if type_ {
					return type_
				}
			}
		}
		thisAccess := cast( /* TODO(PropertyAccessExpression): binaryExpression.left */ TODO, isAccessExpression)
		if !isObjectLiteralMethod(getThisContainer( /* TODO(PropertyAccessExpression): thisAccess.expression */ TODO /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)) {
			return nil
		}
		thisType := checkThisExpression( /* TODO(PropertyAccessExpression): thisAccess.expression */ TODO)
		nameStr := getElementOrPropertyAccessName(thisAccess)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nameStr !== undefined */ TODO && getTypeOfPropertyOfContextualType(thisType, nameStr) || nil
	}
	isCircularMappedProperty := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (getCheckFlags(symbol) & CheckFlags.Mapped && !(symbol as MappedSymbol).links.type && findResolutionCycleStartIndex(symbol, TypeSystemPropertyName.Type) >= 0) */ TODO
	}
	isExcludedMappedPropertyName := func(constraint Type, propertyNameType Type) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constraint.flags & TypeFlags.Conditional */ TODO {
			type_ := constraint /* as */ /* TODO(TypeReference): ConditionalType */
			return !! /* TODO(ParenthesizedExpression): (getReducedType(getTrueTypeFromConditionalType(type)).flags & TypeFlags.Never) */ TODO && getActualTypeVariable(getFalseTypeFromConditionalType(type_)) == getActualTypeVariable( /* TODO(PropertyAccessExpression): type.checkType */ TODO) && isTypeAssignableTo(propertyNameType /* TODO(PropertyAccessExpression): type.extendsType */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constraint.flags & TypeFlags.Intersection */ TODO {
			return some( /* TODO(PropertyAccessExpression): (constraint as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => isExcludedMappedPropertyName(t, propertyNameType) */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getTypeOfPropertyOfContextualType := func(type_ Type, name __String, nameType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return mapType(type_ /* TODO(ArrowFunction): t => {             if (t.flags & TypeFlags.Intersection) {                 let types: Type[] | undefined;                 let indexInfoCandidates: Type[] | undefined;                 let ignoreIndexInfos = false;                 for (const constituentType of (t as IntersectionType).types) {                     if (!(constituentType.flags & TypeFlags.Object)) {                         continue;                     }                     if (isGenericMappedType(constituentType) && getMappedTypeNameTypeKind(constituentType) !== MappedTypeNameTypeKind.Remapping) {                         const substitutedType = getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType);                         types = appendContextualPropertyTypeConstituent(types, substitutedType);                         continue;                     }                     const propertyType = getTypeOfConcretePropertyOfContextualType(constituentType, name);                     if (!propertyType) {                         if (!ignoreIndexInfos) {                             indexInfoCandidates = append(indexInfoCandidates, constituentType);                         }                         continue;                     }                     ignoreIndexInfos = true;                     indexInfoCandidates = undefined;                     types = appendContextualPropertyTypeConstituent(types, propertyType);                 }                 if (indexInfoCandidates) {                     for (const candidate of indexInfoCandidates) {                         const indexInfoType = getTypeFromIndexInfosOfContextualType(candidate, name, nameType);                         types = appendContextualPropertyTypeConstituent(types, indexInfoType);                     }                 }                 if (!types) {                     return;                 }                 if (types.length === 1) {                     return types[0];                 }                 return getIntersectionType(types);             }             if (!(t.flags & TypeFlags.Object)) {                 return;             }             return isGenericMappedType(t) && getMappedTypeNameTypeKind(t) !== MappedTypeNameTypeKind.Remapping                 ? getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)                 : getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType);         } */, TODO /* TODO(TrueKeyword): true */, TODO)
	}
	appendContextualPropertyTypeConstituent := func(types /* TODO(ArrayType): Type[] */ any, type_ *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		return /* TODO(ConditionalExpression): type ? append(types, type.flags & TypeFlags.Any ? unknownType : type) : types */ TODO
	}
	getIndexedMappedTypeSubstitutedTypeOfContextualType := func(type_ MappedType, name __String, nameType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		propertyNameType := nameType || getStringLiteralType(unescapeLeadingUnderscores(name))
		constraint := getConstraintTypeFromMappedType(type_)
		if /* TODO(PropertyAccessExpression): type.nameType */ TODO && isExcludedMappedPropertyName( /* TODO(PropertyAccessExpression): type.nameType */ TODO, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType) {
			return
		}
		constraintOfConstraint := getBaseConstraintOfType(constraint) || constraint
		if !isTypeAssignableTo(propertyNameType, constraintOfConstraint) {
			return
		}
		return substituteIndexedMappedType(type_, propertyNameType)
	}
	getTypeOfConcretePropertyOfContextualType := func(type_ Type, name __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		prop := getPropertyOfType(type_, name)
		if !prop || isCircularMappedProperty(prop) {
			return
		}
		return removeMissingType(getTypeOfSymbol(prop), !! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.Optional) */ TODO)
	}
	getTypeFromIndexInfosOfContextualType := func(type_ Type, name __String, nameType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isTupleType(type_) && isNumericLiteralName(name) && +name >= 0 {
			restType := getElementTypeOfSliceOfTupleType(type_ /* TODO(PropertyAccessExpression): type.target.fixedLength */, TODO, 0 /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
			if restType {
				return restType
			}
		}
		return /* TODO(PropertyAccessExpression): findApplicableIndexInfo(getIndexInfosOfStructuredType(type), nameType || getStringLiteralType(unescapeLeadingUnderscores(name)))?.type */ TODO
	}
	getContextualTypeForObjectLiteralMethod := func(node MethodDeclaration, contextFlags *ContextFlags) *Type {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isObjectLiteralMethod(node))
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
			return nil
		}
		return getContextualTypeForObjectLiteralElement(node, contextFlags)
	}
	getContextualTypeForObjectLiteralElement := func(element ObjectLiteralElementLike, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		objectLiteral := /* TODO(PropertyAccessExpression): element.parent */ TODO /* as */ /* TODO(TypeReference): ObjectLiteralExpression */
		propertyAssignmentType := isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags)
		if propertyAssignmentType {
			return propertyAssignmentType
		}
		type_ := getApparentTypeOfContextualType(objectLiteral, contextFlags)
		if type_ {
			if hasBindableName(element) {
				symbol := getSymbolOfDeclaration(element)
				return getTypeOfPropertyOfContextualType(type_ /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).nameType */, TODO)
			}
			if hasDynamicName(element) {
				name := getNameOfDeclaration(element)
				if name && isComputedPropertyName(name) {
					exprType := checkExpression( /* TODO(PropertyAccessExpression): name.expression */ TODO)
					propType := isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type_, getPropertyNameFromType(exprType))
					if propType {
						return propType
					}
				}
			}
			if /* TODO(PropertyAccessExpression): element.name */ TODO {
				nameType := getLiteralTypeFromPropertyName( /* TODO(PropertyAccessExpression): element.name */ TODO)
				return mapType(type_ /* TODO(ArrowFunction): t => findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType)?.type */, TODO /* TODO(TrueKeyword): true */, TODO)
			}
		}
		return nil
	}
	getSpreadIndices := func(elements []Node) /* TODO(undefined): { first: number | undefined; last: number | undefined; } */ TODO {
		var first TODO
		var last TODO
		/* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             if (isSpreadElement(elements[i])) {                 first ??= i;                 last = i;             }         } */
		return /* TODO(ObjectLiteralExpression): { first, last } */ TODO
	}
	getContextualTypeForElementExpression := func(type_ *Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) *Type {
		return type_ && mapType(type_ /* TODO(ArrowFunction): t => {             if (isTupleType(t)) {                 // If index is before any spread element and within the fixed part of the contextual tuple type, return                 // the type of the contextual tuple element.                 if ((firstSpreadIndex === undefined || index < firstSpreadIndex) && index < t.target.fixedLength) {                     return removeMissingType(getTypeArguments(t)[index], !!(t.target.elementFlags[index] && ElementFlags.Optional));                 }                 // When the length is known and the index is after all spread elements we compute the offset from the element                 // to the end and the number of ending fixed elements in the contextual tuple type.                 const offset = length !== undefined && (lastSpreadIndex === undefined || index > lastSpreadIndex) ? length - index : 0;                 const fixedEndLength = offset > 0 && (t.target.combinedFlags & ElementFlags.Variable) ? getEndElementCount(t.target, ElementFlags.Fixed) : 0;                 // If the offset is within the ending fixed part of the contextual tuple type, return the type of the contextual                 // tuple element.                 if (offset > 0 && offset <= fixedEndLength) {                     return getTypeArguments(t)[getTypeReferenceArity(t) - offset];                 }                 // Return a union of the possible contextual element types with no subtype reduction.                 return getElementTypeOfSliceOfTupleType(t, firstSpreadIndex === undefined ? t.target.fixedLength : Math.min(t.target.fixedLength, firstSpreadIndex), length === undefined || lastSpreadIndex === undefined ? fixedEndLength : Math.min(fixedEndLength, length - lastSpreadIndex), /*writing* / false, /*noReductions* / true);             }             // If element index is known and a contextual property with that name exists, return it. Otherwise return the             // iterated or element type of the contextual type.             return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t, "" + index as __String) ||                 getIteratedTypeOrElementType(IterationUse.Element, t, undefinedType, /*errorNode* / undefined, /*checkAssignability* / false);         } */, TODO /* TODO(TrueKeyword): true */, TODO)
	}
	getContextualTypeForConditionalOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		conditional := /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(TypeReference): ConditionalExpression */
		return /* TODO(ConditionalExpression): node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined */ TODO
	}
	getContextualTypeForChildJsxExpression := func(node JsxElement, child JsxChild, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		attributesType := getApparentTypeOfContextualType( /* TODO(PropertyAccessExpression): node.openingElement.attributes */ TODO, contextFlags)
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		if ! /* TODO(ParenthesizedExpression): (attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") */ TODO {
			return nil
		}
		realChildren := getSemanticJsxChildren( /* TODO(PropertyAccessExpression): node.children */ TODO)
		childIndex := /* TODO(PropertyAccessExpression): realChildren.indexOf */ TODO(child)
		childFieldType := getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
		return childFieldType && /* TODO(ParenthesizedExpression): (realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => {             if (isArrayLikeType(t)) {                 return getIndexedAccessType(t, getNumberLiteralType(childIndex));             }             else {                 return t;             }         }, /*noReductions* / true)) */ TODO
	}
	getContextualTypeForJsxExpression := func(node JsxExpression, contextFlags *ContextFlags) *Type {
		exprParent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		return /* TODO(ConditionalExpression): isJsxAttributeLike(exprParent)             ? getContextualType(node, contextFlags)             : isJsxElement(exprParent)             ? getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)             : undefined */ TODO
	}
	getContextualTypeForJsxAttribute := func(attribute /* TODO(UnionType): JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) *Type {
		if isJsxAttribute(attribute) {
			attributesType := getApparentTypeOfContextualType( /* TODO(PropertyAccessExpression): attribute.parent */ TODO, contextFlags)
			if !attributesType || isTypeAny(attributesType) {
				return nil
			}
			return getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName( /* TODO(PropertyAccessExpression): attribute.name */ TODO))
		} else {
			return getContextualType( /* TODO(PropertyAccessExpression): attribute.parent */ TODO, contextFlags)
		}
	}
	isPossiblyDiscriminantValue := func(node Expression) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.StringLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.TemplateExpression:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.NullKeyword:             case SyntaxKind.Identifier:             case SyntaxKind.UndefinedKeyword:                 return true;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ParenthesizedExpression:                 return isPossiblyDiscriminantValue((node as PropertyAccessExpression | ParenthesizedExpression).expression);             case SyntaxKind.JsxExpression:                 return !(node as JsxExpression).expression || isPossiblyDiscriminantValue((node as JsxExpression).expression!);         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	discriminateContextualTypeByObjectMembers := func(node ObjectLiteralExpression, contextualType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(             key,             getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems(                 contextualType,                 concatenate(                     map(                         filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => {                             if (!p.symbol) {                                 return false;                             }                             if (p.kind === SyntaxKind.PropertyAssignment) {                                 return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             if (p.kind === SyntaxKind.ShorthandPropertyAssignment) {                                 return isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             return false;                         }),                         prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const),                     ),                     map(                         filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),                         s => [() => undefinedType, s.escapedName] as const,                     ),                 ),                 isTypeAssignableTo,             ),         ) */ TODO
	}
	discriminateContextualTypeByJSXAttributes := func(node JsxAttributes, contextualType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		cached := getCachedType(key)
		if cached {
			/* TODO(Identifier): cached */
		}
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		return setCachedType(key, discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter( /* TODO(PropertyAccessExpression): node.properties */ TODO /* TODO(ArrowFunction): p => !!p.symbol && p.kind === SyntaxKind.JsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer)) */, TODO) /* TODO(ArrowFunction): prop => ([!(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)), prop.symbol.escapedName] as const) */, TODO), map_(filter(getPropertiesOfType(contextualType) /* TODO(ArrowFunction): s => {                             if (!(s.flags & SymbolFlags.Optional) || !node?.symbol?.members) {                                 return false;                             }                             const element = node.parent.parent;                             if (s.escapedName === jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length) {                                 return false;                             }                             return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName);                         } */, TODO) /* TODO(ArrowFunction): s => [() => undefinedType, s.escapedName] as const */, TODO)), isTypeAssignableTo))
	}
	getApparentTypeOfContextualType := func(node /* TODO(UnionType): Expression | MethodDeclaration */ any, contextFlags *ContextFlags) *Type {
		contextualType := /* TODO(ConditionalExpression): isObjectLiteralMethod(node) ?             getContextualTypeForObjectLiteralMethod(node, contextFlags) :             getContextualType(node, contextFlags) */ TODO
		instantiatedType := instantiateContextualType(contextualType, node, contextFlags)
		if instantiatedType && ! /* TODO(ParenthesizedExpression): (contextFlags && contextFlags & ContextFlags.NoConstraints && instantiatedType.flags & TypeFlags.TypeVariable) */ TODO {
			apparentType := mapType(instantiatedType /* TODO(ArrowFunction): t => getObjectFlags(t) & ObjectFlags.Mapped ? t : getApparentType(t) */, TODO /* TODO(TrueKeyword): true */, TODO)
			return /* TODO(ConditionalExpression): apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType as UnionType) :                 apparentType.flags & TypeFlags.Union && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType) :                 apparentType */ TODO
		}
	}
	instantiateContextualType := func(contextualType *Type, node Node, contextFlags *ContextFlags) *Type {
		if contextualType && maybeTypeOfKind(contextualType /* TODO(PropertyAccessExpression): TypeFlags.Instantiable */, TODO) {
			inferenceContext := getInferenceContext(node)
			if inferenceContext && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): contextFlags! & ContextFlags.Signature */ TODO && some( /* TODO(PropertyAccessExpression): inferenceContext.inferences */ TODO, hasInferenceCandidatesOrDefault) {
				return instantiateInstantiableTypes(contextualType /* TODO(PropertyAccessExpression): inferenceContext.nonFixingMapper */, TODO)
			}
			if /* TODO(PropertyAccessExpression): inferenceContext?.returnMapper */ TODO {
				type_ := instantiateInstantiableTypes(contextualType /* TODO(PropertyAccessExpression): inferenceContext.returnMapper */, TODO)
				return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && containsType((type as UnionType).types, regularFalseType) && containsType((type as UnionType).types, regularTrueType) ?                     filterType(type, t => t !== regularFalseType && t !== regularTrueType) :                     type */ TODO
			}
		}
		return contextualType
	}
	instantiateInstantiableTypes := func(type_ Type, mapper TypeMapper) Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Instantiable */ TODO {
			return instantiateType(type_, mapper)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			return getUnionType(map_( /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO /* TODO(ArrowFunction): t => instantiateInstantiableTypes(t, mapper) */, TODO) /* TODO(PropertyAccessExpression): UnionReduction.None */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
			return getIntersectionType(map_( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO /* TODO(ArrowFunction): t => instantiateInstantiableTypes(t, mapper) */, TODO))
		}
		return type_
	}
	getContextualType := func(node Expression, contextFlags *ContextFlags) *Type {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
			return nil
		}
		index := findContextualNode(node, !contextFlags)
		if index >= 0 {
			return /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
		}
		TODO_IDENTIFIER := node
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.VariableDeclaration:             case SyntaxKind.Parameter:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:             case SyntaxKind.BindingElement:                 return getContextualTypeForInitializerExpression(node, contextFlags);             case SyntaxKind.ArrowFunction:             case SyntaxKind.ReturnStatement:                 return getContextualTypeForReturnExpression(node, contextFlags);             case SyntaxKind.YieldExpression:                 return getContextualTypeForYieldOperand(parent as YieldExpression, contextFlags);             case SyntaxKind.AwaitExpression:                 return getContextualTypeForAwaitOperand(parent as AwaitExpression, contextFlags);             case SyntaxKind.CallExpression:             case SyntaxKind.NewExpression:                 return getContextualTypeForArgument(parent as CallExpression | NewExpression | Decorator, node);             case SyntaxKind.Decorator:                 return getContextualTypeForDecorator(parent as Decorator);             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:                 return isConstTypeReference((parent as AssertionExpression).type) ? getContextualType(parent as AssertionExpression, contextFlags) : getTypeFromTypeNode((parent as AssertionExpression).type);             case SyntaxKind.BinaryExpression:                 return getContextualTypeForBinaryOperand(node, contextFlags);             case SyntaxKind.PropertyAssignment:             case SyntaxKind.ShorthandPropertyAssignment:                 return getContextualTypeForObjectLiteralElement(parent as PropertyAssignment | ShorthandPropertyAssignment, contextFlags);             case SyntaxKind.SpreadAssignment:                 return getContextualType(parent.parent as ObjectLiteralExpression, contextFlags);             case SyntaxKind.ArrayLiteralExpression: {                 const arrayLiteral = parent as ArrayLiteralExpression;                 const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);                 const elementIndex = indexOfNode(arrayLiteral.elements, node);                 const spreadIndices = getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements);                 return getContextualTypeForElementExpression(type, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last);             }             case SyntaxKind.ConditionalExpression:                 return getContextualTypeForConditionalOperand(node, contextFlags);             case SyntaxKind.TemplateSpan:                 Debug.assert(parent.parent.kind === SyntaxKind.TemplateExpression);                 return getContextualTypeForSubstitutionExpression(parent.parent as TemplateExpression, node);             case SyntaxKind.ParenthesizedExpression: {                 if (isInJSFile(parent)) {                     if (isJSDocSatisfiesExpression(parent)) {                         return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent));                     }                     // Like in `checkParenthesizedExpression`, an `/** @type {xyz} * /` comment before a parenthesized expression acts as a type cast.                     const typeTag = getJSDocTypeTag(parent);                     if (typeTag && !isConstTypeReference(typeTag.typeExpression.type)) {                         return getTypeFromTypeNode(typeTag.typeExpression.type);                     }                 }                 return getContextualType(parent as ParenthesizedExpression, contextFlags);             }             case SyntaxKind.NonNullExpression:                 return getContextualType(parent as NonNullExpression, contextFlags);             case SyntaxKind.SatisfiesExpression:                 return getTypeFromTypeNode((parent as SatisfiesExpression).type);             case SyntaxKind.ExportAssignment:                 return tryGetTypeFromEffectiveTypeNode(parent as ExportAssignment);             case SyntaxKind.JsxExpression:                 return getContextualTypeForJsxExpression(parent as JsxExpression, contextFlags);             case SyntaxKind.JsxAttribute:             case SyntaxKind.JsxSpreadAttribute:                 return getContextualTypeForJsxAttribute(parent as JsxAttribute | JsxSpreadAttribute, contextFlags);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return getContextualJsxElementAttributesType(parent as JsxOpeningLikeElement, contextFlags);             case SyntaxKind.ImportAttribute:                 return getContextualImportAttributeType(parent as ImportAttribute);         } */
		return nil
	}
	pushCachedContextualType := func(node Expression) {
		pushContextualType(node, getContextualType(node, nil) /* TODO(TrueKeyword): true */, TODO)
	}
	pushContextualType := func(node Expression, type_ *Type, isCache bool) {
		/* TODO(ExpressionStatement): contextualTypeNodes[contextualTypeCount] = node; */
		/* TODO(ExpressionStatement): contextualTypes[contextualTypeCount] = type; */
		/* TODO(ExpressionStatement): contextualIsCache[contextualTypeCount] = isCache; */
		/* TODO(ExpressionStatement): contextualTypeCount++; */
	}
	popContextualType := func() {
		/* TODO(ExpressionStatement): contextualTypeCount--; */
	}
	findContextualNode := func(node Node, includeCaches bool) /* TODO(undefined): number */ TODO {
		/* TODO(ForStatement): for (let i = contextualTypeCount - 1; i >= 0; i--) {             if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {                 return i;             }         } */
		return -1
	}
	pushInferenceContext := func(node Node, inferenceContext *InferenceContext) {
		/* TODO(ExpressionStatement): inferenceContextNodes[inferenceContextCount] = node; */
		/* TODO(ExpressionStatement): inferenceContexts[inferenceContextCount] = inferenceContext; */
		/* TODO(ExpressionStatement): inferenceContextCount++; */
	}
	popInferenceContext := func() {
		/* TODO(ExpressionStatement): inferenceContextCount--; */
	}
	getInferenceContext := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ TODO {
		/* TODO(ForStatement): for (let i = inferenceContextCount - 1; i >= 0; i--) {             if (isNodeDescendantOf(node, inferenceContextNodes[i])) {                 return inferenceContexts[i];             }         } */
	}
	getContextualImportAttributeType := func(node ImportAttribute) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return getTypeOfPropertyOfContextualType(getGlobalImportAttributesType( /* TODO(FalseKeyword): false */ TODO), getNameFromImportAttribute(node))
	}
	getContextualJsxElementAttributesType := func(node JsxOpeningLikeElement, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isJsxOpeningElement(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): contextFlags !== ContextFlags.Completions */ TODO {
			index := findContextualNode( /* TODO(PropertyAccessExpression): node.parent */ TODO, !contextFlags)
			if index >= 0 {
				return /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
			}
		}
		return getContextualTypeForArgumentAtIndex(node, 0)
	}
	getEffectiveFirstArgumentForJsxSignature := func(signature Signature, node JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): getJsxReferenceKind(node) !== JsxReferenceKind.Component             ? getJsxPropsTypeFromCallSignature(signature, node)             : getJsxPropsTypeFromClassType(signature, node) */ TODO
	}
	getJsxPropsTypeFromCallSignature := func(sig Signature, context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		propsType := getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
		/* TODO(ExpressionStatement): propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType); */
		intrinsicAttribs := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicAttributes */ TODO, context)
		if !isErrorType(intrinsicAttribs) {
			/* TODO(ExpressionStatement): propsType = intersectTypes(intrinsicAttribs, propsType); */
		}
		return propsType
	}
	getJsxPropsTypeForSignatureFromMember := func(sig Signature, forcedLookupLocation __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): sig.compositeSignatures */ TODO {
			var results []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, signature := range /* TODO(PropertyAccessExpression): sig.compositeSignatures */ TODO {
				instance := getReturnTypeOfSignature(signature)
				if isTypeAny(instance) {
					return instance
				}
				propType := getTypeOfPropertyOfType(instance, forcedLookupLocation)
				if !propType {
					return
				}
				/* TODO(PropertyAccessExpression): results.push */ TODO(propType)
			}
			return getIntersectionType(results)
		}
		instanceType := getReturnTypeOfSignature(sig)
		return /* TODO(ConditionalExpression): isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation) */ TODO
	}
	getStaticTypeOfReferencedJsxConstructor := func(context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isJsxIntrinsicTagName( /* TODO(PropertyAccessExpression): context.tagName */ TODO) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		tagType := checkExpressionCached( /* TODO(PropertyAccessExpression): context.tagName */ TODO)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): tagType.flags & TypeFlags.StringLiteral */ TODO {
			result := getIntrinsicAttributesTypeFromStringLiteralType(tagType /* as */ /* TODO(TypeReference): StringLiteralType */, context)
			if !result {
				return errorType
			}
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		return tagType
	}
	getJsxManagedAttributesFromLocatedAttributes := func(context JsxOpeningLikeElement, ns Symbol, attributesType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		managedSym := getJsxLibraryManagedAttributes(ns)
		if managedSym {
			ctorType := getStaticTypeOfReferencedJsxConstructor(context)
			result := instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
			if result {
				return result
			}
		}
		return attributesType
	}
	getJsxPropsTypeFromClassType := func(sig Signature, context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		ns := getJsxNamespaceAt(context)
		forcedLookupLocation := getJsxElementPropertiesName(ns)
		attributesType := /* TODO(ConditionalExpression): forcedLookupLocation === undefined             // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type             ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)             : forcedLookupLocation === ""             // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead             ? getReturnTypeOfSignature(sig)             // Otherwise get the type of the property on the signature return type             : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) */ TODO
		if !attributesType {
			if !!forcedLookupLocation && !!length( /* TODO(PropertyAccessExpression): context.attributes.properties */ TODO) {
				error(context /* TODO(PropertyAccessExpression): Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property */, TODO, unescapeLeadingUnderscores(forcedLookupLocation))
			}
			return unknownType
		}
		/* TODO(ExpressionStatement): attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType); */
		if isTypeAny(attributesType) {
			return attributesType
		} else {
			apparentAttributesType := attributesType
			intrinsicClassAttribs := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicClassAttributes */ TODO, context)
			if !isErrorType(intrinsicClassAttribs) {
				typeParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias( /* TODO(PropertyAccessExpression): intrinsicClassAttribs.symbol */ TODO)
				hostClassType := getReturnTypeOfSignature(sig)
				var libraryManagedAttributeType Type
				if typeParams {
					inferredArgs := fillMissingTypeArguments( /* TODO(ArrayLiteralExpression): [hostClassType] */ TODO, typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context))
					/* TODO(ExpressionStatement): libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs)); */
				} else {
					/* TODO(BinaryExpression): libraryManagedAttributeType = intrinsicClassAttribs */
				}
				/* TODO(ExpressionStatement): apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType); */
			}
			intrinsicAttribs := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicAttributes */ TODO, context)
			if !isErrorType(intrinsicAttribs) {
				/* TODO(ExpressionStatement): apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType); */
			}
			return apparentAttributesType
		}
	}
	getIntersectedSignatures := func(signatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		return /* TODO(ConditionalExpression): getStrictOptionValue(compilerOptions, "noImplicitAny")             ? reduceLeft(                 signatures,                 (left: Signature | undefined, right) =>                     left === right || !left ? left                         : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!)                         : undefined,             )             : undefined */ TODO
	}
	combineIntersectionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getUnionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
		return createSymbolWithType(left, thisType)
	}
	combineIntersectionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getUnionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
		if needsExtraRestElement {
			restParamSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, "args" /* as */ /* TODO(TypeReference): __String */)
			/* TODO(ExpressionStatement): restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount)); */
			if shorter == right {
				/* TODO(ExpressionStatement): restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper); */
			}
			/* TODO(ExpressionStatement): params[longestCount] = restParamSymbol; */
		}
		return params
	}
	combineSignaturesOfIntersectionMembers := func(left Signature, right Signature) Signature {
		typeParams := /* TODO(PropertyAccessExpression): left.typeParameters */ TODO || /* TODO(PropertyAccessExpression): right.typeParameters */ TODO
		var paramMapper *TypeMapper
		if /* TODO(PropertyAccessExpression): left.typeParameters */ TODO && /* TODO(PropertyAccessExpression): right.typeParameters */ TODO {
			/* TODO(ExpressionStatement): paramMapper = createTypeMapper(right.typeParameters, left.typeParameters); */
		}
		declaration := /* TODO(PropertyAccessExpression): left.declaration */ TODO
		params := combineIntersectionParameters(left, right, paramMapper)
		thisParam := combineIntersectionThisParam( /* TODO(PropertyAccessExpression): left.thisParameter */ TODO /* TODO(PropertyAccessExpression): right.thisParameter */, TODO, paramMapper)
		minArgCount := /* TODO(PropertyAccessExpression): Math.max */ TODO( /* TODO(PropertyAccessExpression): left.minArgumentCount */ TODO /* TODO(PropertyAccessExpression): right.minArgumentCount */, TODO)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (left.flags | right.flags) & SignatureFlags.PropagatingFlags */, TODO)
		/* TODO(ExpressionStatement): result.compositeKind = TypeFlags.Intersection; */
		/* TODO(ExpressionStatement): result.compositeSignatures = concatenate(left.compositeKind === TypeFlags.Intersection && left.compositeSignatures || [left], [right]); */
		if paramMapper {
			/* TODO(ExpressionStatement): result.mapper = left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper; */
		}
		return result
	}
	getContextualCallSignature := func(type_ Type, node SignatureDeclaration) *Signature {
		signatures := getSignaturesOfType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		applicableByArity := filter(signatures /* TODO(ArrowFunction): s => !isAritySmaller(s, node) */, TODO)
		return /* TODO(ConditionalExpression): applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity) */ TODO
	}
	isAritySmaller := func(signature Signature, target SignatureDeclaration) /* TODO(undefined): boolean */ TODO {
		targetParameterCount := 0
		/* TODO(ForStatement): for (; targetParameterCount < target.parameters.length; targetParameterCount++) {             const param = target.parameters[targetParameterCount];             if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {                 break;             }         } */
		if /* TODO(PropertyAccessExpression): target.parameters.length */ TODO && parameterIsThisKeyword( /* TODO(ElementAccessExpression): target.parameters[0] */ TODO) {
			/* TODO(ExpressionStatement): targetParameterCount--; */
		}
		return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount
	}
	getContextualSignatureForFunctionLikeDeclaration := func(node FunctionLikeDeclaration) *Signature {
		return /* TODO(ConditionalExpression): isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node)             ? getContextualSignature(node as FunctionExpression)             : undefined */ TODO
	}
	getContextualSignature := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		typeTagSignature := getSignatureOfTypeTag(node)
		if typeTagSignature {
			return typeTagSignature
		}
		type_ := getApparentTypeOfContextualType(node /* TODO(PropertyAccessExpression): ContextFlags.Signature */, TODO)
		if !type_ {
			return nil
		}
		if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union) */ TODO {
			return getContextualCallSignature(type_, node)
		}
		var signatureList /* TODO(ArrayType): Signature[] */ any
		types := /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO
		for _, current := range types {
			signature := getContextualCallSignature(current, node)
			if signature {
				if !signatureList {
					/* TODO(ExpressionStatement): signatureList = [signature]; */
				} else if !compareSignaturesIdentical( /* TODO(ElementAccessExpression): signatureList[0] */ TODO, signature /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, compareTypesIdentical) {
					return nil
				} else {
					/* TODO(PropertyAccessExpression): signatureList.push */ TODO(signature)
				}
			}
		}
		if signatureList {
			return /* TODO(ConditionalExpression): signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList) */ TODO
		}
	}
	checkGrammarRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO(undefined): boolean */ TODO {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) && ! /* TODO(PropertyAccessExpression): node.isUnterminated */ TODO {
			var lastError *DiagnosticWithLocation
			/* TODO(ExpressionStatement): scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true); */
			/* TODO(PropertyAccessExpression): scanner.setScriptTarget */
			TODO( /* TODO(PropertyAccessExpression): sourceFile.languageVersion */ TODO)
			/* TODO(PropertyAccessExpression): scanner.setLanguageVariant */ TODO( /* TODO(PropertyAccessExpression): sourceFile.languageVariant */ TODO)
			/* TODO(PropertyAccessExpression): scanner.setOnError */ TODO( /* TODO(ArrowFunction): (message, length, arg0) => {                 // For providing spelling suggestions                 const start = scanner!.getTokenEnd();                 if (message.category === DiagnosticCategory.Message && lastError && start === lastError.start && length === lastError.length) {                     const error = createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0);                     addRelatedInfo(lastError, error);                 }                 else if (!lastError || start !== lastError.start) {                     lastError = createFileDiagnostic(sourceFile, start, length, message, arg0);                     diagnostics.add(lastError);                 }             } */ TODO)
			/* TODO(PropertyAccessExpression): scanner.setText */ TODO( /* TODO(PropertyAccessExpression): sourceFile.text */ TODO /* TODO(PropertyAccessExpression): node.pos */, TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.end - node.pos */, TODO)
			/* TODO(TryStatement): try {                 scanner.scan();                 Debug.assert(scanner.reScanSlashToken(/*reportErrors* / true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral");                 return !!lastError;             }             finally {                 scanner.setText("");                 scanner.setOnError(/*onError* / undefined);             } */
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		nodeLinks := getNodeLinks(node)
		if ! /* TODO(ParenthesizedExpression): (nodeLinks.flags & NodeCheckFlags.TypeChecked) */ TODO {
			/* TODO(ExpressionStatement): nodeLinks.flags |= NodeCheckFlags.TypeChecked; */
			addLazyDiagnostic( /* TODO(ArrowFunction): () => checkGrammarRegularExpressionLiteral(node) */ TODO)
		}
		return globalRegExpType
	}
	checkSpreadExpression := func(node SpreadElement, checkMode CheckMode) Type {
		if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.SpreadElements */ TODO {
			checkExternalEmitHelpers(node /* TODO(ConditionalExpression): compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray */, TODO)
		}
		arrayOrIterableType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO, checkMode)
		return checkIteratedTypeOrElementType( /* TODO(PropertyAccessExpression): IterationUse.Spread */ TODO, arrayOrIterableType, undefinedType /* TODO(PropertyAccessExpression): node.expression */, TODO)
	}
	checkSyntheticExpression := func(node SyntheticExpression) Type {
		return /* TODO(ConditionalExpression): node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type */ TODO
	}
	hasDefaultValue := func(node /* TODO(UnionType): BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO && !! /* TODO(PropertyAccessExpression): (node as BindingElement).initializer */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO && hasDefaultValue( /* TODO(PropertyAccessExpression): (node as PropertyAssignment).initializer */ TODO) || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO && !! /* TODO(PropertyAccessExpression): (node as ShorthandPropertyAssignment).objectAssignmentInitializer */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (node as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO
	}
	isSpreadIntoCallOrNew := func(node ArrayLiteralExpression) /* TODO(undefined): boolean */ TODO {
		parent := walkUpParenthesizedExpressions( /* TODO(PropertyAccessExpression): node.parent */ TODO)
		return isSpreadElement(parent) && isCallOrNewExpression( /* TODO(PropertyAccessExpression): parent.parent */ TODO)
	}
	checkArrayLiteral := func(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple /* TODO(BooleanKeyword): boolean */ any) Type {
		elements := /* TODO(PropertyAccessExpression): node.elements */ TODO
		elementCount := /* TODO(PropertyAccessExpression): elements.length */ TODO
		var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var elementFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
		pushCachedContextualType(node)
		inDestructuringPattern := isAssignmentTarget(node)
		inConstContext := isConstContext(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		inTupleContext := isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType /* TODO(ArrowFunction): t => isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target as MappedType || t) */, TODO)
		hasOmittedExpression := /* TODO(FalseKeyword): false */ TODO
		/* TODO(ForStatement): for (let i = 0; i < elementCount; i++) {             const e = elements[i];             if (e.kind === SyntaxKind.SpreadElement) {                 if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {                     checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);                 }                 const spreadType = checkExpression((e as SpreadElement).expression, checkMode, forceTuple);                 if (isArrayLikeType(spreadType)) {                     elementTypes.push(spreadType);                     elementFlags.push(ElementFlags.Variadic);                 }                 else if (inDestructuringPattern) {                     // Given the following situation:                     //    var c: {};                     //    [...c] = ["", 0];                     //                     // c is represented in the tree as a spread element in an array literal.                     // But c really functions as a rest element, and its purpose is to provide                     // a contextual type for the right hand side of the assignment. Therefore,                     // instead of calling checkExpression on "...c", which will give an error                     // if c is not iterable/array-like, we need to act as if we are trying to                     // get the contextual element type from it. So we do something similar to                     // getContextualTypeForElementExpression, which will crucially not error                     // if there is no index type / iterated type.                     const restElementType = getIndexTypeOfType(spreadType, numberType) ||                         getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, /*errorNode* / undefined, /*checkAssignability* / false) ||                         unknownType;                     elementTypes.push(restElementType);                     elementFlags.push(ElementFlags.Rest);                 }                 else {                     elementTypes.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, (e as SpreadElement).expression));                     elementFlags.push(ElementFlags.Rest);                 }             }             else if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {                 hasOmittedExpression = true;                 elementTypes.push(undefinedOrMissingType);                 elementFlags.push(ElementFlags.Optional);             }             else {                 const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);                 elementTypes.push(addOptionality(type, /*isProperty* / true, hasOmittedExpression));                 elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);                 if (inTupleContext && checkMode && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(e)) {                     const inferenceContext = getInferenceContext(node);                     Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context                     addIntraExpressionInferenceSite(inferenceContext, e, type);                 }             }         } */
		popContextualType()
		if inDestructuringPattern {
			return createTupleType(elementTypes, elementFlags)
		}
		if forceTuple || inConstContext || inTupleContext {
			return createArrayLiteralType(createTupleType(elementTypes, elementFlags, inConstContext && ! /* TODO(ParenthesizedExpression): (contextualType && someType(contextualType, isMutableArrayLikeType)) */ TODO))
		}
		return createArrayLiteralType(createArrayType( /* TODO(ConditionalExpression): elementTypes.length ?                 getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) :                 strictNullChecks ? implicitNeverType : undefinedWideningType */ TODO, inConstContext))
	}
	createArrayLiteralType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if ! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference) */ TODO {
			return type_
		}
		literalType := /* TODO(PropertyAccessExpression): (type as TypeReference).literalType */ TODO
		if !literalType {
			/* TODO(ExpressionStatement): literalType = (type as TypeReference).literalType = cloneTypeReference(type as TypeReference); */
			/* TODO(ExpressionStatement): literalType.objectFlags |= ObjectFlags.ArrayLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
		}
		return literalType
	}
	isNumericName := func(name DeclarationName) bool {
		/* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.ComputedPropertyName:                 return isNumericComputedName(name);             case SyntaxKind.Identifier:                 return isNumericLiteralName(name.escapedText);             case SyntaxKind.NumericLiteral:             case SyntaxKind.StringLiteral:                 return isNumericLiteralName(name.text);             default:                 return false;         } */
	}
	isNumericComputedName := func(name ComputedPropertyName) bool {
		return isTypeAssignableToKind(checkComputedPropertyName(name) /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */, TODO)
	}
	checkComputedPropertyName := func(node ComputedPropertyName) Type {
		links := getNodeLinks( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			if /* TODO(ParenthesizedExpression): (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) */ TODO && isBinaryExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO) && /* TODO(PropertyAccessExpression): node.expression.operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InKeyword */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.GetAccessor */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SetAccessor */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			/* TODO(ExpressionStatement): links.resolvedType = checkExpression(node.expression); */
			if isPropertyDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO) && !hasStaticModifier( /* TODO(PropertyAccessExpression): node.parent */ TODO) && isClassExpression( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO) {
				container := getEnclosingBlockScopeContainer( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
				enclosingIterationStatement := getEnclosingIterationStatement(container)
				if enclosingIterationStatement {
					/* TODO(ExpressionStatement): getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding; */
					/* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
					/* TODO(ExpressionStatement): getNodeLinks(node.parent.parent).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.resolvedType.flags & TypeFlags.Nullable */ TODO || !isTypeAssignableToKind( /* TODO(PropertyAccessExpression): links.resolvedType */ TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.StringLike | TypeFlags.NumberLike | TypeFlags.ESSymbolLike */, TODO) && !isTypeAssignableTo( /* TODO(PropertyAccessExpression): links.resolvedType */ TODO, stringNumberSymbolType) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any */, TODO)
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	isSymbolWithNumericName := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
		return isNumericLiteralName( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO) || /* TODO(ParenthesizedExpression): (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name)) */ TODO
	}
	isSymbolWithSymbolName := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
		return isKnownSymbol(symbol) || /* TODO(ParenthesizedExpression): (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) &&             isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlags.ESSymbol)) */ TODO
	}
	getObjectLiteralIndexInfo := func(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
		var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = offset; i < properties.length; i++) {             const prop = properties[i];             if (                 keyType === stringType && !isSymbolWithSymbolName(prop) ||                 keyType === numberType && isSymbolWithNumericName(prop) ||                 keyType === esSymbolType && isSymbolWithSymbolName(prop)             ) {                 propTypes.push(getTypeOfSymbol(properties[i]));             }         } */
		unionType := /* TODO(ConditionalExpression): propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType */ TODO
		return createIndexInfo(keyType, unionType, isConstContext(node))
	}
	getImmediateAliasedSymbol := func(symbol Symbol) *Symbol {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Alias) !== 0 */ TODO, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.immediateTarget */ TODO {
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				/* TODO(CallExpression): Debug.fail() */
			}
			/* TODO(ExpressionStatement): links.immediateTarget = getTargetOfAliasDeclaration(node, /*dontRecursivelyResolve* / true); */
		}
		return /* TODO(PropertyAccessExpression): links.immediateTarget */ TODO
	}
	checkObjectLiteral := func(node ObjectLiteralExpression, checkMode CheckMode /* = */ /* TODO(PropertyAccessExpression): CheckMode.Normal */) Type {
		inDestructuringPattern := isAssignmentTarget(node)
		checkGrammarObjectLiteralExpression(node, inDestructuringPattern)
		allPropertiesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		propertiesTable := createSymbolTable()
		var propertiesArray []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var spread Type = emptyObjectType
		pushCachedContextualType(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		contextualTypeHasPattern := contextualType && /* TODO(PropertyAccessExpression): contextualType.pattern */ TODO && /* TODO(ParenthesizedExpression): (contextualType.pattern.kind === SyntaxKind.ObjectBindingPattern || contextualType.pattern.kind === SyntaxKind.ObjectLiteralExpression) */ TODO
		inConstContext := isConstContext(node)
		checkFlags := /* TODO(ConditionalExpression): inConstContext ? CheckFlags.Readonly : 0 */ TODO
		isInJavascript := isInJSFile(node) && !isInJsonFile(node)
		enumTag := /* TODO(ConditionalExpression): isInJavascript ? getJSDocEnumTag(node) : undefined */ TODO
		isJSObjectLiteral := !contextualType && isInJavascript && !enumTag
		var objectFlags ObjectFlags = /* TODO(PropertyAccessExpression): ObjectFlags.FreshLiteral */ TODO
		patternWithComputedProperties := /* TODO(FalseKeyword): false */ TODO
		hasComputedStringProperty := /* TODO(FalseKeyword): false */ TODO
		hasComputedNumberProperty := /* TODO(FalseKeyword): false */ TODO
		hasComputedSymbolProperty := /* TODO(FalseKeyword): false */ TODO
		for _, elem := range /* TODO(PropertyAccessExpression): node.properties */ TODO {
			if /* TODO(PropertyAccessExpression): elem.name */ TODO && isComputedPropertyName( /* TODO(PropertyAccessExpression): elem.name */ TODO) {
				checkComputedPropertyName( /* TODO(PropertyAccessExpression): elem.name */ TODO)
			}
		}
		offset := 0
		for _, memberDecl := range /* TODO(PropertyAccessExpression): node.properties */ TODO {
			member := getSymbolOfDeclaration(memberDecl)
			computedNameType := /* TODO(ConditionalExpression): memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ?                 checkComputedPropertyName(memberDecl.name) : undefined */ TODO
			if /* TODO(PropertyAccessExpression): memberDecl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO || /* TODO(PropertyAccessExpression): memberDecl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO || isObjectLiteralMethod(memberDecl) {
				type_ := /* TODO(ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) :                     // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring                     // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.                     // we don't want to say "could not find 'a'".                     memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :                     checkObjectLiteralMethod(memberDecl, checkMode) */ TODO
				if isInJavascript {
					jsDocType := getTypeForDeclarationFromJSDocComment(memberDecl)
					if jsDocType {
						checkTypeAssignableTo(type_, jsDocType, memberDecl)
						/* TODO(ExpressionStatement): type = jsDocType; */
					} else if enumTag && /* TODO(PropertyAccessExpression): enumTag.typeExpression */ TODO {
						checkTypeAssignableTo(type_, getTypeFromTypeNode( /* TODO(PropertyAccessExpression): enumTag.typeExpression */ TODO), memberDecl)
					}
				}
				/* TODO(ExpressionStatement): objectFlags |= getObjectFlags(type) & ObjectFlags.PropagatingFlags; */
				nameType := /* TODO(ConditionalExpression): computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined */ TODO
				prop := /* TODO(ConditionalExpression): nameType ?                     createSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late) :                     createSymbol(SymbolFlags.Property | member.flags, member.escapedName, checkFlags) */ TODO
				if nameType {
					/* TODO(ExpressionStatement): prop.links.nameType = nameType; */
				}
				if inDestructuringPattern && hasDefaultValue(memberDecl) {
					/* TODO(ExpressionStatement): prop.flags |= SymbolFlags.Optional; */
				} else if contextualTypeHasPattern && ! /* TODO(ParenthesizedExpression): (getObjectFlags(contextualType) & ObjectFlags.ObjectLiteralPatternWithComputedProperties) */ TODO {
					impliedProp := getPropertyOfType(contextualType /* TODO(PropertyAccessExpression): member.escapedName */, TODO)
					if impliedProp {
						/* TODO(ExpressionStatement): prop.flags |= impliedProp.flags & SymbolFlags.Optional; */
					} else if !getIndexInfoOfType(contextualType, stringType) {
						error( /* TODO(PropertyAccessExpression): memberDecl.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1 */, TODO, symbolToString(member), typeToString(contextualType))
					}
				}
				/* TODO(ExpressionStatement): prop.declarations = member.declarations; */
				/* TODO(ExpressionStatement): prop.parent = member.parent; */
				if /* TODO(PropertyAccessExpression): member.valueDeclaration */ TODO {
					/* TODO(ExpressionStatement): prop.valueDeclaration = member.valueDeclaration; */
				}
				/* TODO(ExpressionStatement): prop.links.type = type; */
				/* TODO(ExpressionStatement): prop.links.target = member; */
				/* TODO(ExpressionStatement): member = prop; */
				/* TODO(PropertyAccessExpression): allPropertiesTable?.set */
				TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, prop)
				if contextualType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */ TODO && ! /* TODO(ParenthesizedExpression): (checkMode & CheckMode.SkipContextSensitive) */ TODO && /* TODO(ParenthesizedExpression): (memberDecl.kind === SyntaxKind.PropertyAssignment || memberDecl.kind === SyntaxKind.MethodDeclaration) */ TODO && isContextSensitive(memberDecl) {
					inferenceContext := getInferenceContext(node)
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO(inferenceContext)
					inferenceNode := /* TODO(ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl */ TODO
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type_)
				}
			} else if /* TODO(PropertyAccessExpression): memberDecl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SpreadAssignment */ TODO {
				if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ObjectAssign */ TODO {
					checkExternalEmitHelpers(memberDecl /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Assign */, TODO)
				}
				if /* TODO(PropertyAccessExpression): propertiesArray.length */ TODO > 0 {
					/* TODO(ExpressionStatement): spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext); */
					/* TODO(ExpressionStatement): propertiesArray = []; */
					/* TODO(ExpressionStatement): propertiesTable = createSymbolTable(); */
					/* TODO(ExpressionStatement): hasComputedStringProperty = false; */
					/* TODO(ExpressionStatement): hasComputedNumberProperty = false; */
					/* TODO(ExpressionStatement): hasComputedSymbolProperty = false; */
				}
				type_ := getReducedType(checkExpression( /* TODO(PropertyAccessExpression): memberDecl.expression */ TODO /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */, TODO))
				if isValidSpreadType(type_) {
					mergedType := tryMergeUnionOfObjectTypeAndEmptyObject(type_, inConstContext)
					if allPropertiesTable {
						checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl)
					}
					/* TODO(ExpressionStatement): offset = propertiesArray.length; */
					if isErrorType(spread) {
						/* TODO(ContinueStatement): continue; */
					}
					/* TODO(ExpressionStatement): spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext); */
				} else {
					error(memberDecl /* TODO(PropertyAccessExpression): Diagnostics.Spread_types_may_only_be_created_from_object_types */, TODO)
					/* TODO(ExpressionStatement): spread = errorType; */
				}
				/* TODO(ContinueStatement): continue; */
			} else {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): memberDecl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO || /* TODO(PropertyAccessExpression): memberDecl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO)
				checkNodeDeferred(memberDecl)
			}
			if computedNameType && ! /* TODO(ParenthesizedExpression): (computedNameType.flags & TypeFlags.StringOrNumberLiteralOrUnique) */ TODO {
				if isTypeAssignableTo(computedNameType, stringNumberSymbolType) {
					if isTypeAssignableTo(computedNameType, numberType) {
						/* TODO(ExpressionStatement): hasComputedNumberProperty = true; */
					} else if isTypeAssignableTo(computedNameType, esSymbolType) {
						/* TODO(ExpressionStatement): hasComputedSymbolProperty = true; */
					} else {
						/* TODO(ExpressionStatement): hasComputedStringProperty = true; */
					}
					if inDestructuringPattern {
						/* TODO(ExpressionStatement): patternWithComputedProperties = true; */
					}
				}
			} else {
				/* TODO(PropertyAccessExpression): propertiesTable.set */ TODO( /* TODO(PropertyAccessExpression): member.escapedName */ TODO, member)
			}
			/* TODO(PropertyAccessExpression): propertiesArray.push */ TODO(member)
		}
		popContextualType()
		if isErrorType(spread) {
			return errorType
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): spread !== emptyObjectType */ TODO {
			if /* TODO(PropertyAccessExpression): propertiesArray.length */ TODO > 0 {
				/* TODO(ExpressionStatement): spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext); */
				/* TODO(ExpressionStatement): propertiesArray = []; */
				/* TODO(ExpressionStatement): propertiesTable = createSymbolTable(); */
				/* TODO(ExpressionStatement): hasComputedStringProperty = false; */
				/* TODO(ExpressionStatement): hasComputedNumberProperty = false; */
			}
			return mapType(spread /* TODO(ArrowFunction): t => t === emptyObjectType ? createObjectLiteralType() : t */, TODO)
		}
		return createObjectLiteralType()
		createObjectLiteralType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			indexInfos := /* TODO(ArrayLiteralExpression): [] */ TODO
			if hasComputedStringProperty {
				/* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType)) */
			}
			if hasComputedNumberProperty {
				/* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType)) */
			}
			if hasComputedSymbolProperty {
				/* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType)) */
			}
			result := createAnonymousType( /* TODO(PropertyAccessExpression): node.symbol */ TODO, propertiesTable, emptyArray, emptyArray, indexInfos)
			/* TODO(ExpressionStatement): result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
			if isJSObjectLiteral {
				/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.JSLiteral; */
			}
			if patternWithComputedProperties {
				/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.ObjectLiteralPatternWithComputedProperties; */
			}
			if inDestructuringPattern {
				/* TODO(ExpressionStatement): result.pattern = node; */
			}
			return result
		}
	}
	isValidSpreadType := func(type_ Type) bool {
		t := removeDefinitelyFalsyTypes(mapType(type_, getBaseConstraintOrType))
		return !! /* TODO(ParenthesizedExpression): (t.flags & (TypeFlags.Any | TypeFlags.NonPrimitive | TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ||             t.flags & TypeFlags.UnionOrIntersection && every((t as UnionOrIntersectionType).types, isValidSpreadType)) */ TODO
	}
	checkJsxSelfClosingElementDeferred := func(node JsxSelfClosingElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node)
	}
	checkJsxSelfClosingElement := func(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxElementDeferred := func(node JsxElement) {
		checkJsxOpeningLikeElementOrOpeningFragment( /* TODO(PropertyAccessExpression): node.openingElement */ TODO)
		if isJsxIntrinsicTagName( /* TODO(PropertyAccessExpression): node.closingElement.tagName */ TODO) {
			getIntrinsicTagSymbol( /* TODO(PropertyAccessExpression): node.closingElement */ TODO)
		} else {
			checkExpression( /* TODO(PropertyAccessExpression): node.closingElement.tagName */ TODO)
		}
		checkJsxChildren(node)
	}
	checkJsxElement := func(node JsxElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxFragment := func(node JsxFragment) Type {
		checkJsxOpeningLikeElementOrOpeningFragment( /* TODO(PropertyAccessExpression): node.openingFragment */ TODO)
		nodeSourceFile := getSourceFileOfNode(node)
		if getJSXTransformEnabled(compilerOptions) && /* TODO(ParenthesizedExpression): (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) */ TODO && ! /* TODO(PropertyAccessExpression): compilerOptions.jsxFragmentFactory */ TODO && ! /* TODO(PropertyAccessExpression): nodeSourceFile.pragmas.has */ TODO("jsxfrag") {
			error(node /* TODO(ConditionalExpression): compilerOptions.jsxFactory                     ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option                     : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments */, TODO)
		}
		checkJsxChildren(node)
		return getJsxElementTypeAt(node) || anyType
	}
	isHyphenatedJsxName := func(name /* TODO(UnionType): string | __String */ any) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): (name as string).includes */ TODO("-")
	}
	isJsxIntrinsicTagName := func(tagName Node) /* TODO(TypePredicate): tagName is Identifier | JsxNamespacedName */ TODO {
		return isIdentifier(tagName) && isIntrinsicJsxName( /* TODO(PropertyAccessExpression): tagName.escapedText */ TODO) || isJsxNamespacedName(tagName)
	}
	checkJsxAttribute := func(node JsxAttribute, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.initializer             ? checkExpressionForMutableLocation(node.initializer, checkMode)             : trueType */ TODO
	}
	createJsxAttributesTypeFromAttributesProperty := func(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /* = */ /* TODO(PropertyAccessExpression): CheckMode.Normal */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		attributes := /* TODO(PropertyAccessExpression): openingLikeElement.attributes */ TODO
		contextualType := getContextualType(attributes /* TODO(PropertyAccessExpression): ContextFlags.None */, TODO)
		allAttributesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		attributesTable := createSymbolTable()
		var spread Type = emptyJsxObjectType
		hasSpreadAnyType := /* TODO(FalseKeyword): false */ TODO
		var typeToIntersect *Type
		explicitlySpecifyChildrenAttribute := /* TODO(FalseKeyword): false */ TODO
		var objectFlags ObjectFlags = /* TODO(PropertyAccessExpression): ObjectFlags.JsxAttributes */ TODO
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement))
		for _, attributeDecl := range /* TODO(PropertyAccessExpression): attributes.properties */ TODO {
			member := /* TODO(PropertyAccessExpression): attributeDecl.symbol */ TODO
			if isJsxAttribute(attributeDecl) {
				exprType := checkJsxAttribute(attributeDecl, checkMode)
				/* TODO(ExpressionStatement): objectFlags |= getObjectFlags(exprType) & ObjectFlags.PropagatingFlags; */
				attributeSymbol := createSymbol( /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | member.flags */ TODO /* TODO(PropertyAccessExpression): member.escapedName */, TODO)
				/* TODO(ExpressionStatement): attributeSymbol.declarations = member.declarations; */
				/* TODO(ExpressionStatement): attributeSymbol.parent = member.parent; */
				if /* TODO(PropertyAccessExpression): member.valueDeclaration */ TODO {
					/* TODO(ExpressionStatement): attributeSymbol.valueDeclaration = member.valueDeclaration; */
				}
				/* TODO(ExpressionStatement): attributeSymbol.links.type = exprType; */
				/* TODO(ExpressionStatement): attributeSymbol.links.target = member; */
				/* TODO(PropertyAccessExpression): attributesTable.set */
				TODO( /* TODO(PropertyAccessExpression): attributeSymbol.escapedName */ TODO, attributeSymbol)
				/* TODO(PropertyAccessExpression): allAttributesTable?.set */ TODO( /* TODO(PropertyAccessExpression): attributeSymbol.escapedName */ TODO, attributeSymbol)
				if getEscapedTextOfJsxAttributeName( /* TODO(PropertyAccessExpression): attributeDecl.name */ TODO) == jsxChildrenPropertyName {
					/* TODO(ExpressionStatement): explicitlySpecifyChildrenAttribute = true; */
				}
				if contextualType {
					prop := getPropertyOfType(contextualType /* TODO(PropertyAccessExpression): member.escapedName */, TODO)
					if prop && /* TODO(PropertyAccessExpression): prop.declarations */ TODO && isDeprecatedSymbol(prop) && isIdentifier( /* TODO(PropertyAccessExpression): attributeDecl.name */ TODO) {
						addDeprecatedSuggestion( /* TODO(PropertyAccessExpression): attributeDecl.name */ TODO /* TODO(PropertyAccessExpression): prop.declarations */, TODO /* TODO(PropertyAccessExpression): attributeDecl.name.escapedText */, TODO /* as */ /* TODO(StringKeyword): string */)
					}
				}
				if contextualType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */ TODO && ! /* TODO(ParenthesizedExpression): (checkMode & CheckMode.SkipContextSensitive) */ TODO && isContextSensitive(attributeDecl) {
					inferenceContext := getInferenceContext(attributes)
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO(inferenceContext)
					inferenceNode := /* TODO(NonNullExpression): (attributeDecl.initializer as JsxExpression).expression! */ TODO
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType)
				}
			} else {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): attributeDecl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JsxSpreadAttribute */ TODO)
				if /* TODO(PropertyAccessExpression): attributesTable.size */ TODO > 0 {
					/* TODO(ExpressionStatement): spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, /*readonly* / false); */
					/* TODO(ExpressionStatement): attributesTable = createSymbolTable(); */
				}
				exprType := getReducedType(checkExpression( /* TODO(PropertyAccessExpression): attributeDecl.expression */ TODO /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */, TODO))
				if isTypeAny(exprType) {
					/* TODO(ExpressionStatement): hasSpreadAnyType = true; */
				}
				if isValidSpreadType(exprType) {
					/* TODO(ExpressionStatement): spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, /*readonly* / false); */
					if allAttributesTable {
						checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl)
					}
				} else {
					error( /* TODO(PropertyAccessExpression): attributeDecl.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Spread_types_may_only_be_created_from_object_types */, TODO)
					/* TODO(ExpressionStatement): typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType; */
				}
			}
		}
		if !hasSpreadAnyType {
			if /* TODO(PropertyAccessExpression): attributesTable.size */ TODO > 0 {
				/* TODO(ExpressionStatement): spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, /*readonly* / false); */
			}
		}
		parent := /* TODO(ConditionalExpression): openingLikeElement.parent.kind === SyntaxKind.JsxElement ? openingLikeElement.parent as JsxElement : undefined */ TODO
		if parent && /* TODO(PropertyAccessExpression): parent.openingElement */ TODO == openingLikeElement && /* TODO(PropertyAccessExpression): getSemanticJsxChildren(parent.children).length */ TODO > 0 {
			var childrenTypes []Type = checkJsxChildren(parent, checkMode)
			if !hasSpreadAnyType && jsxChildrenPropertyName && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): jsxChildrenPropertyName !== "" */ TODO {
				if explicitlySpecifyChildrenAttribute {
					error(attributes /* TODO(PropertyAccessExpression): Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten */, TODO, unescapeLeadingUnderscores(jsxChildrenPropertyName))
				}
				contextualType := getApparentTypeOfContextualType( /* TODO(PropertyAccessExpression): openingLikeElement.attributes */ TODO, nil)
				childrenContextualType := contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName)
				childrenPropSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, jsxChildrenPropertyName)
				/* TODO(ExpressionStatement): childrenPropSymbol.links.type = childrenTypes.length === 1 ? childrenTypes[0] :                     childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) :                     createArrayType(getUnionType(childrenTypes)); */
				/* TODO(ExpressionStatement): childrenPropSymbol.valueDeclaration = factory.createPropertySignature(/*modifiers* / undefined, unescapeLeadingUnderscores(jsxChildrenPropertyName), /*questionToken* / undefined, /*type* / undefined); */
				setParent( /* TODO(PropertyAccessExpression): childrenPropSymbol.valueDeclaration */ TODO, attributes)
				/* TODO(ExpressionStatement): childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol; */
				childPropMap := createSymbolTable()
				/* TODO(PropertyAccessExpression): childPropMap.set */ TODO(jsxChildrenPropertyName, childrenPropSymbol)
				/* TODO(ExpressionStatement): spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags, /*readonly* / false); */
			}
		}
		if hasSpreadAnyType {
			return anyType
		}
		if typeToIntersect && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): spread !== emptyJsxObjectType */ TODO {
			return getIntersectionType( /* TODO(ArrayLiteralExpression): [typeToIntersect, spread] */ TODO)
		}
		return typeToIntersect || /* TODO(ParenthesizedExpression): (spread === emptyJsxObjectType ? createJsxAttributesType() : spread) */ TODO
		createJsxAttributesType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			/* TODO(ExpressionStatement): objectFlags |= ObjectFlags.FreshLiteral; */
			result := createAnonymousType( /* TODO(PropertyAccessExpression): attributes.symbol */ TODO, attributesTable, emptyArray, emptyArray, emptyArray)
			/* TODO(ExpressionStatement): result.objectFlags |= objectFlags | ObjectFlags.ObjectLiteral | ObjectFlags.ContainsObjectOrArrayLiteral; */
			return result
		}
	}
	checkJsxChildren := func(node /* TODO(UnionType): JsxElement | JsxFragment */ any, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		var childrenTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, child := range /* TODO(PropertyAccessExpression): node.children */ TODO {
			if /* TODO(PropertyAccessExpression): child.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JsxText */ TODO {
				if ! /* TODO(PropertyAccessExpression): child.containsOnlyTriviaWhiteSpaces */ TODO {
					/* TODO(PropertyAccessExpression): childrenTypes.push */ TODO(stringType)
				}
			} else if /* TODO(PropertyAccessExpression): child.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JsxExpression */ TODO && ! /* TODO(PropertyAccessExpression): child.expression */ TODO {
				/* TODO(ContinueStatement): continue; */
			} else {
				/* TODO(PropertyAccessExpression): childrenTypes.push */ TODO(checkExpressionForMutableLocation(child, checkMode))
			}
		}
		return childrenTypes
	}
	checkSpreadPropOverrides := func(type_ Type, props SymbolTable, spread /* TODO(UnionType): SpreadAssignment | JsxSpreadAttribute */ any) {
		for _, right := range getPropertiesOfType(type_) {
			if ! /* TODO(ParenthesizedExpression): (right.flags & SymbolFlags.Optional) */ TODO {
				left := /* TODO(PropertyAccessExpression): props.get */ TODO( /* TODO(PropertyAccessExpression): right.escapedName */ TODO)
				if left {
					diagnostic := error( /* TODO(PropertyAccessExpression): left.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten */, TODO, unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): left.escapedName */ TODO))
					addRelatedInfo(diagnostic, createDiagnosticForNode(spread /* TODO(PropertyAccessExpression): Diagnostics.This_spread_always_overwrites_this_property */, TODO))
				}
			}
		}
	}
	checkJsxAttributes := func(node JsxAttributes, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return createJsxAttributesTypeFromAttributesProperty( /* TODO(PropertyAccessExpression): node.parent */ TODO, checkMode)
	}
	getJsxType := func(name __String, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		namespace := getJsxNamespaceAt(location)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, name /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
		return /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */ TODO
	}
	getIntrinsicTagSymbol := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO {
			intrinsicElementsType := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO, node)
			if !isErrorType(intrinsicElementsType) {
				if !isIdentifier( /* TODO(PropertyAccessExpression): node.tagName */ TODO) && !isJsxNamespacedName( /* TODO(PropertyAccessExpression): node.tagName */ TODO) {
					/* TODO(CallExpression): Debug.fail() */
				}
				propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				intrinsicProp := getPropertyOfType(intrinsicElementsType, propName)
				if intrinsicProp {
					/* TODO(ExpressionStatement): links.jsxFlags |= JsxFlags.IntrinsicNamedElement; */
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicProp */ TODO
				}
				indexSymbol := getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)))
				if indexSymbol {
					/* TODO(ExpressionStatement): links.jsxFlags |= JsxFlags.IntrinsicIndexedElement; */
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = indexSymbol */ TODO
				}
				if getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
					/* TODO(ExpressionStatement): links.jsxFlags |= JsxFlags.IntrinsicIndexedElement; */
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicElementsType.symbol */ TODO
				}
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO, intrinsicTagNameToString( /* TODO(PropertyAccessExpression): node.tagName */ TODO) /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "JSX." + JsxNames.IntrinsicElements */, TODO)
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
			} else {
				if noImplicitAny {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists */, TODO, unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO))
				}
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
	}
	getJsxNamespaceContainerForImplicitImport := func(location Node) *Symbol {
		file := location && getSourceFileOfNode(location)
		links := file && getNodeLinks(file)
		if links && /* TODO(PropertyAccessExpression): links.jsxImplicitImportContainer */ TODO == /* TODO(FalseKeyword): false */ TODO {
			return nil
		}
		if links && /* TODO(PropertyAccessExpression): links.jsxImplicitImportContainer */ TODO {
			return /* TODO(PropertyAccessExpression): links.jsxImplicitImportContainer */ TODO
		}
		runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions)
		if !runtimeImportSpecifier {
			return nil
		}
		isClassic := getEmitModuleResolutionKind(compilerOptions) == /* TODO(PropertyAccessExpression): ModuleResolutionKind.Classic */ TODO
		errorMessage := /* TODO(ConditionalExpression): isClassic             ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		specifier := getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
		mod := resolveExternalModule(specifier || /* TODO(NonNullExpression): location! */ TODO, runtimeImportSpecifier, errorMessage, location)
		result := /* TODO(ConditionalExpression): mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined */ TODO
		if links {
			/* TODO(ExpressionStatement): links.jsxImplicitImportContainer = result || false; */
		}
		return result
	}
	getJsxNamespaceAt := func(location Node) Symbol {
		links := location && getNodeLinks(location)
		if links && /* TODO(PropertyAccessExpression): links.jsxNamespace */ TODO {
			return /* TODO(PropertyAccessExpression): links.jsxNamespace */ TODO
		}
		if !links || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): links.jsxNamespace !== false */ TODO {
			resolvedNamespace := getJsxNamespaceContainerForImplicitImport(location)
			if !resolvedNamespace || resolvedNamespace == unknownSymbol {
				namespaceName := getJsxNamespace(location)
				/* TODO(ExpressionStatement): resolvedNamespace = resolveName(location, namespaceName, SymbolFlags.Namespace, /*nameNotFoundMessage* / undefined, /*isUse* / false); */
			}
			if resolvedNamespace {
				candidate := resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)) /* TODO(PropertyAccessExpression): JsxNames.JSX */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */, TODO))
				if candidate && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): candidate !== unknownSymbol */ TODO {
					if links {
						/* TODO(ExpressionStatement): links.jsxNamespace = candidate; */
					}
					return candidate
				}
			}
			if links {
				/* TODO(ExpressionStatement): links.jsxNamespace = false; */
			}
		}
		s := resolveSymbol(getGlobalSymbol( /* TODO(PropertyAccessExpression): JsxNames.JSX */ TODO /* TODO(PropertyAccessExpression): SymbolFlags.Namespace */, TODO, nil))
		if s == unknownSymbol {
			return /* TODO(NonNullExpression): undefined! */ TODO
		}
		return /* TODO(NonNullExpression): s! */ TODO
	}
	getNameFromJsxElementAttributesContainer := func(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
		jsxElementAttribPropInterfaceSym := jsxNamespace && getSymbol( /* TODO(NonNullExpression): jsxNamespace.exports! */ TODO, nameOfAttribPropContainer /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
		jsxElementAttribPropInterfaceType := jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym)
		propertiesOfJsxElementAttribPropInterface := jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType)
		if propertiesOfJsxElementAttribPropInterface {
			if /* TODO(PropertyAccessExpression): propertiesOfJsxElementAttribPropInterface.length */ TODO == 0 {
				return "" /* as */ /* TODO(TypeReference): __String */
			} else if /* TODO(PropertyAccessExpression): propertiesOfJsxElementAttribPropInterface.length */ TODO == 1 {
				return /* TODO(PropertyAccessExpression): propertiesOfJsxElementAttribPropInterface[0].escapedName */ TODO
			} else if /* TODO(PropertyAccessExpression): propertiesOfJsxElementAttribPropInterface.length */ TODO > 1 && /* TODO(PropertyAccessExpression): jsxElementAttribPropInterfaceSym.declarations */ TODO {
				error( /* TODO(ElementAccessExpression): jsxElementAttribPropInterfaceSym.declarations[0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property */, TODO, unescapeLeadingUnderscores(nameOfAttribPropContainer))
			}
		}
		return nil
	}
	getJsxLibraryManagedAttributes := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		return jsxNamespace && getSymbol( /* TODO(NonNullExpression): jsxNamespace.exports! */ TODO /* TODO(PropertyAccessExpression): JsxNames.LibraryManagedAttributes */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
	}
	getJsxElementTypeSymbol := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		return jsxNamespace && getSymbol( /* TODO(NonNullExpression): jsxNamespace.exports! */ TODO /* TODO(PropertyAccessExpression): JsxNames.ElementType */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
	}
	getJsxElementPropertiesName := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return getNameFromJsxElementAttributesContainer( /* TODO(PropertyAccessExpression): JsxNames.ElementAttributesPropertyNameContainer */ TODO, jsxNamespace)
	}
	getJsxElementChildrenPropertyName := func(jsxNamespace Symbol) *__String {
		return getNameFromJsxElementAttributesContainer( /* TODO(PropertyAccessExpression): JsxNames.ElementChildrenAttributeNameContainer */ TODO, jsxNamespace)
	}
	getUninstantiatedJsxSignaturesOfType := func(elementType Type, caller JsxOpeningLikeElement) []Signature {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementType.flags & TypeFlags.String */ TODO {
			return /* TODO(ArrayLiteralExpression): [anySignature] */ TODO
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): elementType.flags & TypeFlags.StringLiteral */ TODO {
			intrinsicType := getIntrinsicAttributesTypeFromStringLiteralType(elementType /* as */ /* TODO(TypeReference): StringLiteralType */, caller)
			if !intrinsicType {
				error(caller /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO /* TODO(PropertyAccessExpression): (elementType as StringLiteralType).value */, TODO /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "JSX." + JsxNames.IntrinsicElements */, TODO)
				return emptyArray
			} else {
				fakeSignature := createSignatureForJSXIntrinsic(caller, intrinsicType)
				return /* TODO(ArrayLiteralExpression): [fakeSignature] */ TODO
			}
		}
		apparentElemType := getApparentType(elementType)
		signatures := getSignaturesOfType(apparentElemType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		if /* TODO(PropertyAccessExpression): signatures.length */ TODO == 0 {
			/* TODO(ExpressionStatement): signatures = getSignaturesOfType(apparentElemType, SignatureKind.Call); */
		}
		if /* TODO(PropertyAccessExpression): signatures.length */ TODO == 0 && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): apparentElemType.flags & TypeFlags.Union */ TODO {
			/* TODO(ExpressionStatement): signatures = getUnionSignatures(map((apparentElemType as UnionType).types, t => getUninstantiatedJsxSignaturesOfType(t, caller))); */
		}
		return signatures
	}
	getIntrinsicAttributesTypeFromStringLiteralType := func(type_ StringLiteralType, location Node) *Type {
		intrinsicElementsType := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO, location)
		if !isErrorType(intrinsicElementsType) {
			stringLiteralTypeName := /* TODO(PropertyAccessExpression): type.value */ TODO
			intrinsicProp := getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
			if intrinsicProp {
				return getTypeOfSymbol(intrinsicProp)
			}
			indexSignatureType := getIndexTypeOfType(intrinsicElementsType, stringType)
			if indexSignatureType {
				return indexSignatureType
			}
			return nil
		}
		return anyType
	}
	checkJsxReturnAssignableToAppropriateBound := func(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
		if refKind == /* TODO(PropertyAccessExpression): JsxReferenceKind.Function */ TODO {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			if sfcReturnConstraint {
				checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation /* TODO(PropertyAccessExpression): openingLikeElement.tagName */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element */, TODO, generateInitialErrorChain)
			}
		} else if refKind == /* TODO(PropertyAccessExpression): JsxReferenceKind.Component */ TODO {
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if classConstraint {
				checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation /* TODO(PropertyAccessExpression): openingLikeElement.tagName */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element */, TODO, generateInitialErrorChain)
			}
		} else {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if !sfcReturnConstraint || !classConstraint {
				return
			}
			combined := getUnionType( /* TODO(ArrayLiteralExpression): [sfcReturnConstraint, classConstraint] */ TODO)
			checkTypeRelatedTo(elemInstanceType, combined, assignableRelation /* TODO(PropertyAccessExpression): openingLikeElement.tagName */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element */, TODO, generateInitialErrorChain)
		}
		generateInitialErrorChain := func() DiagnosticMessageChain {
			componentName := getTextOfNode( /* TODO(PropertyAccessExpression): openingLikeElement.tagName */ TODO)
			return chainDiagnosticMessages(nil /* TODO(PropertyAccessExpression): Diagnostics._0_cannot_be_used_as_a_JSX_component */, TODO, componentName)
		}
	}
	getIntrinsicAttributesTypeFromJsxOpeningLikeElement := func(node JsxOpeningLikeElement) Type {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isJsxIntrinsicTagName( /* TODO(PropertyAccessExpression): node.tagName */ TODO))
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedJsxElementAttributesType */ TODO {
			symbol := getIntrinsicTagSymbol(node)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.jsxFlags & JsxFlags.IntrinsicNamedElement */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType */ TODO
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.jsxFlags & JsxFlags.IntrinsicIndexedElement */ TODO {
				propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName)?.type || errorType */ TODO
			} else {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = errorType */ TODO
			}
		}
		return /* TODO(PropertyAccessExpression): links.resolvedJsxElementAttributesType */ TODO
	}
	getJsxElementClassTypeAt := func(location Node) *Type {
		type_ := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.ElementClass */ TODO, location)
		if isErrorType(type_) {
			/* TODO(Identifier): undefined */
		}
		return type_
	}
	getJsxElementTypeAt := func(location Node) Type {
		return getJsxType( /* TODO(PropertyAccessExpression): JsxNames.Element */ TODO, location)
	}
	getJsxStatelessElementTypeAt := func(location Node) *Type {
		jsxElementType := getJsxElementTypeAt(location)
		if jsxElementType {
			return getUnionType( /* TODO(ArrayLiteralExpression): [jsxElementType, nullType] */ TODO)
		}
	}
	getJsxElementTypeTypeAt := func(location Node) *Type {
		ns := getJsxNamespaceAt(location)
		if !ns {
			/* TODO(Identifier): undefined */
		}
		sym := getJsxElementTypeSymbol(ns)
		if !sym {
			/* TODO(Identifier): undefined */
		}
		type_ := instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
		if !type_ || isErrorType(type_) {
			/* TODO(Identifier): undefined */
		}
		return type_
	}
	instantiateAliasOrInterfaceWithDefaults := func(managedSym Symbol, inJs bool, typeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		declaredManagedType := getDeclaredTypeOfSymbol(managedSym)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): managedSym.flags & SymbolFlags.TypeAlias */ TODO {
			params := /* TODO(PropertyAccessExpression): getSymbolLinks(managedSym).typeParameters */ TODO
			if length(params) >= /* TODO(PropertyAccessExpression): typeArguments.length */ TODO {
				args := fillMissingTypeArguments(typeArguments, params /* TODO(PropertyAccessExpression): typeArguments.length */, TODO, inJs)
				return /* TODO(ConditionalExpression): length(args) === 0 ? declaredManagedType : getTypeAliasInstantiation(managedSym, args) */ TODO
			}
		}
		if length( /* TODO(PropertyAccessExpression): (declaredManagedType as GenericType).typeParameters */ TODO) >= /* TODO(PropertyAccessExpression): typeArguments.length */ TODO {
			args := fillMissingTypeArguments(typeArguments /* TODO(PropertyAccessExpression): (declaredManagedType as GenericType).typeParameters */, TODO /* TODO(PropertyAccessExpression): typeArguments.length */, TODO, inJs)
			return createTypeReference(declaredManagedType /* as */ /* TODO(TypeReference): GenericType */, args)
		}
		return nil
	}
	getJsxIntrinsicTagNamesAt := func(location Node) []Symbol {
		intrinsics := getJsxType( /* TODO(PropertyAccessExpression): JsxNames.IntrinsicElements */ TODO, location)
		return /* TODO(ConditionalExpression): intrinsics ? getPropertiesOfType(intrinsics) : emptyArray */ TODO
	}
	checkJsxPreconditions := func(errorNode Node) {
		if /* TODO(ParenthesizedExpression): (compilerOptions.jsx || JsxEmit.None) */ TODO == /* TODO(PropertyAccessExpression): JsxEmit.None */ TODO {
			error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided */, TODO)
		}
		if getJsxElementTypeAt(errorNode) == nil {
			if noImplicitAny {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist */, TODO)
			}
		}
	}
	checkJsxOpeningLikeElementOrOpeningFragment := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)
		if isNodeOpeningLikeElement {
			checkGrammarJsxElement(node)
		}
		checkJsxPreconditions(node)
		markJsxAliasReferenced(node)
		if isNodeOpeningLikeElement {
			jsxOpeningLikeNode := node
			sig := getResolvedSignature(jsxOpeningLikeNode)
			checkDeprecatedSignature(sig, node)
			elementTypeConstraint := getJsxElementTypeTypeAt(jsxOpeningLikeNode)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): elementTypeConstraint !== undefined */ TODO {
				tagName := /* TODO(PropertyAccessExpression): jsxOpeningLikeNode.tagName */ TODO
				tagType := /* TODO(ConditionalExpression): isJsxIntrinsicTagName(tagName)                     ? getStringLiteralType(intrinsicTagNameToString(tagName))                     : checkExpression(tagName) */ TODO
				checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName /* TODO(PropertyAccessExpression): Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type */, TODO /* TODO(ArrowFunction): () => {                     const componentName = getTextOfNode(tagName);                     return chainDiagnosticMessages(/*details* / undefined, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName);                 } */, TODO)
			} else {
				checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode)
			}
		}
	}
	isKnownProperty := func(targetType Type, name __String, isComparingJsxAttributes bool) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetType.flags & TypeFlags.Object */ TODO {
			if getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(targetType, name) || isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) || isComparingJsxAttributes && isHyphenatedJsxName(name) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetType.flags & TypeFlags.Substitution */ TODO {
			return isKnownProperty( /* TODO(PropertyAccessExpression): (targetType as SubstitutionType).baseType */ TODO, name, isComparingJsxAttributes)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetType.flags & TypeFlags.UnionOrIntersection */ TODO && isExcessPropertyCheckTarget(targetType) {
			for _, t := range /* TODO(PropertyAccessExpression): (targetType as UnionOrIntersectionType).types */ TODO {
				if isKnownProperty(t, name, isComparingJsxAttributes) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isExcessPropertyCheckTarget := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object && !(getObjectFlags(type) & ObjectFlags.ObjectLiteralPatternWithComputedProperties) ||             type.flags & TypeFlags.NonPrimitive ||             type.flags & TypeFlags.Substitution && isExcessPropertyCheckTarget((type as SubstitutionType).baseType) ||             type.flags & TypeFlags.Union && some((type as UnionType).types, isExcessPropertyCheckTarget) ||             type.flags & TypeFlags.Intersection && every((type as IntersectionType).types, isExcessPropertyCheckTarget)) */ TODO
	}
	checkJsxExpression := func(node JsxExpression, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkGrammarJsxExpression(node)
		if /* TODO(PropertyAccessExpression): node.expression */ TODO {
			type_ := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO, checkMode)
			if /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== anyType */ TODO && !isArrayType(type_) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.JSX_spread_child_must_be_an_array_type */, TODO)
			}
			return type_
		} else {
			return errorType
		}
	}
	getDeclarationNodeFlagsFromSymbol := func(s Symbol) NodeFlags {
		return /* TODO(ConditionalExpression): s.valueDeclaration ? getCombinedNodeFlagsCached(s.valueDeclaration) : 0 */ TODO
	}
	isPrototypeProperty := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Method */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.SyntheticMethod */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if isInJSFile( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) {
			parent := /* TODO(PropertyAccessExpression): symbol.valueDeclaration!.parent */ TODO
			return parent && isBinaryExpression(parent) && getAssignmentDeclarationKind(parent) == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.PrototypeProperty */ TODO
		}
	}
	checkPropertyAccessibility := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) bool {
		errorNode := /* TODO(ConditionalExpression): !reportError ? undefined :             node.kind === SyntaxKind.QualifiedName ? node.right :             node.kind === SyntaxKind.ImportType ? node :             node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name */ TODO
		return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
	}
	checkPropertyAccessibilityAtLocation := func(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
		flags := getDeclarationModifierFlagsFromSymbol(prop, writing)
		if isSuper {
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO {
				if symbolHasNonMethodDeclaration(prop) {
					if errorNode {
						error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword */, TODO)
					}
					return /* TODO(FalseKeyword): false */ TODO
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Abstract */ TODO {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression */, TODO, symbolToString(prop), typeToString( /* TODO(NonNullExpression): getDeclaringClass(prop)! */ TODO))
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
			if ! /* TODO(ParenthesizedExpression): (flags & ModifierFlags.Static) */ TODO && /* TODO(PropertyAccessExpression): prop.declarations?.some */ TODO(isClassInstanceProperty) {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super */, TODO, symbolToString(prop))
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		if /* TODO(ParenthesizedExpression): (flags & ModifierFlags.Abstract) */ TODO && symbolHasNonMethodDeclaration(prop) && /* TODO(ParenthesizedExpression): (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) */ TODO {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol( /* TODO(NonNullExpression): getParentOfSymbol(prop)! */ TODO)
			if declaringClassDeclaration && isNodeUsedDuringClassInitialization(location) {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor */, TODO, symbolToString(prop), getTextOfIdentifierOrLiteral( /* TODO(NonNullExpression): declaringClassDeclaration.name! */ TODO))
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		if ! /* TODO(ParenthesizedExpression): (flags & ModifierFlags.NonPublicAccessibilityModifier) */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Private */ TODO {
			declaringClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!)! */ TODO
			if !isNodeWithinClass(location, declaringClassDeclaration) {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_private_and_only_accessible_within_class_1 */, TODO, symbolToString(prop), typeToString( /* TODO(NonNullExpression): getDeclaringClass(prop)! */ TODO))
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		if isSuper {
			return /* TODO(TrueKeyword): true */ TODO
		}
		enclosingClass := forEachEnclosingClass(location /* TODO(ArrowFunction): enclosingDeclaration => {             const enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration)) as InterfaceType;             return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);         } */, TODO)
		if !enclosingClass {
			/* TODO(ExpressionStatement): enclosingClass = getEnclosingClassFromThisParameter(location); */
			/* TODO(ExpressionStatement): enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing); */
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Static */ TODO || !enclosingClass {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses */, TODO, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType))
				}
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Static */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): containingType.flags & TypeFlags.TypeParameter */ TODO {
			/* TODO(ExpressionStatement): containingType = (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)!; */
		}
		if !containingType || !hasBaseType(containingType, enclosingClass) {
			if errorNode {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2 */, TODO, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType))
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getEnclosingClassFromThisParameter := func(node Node) *InterfaceType {
		thisParameter := getThisParameterFromNodeContext(node)
		thisType := /* TODO(PropertyAccessExpression): thisParameter?.type */ TODO && getTypeFromTypeNode( /* TODO(PropertyAccessExpression): thisParameter.type */ TODO)
		if thisType {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): thisType.flags & TypeFlags.TypeParameter */ TODO {
				/* TODO(ExpressionStatement): thisType = getConstraintOfTypeParameter(thisType as TypeParameter); */
			}
		} else {
			thisContainer := getThisContainer(node /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
			if isFunctionLike(thisContainer) {
				/* TODO(ExpressionStatement): thisType = getContextualThisParameterType(thisContainer); */
			}
		}
		if thisType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(thisType) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) */ TODO {
			return getTargetType(thisType) /* as */ /* TODO(TypeReference): InterfaceType */
		}
		return nil
	}
	getThisParameterFromNodeContext := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
		thisContainer := getThisContainer(node /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		return /* TODO(ConditionalExpression): thisContainer && isFunctionLike(thisContainer) ? getThisParameter(thisContainer) : undefined */ TODO
	}
	symbolHasNonMethodDeclaration := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		return !!forEachProperty(symbol /* TODO(ArrowFunction): prop => !(prop.flags & SymbolFlags.Method) */, TODO)
	}
	checkNonNullExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkNonNullType(checkExpression(node), node)
	}
	isNullableType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return hasTypeFacts(type_ /* TODO(PropertyAccessExpression): TypeFacts.IsUndefinedOrNull */, TODO)
	}
	getNonNullableTypeIfNeeded := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNullableType(type) ? getNonNullableType(type) : type */ TODO
	}
	reportObjectPossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		nodeText := /* TODO(ConditionalExpression): isEntityNameExpression(node) ? entityNameToString(node) : undefined */ TODO
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NullKeyword */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.The_value_0_cannot_be_used_here */, TODO, "null")
			return
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nodeText !== undefined */ TODO && /* TODO(PropertyAccessExpression): nodeText.length */ TODO < 100 {
			if isIdentifier(node) && nodeText == "undefined" {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.The_value_0_cannot_be_used_here */, TODO, "undefined")
				return
			}
			error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics._0_is_possibly_null_or_undefined :                     Diagnostics._0_is_possibly_undefined :                     Diagnostics._0_is_possibly_null */, TODO, nodeText)
		} else {
			error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics.Object_is_possibly_null_or_undefined :                     Diagnostics.Object_is_possibly_undefined :                     Diagnostics.Object_is_possibly_null */, TODO)
		}
	}
	reportCannotInvokePossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null */, TODO)
	}
	checkNonNullTypeWithReporter := func(type_ Type, node Node, reportError func(node Node, facts TypeFacts)) Type {
		if strictNullChecks && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Unknown */ TODO {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if /* TODO(PropertyAccessExpression): nodeText.length */ TODO < 100 {
					error(node /* TODO(PropertyAccessExpression): Diagnostics._0_is_of_type_unknown */, TODO, nodeText)
					return errorType
				}
			}
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Object_is_of_type_unknown */, TODO)
			return errorType
		}
		facts := getTypeFacts(type_ /* TODO(PropertyAccessExpression): TypeFacts.IsUndefinedOrNull */, TODO)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): facts & TypeFacts.IsUndefinedOrNull */ TODO {
			reportError(node, facts)
			t := getNonNullableType(type_)
			return /* TODO(ConditionalExpression): t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t */ TODO
		}
		return type_
	}
	checkNonNullType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkNonNullTypeWithReporter(type_, node, reportObjectPossiblyNullOrUndefinedError)
	}
	checkNonNullNonVoidType := func(type_ Type, node Node) Type {
		nonNullType := checkNonNullType(type_, node)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nonNullType.flags & TypeFlags.Void */ TODO {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if isIdentifier(node) && nodeText == "undefined" {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.The_value_0_cannot_be_used_here */, TODO, nodeText)
					return nonNullType
				}
				if /* TODO(PropertyAccessExpression): nodeText.length */ TODO < 100 {
					error(node /* TODO(PropertyAccessExpression): Diagnostics._0_is_possibly_undefined */, TODO, nodeText)
					return nonNullType
				}
			}
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Object_is_possibly_undefined */, TODO)
		}
		return nonNullType
	}
	checkPropertyAccessExpression := func(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(node as PropertyAccessChain, checkMode) :             checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly) */ TODO
	}
	checkPropertyAccessChain := func(node PropertyAccessChain, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		nonOptionalType := getOptionalExpressionType(leftType /* TODO(PropertyAccessExpression): node.expression */, TODO)
		return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node /* TODO(PropertyAccessExpression): node.expression */, TODO, checkNonNullType(nonOptionalType /* TODO(PropertyAccessExpression): node.expression */, TODO) /* TODO(PropertyAccessExpression): node.name */, TODO, checkMode), node /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== leftType */, TODO)
	}
	checkQualifiedName := func(node QualifiedName, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := /* TODO(ConditionalExpression): isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left) */ TODO
		return checkPropertyAccessExpressionOrQualifiedName(node /* TODO(PropertyAccessExpression): node.left */, TODO, leftType /* TODO(PropertyAccessExpression): node.right */, TODO, checkMode)
	}
	isMethodAccessForCall := func(node Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.ParenthesizedExpression) {             node = node.parent;         } */
		return isCallOrNewExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(PropertyAccessExpression): node.parent.expression */ TODO == node
	}
	lookupSymbolForPrivateIdentifierDeclaration := func(propName __String, location Node) *Symbol {
		/* TODO(ForStatement): for (let containingClass = getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass)) {             const { symbol } = containingClass;             const name = getSymbolNameForPrivateIdentifier(symbol, propName);             const prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));             if (prop) {                 return prop;             }         } */
	}
	checkGrammarPrivateIdentifierExpression := func(privId PrivateIdentifier) bool {
		if !getContainingClass(privId) {
			return grammarErrorOnNode(privId /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies */, TODO)
		}
		if !isForInStatement( /* TODO(PropertyAccessExpression): privId.parent */ TODO) {
			if !isExpressionNode(privId) {
				return grammarErrorOnNode(privId /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression */, TODO)
			}
			isInOperation := isBinaryExpression( /* TODO(PropertyAccessExpression): privId.parent */ TODO) && /* TODO(PropertyAccessExpression): privId.parent.operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InKeyword */ TODO
			if !getSymbolForPrivateIdentifierExpression(privId) && !isInOperation {
				return grammarErrorOnNode(privId /* TODO(PropertyAccessExpression): Diagnostics.Cannot_find_name_0 */, TODO, idText(privId))
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkPrivateIdentifierExpression := func(privId PrivateIdentifier) Type {
		checkGrammarPrivateIdentifierExpression(privId)
		symbol := getSymbolForPrivateIdentifierExpression(privId)
		if symbol {
			markPropertyAsReferenced(symbol, nil /* TODO(FalseKeyword): false */, TODO)
		}
		return anyType
	}
	getSymbolForPrivateIdentifierExpression := func(privId PrivateIdentifier) *Symbol {
		if !isExpressionNode(privId) {
			return nil
		}
		links := getNodeLinks(privId)
		if /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO == nil {
			/* TODO(ExpressionStatement): links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId); */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
	}
	getPrivateIdentifierPropertyOfType := func(leftType Type, lexicallyScopedIdentifier Symbol) *Symbol {
		return getPropertyOfType(leftType /* TODO(PropertyAccessExpression): lexicallyScopedIdentifier.escapedName */, TODO)
	}
	checkPrivateIdentifierPropertyAccess := func(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier *Symbol) bool {
		var propertyOnType *Symbol
		properties := getPropertiesOfType(leftType)
		if properties {
			forEach(properties /* TODO(ArrowFunction): (symbol: Symbol) => {                 const decl = symbol.valueDeclaration;                 if (decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText === right.escapedText) {                     propertyOnType = symbol;                     return true;                 }             } */, TODO)
		}
		diagName := diagnosticName(right)
		if propertyOnType {
			typeValueDecl := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO( /* TODO(PropertyAccessExpression): propertyOnType.valueDeclaration */ TODO)
			typeClass := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(getContainingClass(typeValueDecl))
			if /* TODO(PropertyAccessExpression): lexicallyScopedIdentifier?.valueDeclaration */ TODO {
				lexicalValueDecl := /* TODO(PropertyAccessExpression): lexicallyScopedIdentifier.valueDeclaration */ TODO
				lexicalClass := getContainingClass(lexicalValueDecl)
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!!lexicalClass)
				if findAncestor(lexicalClass /* TODO(ArrowFunction): n => typeClass === n */, TODO) {
					diagnostic := error(right /* TODO(PropertyAccessExpression): Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling */, TODO, diagName, typeToString(leftType))
					addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl /* TODO(PropertyAccessExpression): Diagnostics.The_shadowing_declaration_of_0_is_defined_here */, TODO, diagName), createDiagnosticForNode(typeValueDecl /* TODO(PropertyAccessExpression): Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here */, TODO, diagName))
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
			error(right /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier */, TODO, diagName, diagnosticName( /* TODO(PropertyAccessExpression): typeClass.name */ TODO || anon))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isThisPropertyAccessInConstructor := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		return /* TODO(ParenthesizedExpression): (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop)) */ TODO && getThisContainer(node /* TODO(TrueKeyword): true */, TODO /* TODO(FalseKeyword): false */, TODO) == getDeclaringConstructor(prop)
	}
	checkPropertyAccessExpressionOrQualifiedName := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, left /* TODO(UnionType): Expression | QualifiedName */ any, leftType Type, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		parentSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(left).resolvedSymbol */ TODO
		assignmentKind := getAssignmentTargetKind(node)
		apparentType := getApparentType( /* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType */ TODO)
		isAnyLike := isTypeAny(apparentType) || apparentType == silentNeverType
		var prop *Symbol
		if isPrivateIdentifier(right) {
			if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks */ TODO || languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO || !useDefineForClassFields {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.None */ TODO {
					checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ClassPrivateFieldSet */, TODO)
				}
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.Definite */ TODO {
					checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ClassPrivateFieldGet */, TODO)
				}
			}
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration( /* TODO(PropertyAccessExpression): right.escapedText */ TODO, right)
			if assignmentKind && lexicallyScopedSymbol && /* TODO(PropertyAccessExpression): lexicallyScopedSymbol.valueDeclaration */ TODO && isMethodDeclaration( /* TODO(PropertyAccessExpression): lexicallyScopedSymbol.valueDeclaration */ TODO) {
				grammarErrorOnNode(right /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable */, TODO, idText(right))
			}
			if isAnyLike {
				if lexicallyScopedSymbol {
					return /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
				}
				if getContainingClassExcludingClassDecorators(right) == nil {
					grammarErrorOnNode(right /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies */, TODO)
					return anyType
				}
			}
			/* TODO(ExpressionStatement): prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol); */
			if prop == nil {
				if checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
					return errorType
				}
				containingClass := getContainingClassExcludingClassDecorators(right)
				if containingClass && isPlainJsFile(getSourceFileOfNode(containingClass) /* TODO(PropertyAccessExpression): compilerOptions.checkJs */, TODO) {
					grammarErrorOnNode(right /* TODO(PropertyAccessExpression): Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class */, TODO, idText(right))
				}
			} else {
				isSetonlyAccessor := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): prop.flags & SymbolFlags.SetAccessor */ TODO && ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.GetAccessor) */ TODO
				if isSetonlyAccessor && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.Definite */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Private_accessor_was_defined_without_a_getter */, TODO)
				}
			}
		} else {
			if isAnyLike {
				if isIdentifier(left) && parentSymbol {
					markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.Property */, TODO, nil, leftType)
				}
				return /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
			}
			/* TODO(ExpressionStatement): prop = getPropertyOfType(apparentType, right.escapedText, /*skipObjectFunctionPropertyAugment* / isConstEnumObjectType(apparentType), /*includeTypeOnlyMembers* / node.kind === SyntaxKind.QualifiedName); */
		}
		markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.Property */, TODO, prop, leftType)
		var propType Type
		if !prop {
			indexInfo := /* TODO(ConditionalExpression): !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ?                 getApplicableIndexInfoForName(apparentType, right.escapedText) : undefined */ TODO
			if ! /* TODO(ParenthesizedExpression): (indexInfo && indexInfo.type) */ TODO {
				isUncheckedJS := isUncheckedJSSuggestion(node /* TODO(PropertyAccessExpression): leftType.symbol */, TODO /* TODO(TrueKeyword): true */, TODO)
				if !isUncheckedJS && isJSLiteralType(leftType) {
					return anyType
				}
				if /* TODO(PropertyAccessExpression): leftType.symbol */ TODO == globalThisSymbol {
					if /* TODO(PropertyAccessExpression): globalThisSymbol.exports!.has */ TODO( /* TODO(PropertyAccessExpression): right.escapedText */ TODO) && /* TODO(ParenthesizedExpression): (globalThisSymbol.exports!.get(right.escapedText)!.flags & SymbolFlags.BlockScoped) */ TODO {
						error(right /* TODO(PropertyAccessExpression): Diagnostics.Property_0_does_not_exist_on_type_1 */, TODO, unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): right.escapedText */ TODO), typeToString(leftType))
					} else if noImplicitAny {
						error(right /* TODO(PropertyAccessExpression): Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature */, TODO, typeToString(leftType))
					}
					return anyType
				}
				if /* TODO(PropertyAccessExpression): right.escapedText */ TODO && !checkAndReportErrorForExtendingInterface(node) {
					reportNonexistentProperty(right /* TODO(ConditionalExpression): isThisTypeParameter(leftType) ? apparentType : leftType */, TODO, isUncheckedJS)
				}
				return errorType
			}
			if /* TODO(PropertyAccessExpression): indexInfo.isReadonly */ TODO && /* TODO(ParenthesizedExpression): (isAssignmentTarget(node) || isDeleteTarget(node)) */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Index_signature_in_type_0_only_permits_reading */, TODO, typeToString(apparentType))
			}
			/* TODO(ExpressionStatement): propType = indexInfo.type; */
			if /* TODO(PropertyAccessExpression): compilerOptions.noUncheckedIndexedAccess */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getAssignmentTargetKind(node) !== AssignmentKind.Definite */ TODO {
				/* TODO(ExpressionStatement): propType = getUnionType([propType, missingType]); */
			}
			if /* TODO(PropertyAccessExpression): compilerOptions.noPropertyAccessFromIndexSignature */ TODO && isPropertyAccessExpression(node) {
				error(right /* TODO(PropertyAccessExpression): Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0 */, TODO, unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): right.escapedText */ TODO))
			}
			if /* TODO(PropertyAccessExpression): indexInfo.declaration */ TODO && isDeprecatedDeclaration( /* TODO(PropertyAccessExpression): indexInfo.declaration */ TODO) {
				addDeprecatedSuggestion(right /* TODO(ArrayLiteralExpression): [indexInfo.declaration] */, TODO /* TODO(PropertyAccessExpression): right.escapedText */, TODO /* as */ /* TODO(StringKeyword): string */)
			}
		} else {
			targetPropSymbol := resolveAliasWithDeprecationCheck(prop, right)
			if isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && /* TODO(PropertyAccessExpression): targetPropSymbol.declarations */ TODO {
				addDeprecatedSuggestion(right /* TODO(PropertyAccessExpression): targetPropSymbol.declarations */, TODO /* TODO(PropertyAccessExpression): right.escapedText */, TODO /* as */ /* TODO(StringKeyword): string */)
			}
			checkPropertyNotUsedBeforeDeclaration(prop, node, right)
			markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol))
			/* TODO(ExpressionStatement): getNodeLinks(node).resolvedSymbol = prop; */
			checkPropertyAccessibility(node /* TODO(PropertyAccessExpression): left.kind */, TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO, isWriteAccess(node), apparentType, prop)
			if isAssignmentToReadonlyEntity(node /* as */ /* TODO(TypeReference): Expression */, prop, assignmentKind) {
				error(right /* TODO(PropertyAccessExpression): Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property */, TODO, idText(right))
				return errorType
			}
			/* TODO(ExpressionStatement): propType = isThisPropertyAccessInConstructor(node, prop) ? autoType : writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop); */
		}
		return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
	}
	isUncheckedJSSuggestion := func(node Node, suggestion *Symbol, excludeClasses bool) bool {
		file := getSourceFileOfNode(node)
		if file {
			if /* TODO(PropertyAccessExpression): compilerOptions.checkJs */ TODO == nil && /* TODO(PropertyAccessExpression): file.checkJsDirective */ TODO == nil && /* TODO(ParenthesizedExpression): (file.scriptKind === ScriptKind.JS || file.scriptKind === ScriptKind.JSX) */ TODO {
				declarationFile := forEach( /* TODO(PropertyAccessExpression): suggestion?.declarations */ TODO, getSourceFileOfNode)
				suggestionHasNoExtendsOrDecorators := ! /* TODO(PropertyAccessExpression): suggestion?.valueDeclaration */ TODO || !isClassLike( /* TODO(PropertyAccessExpression): suggestion.valueDeclaration */ TODO) || /* TODO(PropertyAccessExpression): suggestion.valueDeclaration.heritageClauses?.length */ TODO || classOrConstructorParameterIsDecorated( /* TODO(FalseKeyword): false */ TODO /* TODO(PropertyAccessExpression): suggestion.valueDeclaration */, TODO)
				return ! /* TODO(ParenthesizedExpression): (file !== declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile)) */ TODO && ! /* TODO(ParenthesizedExpression): (excludeClasses && suggestion && suggestion.flags & SymbolFlags.Class && suggestionHasNoExtendsOrDecorators) */ TODO && ! /* TODO(ParenthesizedExpression): (!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind === SyntaxKind.ThisKeyword && suggestionHasNoExtendsOrDecorators) */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getFlowTypeOfAccessExpression := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop *Symbol, propType Type, errorNode Node, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind == /* TODO(PropertyAccessExpression): AssignmentKind.Definite */ TODO {
			return removeMissingType(propType, !! /* TODO(ParenthesizedExpression): (prop && prop.flags & SymbolFlags.Optional) */ TODO)
		}
		if prop && ! /* TODO(ParenthesizedExpression): (prop.flags & (SymbolFlags.Variable | SymbolFlags.Property | SymbolFlags.Accessor)) */ TODO && ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.Method && propType.flags & TypeFlags.Union) */ TODO && !isDuplicatedCommonJSExport( /* TODO(PropertyAccessExpression): prop.declarations */ TODO) {
			return propType
		}
		if propType == autoType {
			return getFlowTypeOfProperty(node, prop)
		}
		/* TODO(ExpressionStatement): propType = getNarrowableTypeForReference(propType, node, checkMode); */
		assumeUninitialized := /* TODO(FalseKeyword): false */ TODO
		if strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO {
			declaration := prop && /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO
			if declaration && isPropertyWithoutInitializer(declaration) {
				if !isStatic(declaration) {
					flowContainer := getControlFlowContainer(node)
					if /* TODO(PropertyAccessExpression): flowContainer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO && /* TODO(PropertyAccessExpression): flowContainer.parent */ TODO == /* TODO(PropertyAccessExpression): declaration.parent */ TODO && ! /* TODO(ParenthesizedExpression): (declaration.flags & NodeFlags.Ambient) */ TODO {
						/* TODO(ExpressionStatement): assumeUninitialized = true; */
					}
				}
			}
		} else if strictNullChecks && prop && /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && isPropertyAccessExpression( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) && getAssignmentDeclarationPropertyAccessKind( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) && getControlFlowContainer(node) == getControlFlowContainer( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) {
			/* TODO(ExpressionStatement): assumeUninitialized = true; */
		}
		flowType := getFlowTypeOfReference(node, propType /* TODO(ConditionalExpression): assumeUninitialized ? getOptionalType(propType) : propType */, TODO)
		if assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType) {
			error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_used_before_being_assigned */, TODO, symbolToString( /* TODO(NonNullExpression): prop! */ TODO))
			return propType
		}
		return /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
	}
	checkPropertyNotUsedBeforeDeclaration := func(prop Symbol, node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any) {
		TODO_IDENTIFIER := prop
		if !valueDeclaration || /* TODO(PropertyAccessExpression): getSourceFileOfNode(node).isDeclarationFile */ TODO {
			return
		}
		var diagnosticMessage TODO
		declarationName := idText(right)
		if isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(valueDeclaration) && ! /* TODO(ParenthesizedExpression): (isAccessExpression(node) && isAccessExpression(node.expression)) */ TODO && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && ! /* TODO(ParenthesizedExpression): (isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration) & ModifierFlags.Static) */ TODO && /* TODO(ParenthesizedExpression): (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop)) */ TODO {
			/* TODO(ExpressionStatement): diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName); */
		} else if /* TODO(PropertyAccessExpression): valueDeclaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.TypeReference */ TODO && ! /* TODO(ParenthesizedExpression): (valueDeclaration.flags & NodeFlags.Ambient) */ TODO && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) {
			/* TODO(ExpressionStatement): diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName); */
		}
		if diagnosticMessage {
			addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_here */, TODO, declarationName))
		}
	}
	isInPropertyInitializerOrClassStaticBlock := func(node Node) bool {
		return !!findAncestor(node /* TODO(ArrowFunction): node => {             switch (node.kind) {                 case SyntaxKind.PropertyDeclaration:                     return true;                 case SyntaxKind.PropertyAssignment:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.SpreadAssignment:                 case SyntaxKind.ComputedPropertyName:                 case SyntaxKind.TemplateSpan:                 case SyntaxKind.JsxExpression:                 case SyntaxKind.JsxAttribute:                 case SyntaxKind.JsxAttributes:                 case SyntaxKind.JsxSpreadAttribute:                 case SyntaxKind.JsxOpeningElement:                 case SyntaxKind.ExpressionWithTypeArguments:                 case SyntaxKind.HeritageClause:                     return false;                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.ExpressionStatement:                     return isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent) ? true : "quit";                 default:                     return isExpressionNode(node) ? false : "quit";             }         } */, TODO)
	}
	isPropertyDeclaredInAncestorClass := func(prop Symbol) bool {
		if ! /* TODO(ParenthesizedExpression): (prop.parent!.flags & SymbolFlags.Class) */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		var classType *InterfaceType = getTypeOfSymbol( /* TODO(NonNullExpression): prop.parent! */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
		/* TODO(WhileStatement): while (true) {             classType = classType.symbol && getSuperClass(classType) as InterfaceType | undefined;             if (!classType) {                 return false;             }             const superProperty = getPropertyOfType(classType, prop.escapedName);             if (superProperty && superProperty.valueDeclaration) {                 return true;             }         } */
	}
	getSuperClass := func(classType InterfaceType) *Type {
		x := getBaseTypes(classType)
		if /* TODO(PropertyAccessExpression): x.length */ TODO == 0 {
			return nil
		}
		return getIntersectionType(x)
	}
	reportNonexistentProperty := func(propNode /* TODO(UnionType): Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo *Diagnostic
		if !isPrivateIdentifier(propNode) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): containingType.flags & TypeFlags.Union */ TODO && ! /* TODO(ParenthesizedExpression): (containingType.flags & TypeFlags.Primitive) */ TODO {
			for _, subtype := range /* TODO(PropertyAccessExpression): (containingType as UnionType).types */ TODO {
				if !getPropertyOfType(subtype /* TODO(PropertyAccessExpression): propNode.escapedText */, TODO) && !getApplicableIndexInfoForName(subtype /* TODO(PropertyAccessExpression): propNode.escapedText */, TODO) {
					/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype)); */
					/* TODO(BreakStatement): break; */
				}
			}
		}
		if typeHasStaticProperty( /* TODO(PropertyAccessExpression): propNode.escapedText */ TODO, containingType) {
			propName := declarationNameToString(propNode)
			typeName := typeToString(containingType)
			/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "." + propName); */
		} else {
			promisedType := getPromisedTypeOfPromise(containingType)
			if promisedType && getPropertyOfType(promisedType /* TODO(PropertyAccessExpression): propNode.escapedText */, TODO) {
				/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType)); */
				/* TODO(ExpressionStatement): relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await); */
			} else {
				missingProperty := declarationNameToString(propNode)
				container := typeToString(containingType)
				libSuggestion := getSuggestedLibForNonExistentProperty(missingProperty, containingType)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): libSuggestion !== undefined */ TODO {
					/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion); */
				} else {
					suggestion := getSuggestedSymbolForNonexistentProperty(propNode, containingType)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
						suggestedName := symbolName(suggestion)
						message := /* TODO(ConditionalExpression): isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */ TODO
						/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName); */
						/* TODO(ExpressionStatement): relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName); */
					} else {
						diagnostic := /* TODO(ConditionalExpression): containerSeemsToBeEmptyDomElement(containingType)                             ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom                             : Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO
						/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container); */
					}
				}
			}
		}
		resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
		if relatedInfo {
			addRelatedInfo(resultDiagnostic, relatedInfo)
		}
		addErrorOrSuggestion(!isUncheckedJS || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code */ TODO, resultDiagnostic)
	}
	containerSeemsToBeEmptyDomElement := func(containingType Type) /* TODO(undefined): boolean | undefined */ TODO {
		return /* TODO(ParenthesizedExpression): (compilerOptions.lib && !compilerOptions.lib.includes("dom")) */ TODO && everyContainedType(containingType /* TODO(ArrowFunction): type => type.symbol && /^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$/.test(unescapeLeadingUnderscores(type.symbol.escapedName)) */, TODO) && isEmptyObjectType(containingType)
	}
	typeHasStaticProperty := func(propName __String, containingType Type) bool {
		prop := /* TODO(PropertyAccessExpression): containingType.symbol */ TODO && getPropertyOfType(getTypeOfSymbol( /* TODO(PropertyAccessExpression): containingType.symbol */ TODO), propName)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop !== undefined */ TODO && !! /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && isStatic( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO)
	}
	getSuggestedLibForNonExistentName := func(name /* TODO(UnionType): __String | Identifier */ any) /* TODO(undefined): string | undefined */ TODO {
		missingName := diagnosticName(name)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := /* TODO(PropertyAccessExpression): allFeatures.get */ TODO(missingName)
		return typeFeatures && firstIterator( /* TODO(PropertyAccessExpression): typeFeatures.keys */ TODO())
	}
	getSuggestedLibForNonExistentProperty := func(missingProperty string, containingType Type) /* TODO(undefined): string | undefined */ TODO {
		container := /* TODO(PropertyAccessExpression): getApparentType(containingType).symbol */ TODO
		if !container {
			return nil
		}
		containingTypeName := symbolName(container)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := /* TODO(PropertyAccessExpression): allFeatures.get */ TODO(containingTypeName)
		if typeFeatures {
			for _, TODO_IDENTIFIER := range typeFeatures {
				if contains(featuresOfType, missingProperty) {
					return libTarget
				}
			}
		}
	}
	getSuggestedSymbolForNonexistentClassMember := func(name string, baseType Type) *Symbol {
		return getSpellingSuggestionForName(name, getPropertiesOfType(baseType) /* TODO(PropertyAccessExpression): SymbolFlags.ClassMember */, TODO)
	}
	getSuggestedSymbolForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		props := getPropertiesOfType(containingType)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeof name !== "string" */ TODO {
			parent := /* TODO(PropertyAccessExpression): name.parent */ TODO
			if isPropertyAccessExpression(parent) {
				/* TODO(ExpressionStatement): props = filter(props, prop => isValidPropertyAccessForCompletions(parent, containingType, prop)); */
			}
			/* TODO(ExpressionStatement): name = idText(name); */
		}
		return getSpellingSuggestionForName(name, props /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
	}
	getSuggestedSymbolForNonexistentJSXAttribute := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		strName := /* TODO(ConditionalExpression): isString(name) ? name : idText(name) */ TODO
		properties := getPropertiesOfType(containingType)
		jsxSpecific := /* TODO(ConditionalExpression): strName === "for" ? find(properties, x => symbolName(x) === "htmlFor")             : strName === "class" ? find(properties, x => symbolName(x) === "className")             : undefined */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
	}
	getSuggestionForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) /* TODO(StringKeyword): string */ any {
		suggestion := getSuggestedSymbolForNonexistentProperty(name, containingType)
		return suggestion && symbolName(suggestion)
	}
	getSuggestionForSymbolNameLookup := func(symbols SymbolTable, name __String, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		symbol := getSymbol(symbols, name, meaning)
		if symbol {
			/* TODO(Identifier): symbol */
		}
		var candidates []Symbol
		if symbols == globals {
			primitives := mapDefined( /* TODO(ArrayLiteralExpression): ["string", "number", "boolean", "object", "bigint", "symbol"] */ TODO /* TODO(ArrowFunction): s => symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as __String)                     ? createSymbol(SymbolFlags.TypeAlias, s as __String) as Symbol                     : undefined */, TODO)
			/* TODO(ExpressionStatement): candidates = primitives.concat(arrayFrom(symbols.values())); */
		} else {
			/* TODO(ExpressionStatement): candidates = arrayFrom(symbols.values()); */
		}
		return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
	}
	getSuggestedSymbolForNonexistentSymbol := func(location Node, outerName __String, meaning SymbolFlags) *Symbol {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): outerName !== undefined */ TODO, "outername should always be defined")
		result := resolveNameForSymbolSuggestion(location, outerName, meaning, nil /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
		return result
	}
	getSuggestedSymbolForNonexistentModule := func(name Identifier, targetModule Symbol) *Symbol {
		return /* TODO(PropertyAccessExpression): targetModule.exports */ TODO && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule) /* TODO(PropertyAccessExpression): SymbolFlags.ModuleMember */, TODO)
	}
	getSuggestionForNonexistentIndexSignature := func(objectType Type, expr ElementAccessExpression, keyedType Type) /* TODO(StringKeyword): string */ any {
		hasProp := func(name /* TODO(UnionType): "set" | "get" */ any) /* TODO(undefined): boolean */ TODO {
			prop := getPropertyOfObjectType(objectType, name /* as */ /* TODO(TypeReference): __String */)
			if prop {
				s := getSingleCallSignature(getTypeOfSymbol(prop))
				return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0))
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		suggestedMethod := /* TODO(ConditionalExpression): isAssignmentTarget(expr) ? "set" : "get" */ TODO
		if !hasProp(suggestedMethod) {
			return nil
		}
		suggestion := tryGetPropertyAccessOrIdentifierToString( /* TODO(PropertyAccessExpression): expr.expression */ TODO)
		if suggestion == nil {
			/* TODO(ExpressionStatement): suggestion = suggestedMethod; */
		} else {
			/* TODO(ExpressionStatement): suggestion += "." + suggestedMethod; */
		}
		return suggestion
	}
	getSuggestedTypeForNonexistentStringLiteralType := func(source StringLiteralType, target UnionType) *StringLiteralType {
		candidates := /* TODO(PropertyAccessExpression): target.types.filter */ TODO( /* TODO(ArrowFunction): (type): type is StringLiteralType => !!(type.flags & TypeFlags.StringLiteral) */ TODO)
		return getSpellingSuggestion( /* TODO(PropertyAccessExpression): source.value */ TODO, candidates /* TODO(ArrowFunction): type => type.value */, TODO)
	}
	getSpellingSuggestionForName := func(name string, symbols []Symbol, meaning SymbolFlags) *Symbol {
		return getSpellingSuggestion(name, symbols, getCandidateName)
		getCandidateName := func(candidate Symbol) /* TODO(undefined): string | undefined */ TODO {
			candidateName := symbolName(candidate)
			if startsWith(candidateName, '"') {
				return nil
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): candidate.flags & meaning */ TODO {
				return candidateName
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): candidate.flags & SymbolFlags.Alias */ TODO {
				alias := tryResolveAlias(candidate)
				if alias && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): alias.flags & meaning */ TODO {
					return candidateName
				}
			}
			return nil
		}
	}
	markPropertyAsReferenced := func(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
		valueDeclaration := prop && /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.ClassMember) */ TODO && /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO
		if !valueDeclaration {
			return
		}
		hasPrivateModifier := hasEffectiveModifier(valueDeclaration /* TODO(PropertyAccessExpression): ModifierFlags.Private */, TODO)
		hasPrivateIdentifier := /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO && isNamedDeclaration( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO) && isPrivateIdentifier( /* TODO(PropertyAccessExpression): prop.valueDeclaration.name */ TODO)
		if !hasPrivateModifier && !hasPrivateIdentifier {
			return
		}
		if nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && ! /* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.SetAccessor) */ TODO {
			return
		}
		if isSelfTypeAccess {
			containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
			if containingMethod && /* TODO(PropertyAccessExpression): containingMethod.symbol */ TODO == prop {
				return
			}
		}
		/* TODO(ExpressionStatement): (getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop)!.isReferenced = SymbolFlags.All; */
	}
	isSelfTypeAccess := func(name /* TODO(UnionType): Expression | QualifiedName */ any, parent *Symbol) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO || !!parent && isEntityNameExpression(name) && parent == getResolvedSymbol(getFirstIdentifier(name))
	}
	isValidPropertyAccess := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.PropertyAccessExpression:                 return isValidPropertyAccessWithType(node, node.expression.kind === SyntaxKind.SuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)));             case SyntaxKind.QualifiedName:                 return isValidPropertyAccessWithType(node, /*isSuper* / false, propertyName, getWidenedType(checkExpression(node.left)));             case SyntaxKind.ImportType:                 return isValidPropertyAccessWithType(node, /*isSuper* / false, propertyName, getTypeFromTypeNode(node));         } */
	}
	isValidPropertyAccessForCompletions := func(node /* TODO(UnionType): PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
		return isPropertyAccessible(node /* TODO(PropertyAccessExpression): node.kind */, TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO && /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO /* TODO(FalseKeyword): false */, TODO, type_, property)
	}
	isValidPropertyAccessWithType := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
		if isTypeAny(type_) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		prop := getPropertyOfType(type_, propertyName)
		return !!prop && isPropertyAccessible(node, isSuper /* TODO(FalseKeyword): false */, TODO, type_, prop)
	}
	isPropertyAccessible := func(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
		if isTypeAny(containingType) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(PropertyAccessExpression): property.valueDeclaration */ TODO && isPrivateIdentifierClassElementDeclaration( /* TODO(PropertyAccessExpression): property.valueDeclaration */ TODO) {
			declClass := getContainingClass( /* TODO(PropertyAccessExpression): property.valueDeclaration */ TODO)
			return !isOptionalChain(node) && !!findAncestor(node /* TODO(ArrowFunction): parent => parent === declClass */, TODO)
		}
		return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
	}
	getForInVariableSymbol := func(node ForInStatement) *Symbol {
		initializer := /* TODO(PropertyAccessExpression): node.initializer */ TODO
		if /* TODO(PropertyAccessExpression): initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO {
			variable := /* TODO(ElementAccessExpression): (initializer as VariableDeclarationList).declarations[0] */ TODO
			if variable && !isBindingPattern( /* TODO(PropertyAccessExpression): variable.name */ TODO) {
				return getSymbolOfDeclaration(variable)
			}
		} else if /* TODO(PropertyAccessExpression): initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			return getResolvedSymbol(initializer /* as */ /* TODO(TypeReference): Identifier */)
		}
		return nil
	}
	hasNumericPropertyNames := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): getIndexInfosOfType(type).length */ TODO == 1 && !!getIndexInfoOfType(type_, numberType)
	}
	isForInVariableForNumericPropertyNames := func(expr Expression) /* TODO(undefined): boolean */ TODO {
		e := skipParentheses(expr)
		if /* TODO(PropertyAccessExpression): e.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			symbol := getResolvedSymbol(e /* as */ /* TODO(TypeReference): Identifier */)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Variable */ TODO {
				var child Node = expr
				node := /* TODO(PropertyAccessExpression): expr.parent */ TODO
				/* TODO(WhileStatement): while (node) {                     if (                         node.kind === SyntaxKind.ForInStatement &&                         child === (node as ForInStatement).statement &&                         getForInVariableSymbol(node as ForInStatement) === symbol &&                         hasNumericPropertyNames(getTypeOfExpression((node as ForInStatement).expression))                     ) {                         return true;                     }                     child = node;                     node = node.parent;                 } */
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkIndexedAccess := func(node ElementAccessExpression, checkMode *CheckMode) Type {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain, checkMode) :             checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode) */ TODO
	}
	checkElementAccessChain := func(node ElementAccessChain, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		exprType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		nonOptionalType := getOptionalExpressionType(exprType /* TODO(PropertyAccessExpression): node.expression */, TODO)
		return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType /* TODO(PropertyAccessExpression): node.expression */, TODO), checkMode), node /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== exprType */, TODO)
	}
	checkElementAccessExpression := func(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
		objectType := /* TODO(ConditionalExpression): getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType */ TODO
		indexExpression := /* TODO(PropertyAccessExpression): node.argumentExpression */ TODO
		indexType := checkExpression(indexExpression)
		if isErrorType(objectType) || objectType == silentNeverType {
			return objectType
		}
		if isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
			error(indexExpression /* TODO(PropertyAccessExpression): Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal */, TODO)
			return errorType
		}
		effectiveIndexType := /* TODO(ConditionalExpression): isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType */ TODO
		assignmentTargetKind := getAssignmentTargetKind(node)
		var accessFlags AccessFlags
		if assignmentTargetKind == /* TODO(PropertyAccessExpression): AssignmentKind.None */ TODO {
			/* TODO(ExpressionStatement): accessFlags = AccessFlags.ExpressionPosition; */
		} else {
			/* TODO(ExpressionStatement): accessFlags = AccessFlags.Writing | (isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0); */
			if assignmentTargetKind == /* TODO(PropertyAccessExpression): AssignmentKind.Compound */ TODO {
				/* TODO(ExpressionStatement): accessFlags |= AccessFlags.ExpressionPosition; */
			}
		}
		indexedAccessType := getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType
		return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */, TODO, indexedAccessType, indexExpression, checkMode), node)
	}
	callLikeExpressionMayHaveTypeArguments := func(node CallLikeExpression) /* TODO(TypePredicate): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ TODO {
		return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node)
	}
	resolveUntypedCall := func(node CallLikeExpression) Signature {
		if callLikeExpressionMayHaveTypeArguments(node) {
			forEach( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, checkSourceElement)
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TaggedTemplateExpression */ TODO {
			checkExpression( /* TODO(PropertyAccessExpression): node.template */ TODO)
		} else if isJsxOpeningLikeElement(node) {
			checkExpression( /* TODO(PropertyAccessExpression): node.attributes */ TODO)
		} else if isBinaryExpression(node) {
			checkExpression( /* TODO(PropertyAccessExpression): node.left */ TODO)
		} else if isCallOrNewExpression(node) {
			forEach( /* TODO(PropertyAccessExpression): node.arguments */ TODO /* TODO(ArrowFunction): argument => {                 checkExpression(argument);             } */, TODO)
		}
		return anySignature
	}
	resolveErrorCall := func(node CallLikeExpression) Signature {
		resolveUntypedCall(node)
		return unknownSignature
	}
	reorderCandidates := func(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
		var lastParent Node
		var lastSymbol *Symbol
		cutoffIndex := 0
		var index /* TODO(NumberKeyword): number */ any
		specializedIndex := -1
		var spliceIndex number
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(! /* TODO(PropertyAccessExpression): result.length */ TODO)
		for _, signature := range signatures {
			symbol := /* TODO(PropertyAccessExpression): signature.declaration */ TODO && getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
			parent := /* TODO(PropertyAccessExpression): signature.declaration */ TODO && /* TODO(PropertyAccessExpression): signature.declaration.parent */ TODO
			if !lastSymbol || symbol == lastSymbol {
				if lastParent && parent == lastParent {
					/* TODO(ExpressionStatement): index = index! + 1; */
				} else {
					/* TODO(ExpressionStatement): lastParent = parent; */
					/* TODO(ExpressionStatement): index = cutoffIndex; */
				}
			} else {
				/* TODO(ExpressionStatement): index = cutoffIndex = result.length; */
				/* TODO(ExpressionStatement): lastParent = parent; */
			}
			/* TODO(ExpressionStatement): lastSymbol = symbol; */
			if signatureHasLiteralTypes(signature) {
				/* TODO(ExpressionStatement): specializedIndex++; */
				/* TODO(ExpressionStatement): spliceIndex = specializedIndex; */
				/* TODO(ExpressionStatement): cutoffIndex++; */
			} else {
				/* TODO(ExpressionStatement): spliceIndex = index; */
			}
			/* TODO(PropertyAccessExpression): result.splice */ TODO(spliceIndex, 0 /* TODO(ConditionalExpression): callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature */, TODO)
		}
	}
	isSpreadArgument := func(arg *Expression) /* TODO(TypePredicate): arg is Expression */ TODO {
		return !!arg && /* TODO(ParenthesizedExpression): (arg.kind === SyntaxKind.SpreadElement || arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).isSpread) */ TODO
	}
	getSpreadArgumentIndex := func(args []Expression) number {
		return findIndex(args, isSpreadArgument)
	}
	acceptsVoid := func(t Type) bool {
		return !! /* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Void) */ TODO
	}
	acceptsVoidUndefinedUnknownOrAny := func(t Type) bool {
		return !! /* TODO(ParenthesizedExpression): (t.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Unknown | TypeFlags.Any)) */ TODO
	}
	hasCorrectArity := func(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): boolean */ TODO {
		var argCount number
		callIsIncomplete := /* TODO(FalseKeyword): false */ TODO
		effectiveParameterCount := getParameterCount(signature)
		effectiveMinimumArguments := getMinArgumentCount(signature)
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TaggedTemplateExpression */ TODO {
			/* TODO(ExpressionStatement): argCount = args.length; */
			if /* TODO(PropertyAccessExpression): node.template.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TemplateExpression */ TODO {
				lastSpan := last( /* TODO(PropertyAccessExpression): node.template.templateSpans */ TODO)
				/* TODO(ExpressionStatement): callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated; */
			} else {
				templateLiteral := /* TODO(PropertyAccessExpression): node.template */ TODO /* as */ /* TODO(TypeReference): LiteralExpression */
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): templateLiteral.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NoSubstitutionTemplateLiteral */ TODO)
				/* TODO(ExpressionStatement): callIsIncomplete = !!templateLiteral.isUnterminated; */
			}
		} else if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Decorator */ TODO {
			/* TODO(ExpressionStatement): argCount = getDecoratorArgumentCount(node, signature); */
		} else if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO {
			/* TODO(ExpressionStatement): argCount = 1; */
		} else if isJsxOpeningLikeElement(node) {
			/* TODO(ExpressionStatement): callIsIncomplete = node.attributes.end === node.end; */
			if callIsIncomplete {
				return /* TODO(TrueKeyword): true */ TODO
			}
			/* TODO(ExpressionStatement): argCount = effectiveMinimumArguments === 0 ? args.length : 1; */
			/* TODO(ExpressionStatement): effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1; */
			/* TODO(ExpressionStatement): effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1); */
		} else if ! /* TODO(PropertyAccessExpression): node.arguments */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NewExpression */ TODO)
			return getMinArgumentCount(signature) == 0
		} else {
			/* TODO(ExpressionStatement): argCount = signatureHelpTrailingComma ? args.length + 1 : args.length; */
			/* TODO(ExpressionStatement): callIsIncomplete = node.arguments.end === node.end; */
			spreadArgIndex := getSpreadArgumentIndex(args)
			if spreadArgIndex >= 0 {
				return spreadArgIndex >= getMinArgumentCount(signature) && /* TODO(ParenthesizedExpression): (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature)) */ TODO
			}
		}
		if !hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if callIsIncomplete || argCount >= effectiveMinimumArguments {
			return /* TODO(TrueKeyword): true */ TODO
		}
		/* TODO(ForStatement): for (let i = argCount; i < effectiveMinimumArguments; i++) {             const type = getTypeAtPosition(signature, i);             if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & TypeFlags.Never) {                 return false;             }         } */
		return /* TODO(TrueKeyword): true */ TODO
	}
	hasCorrectTypeArgumentArity := func(signature Signature, typeArguments *NodeArray[TypeNode]) /* TODO(undefined): boolean */ TODO {
		numTypeParameters := length( /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO)
		minTypeArgumentCount := getMinTypeArgumentCount( /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO)
		return !some(typeArguments) || /* TODO(ParenthesizedExpression): (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters) */ TODO
	}
	isInstantiatedGenericParameter := func(signature Signature, pos number) /* TODO(undefined): boolean */ TODO {
		var type_ TODO
		return !! /* TODO(ParenthesizedExpression): (signature.target && (type = tryGetTypeAtPosition(signature.target, pos)) && isGenericType(type)) */ TODO
	}
	getSingleCallSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO /* TODO(FalseKeyword): false */, TODO)
	}
	getSingleCallOrConstructSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO /* TODO(FalseKeyword): false */, TODO) || getSingleSignature(type_ /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO /* TODO(FalseKeyword): false */, TODO)
	}
	getSingleSignature := func(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			if allowMembers || /* TODO(PropertyAccessExpression): resolved.properties.length */ TODO == 0 && /* TODO(PropertyAccessExpression): resolved.indexInfos.length */ TODO == 0 {
				if kind == /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO && /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO == 1 && /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO == 0 {
					return /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
				}
				if kind == /* TODO(PropertyAccessExpression): SignatureKind.Construct */ TODO && /* TODO(PropertyAccessExpression): resolved.constructSignatures.length */ TODO == 1 && /* TODO(PropertyAccessExpression): resolved.callSignatures.length */ TODO == 0 {
					return /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
				}
			}
		}
		return nil
	}
	instantiateSignatureInContextOf := func(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
		context := createInferenceContext( /* TODO(NonNullExpression): getTypeParametersForMapper(signature)! */ TODO, signature /* TODO(PropertyAccessExpression): InferenceFlags.None */, TODO, compareTypes)
		restType := getEffectiveRestType(contextualSignature)
		mapper := inferenceContext && /* TODO(ParenthesizedExpression): (restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper) */ TODO
		sourceSignature := /* TODO(ConditionalExpression): mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature */ TODO
		applyToParameterTypes(sourceSignature, signature /* TODO(ArrowFunction): (source, target) => {             // Type parameters from outer context referenced by source type are fixed by instantiation of the source type             inferTypes(context.inferences, source, target);         } */, TODO)
		if !inferenceContext {
			applyToReturnTypes(contextualSignature, signature /* TODO(ArrowFunction): (source, target) => {                 inferTypes(context.inferences, source, target, InferencePriority.ReturnType);             } */, TODO)
		}
		return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile( /* TODO(PropertyAccessExpression): contextualSignature.declaration */ TODO))
	}
	inferJsxTypeArguments := func(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		checkAttrType := checkExpressionWithContextualType( /* TODO(PropertyAccessExpression): node.attributes */ TODO, paramType, context, checkMode)
		inferTypes( /* TODO(PropertyAccessExpression): context.inferences */ TODO, checkAttrType, paramType)
		return getInferredTypes(context)
	}
	getThisArgumentType := func(thisArgumentNode *Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !thisArgumentNode {
			return voidType
		}
		thisArgumentType := checkExpression(thisArgumentNode)
		return /* TODO(ConditionalExpression): isRightSideOfInstanceofExpression(thisArgumentNode) ? thisArgumentType :             isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(thisArgumentType) :             isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(thisArgumentType) :             thisArgumentType */ TODO
	}
	inferTypeArguments := func(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
		if isJsxOpeningLikeElement(node) {
			return inferJsxTypeArguments(node, signature, checkMode, context)
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.Decorator */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.BinaryExpression */ TODO {
			skipBindingPatterns := every( /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO /* TODO(ArrowFunction): p => !!getDefaultFromTypeParameter(p) */, TODO)
			contextualType := getContextualType(node /* TODO(ConditionalExpression): skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None */, TODO)
			if contextualType {
				inferenceTargetType := getReturnTypeOfSignature(signature)
				if couldContainTypeVariables(inferenceTargetType) {
					outerContext := getInferenceContext(node)
					isFromBindingPattern := !skipBindingPatterns && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getContextualType(node, ContextFlags.SkipBindingPatterns) !== contextualType */ TODO
					if !isFromBindingPattern {
						outerMapper := getMapperFromContext(cloneInferenceContext(outerContext /* TODO(PropertyAccessExpression): InferenceFlags.NoDefault */, TODO))
						instantiatedType := instantiateType(contextualType, outerMapper)
						contextualSignature := getSingleCallSignature(instantiatedType)
						inferenceSourceType := /* TODO(ConditionalExpression): contextualSignature && contextualSignature.typeParameters ?                             getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :                             instantiatedType */ TODO
						inferTypes( /* TODO(PropertyAccessExpression): context.inferences */ TODO, inferenceSourceType, inferenceTargetType /* TODO(PropertyAccessExpression): InferencePriority.ReturnType */, TODO)
					}
					returnContext := createInferenceContext( /* TODO(NonNullExpression): signature.typeParameters! */ TODO, signature /* TODO(PropertyAccessExpression): context.flags */, TODO)
					returnSourceType := instantiateType(contextualType, outerContext && /* TODO(PropertyAccessExpression): outerContext.returnMapper */ TODO)
					inferTypes( /* TODO(PropertyAccessExpression): returnContext.inferences */ TODO, returnSourceType, inferenceTargetType)
					/* TODO(ExpressionStatement): context.returnMapper = some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined; */
				}
			}
		}
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		if restType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): restType.flags & TypeFlags.TypeParameter */ TODO {
			info := find( /* TODO(PropertyAccessExpression): context.inferences */ TODO /* TODO(ArrowFunction): info => info.typeParameter === restType */, TODO)
			if info {
				/* TODO(ExpressionStatement): info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined; */
			}
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && couldContainTypeVariables(thisType) {
			thisArgumentNode := getThisArgumentOfCall(node)
			inferTypes( /* TODO(PropertyAccessExpression): context.inferences */ TODO, getThisArgumentType(thisArgumentNode), thisType)
		}
		/* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 if (couldContainTypeVariables(paramType)) {                     const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);                     inferTypes(context.inferences, argType, paramType);                 }             }         } */
		if restType && couldContainTypeVariables(restType) {
			spreadType := getSpreadArgumentType(args, argCount /* TODO(PropertyAccessExpression): args.length */, TODO, restType, context, checkMode)
			inferTypes( /* TODO(PropertyAccessExpression): context.inferences */ TODO, spreadType, restType)
		}
		return getInferredTypes(context)
	}
	getMutableArrayOrTupleType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, getMutableArrayOrTupleType) :             type.flags & TypeFlags.Any || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :             isTupleType(type) ? createTupleType(getElementTypes(type), type.target.elementFlags, /*readonly* / false, type.target.labeledElementDeclarations) :             createTupleType([type], [ElementFlags.Variadic]) */ TODO
	}
	getSpreadArgumentType := func(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		inConstContext := isConstTypeVariable(restType)
		if index >= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): argCount - 1 */ TODO {
			arg := /* TODO(ElementAccessExpression): args[argCount - 1] */ TODO
			if isSpreadArgument(arg) {
				spreadType := /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type :                     checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode) */ TODO
				if isArrayLikeType(spreadType) {
					return getMutableArrayOrTupleType(spreadType)
				}
				return createArrayType(checkIteratedTypeOrElementType( /* TODO(PropertyAccessExpression): IterationUse.Spread */ TODO, spreadType, undefinedType /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg */, TODO), inConstContext)
			}
		}
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := /* TODO(ArrayLiteralExpression): [] */ TODO
		names := /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = index; i < argCount; i++) {             const arg = args[i];             if (isSpreadArgument(arg)) {                 const spreadType = arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpression((arg as SpreadElement).expression);                 if (isArrayLikeType(spreadType)) {                     types.push(spreadType);                     flags.push(ElementFlags.Variadic);                 }                 else {                     types.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg));                     flags.push(ElementFlags.Rest);                 }             }             else {                 const contextualType = isTupleType(restType) ?                     getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType :                     getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual);                 const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);                 const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);                 types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));                 flags.push(ElementFlags.Required);             }             if (arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).tupleNameSource) {                 names.push((arg as SyntheticExpression).tupleNameSource!);             }             else {                 names.push(undefined);             }         } */
		return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names)
	}
	checkTypeArguments := func(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) /* TODO(ArrayType): Type[] */ any {
		isJavascript := isInJSFile( /* TODO(PropertyAccessExpression): signature.declaration */ TODO)
		typeParameters := /* TODO(NonNullExpression): signature.typeParameters! */ TODO
		typeArgumentTypes := fillMissingTypeArguments(map_(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript)
		var mapper *TypeMapper
		/* TODO(ForStatement): for (let i = 0; i < typeArgumentNodes.length; i++) {             Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 const errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;                 const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;                 if (!mapper) {                     mapper = createTypeMapper(typeParameters, typeArgumentTypes);                 }                 const typeArgument = typeArgumentTypes[i];                 if (                     !checkTypeAssignableTo(                         typeArgument,                         getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),                         reportErrors ? typeArgumentNodes[i] : undefined,                         typeArgumentHeadMessage,                         errorInfo,                     )                 ) {                     return undefined;                 }             }         } */
		return typeArgumentTypes
	}
	getJsxReferenceKind := func(node JsxOpeningLikeElement) JsxReferenceKind {
		if isJsxIntrinsicTagName( /* TODO(PropertyAccessExpression): node.tagName */ TODO) {
			return /* TODO(PropertyAccessExpression): JsxReferenceKind.Mixed */ TODO
		}
		tagType := getApparentType(checkExpression( /* TODO(PropertyAccessExpression): node.tagName */ TODO))
		if length(getSignaturesOfType(tagType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)) {
			return /* TODO(PropertyAccessExpression): JsxReferenceKind.Component */ TODO
		}
		if length(getSignaturesOfType(tagType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)) {
			return /* TODO(PropertyAccessExpression): JsxReferenceKind.Function */ TODO
		}
		return /* TODO(PropertyAccessExpression): JsxReferenceKind.Mixed */ TODO
	}
	checkApplicableSignatureForJsxOpeningLikeElement := func(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO) /* TODO(undefined): boolean */ TODO {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		attributesType := checkExpressionWithContextualType( /* TODO(PropertyAccessExpression): node.attributes */ TODO, paramType, nil, checkMode)
		checkAttributesType := /* TODO(ConditionalExpression): checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(attributesType) : attributesType */ TODO
		return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(checkAttributesType, paramType, relation /* TODO(ConditionalExpression): reportErrors ? node.tagName : undefined */, TODO /* TODO(PropertyAccessExpression): node.attributes */, TODO, nil, containingMessageChain, errorOutputContainer)
		checkTagNameDoesNotExpectTooManyArguments := func() bool {
			if getJsxNamespaceContainerForImplicitImport(node) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			tagType := /* TODO(ConditionalExpression): (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) ? checkExpression(node.tagName) : undefined */ TODO
			if !tagType {
				return /* TODO(TrueKeyword): true */ TODO
			}
			tagCallSignatures := getSignaturesOfType(tagType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			if !length(tagCallSignatures) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			factory := getJsxFactoryEntity(node)
			if !factory {
				return /* TODO(TrueKeyword): true */ TODO
			}
			factorySymbol := resolveEntityName(factory /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(FalseKeyword): false */, TODO, node)
			if !factorySymbol {
				return /* TODO(TrueKeyword): true */ TODO
			}
			factoryType := getTypeOfSymbol(factorySymbol)
			callSignatures := getSignaturesOfType(factoryType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			if !length(callSignatures) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			hasFirstParamSignatures := /* TODO(FalseKeyword): false */ TODO
			maxParamCount := 0
			for _, sig := range callSignatures {
				firstparam := getTypeAtPosition(sig, 0)
				signaturesOfParam := getSignaturesOfType(firstparam /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
				if !length(signaturesOfParam) {
				}
				for _, paramSig := range signaturesOfParam {
					/* TODO(ExpressionStatement): hasFirstParamSignatures = true; */
					if hasEffectiveRestParameter(paramSig) {
						return /* TODO(TrueKeyword): true */ TODO
					}
					paramCount := getParameterCount(paramSig)
					if paramCount > maxParamCount {
						/* TODO(ExpressionStatement): maxParamCount = paramCount; */
					}
				}
			}
			if !hasFirstParamSignatures {
				return /* TODO(TrueKeyword): true */ TODO
			}
			absoluteMinArgCount := Infinity
			for _, tagSig := range tagCallSignatures {
				tagRequiredArgCount := getMinArgumentCount(tagSig)
				if tagRequiredArgCount < absoluteMinArgCount {
					/* TODO(ExpressionStatement): absoluteMinArgCount = tagRequiredArgCount; */
				}
			}
			if absoluteMinArgCount <= maxParamCount {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if reportErrors {
				diag := createDiagnosticForNode( /* TODO(PropertyAccessExpression): node.tagName */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3 */, TODO, entityNameToString( /* TODO(PropertyAccessExpression): node.tagName */ TODO), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
				tagNameDeclaration := /* TODO(PropertyAccessExpression): getSymbolAtLocation(node.tagName)?.valueDeclaration */ TODO
				if tagNameDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_here */, TODO, entityNameToString( /* TODO(PropertyAccessExpression): node.tagName */ TODO)))
				}
				if errorOutputContainer && /* TODO(PropertyAccessExpression): errorOutputContainer.skipLogging */ TODO {
					/* TODO(PropertyAccessExpression): (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push */ TODO(diag)
				}
				if ! /* TODO(PropertyAccessExpression): errorOutputContainer.skipLogging */ TODO {
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
				}
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	getEffectiveCheckNode := func(argument Expression) Expression {
		/* TODO(ExpressionStatement): argument = skipParentheses(argument); */
		return /* TODO(ConditionalExpression): isSatisfiesExpression(argument) ? skipParentheses(argument.expression) : argument */ TODO
	}
	getSignatureApplicabilityError := func(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, inferenceContext *InferenceContext) /* TODO(TypeOperator): readonly Diagnostic[] */ any {
		var errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO = /* TODO(ObjectLiteralExpression): { errors: undefined, skipLogging: true } */ TODO
		if isJsxOpeningLikeElement(node) {
			if !checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!reportErrors || !! /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO, "jsx should have errors when reporting errors")
				return /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO || emptyArray
			}
			return nil
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): thisType !== voidType */ TODO && ! /* TODO(ParenthesizedExpression): (isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) */ TODO {
			thisArgumentNode := getThisArgumentOfCall(node)
			thisArgumentType := getThisArgumentType(thisArgumentNode)
			errorNode := /* TODO(ConditionalExpression): reportErrors ? (thisArgumentNode || node) : undefined */ TODO
			headMessage := /* TODO(PropertyAccessExpression): Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1 */ TODO
			if !checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!reportErrors || !! /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO, "this parameter should have errors when reporting errors")
				return /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO || emptyArray
			}
		}
		headMessage := /* TODO(PropertyAccessExpression): Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 */ TODO
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		/* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 const argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext* / undefined, checkMode);                 // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),                 // we obtain the regular type of any object literal arguments because we may not have inferred complete                 // parameter types yet and therefore excess property checks may yield false positives (see #17041).                 const regularArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;                 // If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving                 // the type variables in the expression.                 const checkArgType = inferenceContext ? instantiateType(regularArgType, inferenceContext.nonFixingMapper) : regularArgType;                 const effectiveCheckArgumentNode = getEffectiveCheckNode(arg);                 if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? effectiveCheckArgumentNode : undefined, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer)) {                     Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");                     maybeAddMissingAwaitInfo(arg, checkArgType, paramType);                     return errorOutputContainer.errors || emptyArray;                 }             }         } */
		if restType {
			spreadType := getSpreadArgumentType(args, argCount /* TODO(PropertyAccessExpression): args.length */, TODO, restType, nil, checkMode)
			restArgCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): args.length - argCount */ TODO
			errorNode := /* TODO(ConditionalExpression): !reportErrors ? undefined :                 restArgCount === 0 ? node :                 restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) :                 setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end) */ TODO
			if !checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, nil, errorOutputContainer) {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!reportErrors || !! /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO, "rest parameter should have errors when reporting errors")
				maybeAddMissingAwaitInfo(errorNode, spreadType, restType)
				return /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO || emptyArray
			}
		}
		return nil
		maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
			if errorNode && reportErrors && /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO && /* TODO(PropertyAccessExpression): errorOutputContainer.errors.length */ TODO {
				if getAwaitedTypeOfPromise(target) {
					return
				}
				awaitedTypeOfSource := getAwaitedTypeOfPromise(source)
				if awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation) {
					addRelatedInfo( /* TODO(ElementAccessExpression): errorOutputContainer.errors[0] */ TODO, createDiagnosticForNode(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Did_you_forget_to_use_await */, TODO))
				}
			}
		}
	}
	getThisArgumentOfCall := func(node CallLikeExpression) *Expression {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO {
			return /* TODO(PropertyAccessExpression): node.right */ TODO
		}
		expression := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ? node.expression :             node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag :             node.kind === SyntaxKind.Decorator && !legacyDecorators ? node.expression :             undefined */ TODO
		if expression {
			callee := skipOuterExpressions(expression)
			if isAccessExpression(callee) {
				return /* TODO(PropertyAccessExpression): callee.expression */ TODO
			}
		}
	}
	createSyntheticExpression := func(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SyntheticExpression */ TODO {
		result := /* TODO(PropertyAccessExpression): parseNodeFactory.createSyntheticExpression */ TODO(type_, isSpread, tupleNameSource)
		setTextRangeWorker(result, parent)
		setParent(result, parent)
		return result
	}
	getEffectiveCallArguments := func(node CallLikeExpression) []Expression {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TaggedTemplateExpression */ TODO {
			template := /* TODO(PropertyAccessExpression): node.template */ TODO
			var args []Expression = /* TODO(ArrayLiteralExpression): [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())] */ TODO
			if /* TODO(PropertyAccessExpression): template.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TemplateExpression */ TODO {
				forEach( /* TODO(PropertyAccessExpression): template.templateSpans */ TODO /* TODO(ArrowFunction): span => {                     args.push(span.expression);                 } */, TODO)
			}
			return args
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Decorator */ TODO {
			return getEffectiveDecoratorArguments(node)
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO {
			return /* TODO(ArrayLiteralExpression): [node.left] */ TODO
		}
		if isJsxOpeningLikeElement(node) {
			return /* TODO(ConditionalExpression): node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : emptyArray */ TODO
		}
		args := /* TODO(PropertyAccessExpression): node.arguments */ TODO || emptyArray
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex >= 0 {
			effectiveArgs := /* TODO(PropertyAccessExpression): args.slice */ TODO(0, spreadIndex)
			/* TODO(ForStatement): for (let i = spreadIndex; i < args.length; i++) {                 const arg = args[i];                 // We can call checkExpressionCached because spread expressions never have a contextual type.                 const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));                 if (spreadType && isTupleType(spreadType)) {                     forEach(getElementTypes(spreadType), (t, i) => {                         const flags = spreadType.target.elementFlags[i];                         const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t, !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);                         effectiveArgs.push(syntheticArg);                     });                 }                 else {                     effectiveArgs.push(arg);                 }             } */
			return effectiveArgs
		}
		return args
	}
	getEffectiveDecoratorArguments := func(node Decorator) []Expression {
		expr := /* TODO(PropertyAccessExpression): node.expression */ TODO
		signature := getDecoratorCallSignature(node)
		if signature {
			var args []Expression = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, param := range /* TODO(PropertyAccessExpression): signature.parameters */ TODO {
				type_ := getTypeOfSymbol(param)
				/* TODO(PropertyAccessExpression): args.push */ TODO(createSyntheticExpression(expr, type_))
			}
			return args
		}
		return /* TODO(PropertyAccessExpression): Debug.fail */ TODO()
	}
	getDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(undefined): number */ TODO {
		return /* TODO(ConditionalExpression): compilerOptions.experimentalDecorators ?             getLegacyDecoratorArgumentCount(node, signature) :             // Allow the runtime to oversupply arguments to an ES decorator as long as there's at least one parameter.             Math.min(Math.max(getParameterCount(signature), 1), 2) */ TODO
	}
	getLegacyDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(undefined): 1 | 2 | 3 */ TODO {
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 return 1;             case SyntaxKind.PropertyDeclaration:                 return hasAccessorModifier(node.parent) ? 3 : 2;             case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 // For decorators with only two parameters we supply only two arguments                 return signature.parameters.length <= 2 ? 2 : 3;             case SyntaxKind.Parameter:                 return 3;             default:                 return Debug.fail();         } */
	}
	getDiagnosticSpanForCallNode := func(node CallExpression) /* TODO(undefined): { start: number; length: number; sourceFile: import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile; } */ TODO {
		sourceFile := getSourceFileOfNode(node)
		TODO_IDENTIFIER := getErrorSpanForNode(sourceFile /* TODO(ConditionalExpression): isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression */, TODO)
		return /* TODO(ObjectLiteralExpression): { start, length, sourceFile } */ TODO
	}
	getDiagnosticForCallNode := func(node CallLikeExpression, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
		if isCallExpression(node) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(node)
			if /* TODO(InKeyword): in */ /* TODO(BinaryExpression): "message" in message */ TODO {
				return createFileDiagnostic(sourceFile, start, length, message /* TODO(SpreadElement): ...args */, TODO)
			}
			return createDiagnosticForFileFromMessageChain(sourceFile, message)
		} else {
			if /* TODO(InKeyword): in */ /* TODO(BinaryExpression): "message" in message */ TODO {
				return createDiagnosticForNode(node, message /* TODO(SpreadElement): ...args */, TODO)
			}
			return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
		}
	}
	getErrorNodeForCallNode := func(callLike CallLikeExpression) Node {
		if isCallOrNewExpression(callLike) {
			return /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.expression) ? callLike.expression.name : callLike.expression */ TODO
		}
		if isTaggedTemplateExpression(callLike) {
			return /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.tag) ? callLike.tag.name : callLike.tag */ TODO
		}
		if isJsxOpeningLikeElement(callLike) {
			return /* TODO(PropertyAccessExpression): callLike.tagName */ TODO
		}
		return callLike
	}
	isPromiseResolveArityError := func(node CallLikeExpression) /* TODO(undefined): boolean */ TODO {
		if !isCallExpression(node) || !isIdentifier( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			/* TODO(FalseKeyword): false */
		}
		symbol := resolveName( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): node.expression.escapedText */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO, nil /* TODO(FalseKeyword): false */, TODO)
		decl := /* TODO(PropertyAccessExpression): symbol?.valueDeclaration */ TODO
		if !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction( /* TODO(PropertyAccessExpression): decl.parent */ TODO) || !isNewExpression( /* TODO(PropertyAccessExpression): decl.parent.parent */ TODO) || !isIdentifier( /* TODO(PropertyAccessExpression): decl.parent.parent.expression */ TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		globalPromiseSymbol := getGlobalPromiseConstructorSymbol( /* TODO(FalseKeyword): false */ TODO)
		if !globalPromiseSymbol {
			/* TODO(FalseKeyword): false */
		}
		constructorSymbol := getSymbolAtLocation( /* TODO(PropertyAccessExpression): decl.parent.parent.expression */ TODO /* TODO(TrueKeyword): true */, TODO)
		return constructorSymbol == globalPromiseSymbol
	}
	getArgumentArityError := func(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex > -1 {
			return createDiagnosticForNode( /* TODO(ElementAccessExpression): args[spreadIndex] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter */, TODO)
		}
		min := /* TODO(PropertyAccessExpression): Number.POSITIVE_INFINITY */ TODO
		max := /* TODO(PropertyAccessExpression): Number.NEGATIVE_INFINITY */ TODO
		maxBelow := /* TODO(PropertyAccessExpression): Number.NEGATIVE_INFINITY */ TODO
		minAbove := /* TODO(PropertyAccessExpression): Number.POSITIVE_INFINITY */ TODO
		var closestSignature *Signature
		for _, sig := range signatures {
			minParameter := getMinArgumentCount(sig)
			maxParameter := getParameterCount(sig)
			if minParameter < min {
				/* TODO(ExpressionStatement): min = minParameter; */
				/* TODO(ExpressionStatement): closestSignature = sig; */
			}
			/* TODO(ExpressionStatement): max = Math.max(max, maxParameter); */
			if minParameter < /* TODO(PropertyAccessExpression): args.length */ TODO && minParameter > maxBelow {
				/* TODO(BinaryExpression): maxBelow = minParameter */
			}
			if /* TODO(PropertyAccessExpression): args.length */ TODO < maxParameter && maxParameter < minAbove {
				/* TODO(BinaryExpression): minAbove = maxParameter */
			}
		}
		hasRestParameter := some(signatures, hasEffectiveRestParameter)
		parameterRange := /* TODO(ConditionalExpression): hasRestParameter ? min             : min < max ? min + "-" + max             : min */ TODO
		isVoidPromiseError := !hasRestParameter && parameterRange == 1 && /* TODO(PropertyAccessExpression): args.length */ TODO == 0 && isPromiseResolveArityError(node)
		if isVoidPromiseError && isInJSFile(node) {
			return getDiagnosticForCallNode(node /* TODO(PropertyAccessExpression): Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments */, TODO)
		}
		error := /* TODO(ConditionalExpression): isDecorator(node) ?             hasRestParameter ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 :                 Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 :             hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 :             isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise :             Diagnostics.Expected_0_arguments_but_got_1 */ TODO
		if min < /* TODO(PropertyAccessExpression): args.length */ TODO && /* TODO(PropertyAccessExpression): args.length */ TODO < max {
			if headMessage {
				chain := chainDiagnosticMessages(nil /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments */, TODO /* TODO(PropertyAccessExpression): args.length */, TODO, maxBelow, minAbove)
				/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
				return getDiagnosticForCallNode(node, chain)
			}
			return getDiagnosticForCallNode(node /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments */, TODO /* TODO(PropertyAccessExpression): args.length */, TODO, maxBelow, minAbove)
		} else if /* TODO(PropertyAccessExpression): args.length */ TODO < min {
			var diagnostic Diagnostic
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange /* TODO(PropertyAccessExpression): args.length */, TODO)
				/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
				/* TODO(ExpressionStatement): diagnostic = getDiagnosticForCallNode(node, chain); */
			} else {
				/* TODO(ExpressionStatement): diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length); */
			}
			parameter := /* TODO(ElementAccessExpression): closestSignature?.declaration?.parameters[closestSignature.thisParameter ? args.length + 1 : args.length] */ TODO
			if parameter {
				var messageAndArgs DiagnosticAndArguments = /* TODO(ConditionalExpression): isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided]                     : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))]                     : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))] */ TODO
				parameterError := createDiagnosticForNode(parameter /* TODO(SpreadElement): ...messageAndArgs */, TODO)
				return addRelatedInfo(diagnostic, parameterError)
			}
			return diagnostic
		} else {
			errorSpan := /* TODO(PropertyAccessExpression): factory.createNodeArray */ TODO( /* TODO(PropertyAccessExpression): args.slice */ TODO(max))
			pos := /* TODO(PropertyAccessExpression): first(errorSpan).pos */ TODO
			end := /* TODO(PropertyAccessExpression): last(errorSpan).end */ TODO
			if end == pos {
				/* TODO(ExpressionStatement): end++; */
			}
			setTextRangePosEnd(errorSpan, pos, end)
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange /* TODO(PropertyAccessExpression): args.length */, TODO)
				/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange /* TODO(PropertyAccessExpression): args.length */, TODO)
		}
	}
	getTypeArgumentArityError := func(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		argCount := /* TODO(PropertyAccessExpression): typeArguments.length */ TODO
		if /* TODO(PropertyAccessExpression): signatures.length */ TODO == 1 {
			sig := /* TODO(ElementAccessExpression): signatures[0] */ TODO
			min := getMinTypeArgumentCount( /* TODO(PropertyAccessExpression): sig.typeParameters */ TODO)
			max := length( /* TODO(PropertyAccessExpression): sig.typeParameters */ TODO)
			if headMessage {
				chain := chainDiagnosticMessages(nil /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */, TODO /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
				/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */, TODO /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
		}
		belowArgCount := -Infinity
		aboveArgCount := Infinity
		for _, sig := range signatures {
			min := getMinTypeArgumentCount( /* TODO(PropertyAccessExpression): sig.typeParameters */ TODO)
			max := length( /* TODO(PropertyAccessExpression): sig.typeParameters */ TODO)
			if min > argCount {
				/* TODO(ExpressionStatement): aboveArgCount = Math.min(aboveArgCount, min); */
			} else if max < argCount {
				/* TODO(ExpressionStatement): belowArgCount = Math.max(belowArgCount, max); */
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): belowArgCount !== -Infinity */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): aboveArgCount !== Infinity */ TODO {
			if headMessage {
				chain := chainDiagnosticMessages(nil /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments */, TODO, argCount, belowArgCount, aboveArgCount)
				/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments /* TODO(PropertyAccessExpression): Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments */, TODO, argCount, belowArgCount, aboveArgCount)
		}
		if headMessage {
			chain := chainDiagnosticMessages(nil /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */, TODO /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
			/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */, TODO /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
	}
	resolveCall := func(node CallLikeExpression, signatures []Signature, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
		isTaggedTemplate := /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TaggedTemplateExpression */ TODO
		isDecorator := /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Decorator */ TODO
		isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
		isInstanceof := /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO
		reportErrors := !isInferencePartiallyBlocked && !candidatesOutArray
		var typeArguments *NodeArray[TypeNode]
		if !isDecorator && !isInstanceof && !isSuperCall(node) {
			/* TODO(ExpressionStatement): typeArguments = (node as CallExpression).typeArguments; */
			if isTaggedTemplate || isJsxOpeningOrSelfClosingElement || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (node as CallExpression).expression.kind !== SyntaxKind.SuperKeyword */ TODO {
				forEach(typeArguments, checkSourceElement)
			}
		}
		candidates := candidatesOutArray || /* TODO(ArrayLiteralExpression): [] */ TODO
		reorderCandidates(signatures, candidates, callChainFlags)
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): candidates.length */ TODO, "Revert #54442 and add a testcase with whatever triggered this")
		args := getEffectiveCallArguments(node)
		isSingleNonGenericCandidate := /* TODO(PropertyAccessExpression): candidates.length */ TODO == 1 && ! /* TODO(PropertyAccessExpression): candidates[0].typeParameters */ TODO
		argCheckMode := /* TODO(ConditionalExpression): !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal */ TODO
		var candidatesForArgumentError /* TODO(ArrayType): Signature[] */ any
		var candidateForArgumentArityError *Signature
		var candidateForTypeArgumentError *Signature
		var result *Signature
		signatureHelpTrailingComma := !! /* TODO(ParenthesizedExpression): (checkMode & CheckMode.IsForSignatureHelp) */ TODO && /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CallExpression */ TODO && /* TODO(PropertyAccessExpression): node.arguments.hasTrailingComma */ TODO
		if /* TODO(PropertyAccessExpression): candidates.length */ TODO > 1 {
			/* TODO(ExpressionStatement): result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma); */
		}
		if !result {
			/* TODO(ExpressionStatement): result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma); */
		}
		if result {
			return result
		}
		/* TODO(ExpressionStatement): result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode); */
		/* TODO(ExpressionStatement): getNodeLinks(node).resolvedSignature = result; */
		if reportErrors {
			if !headMessage && isInstanceof {
				/* TODO(ExpressionStatement): headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method; */
			}
			if candidatesForArgumentError {
				if /* TODO(PropertyAccessExpression): candidatesForArgumentError.length */ TODO == 1 || /* TODO(PropertyAccessExpression): candidatesForArgumentError.length */ TODO > 3 {
					last := /* TODO(ElementAccessExpression): candidatesForArgumentError[candidatesForArgumentError.length - 1] */ TODO
					var chain *DiagnosticMessageChain
					if /* TODO(PropertyAccessExpression): candidatesForArgumentError.length */ TODO > 3 {
						/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error); */
						/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call); */
					}
					if headMessage {
						/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
					}
					diags := getSignatureApplicabilityError(node, args, last, assignableRelation /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(ArrowFunction): () => chain */, TODO, nil)
					if diags {
						for _, d := range diags {
							if /* TODO(PropertyAccessExpression): last.declaration */ TODO && /* TODO(PropertyAccessExpression): candidatesForArgumentError.length */ TODO > 3 {
								addRelatedInfo(d, createDiagnosticForNode( /* TODO(PropertyAccessExpression): last.declaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_last_overload_is_declared_here */, TODO))
							}
							addImplementationSuccessElaboration(last, d)
							/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(d)
						}
					} else {
						/* TODO(PropertyAccessExpression): Debug.fail */ TODO("No error for last overload signature")
					}
				} else {
					var allDiagnostics [][]DiagnosticRelatedInformation = /* TODO(ArrayLiteralExpression): [] */ TODO
					max := 0
					min := /* TODO(PropertyAccessExpression): Number.MAX_VALUE */ TODO
					minIndex := 0
					i := 0
					for _, c := range candidatesForArgumentError {
						chain := /* TODO(ArrowFunction): () => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c)) */ TODO
						diags := getSignatureApplicabilityError(node, args, c, assignableRelation /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO /* TODO(TrueKeyword): true */, TODO, chain, nil)
						if diags {
							if /* TODO(PropertyAccessExpression): diags.length */ TODO <= min {
								/* TODO(ExpressionStatement): min = diags.length; */
								/* TODO(ExpressionStatement): minIndex = i; */
							}
							/* TODO(ExpressionStatement): max = Math.max(max, diags.length); */
							/* TODO(PropertyAccessExpression): allDiagnostics.push */
							TODO(diags)
						} else {
							/* TODO(PropertyAccessExpression): Debug.fail */ TODO("No error for 3 or fewer overload signatures")
						}
						/* TODO(ExpressionStatement): i++; */
					}
					diags := /* TODO(ConditionalExpression): max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics) */ TODO
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): diags.length */ TODO > 0, "No errors reported for 3 or fewer overload signatures")
					chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic) /* TODO(PropertyAccessExpression): Diagnostics.No_overload_matches_this_call */, TODO)
					if headMessage {
						/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, headMessage); */
					}
					related := /* TODO(ArrayLiteralExpression): [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]] */ TODO
					var diag Diagnostic
					if every(diags /* TODO(ArrowFunction): d => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file */, TODO) {
						TODO_IDENTIFIER := /* TODO(ElementAccessExpression): diags[0] */ TODO
						/* TODO(ExpressionStatement): diag = { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related }; */
					} else {
						/* TODO(ExpressionStatement): diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related); */
					}
					addImplementationSuccessElaboration( /* TODO(ElementAccessExpression): candidatesForArgumentError[0] */ TODO, diag)
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
				}
			} else if candidateForArgumentArityError {
				/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(getArgumentArityError(node /* TODO(ArrayLiteralExpression): [candidateForArgumentArityError] */, TODO, args, headMessage))
			} else if candidateForTypeArgumentError {
				checkTypeArguments(candidateForTypeArgumentError /* TODO(NonNullExpression): (node as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement).typeArguments! */, TODO /* TODO(TrueKeyword): true */, TODO, headMessage)
			} else {
				signaturesWithCorrectTypeArgumentArity := filter(signatures /* TODO(ArrowFunction): s => hasCorrectTypeArgumentArity(s, typeArguments) */, TODO)
				if /* TODO(PropertyAccessExpression): signaturesWithCorrectTypeArgumentArity.length */ TODO == 0 {
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(getTypeArgumentArityError(node, signatures /* TODO(NonNullExpression): typeArguments! */, TODO, headMessage))
				} else {
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage))
				}
			}
		}
		return result
		addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
			oldCandidatesForArgumentError := candidatesForArgumentError
			oldCandidateForArgumentArityError := candidateForArgumentArityError
			oldCandidateForTypeArgumentError := candidateForTypeArgumentError
			failedSignatureDeclarations := /* TODO(PropertyAccessExpression): failed.declaration?.symbol?.declarations */ TODO || emptyArray
			isOverload := /* TODO(PropertyAccessExpression): failedSignatureDeclarations.length */ TODO > 1
			implDecl := /* TODO(ConditionalExpression): isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined */ TODO
			if implDecl {
				candidate := getSignatureFromDeclaration(implDecl /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
				isSingleNonGenericCandidate := ! /* TODO(PropertyAccessExpression): candidate.typeParameters */ TODO
				if chooseOverload( /* TODO(ArrayLiteralExpression): [candidate] */ TODO, assignableRelation, isSingleNonGenericCandidate) {
					addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl /* TODO(PropertyAccessExpression): Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible */, TODO))
				}
			}
			/* TODO(ExpressionStatement): candidatesForArgumentError = oldCandidatesForArgumentError; */
			/* TODO(ExpressionStatement): candidateForArgumentArityError = oldCandidateForArgumentArityError; */
			/* TODO(ExpressionStatement): candidateForTypeArgumentError = oldCandidateForTypeArgumentError; */
		}
		chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			/* TODO(ExpressionStatement): candidatesForArgumentError = undefined; */
			/* TODO(ExpressionStatement): candidateForArgumentArityError = undefined; */
			/* TODO(ExpressionStatement): candidateForTypeArgumentError = undefined; */
			if isSingleNonGenericCandidate {
				candidate := /* TODO(ElementAccessExpression): candidates[0] */ TODO
				if some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					return nil
				}
				if getSignatureApplicabilityError(node, args, candidate, relation /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO /* TODO(FalseKeyword): false */, TODO, nil, nil) {
					/* TODO(ExpressionStatement): candidatesForArgumentError = [candidate]; */
					return nil
				}
				return candidate
			}
			/* TODO(ForStatement): for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {                 let candidate = candidates[candidateIndex];                 if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {                     continue;                 }                  let checkCandidate: Signature;                 let inferenceContext: InferenceContext | undefined;                  if (candidate.typeParameters) {                     // If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,                     // so our inference results for this call doesn't pollute expression types referencing the outer type parameter!                     const paramLocation = candidate.typeParameters[0].symbol.declarations?.[0]?.parent;                     const candidateParameterContext = paramLocation || (candidate.declaration && isConstructorDeclaration(candidate.declaration) ? candidate.declaration.parent : candidate.declaration);                     if (candidateParameterContext && findAncestor(node, a => a === candidateParameterContext)) {                         candidate = getImplementationSignature(candidate);                     }                     let typeArgumentTypes: readonly Type[] | undefined;                     if (some(typeArguments)) {                         typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors* / false);                         if (!typeArgumentTypes) {                             candidateForTypeArgumentError = candidate;                             continue;                         }                     }                     else {                         inferenceContext = createInferenceContext(candidate.typeParameters!, candidate, /*flags* / isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);                         // The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's                         //  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.                         typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper);                         argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;                     }                     checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);                     // If the original signature has a generic rest type, instantiation may produce a                     // signature with different arity and we need to perform another arity check.                     if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                         candidateForArgumentArityError = checkCandidate;                         continue;                     }                 }                 else {                     checkCandidate = candidate;                 }                 if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                     // Give preference to error candidates that have no rest parameters (as they are more specific)                     (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                     continue;                 }                 if (argCheckMode) {                     // If one or more context sensitive arguments were excluded, we start including                     // them now (and keeping do so for any subsequent candidates) and perform a second                     // round of type inference and applicability checking for this particular candidate.                     argCheckMode = CheckMode.Normal;                     if (inferenceContext) {                         const typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper);                         checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);                         // If the original signature has a generic rest type, instantiation may produce a                         // signature with different arity and we need to perform another arity check.                         if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                             candidateForArgumentArityError = checkCandidate;                             continue;                         }                     }                     if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                         // Give preference to error candidates that have no rest parameters (as they are more specific)                         (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                         continue;                     }                 }                 candidates[candidateIndex] = checkCandidate;                 return checkCandidate;             } */
			return nil
		}
	}
	getCandidateForOverloadFailure := func(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): candidates.length */ TODO > 0)
		checkNodeDeferred(node)
		return /* TODO(ConditionalExpression): hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters)             ? pickLongestCandidateSignature(node, candidates, args, checkMode)             : createUnionOfSignaturesForOverloadFailure(candidates) */ TODO
	}
	createUnionOfSignaturesForOverloadFailure := func(candidates []Signature) Signature {
		thisParameters := mapDefined(candidates /* TODO(ArrowFunction): c => c.thisParameter */, TODO)
		var thisParameter *Symbol
		if /* TODO(PropertyAccessExpression): thisParameters.length */ TODO {
			/* TODO(ExpressionStatement): thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter)); */
		}
		TODO_IDENTIFIER := minAndMax(candidates, getNumNonRestParameters)
		var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < maxNonRestParam; i++) {             const symbols = mapDefined(candidates, s =>                 signatureHasRestParameter(s) ?                     i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) :                     i < s.parameters.length ? s.parameters[i] : undefined);             Debug.assert(symbols.length !== 0);             parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));         } */
		restParameterSymbols := mapDefined(candidates /* TODO(ArrowFunction): c => signatureHasRestParameter(c) ? last(c.parameters) : undefined */, TODO)
		flags := /* TODO(PropertyAccessExpression): SignatureFlags.IsSignatureCandidateForOverloadFailure */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): restParameterSymbols.length !== 0 */ TODO {
			type_ := createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature) /* TODO(PropertyAccessExpression): UnionReduction.Subtype */, TODO))
			/* TODO(PropertyAccessExpression): parameters.push */ TODO(createCombinedSymbolForOverloadFailure(restParameterSymbols, type_))
			/* TODO(ExpressionStatement): flags |= SignatureFlags.HasRestParameter; */
		}
		if /* TODO(PropertyAccessExpression): candidates.some */ TODO(signatureHasLiteralTypes) {
			/* TODO(ExpressionStatement): flags |= SignatureFlags.HasLiteralTypes; */
		}
		return createSignature( /* TODO(PropertyAccessExpression): candidates[0].declaration */ TODO, nil, thisParameter, parameters, getIntersectionType( /* TODO(PropertyAccessExpression): candidates.map */ TODO(getReturnTypeOfSignature)), nil, minArgumentCount, flags)
	}
	getNumNonRestParameters := func(signature Signature) number {
		numParams := /* TODO(PropertyAccessExpression): signature.parameters.length */ TODO
		return /* TODO(ConditionalExpression): signatureHasRestParameter(signature) ? numParams - 1 : numParams */ TODO
	}
	createCombinedSymbolFromTypes := func(sources []Symbol, types []Type) Symbol {
		return createCombinedSymbolForOverloadFailure(sources, getUnionType(types /* TODO(PropertyAccessExpression): UnionReduction.Subtype */, TODO))
	}
	createCombinedSymbolForOverloadFailure := func(sources []Symbol, type_ Type) Symbol {
		return createSymbolWithType(first(sources), type_)
	}
	pickLongestCandidateSignature := func(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
		bestIndex := getLongestCandidateIndex(candidates /* TODO(ConditionalExpression): apparentArgumentCount === undefined ? args.length : apparentArgumentCount */, TODO)
		candidate := /* TODO(ElementAccessExpression): candidates[bestIndex] */ TODO
		TODO_IDENTIFIER := candidate
		if !typeParameters {
			return candidate
		}
		var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any = /* TODO(ConditionalExpression): callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined */ TODO
		instantiated := /* TODO(ConditionalExpression): typeArgumentNodes             ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))             : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode) */ TODO
		/* TODO(ExpressionStatement): candidates[bestIndex] = instantiated; */
		return instantiated
	}
	getTypeArgumentsFromNodes := func(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
		typeArguments := /* TODO(PropertyAccessExpression): typeArgumentNodes.map */ TODO(getTypeOfNode)
		/* TODO(WhileStatement): while (typeArguments.length > typeParameters.length) {             typeArguments.pop();         } */
		/* TODO(WhileStatement): while (typeArguments.length < typeParameters.length) {             typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));         } */
		return typeArguments
	}
	inferSignatureInstantiationForOverloadFailure := func(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
		inferenceContext := createInferenceContext(typeParameters, candidate /* TODO(ConditionalExpression): isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None */, TODO)
		typeArgumentTypes := inferTypeArguments(node, candidate, args /* TODO(BarToken): | */ /* TODO(BinaryExpression): checkMode | CheckMode.SkipContextSensitive | CheckMode.SkipGenericFunctions */, TODO, inferenceContext)
		return createSignatureInstantiation(candidate, typeArgumentTypes)
	}
	getLongestCandidateIndex := func(candidates []Signature, argsCount number) number {
		maxParamsIndex := -1
		maxParams := -1
		/* TODO(ForStatement): for (let i = 0; i < candidates.length; i++) {             const candidate = candidates[i];             const paramCount = getParameterCount(candidate);             if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {                 return i;             }             if (paramCount > maxParams) {                 maxParams = paramCount;                 maxParamsIndex = i;             }         } */
		return maxParamsIndex
	}
	resolveCallExpression := func(node CallExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		if /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO {
			superType := checkSuperExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
			if isTypeAny(superType) {
				for _, arg := range /* TODO(PropertyAccessExpression): node.arguments */ TODO {
					checkExpression(arg)
				}
				return anySignature
			}
			if !isErrorType(superType) {
				baseTypeNode := getEffectiveBaseTypeNode( /* TODO(NonNullExpression): getContainingClass(node)! */ TODO)
				if baseTypeNode {
					baseConstructors := getInstantiatedConstructorsForTypeArguments(superType /* TODO(PropertyAccessExpression): baseTypeNode.typeArguments */, TODO, baseTypeNode)
					return resolveCall(node, baseConstructors, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
				}
			}
			return resolveUntypedCall(node)
		}
		var callChainFlags SignatureFlags
		funcType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		if isCallChain(node) {
			nonOptionalType := getOptionalExpressionType(funcType /* TODO(PropertyAccessExpression): node.expression */, TODO)
			/* TODO(ExpressionStatement): callChainFlags = nonOptionalType === funcType ? SignatureFlags.None :                 isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain :                 SignatureFlags.IsInnerCallChain; */
			/* TODO(ExpressionStatement): funcType = nonOptionalType; */
		} else {
			/* TODO(ExpressionStatement): callChainFlags = SignatureFlags.None; */
		}
		/* TODO(ExpressionStatement): funcType = checkNonNullTypeWithReporter(             funcType,             node.expression,             reportCannotInvokePossiblyNullOrUndefinedError,         ); */
		if funcType == silentNeverType {
			return silentNeverSignature
		}
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		numConstructSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(apparentType, SignatureKind.Construct).length */ TODO
		if isUntypedFunctionCall(funcType, apparentType /* TODO(PropertyAccessExpression): callSignatures.length */, TODO, numConstructSignatures) {
			if !isErrorType(funcType) && /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Untyped_function_calls_may_not_accept_type_arguments */, TODO)
			}
			return resolveUntypedCall(node)
		}
		if ! /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
			if numConstructSignatures {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new */, TODO, typeToString(funcType))
			} else {
				var relatedInformation *DiagnosticRelatedInformation
				if /* TODO(PropertyAccessExpression): node.arguments.length */ TODO == 1 {
					text := /* TODO(PropertyAccessExpression): getSourceFileOfNode(node).text */ TODO
					if isLineBreak( /* TODO(PropertyAccessExpression): text.charCodeAt */ TODO( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): skipTrivia(text, node.expression.end, /*stopAfterLineBreak* / true) - 1 */ TODO)) {
						/* TODO(ExpressionStatement): relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon); */
					}
				}
				invocationError( /* TODO(PropertyAccessExpression): node.expression */ TODO, apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO, relatedInformation)
			}
			return resolveErrorCall(node)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.SkipGenericFunctions */ TODO && ! /* TODO(PropertyAccessExpression): node.typeArguments */ TODO && /* TODO(PropertyAccessExpression): callSignatures.some */ TODO(isGenericFunctionReturningFunction) {
			skippedGenericFunction(node, checkMode)
			return resolvingSignature
		}
		if /* TODO(PropertyAccessExpression): callSignatures.some */ TODO( /* TODO(ArrowFunction): sig => isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration!) */ TODO) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new */, TODO, typeToString(funcType))
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
	}
	isGenericFunctionReturningFunction := func(signature Signature) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature))) */ TODO
	}
	isUntypedFunctionCall := func(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
		return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !! /* TODO(ParenthesizedExpression): (funcType.flags & TypeFlags.TypeParameter) */ TODO || !numCallSignatures && !numConstructSignatures && ! /* TODO(ParenthesizedExpression): (apparentFuncType.flags & TypeFlags.Union) */ TODO && ! /* TODO(ParenthesizedExpression): (getReducedType(apparentFuncType).flags & TypeFlags.Never) */ TODO && isTypeAssignableTo(funcType, globalFunctionType)
	}
	resolveNewExpression := func(node NewExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		expressionType := checkNonNullExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		if expressionType == silentNeverType {
			return silentNeverSignature
		}
		/* TODO(ExpressionStatement): expressionType = getApparentType(expressionType); */
		if isErrorType(expressionType) {
			return resolveErrorCall(node)
		}
		if isTypeAny(expressionType) {
			if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Untyped_function_calls_may_not_accept_type_arguments */, TODO)
			}
			return resolveUntypedCall(node)
		}
		constructSignatures := getSignaturesOfType(expressionType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		if /* TODO(PropertyAccessExpression): constructSignatures.length */ TODO {
			if !isConstructorAccessible(node /* TODO(ElementAccessExpression): constructSignatures[0] */, TODO) {
				return resolveErrorCall(node)
			}
			if someSignature(constructSignatures /* TODO(ArrowFunction): signature => !!(signature.flags & SignatureFlags.Abstract) */, TODO) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_create_an_instance_of_an_abstract_class */, TODO)
				return resolveErrorCall(node)
			}
			valueDecl := /* TODO(PropertyAccessExpression): expressionType.symbol */ TODO && getClassLikeDeclarationOfSymbol( /* TODO(PropertyAccessExpression): expressionType.symbol */ TODO)
			if valueDecl && hasSyntacticModifier(valueDecl /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_create_an_instance_of_an_abstract_class */, TODO)
				return resolveErrorCall(node)
			}
			return resolveCall(node, constructSignatures, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
		}
		callSignatures := getSignaturesOfType(expressionType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		if /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
			signature := resolveCall(node, callSignatures, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
			if !noImplicitAny {
				if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && !isJSConstructor( /* TODO(PropertyAccessExpression): signature.declaration */ TODO) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getReturnTypeOfSignature(signature) !== voidType */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword */, TODO)
				}
				if getThisTypeOfSignature(signature) == voidType {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void */, TODO)
				}
			}
			return signature
		}
		invocationError( /* TODO(PropertyAccessExpression): node.expression */ TODO, expressionType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		return resolveErrorCall(node)
	}
	someSignature := func(signatures /* TODO(UnionType): Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
		if isArray(signatures) {
			return some(signatures /* TODO(ArrowFunction): signature => someSignature(signature, f) */, TODO)
		}
		return /* TODO(ConditionalExpression): signatures.compositeKind === TypeFlags.Union ? some(signatures.compositeSignatures, f) : f(signatures) */ TODO
	}
	typeHasProtectedAccessibleBase := func(target Symbol, type_ InterfaceType) bool {
		baseTypes := getBaseTypes(type_)
		if !length(baseTypes) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		firstBase := /* TODO(ElementAccessExpression): baseTypes[0] */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): firstBase.flags & TypeFlags.Intersection */ TODO {
			types := /* TODO(PropertyAccessExpression): (firstBase as IntersectionType).types */ TODO
			mixinFlags := findMixins(types)
			i := 0
			for _, intersectionMember := range /* TODO(PropertyAccessExpression): (firstBase as IntersectionType).types */ TODO {
				if ! /* TODO(ElementAccessExpression): mixinFlags[i] */ TODO {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(intersectionMember) & (ObjectFlags.Class | ObjectFlags.Interface) */ TODO {
						if /* TODO(PropertyAccessExpression): intersectionMember.symbol */ TODO == target {
							return /* TODO(TrueKeyword): true */ TODO
						}
						if typeHasProtectedAccessibleBase(target, intersectionMember /* as */ /* TODO(TypeReference): InterfaceType */) {
							return /* TODO(TrueKeyword): true */ TODO
						}
					}
				}
				/* TODO(ExpressionStatement): i++; */
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(PropertyAccessExpression): firstBase.symbol */ TODO == target {
			return /* TODO(TrueKeyword): true */ TODO
		}
		return typeHasProtectedAccessibleBase(target, firstBase /* as */ /* TODO(TypeReference): InterfaceType */)
	}
	isConstructorAccessible := func(node NewExpression, signature Signature) /* TODO(undefined): boolean */ TODO {
		if !signature || ! /* TODO(PropertyAccessExpression): signature.declaration */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		declaration := /* TODO(PropertyAccessExpression): signature.declaration */ TODO
		modifiers := getSelectedEffectiveModifierFlags(declaration /* TODO(PropertyAccessExpression): ModifierFlags.NonPublicAccessibilityModifier */, TODO)
		if !modifiers || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.Constructor */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		declaringClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(declaration.parent.symbol)! */ TODO
		declaringClass := getDeclaredTypeOfSymbol( /* TODO(PropertyAccessExpression): declaration.parent.symbol */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
		if !isNodeWithinClass(node, declaringClassDeclaration) {
			containingClass := getContainingClass(node)
			if containingClass && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): modifiers & ModifierFlags.Protected */ TODO {
				containingType := getTypeOfNode(containingClass)
				if typeHasProtectedAccessibleBase( /* TODO(PropertyAccessExpression): declaration.parent.symbol */ TODO, containingType /* as */ /* TODO(TypeReference): InterfaceType */) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): modifiers & ModifierFlags.Private */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration */, TODO, typeToString(declaringClass))
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): modifiers & ModifierFlags.Protected */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration */, TODO, typeToString(declaringClass))
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	invocationErrorDetails := func(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TypeLiteral): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ TODO {
		var errorInfo *DiagnosticMessageChain
		isCall := kind == /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO
		awaitedType := getAwaitedType(apparentType)
		maybeMissingAwait := awaitedType && /* TODO(PropertyAccessExpression): getSignaturesOfType(awaitedType, kind).length */ TODO > 0
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): apparentType.flags & TypeFlags.Union */ TODO {
			types := /* TODO(PropertyAccessExpression): (apparentType as UnionType).types */ TODO
			hasSignatures := /* TODO(FalseKeyword): false */ TODO
			for _, constituent := range types {
				signatures := getSignaturesOfType(constituent, kind)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signatures.length !== 0 */ TODO {
					/* TODO(ExpressionStatement): hasSignatures = true; */
					if errorInfo {
						/* TODO(BreakStatement): break; */
					}
				} else {
					if !errorInfo {
						/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                             errorInfo,                             isCall ?                                 Diagnostics.Type_0_has_no_call_signatures :                                 Diagnostics.Type_0_has_no_construct_signatures,                             typeToString(constituent),                         ); */
						/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                             errorInfo,                             isCall ?                                 Diagnostics.Not_all_constituents_of_type_0_are_callable :                                 Diagnostics.Not_all_constituents_of_type_0_are_constructable,                             typeToString(apparentType),                         ); */
					}
					if hasSignatures {
						/* TODO(BreakStatement): break; */
					}
				}
			}
			if !hasSignatures {
				/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                     /*details* / undefined,                     isCall ?                         Diagnostics.No_constituent_of_type_0_is_callable :                         Diagnostics.No_constituent_of_type_0_is_constructable,                     typeToString(apparentType),                 ); */
			}
			if !errorInfo {
				/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                     errorInfo,                     isCall ?                         Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :                         Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other,                     typeToString(apparentType),                 ); */
			}
		} else {
			/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(                 errorInfo,                 isCall ?                     Diagnostics.Type_0_has_no_call_signatures :                     Diagnostics.Type_0_has_no_construct_signatures,                 typeToString(apparentType),             ); */
		}
		headMessage := /* TODO(ConditionalExpression): isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable */ TODO
		if isCallExpression( /* TODO(PropertyAccessExpression): errorTarget.parent */ TODO) && /* TODO(PropertyAccessExpression): errorTarget.parent.arguments.length */ TODO == 0 {
			TODO_IDENTIFIER := getNodeLinks(errorTarget)
			if resolvedSymbol && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): resolvedSymbol.flags & SymbolFlags.GetAccessor */ TODO {
				/* TODO(ExpressionStatement): headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without; */
			}
		}
		return /* TODO(ObjectLiteralExpression): {             messageChain: chainDiagnosticMessages(errorInfo, headMessage),             relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined,         } */ TODO
	}
	invocationError := func(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
		TODO_IDENTIFIER := invocationErrorDetails(errorTarget, apparentType, kind)
		diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
		if relatedInfo {
			addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo))
		}
		if isCallExpression( /* TODO(PropertyAccessExpression): errorTarget.parent */ TODO) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode( /* TODO(PropertyAccessExpression): errorTarget.parent */ TODO)
			/* TODO(ExpressionStatement): diagnostic.start = start; */
			/* TODO(ExpressionStatement): diagnostic.length = length; */
		}
		/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
		invocationErrorRecovery(apparentType, kind /* TODO(ConditionalExpression): relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic */, TODO)
	}
	invocationErrorRecovery := func(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
		if ! /* TODO(PropertyAccessExpression): apparentType.symbol */ TODO {
			return
		}
		importNode := /* TODO(PropertyAccessExpression): getSymbolLinks(apparentType.symbol).originatingImport */ TODO
		if importNode && !isImportCall(importNode) {
			sigs := getSignaturesOfType(getTypeOfSymbol( /* TODO(NonNullExpression): getSymbolLinks(apparentType.symbol).target! */ TODO), kind)
			if !sigs || ! /* TODO(PropertyAccessExpression): sigs.length */ TODO {
			}
			addRelatedInfo(diagnostic, createDiagnosticForNode(importNode /* TODO(PropertyAccessExpression): Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead */, TODO))
		}
	}
	resolveTaggedTemplateExpression := func(node TaggedTemplateExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		tagType := checkExpression( /* TODO(PropertyAccessExpression): node.tag */ TODO)
		apparentType := getApparentType(tagType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		numConstructSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(apparentType, SignatureKind.Construct).length */ TODO
		if isUntypedFunctionCall(tagType, apparentType /* TODO(PropertyAccessExpression): callSignatures.length */, TODO, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if ! /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
			if isArrayLiteralExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
				diagnostic := createDiagnosticForNode( /* TODO(PropertyAccessExpression): node.tag */ TODO /* TODO(PropertyAccessExpression): Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked */, TODO)
				/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
				return resolveErrorCall(node)
			}
			invocationError( /* TODO(PropertyAccessExpression): node.tag */ TODO, apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	}
	getDiagnosticHeadMessageForDecoratorResolution := func(node Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;              case SyntaxKind.Parameter:                 return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;              case SyntaxKind.PropertyDeclaration:                 return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;              case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;              default:                 return Debug.fail();         } */
	}
	resolveDecorator := func(node Decorator, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		funcType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		numConstructSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(apparentType, SignatureKind.Construct).length */ TODO
		if isUntypedFunctionCall(funcType, apparentType /* TODO(PropertyAccessExpression): callSignatures.length */, TODO, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			nodeStr := getTextOfNode( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(FalseKeyword): false */, TODO)
			error(node /* TODO(PropertyAccessExpression): Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0 */, TODO, nodeStr)
			return resolveErrorCall(node)
		}
		headMessage := getDiagnosticHeadMessageForDecoratorResolution(node)
		if ! /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
			errorDetails := invocationErrorDetails( /* TODO(PropertyAccessExpression): node.expression */ TODO, apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			messageChain := chainDiagnosticMessages( /* TODO(PropertyAccessExpression): errorDetails.messageChain */ TODO, headMessage)
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode( /* TODO(PropertyAccessExpression): node.expression */ TODO) /* TODO(PropertyAccessExpression): node.expression */, TODO, messageChain)
			if /* TODO(PropertyAccessExpression): errorDetails.relatedMessage */ TODO {
				addRelatedInfo(diag, createDiagnosticForNode( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): errorDetails.relatedMessage */, TODO))
			}
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
			invocationErrorRecovery(apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO, diag)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO, headMessage)
	}
	createSignatureForJSXIntrinsic := func(node JsxOpeningLikeElement, result Type) Signature {
		namespace := getJsxNamespaceAt(node)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports /* TODO(PropertyAccessExpression): JsxNames.Element */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO)
		returnNode := typeSymbol && /* TODO(PropertyAccessExpression): nodeBuilder.symbolToEntityName */ TODO(typeSymbol /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO, node)
		declaration := /* TODO(PropertyAccessExpression): factory.createFunctionTypeNode */ TODO(nil /* TODO(ArrayLiteralExpression): [factory.createParameterDeclaration(/*modifiers* / undefined, /*dotDotDotToken* / undefined, "props", /*questionToken* / undefined, nodeBuilder.typeToTypeNode(result, node))] */, TODO /* TODO(ConditionalExpression): returnNode ? factory.createTypeReferenceNode(returnNode, /*typeArguments* / undefined) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */, TODO)
		parameterSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */ TODO, "props" /* as */ /* TODO(TypeReference): __String */)
		/* TODO(ExpressionStatement): parameterSymbol.links.type = result; */
		return createSignature(declaration, nil, nil /* TODO(ArrayLiteralExpression): [parameterSymbol] */, TODO /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */, TODO, nil, 1 /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	}
	resolveJsxOpeningLikeElement := func(node JsxOpeningLikeElement, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		if isJsxIntrinsicTagName( /* TODO(PropertyAccessExpression): node.tagName */ TODO) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
			fakeSignature := createSignatureForJSXIntrinsic(node, result)
			checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType( /* TODO(PropertyAccessExpression): node.attributes */ TODO, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), nil /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO), result /* TODO(PropertyAccessExpression): node.tagName */, TODO /* TODO(PropertyAccessExpression): node.attributes */, TODO)
			if length( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO) {
				forEach( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, checkSourceElement)
				/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNodeArray(getSourceFileOfNode(node) /* TODO(NonNullExpression): node.typeArguments! */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Expected_0_type_arguments_but_got_1 */, TODO, 0, length( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO)))
			}
			return fakeSignature
		}
		exprTypes := checkExpression( /* TODO(PropertyAccessExpression): node.tagName */ TODO)
		apparentType := getApparentType(exprTypes)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		signatures := getUninstantiatedJsxSignaturesOfType(exprTypes, node)
		if isUntypedFunctionCall(exprTypes, apparentType /* TODO(PropertyAccessExpression): signatures.length */, TODO, 0) {
			return resolveUntypedCall(node)
		}
		if /* TODO(PropertyAccessExpression): signatures.length */ TODO == 0 {
			error( /* TODO(PropertyAccessExpression): node.tagName */ TODO /* TODO(PropertyAccessExpression): Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures */, TODO, getTextOfNode( /* TODO(PropertyAccessExpression): node.tagName */ TODO))
			return resolveErrorCall(node)
		}
		return resolveCall(node, signatures, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
	}
	resolveInstanceofExpression := func(node InstanceofExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		rightType := checkExpression( /* TODO(PropertyAccessExpression): node.right */ TODO)
		if !isTypeAny(rightType) {
			hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(rightType)
			if hasInstanceMethodType {
				apparentType := getApparentType(hasInstanceMethodType)
				if isErrorType(apparentType) {
					return resolveErrorCall(node)
				}
				callSignatures := getSignaturesOfType(apparentType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
				constructSignatures := getSignaturesOfType(apparentType /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
				if isUntypedFunctionCall(hasInstanceMethodType, apparentType /* TODO(PropertyAccessExpression): callSignatures.length */, TODO /* TODO(PropertyAccessExpression): constructSignatures.length */, TODO) {
					return resolveUntypedCall(node)
				}
				if /* TODO(PropertyAccessExpression): callSignatures.length */ TODO {
					return resolveCall(node, callSignatures, candidatesOutArray, checkMode /* TODO(PropertyAccessExpression): SignatureFlags.None */, TODO)
				}
			} else if ! /* TODO(ParenthesizedExpression): (typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)) */ TODO {
				error( /* TODO(PropertyAccessExpression): node.right */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method */, TODO)
				return resolveErrorCall(node)
			}
		}
		return anySignature
	}
	isPotentiallyUncalledDecorator := func(decorator Decorator, signatures []Signature) /* TODO(undefined): boolean | 0 */ TODO {
		return /* TODO(PropertyAccessExpression): signatures.length */ TODO && every(signatures /* TODO(ArrowFunction): signature =>             signature.minArgumentCount === 0 &&             !signatureHasRestParameter(signature) &&             signature.parameters.length < getDecoratorArgumentCount(decorator, signature) */, TODO)
	}
	resolveSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:                 return resolveCallExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.NewExpression:                 return resolveNewExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.TaggedTemplateExpression:                 return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.Decorator:                 return resolveDecorator(node, candidatesOutArray, checkMode);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);             case SyntaxKind.BinaryExpression:                 return resolveInstanceofExpression(node, candidatesOutArray, checkMode);         } */
		/* TODO(PropertyAccessExpression): Debug.assertNever */
		TODO(node, "Branch in 'resolveSignature' should be unreachable.")
	}
	getResolvedSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		links := getNodeLinks(node)
		cached := /* TODO(PropertyAccessExpression): links.resolvedSignature */ TODO
		if cached && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): cached !== resolvingSignature */ TODO && !candidatesOutArray {
			return cached
		}
		saveResolutionStart := resolutionStart
		if !cached {
			/* TODO(ExpressionStatement): resolutionStart = resolutionTargets.length; */
		}
		/* TODO(ExpressionStatement): links.resolvedSignature = resolvingSignature; */
		result := resolveSignature(node, candidatesOutArray, checkMode || /* TODO(PropertyAccessExpression): CheckMode.Normal */ TODO)
		/* TODO(ExpressionStatement): resolutionStart = saveResolutionStart; */
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== resolvingSignature */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): links.resolvedSignature !== resolvingSignature */ TODO {
				/* TODO(ExpressionStatement): result = links.resolvedSignature; */
			}
			/* TODO(ExpressionStatement): links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached; */
		}
		return result
	}
	isJSConstructor := func(node Node) /* TODO(TypePredicate): node is FunctionDeclaration | FunctionExpression */ TODO {
		if !node || !isInJSFile(node) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		func_ := /* TODO(ConditionalExpression): isFunctionDeclaration(node) || isFunctionExpression(node) ? node :             (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer :             undefined */ TODO
		if func_ {
			if getJSDocClassTag(node) {
				/* TODO(TrueKeyword): true */
			}
			if isPropertyAssignment(walkUpParenthesizedExpressions( /* TODO(PropertyAccessExpression): func.parent */ TODO)) {
				/* TODO(FalseKeyword): false */
			}
			symbol := getSymbolOfDeclaration(func_)
			return !! /* TODO(PropertyAccessExpression): symbol?.members?.size */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	mergeJSSymbols := func(target Symbol, source *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol | undefined */ TODO {
		if source {
			links := getSymbolLinks(source)
			if ! /* TODO(PropertyAccessExpression): links.inferredClassSymbol */ TODO || ! /* TODO(PropertyAccessExpression): links.inferredClassSymbol.has */ TODO(getSymbolId(target)) {
				inferred := /* TODO(ConditionalExpression): isTransientSymbol(target) ? target : cloneSymbol(target) */ TODO
				/* TODO(ExpressionStatement): inferred.exports = inferred.exports || createSymbolTable(); */
				/* TODO(ExpressionStatement): inferred.members = inferred.members || createSymbolTable(); */
				/* TODO(ExpressionStatement): inferred.flags |= source.flags & SymbolFlags.Class; */
				if /* TODO(PropertyAccessExpression): source.exports?.size */ TODO {
					mergeSymbolTable( /* TODO(PropertyAccessExpression): inferred.exports */ TODO /* TODO(PropertyAccessExpression): source.exports */, TODO)
				}
				if /* TODO(PropertyAccessExpression): source.members?.size */ TODO {
					mergeSymbolTable( /* TODO(PropertyAccessExpression): inferred.members */ TODO /* TODO(PropertyAccessExpression): source.members */, TODO)
				}
				/* TODO(PropertyAccessExpression): (links.inferredClassSymbol || (links.inferredClassSymbol = new Map())).set */ TODO(getSymbolId(inferred), inferred)
				return inferred
			}
			return /* TODO(PropertyAccessExpression): links.inferredClassSymbol.get */ TODO(getSymbolId(target))
		}
	}
	getAssignedClassSymbol := func(decl Declaration) *Symbol {
		assignmentSymbol := decl && getSymbolOfExpando(decl /* TODO(TrueKeyword): true */, TODO)
		prototype := /* TODO(PropertyAccessExpression): assignmentSymbol?.exports?.get */ TODO("prototype" /* as */ /* TODO(TypeReference): __String */)
		init := /* TODO(PropertyAccessExpression): prototype?.valueDeclaration */ TODO && getAssignedJSPrototype( /* TODO(PropertyAccessExpression): prototype.valueDeclaration */ TODO)
		return /* TODO(ConditionalExpression): init ? getSymbolOfDeclaration(init) : undefined */ TODO
	}
	getSymbolOfExpando := func(node Node, allowDeclaration bool) *Symbol {
		if ! /* TODO(PropertyAccessExpression): node.parent */ TODO {
			return nil
		}
		var name /* TODO(UnionType): Expression | BindingName | undefined */ any
		var decl Node
		if isVariableDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(PropertyAccessExpression): node.parent.initializer */ TODO == node {
			if !isInJSFile(node) && ! /* TODO(ParenthesizedExpression): (isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) */ TODO {
				return nil
			}
			/* TODO(ExpressionStatement): name = node.parent.name; */
			/* TODO(ExpressionStatement): decl = node.parent; */
		} else if isBinaryExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			parentNode := /* TODO(PropertyAccessExpression): node.parent */ TODO
			parentNodeOperator := /* TODO(PropertyAccessExpression): node.parent.operatorToken.kind */ TODO
			if parentNodeOperator == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO && /* TODO(ParenthesizedExpression): (allowDeclaration || parentNode.right === node) */ TODO {
				/* TODO(ExpressionStatement): name = parentNode.left; */
				/* TODO(ExpressionStatement): decl = name; */
			} else if parentNodeOperator == /* TODO(PropertyAccessExpression): SyntaxKind.BarBarToken */ TODO || parentNodeOperator == /* TODO(PropertyAccessExpression): SyntaxKind.QuestionQuestionToken */ TODO {
				if isVariableDeclaration( /* TODO(PropertyAccessExpression): parentNode.parent */ TODO) && /* TODO(PropertyAccessExpression): parentNode.parent.initializer */ TODO == parentNode {
					/* TODO(ExpressionStatement): name = parentNode.parent.name; */
					/* TODO(ExpressionStatement): decl = parentNode.parent; */
				} else if isBinaryExpression( /* TODO(PropertyAccessExpression): parentNode.parent */ TODO) && /* TODO(PropertyAccessExpression): parentNode.parent.operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO && /* TODO(ParenthesizedExpression): (allowDeclaration || parentNode.parent.right === parentNode) */ TODO {
					/* TODO(ExpressionStatement): name = parentNode.parent.left; */
					/* TODO(ExpressionStatement): decl = name; */
				}
				if !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name /* TODO(PropertyAccessExpression): parentNode.left */, TODO) {
					return nil
				}
			}
		} else if allowDeclaration && isFunctionDeclaration(node) {
			/* TODO(ExpressionStatement): name = node.name; */
			/* TODO(ExpressionStatement): decl = node; */
		}
		if !decl || !name || /* TODO(ParenthesizedExpression): (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) */ TODO {
			return nil
		}
		return getSymbolOfNode(decl)
	}
	getAssignedJSPrototype := func(node Node) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralExpression | undefined */ TODO {
		if ! /* TODO(PropertyAccessExpression): node.parent */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		var parent Node = /* TODO(PropertyAccessExpression): node.parent */ TODO
		/* TODO(WhileStatement): while (parent && parent.kind === SyntaxKind.PropertyAccessExpression) {             parent = parent.parent;         } */
		if parent && isBinaryExpression(parent) && isPrototypeAccess( /* TODO(PropertyAccessExpression): parent.left */ TODO) && /* TODO(PropertyAccessExpression): parent.operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO {
			right := getInitializerOfBinaryExpression(parent)
			return isObjectLiteralExpression(right) && right
		}
	}
	checkCallExpression := func(node /* TODO(UnionType): CallExpression | NewExpression */ any, checkMode CheckMode) Type {
		checkGrammarTypeArguments(node /* TODO(PropertyAccessExpression): node.typeArguments */, TODO)
		signature := getResolvedSignature(node, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		checkDeprecatedSignature(signature, node)
		if /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO {
			return voidType
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NewExpression */ TODO {
			declaration := /* TODO(PropertyAccessExpression): signature.declaration */ TODO
			if declaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.Constructor */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.ConstructSignature */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.ConstructorType */ TODO && ! /* TODO(ParenthesizedExpression): (isJSDocSignature(declaration) && getJSDocRoot(declaration)?.parent?.kind === SyntaxKind.Constructor) */ TODO && !isJSDocConstructSignature(declaration) && !isJSConstructor(declaration) {
				if noImplicitAny {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type */, TODO)
				}
				return anyType
			}
		}
		if isInJSFile(node) && isCommonJsRequire(node) {
			return resolveExternalModuleTypeByLiteral( /* TODO(ElementAccessExpression): node.arguments![0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */)
		}
		returnType := getReturnTypeOfSignature(signature)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): returnType.flags & TypeFlags.ESSymbolLike */ TODO && isSymbolOrSymbolForCall(node) {
			return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions( /* TODO(PropertyAccessExpression): node.parent */ TODO))
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CallExpression */ TODO && ! /* TODO(PropertyAccessExpression): node.questionDotToken */ TODO && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExpressionStatement */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): returnType.flags & TypeFlags.Void */ TODO && getTypePredicateOfSignature(signature) {
			if !isDottedName( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
				error( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name */, TODO)
			} else if !getEffectsSignature(node) {
				diagnostic := error( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation */, TODO)
				getTypeOfDottedName( /* TODO(PropertyAccessExpression): node.expression */ TODO, diagnostic)
			}
		}
		if isInJSFile(node) {
			jsSymbol := getSymbolOfExpando(node /* TODO(FalseKeyword): false */, TODO)
			if /* TODO(PropertyAccessExpression): jsSymbol?.exports?.size */ TODO {
				jsAssignmentType := createAnonymousType(jsSymbol /* TODO(PropertyAccessExpression): jsSymbol.exports */, TODO, emptyArray, emptyArray, emptyArray)
				/* TODO(ExpressionStatement): jsAssignmentType.objectFlags |= ObjectFlags.JSLiteral; */
				return getIntersectionType( /* TODO(ArrayLiteralExpression): [returnType, jsAssignmentType] */ TODO)
			}
		}
		return returnType
	}
	checkDeprecatedSignature := func(signature Signature, node CallLikeExpression) {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsSignatureCandidateForOverloadFailure */ TODO {
		}
		if /* TODO(PropertyAccessExpression): signature.declaration */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.declaration.flags & NodeFlags.Deprecated */ TODO {
			suggestionNode := getDeprecatedSuggestionNode(node)
			name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
			addDeprecatedSuggestionWithSignature(suggestionNode /* TODO(PropertyAccessExpression): signature.declaration */, TODO, name, signatureToString(signature))
		}
	}
	getDeprecatedSuggestionNode := func(node Node) Node {
		/* TODO(ExpressionStatement): node = skipParentheses(node); */
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:             case SyntaxKind.Decorator:             case SyntaxKind.NewExpression:                 return getDeprecatedSuggestionNode((node as Decorator | CallExpression | NewExpression).expression);             case SyntaxKind.TaggedTemplateExpression:                 return getDeprecatedSuggestionNode((node as TaggedTemplateExpression).tag);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return getDeprecatedSuggestionNode((node as JsxOpeningLikeElement).tagName);             case SyntaxKind.ElementAccessExpression:                 return (node as ElementAccessExpression).argumentExpression;             case SyntaxKind.PropertyAccessExpression:                 return (node as PropertyAccessExpression).name;             case SyntaxKind.TypeReference:                 const typeReference = node as TypeReferenceNode;                 return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;             default:                 return node;         } */
	}
	isSymbolOrSymbolForCall := func(node Node) /* TODO(undefined): boolean */ TODO {
		if !isCallExpression(node) {
			/* TODO(FalseKeyword): false */
		}
		left := /* TODO(PropertyAccessExpression): node.expression */ TODO
		if isPropertyAccessExpression(left) && /* TODO(PropertyAccessExpression): left.name.escapedText */ TODO == "for" {
			/* TODO(ExpressionStatement): left = left.expression; */
		}
		if !isIdentifier(left) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): left.escapedText !== "Symbol" */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		globalESSymbol := getGlobalESSymbolConstructorSymbol( /* TODO(FalseKeyword): false */ TODO)
		if !globalESSymbol {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return globalESSymbol == resolveName(left, "Symbol" /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO, nil /* TODO(FalseKeyword): false */, TODO)
	}
	checkImportCallExpression := func(node ImportCall) Type {
		checkGrammarImportCallExpression(node)
		if /* TODO(PropertyAccessExpression): node.arguments.length */ TODO == 0 {
			return createPromiseReturnType(node, anyType)
		}
		specifier := /* TODO(ElementAccessExpression): node.arguments[0] */ TODO
		specifierType := checkExpressionCached(specifier)
		optionsType := /* TODO(ConditionalExpression): node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : undefined */ TODO
		/* TODO(ForStatement): for (let i = 2; i < node.arguments.length; ++i) {             checkExpressionCached(node.arguments[i]);         } */
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): specifierType.flags & TypeFlags.Undefined */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): specifierType.flags & TypeFlags.Null */ TODO || !isTypeAssignableTo(specifierType, stringType) {
			error(specifier /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0 */, TODO, typeToString(specifierType))
		}
		if optionsType {
			importCallOptionsType := getGlobalImportCallOptionsType( /* TODO(TrueKeyword): true */ TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): importCallOptionsType !== emptyObjectType */ TODO {
				checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, TODO) /* TODO(ElementAccessExpression): node.arguments[1] */, TODO)
			}
		}
		moduleSymbol := resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			esModuleSymbol := resolveESModuleSymbol(moduleSymbol, specifier /* TODO(TrueKeyword): true */, TODO /* TODO(FalseKeyword): false */, TODO)
			if esModuleSymbol {
				return createPromiseReturnType(node, getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier))
			}
		}
		return createPromiseReturnType(node, anyType)
	}
	createDefaultPropertyWrapperForModule := func(symbol Symbol, originalSymbol *Symbol, anonymousSymbol *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
		memberTable := createSymbolTable()
		newSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Alias */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Default */, TODO)
		/* TODO(ExpressionStatement): newSymbol.parent = originalSymbol; */
		/* TODO(ExpressionStatement): newSymbol.links.nameType = getStringLiteralType("default"); */
		/* TODO(ExpressionStatement): newSymbol.links.aliasTarget = resolveSymbol(symbol); */
		/* TODO(PropertyAccessExpression): memberTable.set */
		TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.Default */ TODO, newSymbol)
		return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
	}
	getTypeWithSyntheticDefaultOnly := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		hasDefaultOnly := isOnlyImportableAsDefault(moduleSpecifier)
		if hasDefaultOnly && type_ && !isErrorType(type_) {
			synthType := type_ /* as */ /* TODO(TypeReference): SyntheticDefaultModuleType */
			if ! /* TODO(PropertyAccessExpression): synthType.defaultOnlyType */ TODO {
				type_ := createDefaultPropertyWrapperForModule(symbol, originalSymbol)
				/* TODO(ExpressionStatement): synthType.defaultOnlyType = type; */
			}
			return /* TODO(PropertyAccessExpression): synthType.defaultOnlyType */ TODO
		}
		return nil
	}
	getTypeWithSyntheticDefaultImportType := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
		if allowSyntheticDefaultImports && type_ && !isErrorType(type_) {
			synthType := type_ /* as */ /* TODO(TypeReference): SyntheticDefaultModuleType */
			if ! /* TODO(PropertyAccessExpression): synthType.syntheticType */ TODO {
				file := /* TODO(PropertyAccessExpression): originalSymbol.declarations?.find */ TODO(isSourceFile)
				hasSyntheticDefault := canHaveSyntheticDefault(file, originalSymbol /* TODO(FalseKeyword): false */, TODO, moduleSpecifier)
				if hasSyntheticDefault {
					anonymousSymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.TypeLiteral */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Type */, TODO)
					defaultContainingObject := createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
					/* TODO(ExpressionStatement): anonymousSymbol.links.type = defaultContainingObject; */
					/* TODO(ExpressionStatement): synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags* / 0, /*readonly* / false) : defaultContainingObject; */
				} else {
					/* TODO(ExpressionStatement): synthType.syntheticType = type; */
				}
			}
			return /* TODO(PropertyAccessExpression): synthType.syntheticType */ TODO
		}
		return type_
	}
	isCommonJsRequire := func(node Node) bool {
		if !isRequireCall(node /* TODO(TrueKeyword): true */, TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if !isIdentifier( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			/* TODO(CallExpression): Debug.fail() */
		}
		resolvedRequire := /* TODO(NonNullExpression): resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / true)! */ TODO
		if resolvedRequire == requireSymbol {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): resolvedRequire.flags & SymbolFlags.Alias */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		targetDeclarationKind := /* TODO(ConditionalExpression): resolvedRequire.flags & SymbolFlags.Function             ? SyntaxKind.FunctionDeclaration             : resolvedRequire.flags & SymbolFlags.Variable             ? SyntaxKind.VariableDeclaration             : SyntaxKind.Unknown */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetDeclarationKind !== SyntaxKind.Unknown */ TODO {
			decl := /* TODO(NonNullExpression): getDeclarationOfKind(resolvedRequire, targetDeclarationKind)! */ TODO
			return !!decl && !! /* TODO(ParenthesizedExpression): (decl.flags & NodeFlags.Ambient) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkTaggedTemplateExpression := func(node TaggedTemplateExpression) Type {
		if !checkGrammarTaggedTemplateChain(node) {
			/* TODO(CallExpression): checkGrammarTypeArguments(node, node.typeArguments) */
		}
		if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.TaggedTemplates */ TODO {
			checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.MakeTemplateObject */, TODO)
		}
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		return getReturnTypeOfSignature(signature)
	}
	checkAssertion := func(node AssertionExpression, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeAssertionExpression */ TODO {
			file := getSourceFileOfNode(node)
			if file && fileExtensionIsOneOf( /* TODO(PropertyAccessExpression): file.fileName */ TODO /* TODO(ArrayLiteralExpression): [Extension.Cts, Extension.Mts] */, TODO) {
				grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead */, TODO)
			}
		}
		return checkAssertionWorker(node, checkMode)
	}
	isValidConstAssertionArgument := func(node Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.StringLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.TemplateExpression:                 return true;             case SyntaxKind.ParenthesizedExpression:                 return isValidConstAssertionArgument((node as ParenthesizedExpression).expression);             case SyntaxKind.PrefixUnaryExpression:                 const op = (node as PrefixUnaryExpression).operator;                 const arg = (node as PrefixUnaryExpression).operand;                 return op === SyntaxKind.MinusToken && (arg.kind === SyntaxKind.NumericLiteral || arg.kind === SyntaxKind.BigIntLiteral) ||                     op === SyntaxKind.PlusToken && arg.kind === SyntaxKind.NumericLiteral;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const expr = skipParentheses((node as PropertyAccessExpression | ElementAccessExpression).expression);                 const symbol = isEntityNameExpression(expr) ? resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors* / true) : undefined;                 return !!(symbol && symbol.flags & SymbolFlags.Enum);         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkAssertionWorker := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		exprType := checkExpression(expression, checkMode)
		if isConstTypeReference(type_) {
			if !isValidConstAssertionArgument(expression) {
				error(expression /* TODO(PropertyAccessExpression): Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals */, TODO)
			}
			return getRegularTypeOfLiteralType(exprType)
		}
		links := getNodeLinks(node)
		/* TODO(ExpressionStatement): links.assertionExpressionType = exprType; */
		checkSourceElement(type_)
		checkNodeDeferred(node)
		return getTypeFromTypeNode(type_)
	}
	getAssertionTypeAndExpression := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) /* TODO(undefined): { type: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode; expression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; } */ TODO {
		var type_ TypeNode
		var expression Expression
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AsExpression:             case SyntaxKind.TypeAssertionExpression:                 type = node.type;                 expression = node.expression;                 break;             case SyntaxKind.ParenthesizedExpression:                 type = getJSDocTypeAssertionType(node);                 expression = node.expression;                 break;         } */
		return /* TODO(ObjectLiteralExpression): { type, expression } */ TODO
	}
	checkAssertionDeferred := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		errNode := /* TODO(ConditionalExpression): isParenthesizedExpression(node) ? type : node */ TODO
		links := getNodeLinks(node)
		/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO( /* TODO(PropertyAccessExpression): links.assertionExpressionType */ TODO)
		exprType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType( /* TODO(PropertyAccessExpression): links.assertionExpressionType */ TODO))
		targetType := getTypeFromTypeNode(type_)
		if !isErrorType(targetType) {
			addLazyDiagnostic( /* TODO(ArrowFunction): () => {                 const widenedType = getWidenedType(exprType);                 if (!isTypeComparableTo(targetType, widenedType)) {                     checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);                 }             } */ TODO)
		}
	}
	checkNonNullChain := func(node NonNullChain) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		nonOptionalType := getOptionalExpressionType(leftType /* TODO(PropertyAccessExpression): node.expression */, TODO)
		return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== leftType */, TODO)
	}
	checkNonNullAssertion := func(node NonNullExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node as NonNullChain) :             getNonNullableType(checkExpression(node.expression)) */ TODO
	}
	checkExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkGrammarExpressionWithTypeArguments(node)
		forEach( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, checkSourceElement)
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExpressionWithTypeArguments */ TODO {
			parent := walkUpParenthesizedExpressions( /* TODO(PropertyAccessExpression): node.parent */ TODO)
			if /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (parent as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InstanceOfKeyword */ TODO && isNodeDescendantOf(node /* TODO(PropertyAccessExpression): (parent as BinaryExpression).right */, TODO) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression */, TODO)
			}
		}
		exprType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExpressionWithTypeArguments ? checkExpression(node.expression) :             isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) :             checkExpression(node.exprName) */ TODO
		return getInstantiationExpressionType(exprType, node)
	}
	getInstantiationExpressionType := func(exprType Type, node NodeWithTypeArguments) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeArguments := /* TODO(PropertyAccessExpression): node.typeArguments */ TODO
		if exprType == silentNeverType || isErrorType(exprType) || !some(typeArguments) {
			return exprType
		}
		hasSomeApplicableSignature := /* TODO(FalseKeyword): false */ TODO
		var nonApplicableType *Type
		result := getInstantiatedType(exprType)
		errorType := /* TODO(ConditionalExpression): hasSomeApplicableSignature ? nonApplicableType : exprType */ TODO
		if errorType {
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments /* TODO(PropertyAccessExpression): Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable */, TODO, typeToString(errorType)))
		}
		return result
		getInstantiatedType := func(type_ Type) Type {
			hasSignatures := /* TODO(FalseKeyword): false */ TODO
			hasApplicableSignature := /* TODO(FalseKeyword): false */ TODO
			result := getInstantiatedTypePart(type_)
			/* TODO(ExpressionStatement): hasSomeApplicableSignature ||= hasApplicableSignature; */
			if hasSignatures && !hasApplicableSignature {
				/* TODO(ExpressionStatement): nonApplicableType ??= type; */
			}
			return result
			getInstantiatedTypePart := func(type_ Type) Type {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Object */ TODO {
					resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
					callSignatures := getInstantiatedSignatures( /* TODO(PropertyAccessExpression): resolved.callSignatures */ TODO)
					constructSignatures := getInstantiatedSignatures( /* TODO(PropertyAccessExpression): resolved.constructSignatures */ TODO)
					/* TODO(ExpressionStatement): hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0; */
					/* TODO(ExpressionStatement): hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0; */
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): callSignatures !== resolved.callSignatures */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constructSignatures !== resolved.constructSignatures */ TODO {
						result := createAnonymousType(createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.InstantiationExpression */, TODO) /* TODO(PropertyAccessExpression): resolved.members */, TODO, callSignatures, constructSignatures /* TODO(PropertyAccessExpression): resolved.indexInfos */, TODO) /* as */ /* TODO(IntersectionType): ResolvedType & InstantiationExpressionType */
						/* TODO(ExpressionStatement): result.objectFlags |= ObjectFlags.InstantiationExpressionType; */
						/* TODO(ExpressionStatement): result.node = node; */
						return result
					}
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.InstantiableNonPrimitive */ TODO {
					constraint := getBaseConstraintOfType(type_)
					if constraint {
						instantiated := getInstantiatedTypePart(constraint)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): instantiated !== constraint */ TODO {
							return instantiated
						}
					}
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
					return mapType(type_, getInstantiatedType)
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Intersection */ TODO {
					return getIntersectionType(sameMap( /* TODO(PropertyAccessExpression): (type as IntersectionType).types */ TODO, getInstantiatedTypePart))
				}
				return type_
			}
		}
		getInstantiatedSignatures := func(signatures []Signature) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			applicableSignatures := filter(signatures /* TODO(ArrowFunction): sig => !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments) */, TODO)
			return sameMap(applicableSignatures /* TODO(ArrowFunction): sig => {                 const typeArgumentTypes = checkTypeArguments(sig, typeArguments!, /*reportErrors* / true);                 return typeArgumentTypes ? getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration)) : sig;             } */, TODO)
		}
	}
	checkSatisfiesExpression := func(node SatisfiesExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		return checkSatisfiesExpressionWorker( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): node.type */, TODO)
	}
	checkSatisfiesExpressionWorker := func(expression Expression, target TypeNode, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		exprType := checkExpression(expression, checkMode)
		targetType := getTypeFromTypeNode(target)
		if isErrorType(targetType) {
			return targetType
		}
		errorNode := findAncestor( /* TODO(PropertyAccessExpression): target.parent */ TODO /* TODO(ArrowFunction): n => n.kind === SyntaxKind.SatisfiesExpression || n.kind === SyntaxKind.JSDocSatisfiesTag */, TODO)
		checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression /* TODO(PropertyAccessExpression): Diagnostics.Type_0_does_not_satisfy_the_expected_type_1 */, TODO)
		return exprType
	}
	checkMetaProperty := func(node MetaProperty) Type {
		checkGrammarMetaProperty(node)
		if /* TODO(PropertyAccessExpression): node.keywordToken */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NewKeyword */ TODO {
			return checkNewTargetMetaProperty(node)
		}
		if /* TODO(PropertyAccessExpression): node.keywordToken */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportKeyword */ TODO {
			return checkImportMetaProperty(node)
		}
		return /* TODO(PropertyAccessExpression): Debug.assertNever */ TODO( /* TODO(PropertyAccessExpression): node.keywordToken */ TODO)
	}
	checkMetaPropertyKeyword := func(node MetaProperty) Type {
		/* TODO(SwitchStatement): switch (node.keywordToken) {             case SyntaxKind.ImportKeyword:                 return getGlobalImportMetaExpressionType();             case SyntaxKind.NewKeyword:                 const type = checkNewTargetMetaProperty(node);                 return isErrorType(type) ? errorType : createNewTargetExpressionType(type);             default:                 Debug.assertNever(node.keywordToken);         } */
	}
	checkNewTargetMetaProperty := func(node MetaProperty) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		container := getNewTargetContainer(node)
		if !container {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor */, TODO, "new.target")
			return errorType
		} else if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
			symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): container.parent */ TODO)
			return getTypeOfSymbol(symbol)
		} else {
			symbol := getSymbolOfDeclaration(container)
			return getTypeOfSymbol(symbol)
		}
	}
	checkImportMetaProperty := func(node MetaProperty) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		if moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.Node16 */ TODO || moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.NodeNext */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(node).impliedNodeFormat !== ModuleKind.ESNext */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output */, TODO)
			}
		} else if moduleKind < /* TODO(PropertyAccessExpression): ModuleKind.ES2020 */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.System */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext */, TODO)
		}
		file := getSourceFileOfNode(node)
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (file.flags & NodeFlags.PossiblyContainsImportMeta) */ TODO, "Containing file is missing import meta node flag.")
		return /* TODO(ConditionalExpression): node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType */ TODO
	}
	getTypeOfParameter := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		return addOptionality(getTypeOfSymbol(symbol) /* TODO(FalseKeyword): false */, TODO, !!declaration && /* TODO(ParenthesizedExpression): (hasInitializer(declaration) || isOptionalDeclaration(declaration)) */ TODO)
	}
	getTupleElementLabelFromBindingElement := func(node /* TODO(UnionType): BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
		/* TODO(SwitchStatement): switch (node.name.kind) {             case SyntaxKind.Identifier: {                 const name = node.name.escapedText;                 if (node.dotDotDotToken) {                     // given                     //   (...[x, y, ...z]: [number, number, ...number[]]) => ...                     // this produces                     //   (x: number, y: number, ...z: number[]) => ...                     // which preserves rest elements of 'z'                      // given                     //   (...[x, y, ...z]: [number, number, ...[...number[], number]]) => ...                     // this produces                     //   (x: number, y: number, ...z: number[], z_1: number) => ...                     // which preserves rest elements of z but gives distinct numbers to fixed elements of 'z'                     return elementFlags & ElementFlags.Variable ? name : `${name}_${index}` as __String;                 }                 else {                     // given                     //   (...[x]: [number]) => ...                     // this produces                     //   (x: number) => ...                     // which preserves fixed elements of 'x'                      // given                     //   (...[x]: ...number[]) => ...                     // this produces                     //   (x_0: number) => ...                     // which which numbers fixed elements of 'x' whose tuple element type is variable                     return elementFlags & ElementFlags.Fixed ? name : `${name}_n` as __String;                 }             }             case SyntaxKind.ArrayBindingPattern: {                 if (node.dotDotDotToken) {                     const elements = node.name.elements;                     const lastElement = tryCast(lastOrUndefined(elements), isBindingElement);                     const elementCount = elements.length - (lastElement?.dotDotDotToken ? 1 : 0);                     if (index < elementCount) {                         const element = elements[index];                         if (isBindingElement(element)) {                             return getTupleElementLabelFromBindingElement(element, index, elementFlags);                         }                     }                     else if (lastElement?.dotDotDotToken) {                         return getTupleElementLabelFromBindingElement(lastElement, index - elementCount, elementFlags);                     }                 }                 break;             }         } */
		return /* TODO(TemplateExpression): `arg_${index}` */ TODO /* as */ /* TODO(TypeReference): __String */
	}
	// OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) __String
	// OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index number, elementFlags ElementFlags, restSymbol Symbol) __String
	getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */, elementFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): ElementFlags.Fixed */, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		if !d {
			restParameter := tryCast( /* TODO(PropertyAccessExpression): restSymbol?.valueDeclaration */ TODO, isParameter)
			return /* TODO(ConditionalExpression): restParameter ? getTupleElementLabelFromBindingElement(restParameter, index, elementFlags) :                 `${restSymbol?.escapedName ?? "arg"}_${index}` as __String */ TODO
		}
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isIdentifier( /* TODO(PropertyAccessExpression): d.name */ TODO))
		return /* TODO(PropertyAccessExpression): d.name.escapedText */ TODO
	}
	getParameterNameAtPosition := func(signature Signature, pos number, overrideRestType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			return /* TODO(PropertyAccessExpression): signature.parameters[pos].escapedName */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restType := overrideRestType || getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			tupleType := /* TODO(PropertyAccessExpression): (restType as TypeReference).target */ TODO /* as */ /* TODO(TypeReference): TupleType */
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			associatedName := /* TODO(ElementAccessExpression): tupleType.labeledElementDeclarations?.[index] */ TODO
			elementFlags := /* TODO(ElementAccessExpression): tupleType.elementFlags[index] */ TODO
			return getTupleElementLabel(associatedName, index, elementFlags, restParameter)
		}
		return /* TODO(PropertyAccessExpression): restParameter.escapedName */ TODO
	}
	getParameterIdentifierInfoAtPosition := func(signature Signature, pos number) /* TODO(TypeLiteral): { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
		if /* TODO(PropertyAccessExpression): signature.declaration?.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocFunctionType */ TODO {
			return nil
		}
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			param := /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO
			paramIdent := getParameterDeclarationIdentifier(param)
			return /* TODO(ConditionalExpression): paramIdent ? {                 parameter: paramIdent,                 parameterName: param.escapedName,                 isRestParameter: false,             } : undefined */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restIdent := getParameterDeclarationIdentifier(restParameter)
		if !restIdent {
			return nil
		}
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := /* TODO(PropertyAccessExpression): ((restType as TypeReference).target as TupleType).labeledElementDeclarations */ TODO
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			associatedName := /* TODO(ElementAccessExpression): associatedNames?.[index] */ TODO
			isRestTupleElement := !! /* TODO(PropertyAccessExpression): associatedName?.dotDotDotToken */ TODO
			if associatedName {
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isIdentifier( /* TODO(PropertyAccessExpression): associatedName.name */ TODO))
				return /* TODO(ObjectLiteralExpression): { parameter: associatedName.name, parameterName: associatedName.name.escapedText, isRestParameter: isRestTupleElement } */ TODO
			}
			return nil
		}
		if pos == paramCount {
			return /* TODO(ObjectLiteralExpression): { parameter: restIdent, parameterName: restParameter.escapedName, isRestParameter: true } */ TODO
		}
		return nil
	}
	getParameterDeclarationIdentifier := func(symbol Symbol) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | undefined */ TODO {
		return /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isParameter( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) && isIdentifier( /* TODO(PropertyAccessExpression): symbol.valueDeclaration.name */ TODO) && /* TODO(PropertyAccessExpression): symbol.valueDeclaration.name */ TODO
	}
	isValidDeclarationForTupleLabel := func(d Declaration) /* TODO(TypePredicate): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ TODO {
		return /* TODO(PropertyAccessExpression): d.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamedTupleMember */ TODO || /* TODO(ParenthesizedExpression): (isParameter(d) && d.name && isIdentifier(d.name)) */ TODO
	}
	getNameableDeclarationAtPosition := func(signature Signature, pos number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ TODO {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			decl := /* TODO(PropertyAccessExpression): signature.parameters[pos].valueDeclaration */ TODO
			return /* TODO(ConditionalExpression): decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := /* TODO(PropertyAccessExpression): ((restType as TypeReference).target as TupleType).labeledElementDeclarations */ TODO
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			return associatedNames && /* TODO(ElementAccessExpression): associatedNames[index] */ TODO
		}
		return /* TODO(ConditionalExpression): restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined */ TODO
	}
	getTypeAtPosition := func(signature Signature, pos number) Type {
		return tryGetTypeAtPosition(signature, pos) || anyType
	}
	tryGetTypeAtPosition := func(signature Signature, pos number) *Type {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			return getTypeOfParameter( /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO)
		}
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO)
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			if !isTupleType(restType) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): restType.target.combinedFlags & ElementFlags.Variable */ TODO || index < /* TODO(PropertyAccessExpression): restType.target.fixedLength */ TODO {
				return getIndexedAccessType(restType, getNumberLiteralType(index))
			}
		}
		return nil
	}
	getRestTypeAtPosition := func(source Signature, pos number, readonly bool) Type {
		parameterCount := getParameterCount(source)
		minArgumentCount := getMinArgumentCount(source)
		restType := getEffectiveRestType(source)
		if restType && pos >= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): parameterCount - 1 */ TODO {
			return /* TODO(ConditionalExpression): pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType)) */ TODO
		}
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := /* TODO(ArrayLiteralExpression): [] */ TODO
		names := /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = pos; i < parameterCount; i++) {             if (!restType || i < parameterCount - 1) {                 types.push(getTypeAtPosition(source, i));                 flags.push(i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional);             }             else {                 types.push(restType);                 flags.push(ElementFlags.Variadic);             }             names.push(getNameableDeclarationAtPosition(source, i));         } */
		return createTupleType(types, flags, readonly, names)
	}
	getRestOrAnyTypeAtPosition := func(source Signature, pos number) Type {
		restType := getRestTypeAtPosition(source, pos)
		elementType := restType && getElementTypeOfArrayType(restType)
		return /* TODO(ConditionalExpression): elementType && isTypeAny(elementType) ? anyType : restType */ TODO
	}
	getParameterCount := func(signature Signature) /* TODO(undefined): number */ TODO {
		length := /* TODO(PropertyAccessExpression): signature.parameters.length */ TODO
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[length - 1] */ TODO)
			if isTupleType(restType) {
				return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): length + restType.target.fixedLength - (restType.target.combinedFlags & ElementFlags.Variable ? 0 : 1) */ TODO
			}
		}
		return length
	}
	getMinArgumentCount := func(signature Signature, flags MinArgumentCountFlags) /* TODO(undefined): number */ TODO {
		strongArityForUntypedJS := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags! & MinArgumentCountFlags.StrongArityForUntypedJS */ TODO
		voidIsNonOptional := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags! & MinArgumentCountFlags.VoidIsNonOptional */ TODO
		if voidIsNonOptional || /* TODO(PropertyAccessExpression): signature.resolvedMinArgumentCount */ TODO == nil {
			var minArgumentCount /* TODO(NumberKeyword): number */ any
			if signatureHasRestParameter(signature) {
				restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
				if isTupleType(restType) {
					firstOptionalIndex := findIndex( /* TODO(PropertyAccessExpression): restType.target.elementFlags */ TODO /* TODO(ArrowFunction): f => !(f & ElementFlags.Required) */, TODO)
					requiredCount := /* TODO(ConditionalExpression): firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex */ TODO
					if requiredCount > 0 {
						/* TODO(ExpressionStatement): minArgumentCount = signature.parameters.length - 1 + requiredCount; */
					}
				}
			}
			if minArgumentCount == nil {
				if !strongArityForUntypedJS && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): signature.flags & SignatureFlags.IsUntypedSignatureInJSFile */ TODO {
					return 0
				}
				/* TODO(ExpressionStatement): minArgumentCount = signature.minArgumentCount; */
			}
			if voidIsNonOptional {
				return minArgumentCount
			}
			/* TODO(ForStatement): for (let i = minArgumentCount - 1; i >= 0; i--) {                 const type = getTypeAtPosition(signature, i);                 if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {                     break;                 }                 minArgumentCount = i;             } */
			/* TODO(ExpressionStatement): signature.resolvedMinArgumentCount = minArgumentCount; */
		}
		return /* TODO(PropertyAccessExpression): signature.resolvedMinArgumentCount */ TODO
	}
	hasEffectiveRestParameter := func(signature Signature) /* TODO(undefined): boolean */ TODO {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			return !isTupleType(restType) || !! /* TODO(ParenthesizedExpression): (restType.target.combinedFlags & ElementFlags.Variable) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getEffectiveRestType := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			if !isTupleType(restType) {
				return /* TODO(ConditionalExpression): isTypeAny(restType) ? anyArrayType : restType */ TODO
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): restType.target.combinedFlags & ElementFlags.Variable */ TODO {
				return sliceTupleType(restType /* TODO(PropertyAccessExpression): restType.target.fixedLength */, TODO)
			}
		}
		return nil
	}
	getNonArrayRestType := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		restType := getEffectiveRestType(signature)
		return /* TODO(ConditionalExpression): restType && !isArrayType(restType) && !isTypeAny(restType) ? restType : undefined */ TODO
	}
	getTypeOfFirstParameterOfSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType)
	}
	getTypeOfFirstParameterOfSignatureWithFallback := func(signature Signature, fallbackType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType */ TODO
	}
	inferFromAnnotatedParameters := func(signature Signature, context Signature, inferenceContext InferenceContext) {
		len := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             const declaration = signature.parameters[i].valueDeclaration as ParameterDeclaration;             const typeNode = getEffectiveTypeAnnotationNode(declaration);             if (typeNode) {                 const source = addOptionality(getTypeFromTypeNode(typeNode), /*isProperty* / false, isOptionalDeclaration(declaration));                 const target = getTypeAtPosition(context, i);                 inferTypes(inferenceContext.inferences, source, target);             }         } */
	}
	assignContextualParameterTypes := func(signature Signature, context Signature) {
		if /* TODO(PropertyAccessExpression): context.typeParameters */ TODO {
			if ! /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO {
				/* TODO(ExpressionStatement): signature.typeParameters = context.typeParameters; */
			} else {
				return
			}
		}
		if /* TODO(PropertyAccessExpression): context.thisParameter */ TODO {
			parameter := /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO
			if !parameter || /* TODO(PropertyAccessExpression): parameter.valueDeclaration */ TODO && ! /* TODO(PropertyAccessExpression): (parameter.valueDeclaration as ParameterDeclaration).type */ TODO {
				if !parameter {
					/* TODO(ExpressionStatement): signature.thisParameter = createSymbolWithType(context.thisParameter, /*type* / undefined); */
				}
				assignParameterType( /* TODO(NonNullExpression): signature.thisParameter! */ TODO, getTypeOfSymbol( /* TODO(PropertyAccessExpression): context.thisParameter */ TODO))
			}
		}
		len := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             const parameter = signature.parameters[i];             const declaration = parameter.valueDeclaration as ParameterDeclaration;             if (!getEffectiveTypeAnnotationNode(declaration)) {                 let type = tryGetTypeAtPosition(context, i);                 if (type && declaration.initializer) {                     let initializerType = checkDeclarationInitializer(declaration, CheckMode.Normal);                     if (!isTypeAssignableTo(initializerType, type) && isTypeAssignableTo(type, initializerType = widenTypeInferredFromInitializer(declaration, initializerType))) {                         type = initializerType;                     }                 }                 assignParameterType(parameter, type);             }         } */
		if signatureHasRestParameter(signature) {
			parameter := last( /* TODO(PropertyAccessExpression): signature.parameters */ TODO)
			if /* TODO(ConditionalExpression): parameter.valueDeclaration                     ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration)                     // a declarationless parameter may still have a `.type` already set by its construction logic                     // (which may pull a type from a jsdoc) - only allow fixing on `DeferredType` parameters with a fallback type                     : !!(getCheckFlags(parameter) & CheckFlags.DeferredType) */ TODO {
				contextualParameterType := getRestTypeAtPosition(context, len)
				assignParameterType(parameter, contextualParameterType)
			}
		}
	}
	assignNonContextualParameterTypes := func(signature Signature) {
		if /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO {
			assignParameterType( /* TODO(PropertyAccessExpression): signature.thisParameter */ TODO)
		}
		for _, parameter := range /* TODO(PropertyAccessExpression): signature.parameters */ TODO {
			assignParameterType(parameter)
		}
	}
	assignParameterType := func(parameter Symbol, contextualType Type) {
		links := getSymbolLinks(parameter)
		if ! /* TODO(PropertyAccessExpression): links.type */ TODO {
			declaration := /* TODO(PropertyAccessExpression): parameter.valueDeclaration */ TODO /* as */ /* TODO(UnionType): ParameterDeclaration | undefined */
			/* TODO(ExpressionStatement): links.type = addOptionality(                 contextualType || (declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true) : getTypeOfSymbol(parameter)),                 /*isProperty* / false,                 /*isOptional* / !!declaration && !declaration.initializer && isOptionalDeclaration(declaration),             ); */
			if declaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.name.kind !== SyntaxKind.Identifier */ TODO {
				if /* TODO(PropertyAccessExpression): links.type */ TODO == unknownType {
					/* TODO(ExpressionStatement): links.type = getTypeFromBindingPattern(declaration.name); */
				}
				assignBindingElementTypes( /* TODO(PropertyAccessExpression): declaration.name */ TODO /* TODO(PropertyAccessExpression): links.type */, TODO)
			}
		} else if contextualType {
			/* TODO(PropertyAccessExpression): Debug.assertEqual */ TODO( /* TODO(PropertyAccessExpression): links.type */ TODO, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type")
		}
	}
	assignBindingElementTypes := func(pattern BindingPattern, parentType Type) {
		for _, element := range /* TODO(PropertyAccessExpression): pattern.elements */ TODO {
			if !isOmittedExpression(element) {
				type_ := getBindingElementTypeFromParentType(element, parentType /* TODO(FalseKeyword): false */, TODO)
				if /* TODO(PropertyAccessExpression): element.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
					/* TODO(ExpressionStatement): getSymbolLinks(getSymbolOfDeclaration(element)).type = type; */
				} else {
					assignBindingElementTypes( /* TODO(PropertyAccessExpression): element.name */ TODO, type_)
				}
			}
		}
	}
	createClassDecoratorContextType := func(classType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassDecoratorContextType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [classType] */, TODO)
	}
	createClassMethodDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassGetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassSetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassAccessorDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassFieldDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	getClassMemberDecoratorContextOverrideType := func(nameType Type, isPrivate bool, isStatic bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `${isPrivate ? "p" : "P"}${isStatic ? "s" : "S"}${nameType.id}` */ TODO /* as */ /* TODO(TypeReference): const */
		overrideType := /* TODO(PropertyAccessExpression): decoratorContextOverrideTypeCache.get */ TODO(key)
		if !overrideType {
			members := createSymbolTable()
			/* TODO(PropertyAccessExpression): members.set */ TODO("name" /* as */ /* TODO(TypeReference): __String */, createProperty("name" /* as */ /* TODO(TypeReference): __String */, nameType))
			/* TODO(PropertyAccessExpression): members.set */ TODO("private" /* as */ /* TODO(TypeReference): __String */, createProperty("private" /* as */ /* TODO(TypeReference): __String */ /* TODO(ConditionalExpression): isPrivate ? trueType : falseType */, TODO))
			/* TODO(PropertyAccessExpression): members.set */ TODO("static" /* as */ /* TODO(TypeReference): __String */, createProperty("static" /* as */ /* TODO(TypeReference): __String */ /* TODO(ConditionalExpression): isStatic ? trueType : falseType */, TODO))
			/* TODO(ExpressionStatement): overrideType = createAnonymousType(/*symbol* / undefined, members, emptyArray, emptyArray, emptyArray); */
			/* TODO(PropertyAccessExpression): decoratorContextOverrideTypeCache.set */
			TODO(key, overrideType)
		}
		return overrideType
	}
	createClassMemberDecoratorContextTypeForNode := func(node /* TODO(UnionType): MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		isStatic := hasStaticModifier(node)
		isPrivate := isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO)
		nameType := /* TODO(ConditionalExpression): isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name) */ TODO
		contextType := /* TODO(ConditionalExpression): isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) :             isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) :             isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) :             isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) :             isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) :             Debug.failBadSyntaxKind(node) */ TODO
		overrideType := getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
		return getIntersectionType( /* TODO(ArrayLiteralExpression): [contextType, overrideType] */ TODO)
	}
	createClassAccessorDecoratorTargetType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassAccessorDecoratorResultType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType( /* TODO(TrueKeyword): true */ TODO) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassFieldDecoratorInitializerMutatorType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		thisParam := createParameter("this" /* as */ /* TODO(TypeReference): __String */, thisType)
		valueParam := createParameter("value" /* as */ /* TODO(TypeReference): __String */, valueType)
		return createFunctionType(nil, thisParam /* TODO(ArrayLiteralExpression): [valueParam] */, TODO, valueType, nil, 1)
	}
	createESDecoratorCallSignature := func(targetType Type, contextType Type, nonOptionalReturnType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		targetParam := createParameter("target" /* as */ /* TODO(TypeReference): __String */, targetType)
		contextParam := createParameter("context" /* as */ /* TODO(TypeReference): __String */, contextType)
		returnType := getUnionType( /* TODO(ArrayLiteralExpression): [nonOptionalReturnType, voidType] */ TODO)
		return createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam, contextParam] */, TODO, returnType)
	}
	getESDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if ! /* TODO(PropertyAccessExpression): links.decoratorSignature */ TODO {
			/* TODO(ExpressionStatement): links.decoratorSignature = anySignature; */
			/* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression: {                     // Class decorators have a `context` of `ClassDecoratorContext<Class>`, where the `Class` type                     // argument will be the "final type" of the class after all decorators are applied.                      const node = parent as ClassDeclaration | ClassExpression;                     const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));                     const contextType = createClassDecoratorContextType(targetType);                     links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType);                     break;                 }                  case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor: {                     const node = parent as MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;                     if (!isClassLike(node.parent)) break;                      // Method decorators have a `context` of `ClassMethodDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the method.                     //                     // Getter decorators have a `context` of `ClassGetterDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the value returned by the getter.                     //                     // Setter decorators have a `context` of `ClassSetterDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the parameter of the setter.                     //                     // In all three cases, the `This` type argument is the "final type" of either the class or                     // instance, depending on whether the member was `static`.                      const valueType = isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) :                         getTypeOfNode(node);                      const thisType = hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));                      // We wrap the "input type", if necessary, to match the decoration target. For getters this is                     // something like `() => inputType`, for setters it's `(value: inputType) => void` and for                     // methods it is just the input type.                     const targetType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType;                      const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);                      // We also wrap the "output type", as needed.                     const returnType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType;                      links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);                     break;                 }                  case SyntaxKind.PropertyDeclaration: {                     const node = parent as PropertyDeclaration;                     if (!isClassLike(node.parent)) break;                      // Field decorators have a `context` of `ClassFieldDecoratorContext<This, Value>` and                     // auto-accessor decorators have a `context` of `ClassAccessorDecoratorContext<This, Value>. In                     // both cases, the `This` type argument is the "final type" of either the class or instance,                     // depending on whether the member was `static`, and the `Value` type argument corresponds to                     // the "final type" of the value stored in the field.                      const valueType = getTypeOfNode(node);                     const thisType = hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));                      // The `target` of an auto-accessor decorator is a `{ get, set }` object, representing the                     // runtime-generated getter and setter that are added to the class/prototype. The `target` of a                     // regular field decorator is always `undefined` as it isn't installed until it is initialized.                     const targetType = hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) :                         undefinedType;                      const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);                      // We wrap the "output type" depending on the declaration. For auto-accessors, we wrap the                     // "output type" in a `ClassAccessorDecoratorResult<This, In, Out>` type, which allows for                     // mutation of the runtime-generated getter and setter, as well as the injection of an                     // initializer mutator. For regular fields, we wrap the "output type" in an initializer mutator.                     const returnType = hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) :                         createClassFieldDecoratorInitializerMutatorType(thisType, valueType);                      links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);                     break;                 }             } */
		}
		return /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
	}
	getLegacyDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if ! /* TODO(PropertyAccessExpression): links.decoratorSignature */ TODO {
			/* TODO(ExpressionStatement): links.decoratorSignature = anySignature; */
			/* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression: {                     const node = parent as ClassDeclaration | ClassExpression;                     // For a class decorator, the `target` is the type of the class (e.g. the                     // "static" or "constructor" side of the class).                     const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));                     const targetParam = createParameter("target" as __String, targetType);                     links.decoratorSignature = createCallSignature(                         /*typeParameters* / undefined,                         /*thisParameter* / undefined,                         [targetParam],                         getUnionType([targetType, voidType]),                     );                     break;                 }                 case SyntaxKind.Parameter: {                     const node = parent as ParameterDeclaration;                     if (                         !isConstructorDeclaration(node.parent) &&                         !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent))                     ) {                         break;                     }                      if (getThisParameter(node.parent) === node) {                         break;                     }                      const index = getThisParameter(node.parent) ?                         node.parent.parameters.indexOf(node) - 1 :                         node.parent.parameters.indexOf(node);                     Debug.assert(index >= 0);                      // A parameter declaration decorator will have three arguments (see `ParameterDecorator` in                     // core.d.ts).                      const targetType = isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) :                         getParentTypeOfClassElement(node.parent);                      const keyType = isConstructorDeclaration(node.parent) ? undefinedType :                         getClassElementPropertyKeyType(node.parent);                      const indexType = getNumberLiteralType(index);                      const targetParam = createParameter("target" as __String, targetType);                     const keyParam = createParameter("propertyKey" as __String, keyType);                     const indexParam = createParameter("parameterIndex" as __String, indexType);                     links.decoratorSignature = createCallSignature(                         /*typeParameters* / undefined,                         /*thisParameter* / undefined,                         [targetParam, keyParam, indexParam],                         voidType,                     );                     break;                 }                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.PropertyDeclaration: {                     const node = parent as MethodDeclaration | AccessorDeclaration | PropertyDeclaration;                     if (!isClassLike(node.parent)) break;                      // A method or accessor declaration decorator will have either two or three arguments (see                     // `PropertyDecorator` and `MethodDecorator` in core.d.ts).                      const targetType = getParentTypeOfClassElement(node);                     const targetParam = createParameter("target" as __String, targetType);                      const keyType = getClassElementPropertyKeyType(node);                     const keyParam = createParameter("propertyKey" as __String, keyType);                      const returnType = isPropertyDeclaration(node) ? voidType :                         createTypedPropertyDescriptorType(getTypeOfNode(node));                      const hasPropDesc = !isPropertyDeclaration(parent) || hasAccessorModifier(parent);                     if (hasPropDesc) {                         const descriptorType = createTypedPropertyDescriptorType(getTypeOfNode(node));                         const descriptorParam = createParameter("descriptor" as __String, descriptorType);                         links.decoratorSignature = createCallSignature(                             /*typeParameters* / undefined,                             /*thisParameter* / undefined,                             [targetParam, keyParam, descriptorParam],                             getUnionType([returnType, voidType]),                         );                     }                     else {                         links.decoratorSignature = createCallSignature(                             /*typeParameters* / undefined,                             /*thisParameter* / undefined,                             [targetParam, keyParam],                             getUnionType([returnType, voidType]),                         );                     }                     break;                 }             } */
		}
		return /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
	}
	getDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		return /* TODO(ConditionalExpression): legacyDecorators ? getLegacyDecoratorCallSignature(decorator) :             getESDecoratorCallSignature(decorator) */ TODO
	}
	createPromiseType := func(promisedType Type) Type {
		globalPromiseType := getGlobalPromiseType( /* TODO(TrueKeyword): true */ TODO)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalPromiseType !== emptyGenericType */ TODO {
			/* TODO(ExpressionStatement): promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType; */
			return createTypeReference(globalPromiseType /* TODO(ArrayLiteralExpression): [promisedType] */, TODO)
		}
		return unknownType
	}
	createPromiseLikeType := func(promisedType Type) Type {
		globalPromiseLikeType := getGlobalPromiseLikeType( /* TODO(TrueKeyword): true */ TODO)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalPromiseLikeType !== emptyGenericType */ TODO {
			/* TODO(ExpressionStatement): promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType; */
			return createTypeReference(globalPromiseLikeType /* TODO(ArrayLiteralExpression): [promisedType] */, TODO)
		}
		return unknownType
	}
	createPromiseReturnType := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | ImportCall */ any, promisedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		promiseType := createPromiseType(promisedType)
		if promiseType == unknownType {
			error(func_ /* TODO(ConditionalExpression): isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option */, TODO)
			return errorType
		} else if !getGlobalPromiseConstructorSymbol( /* TODO(TrueKeyword): true */ TODO) {
			error(func_ /* TODO(ConditionalExpression): isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option */, TODO)
		}
		return promiseType
	}
	createNewTargetExpressionType := func(targetType Type) Type {
		symbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO, "NewTargetExpression" /* as */ /* TODO(TypeReference): __String */)
		targetPropertySymbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Property */ TODO, "target" /* as */ /* TODO(TypeReference): __String */ /* TODO(PropertyAccessExpression): CheckFlags.Readonly */, TODO)
		/* TODO(ExpressionStatement): targetPropertySymbol.parent = symbol; */
		/* TODO(ExpressionStatement): targetPropertySymbol.links.type = targetType; */
		members := createSymbolTable( /* TODO(ArrayLiteralExpression): [targetPropertySymbol] */ TODO)
		/* TODO(ExpressionStatement): symbol.members = members; */
		return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	getReturnTypeFromBody := func(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
		if ! /* TODO(PropertyAccessExpression): func.body */ TODO {
			return errorType
		}
		functionFlags := getFunctionFlags(func_)
		isAsync := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
		isGenerator := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Generator) !== 0 */ TODO
		var returnType *Type
		var yieldType *Type
		var nextType *Type
		var fallbackReturnType Type = voidType
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.body.kind !== SyntaxKind.Block */ TODO {
			/* TODO(ExpressionStatement): returnType = checkExpressionCached(func.body, checkMode && checkMode & ~CheckMode.SkipGenericFunctions); */
			if isAsync {
				/* TODO(ExpressionStatement): returnType = unwrapAwaitedType(checkAwaitedType(returnType, /*withAlias* / false, /*errorNode* / func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)); */
			}
		} else if isGenerator {
			returnTypes := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !returnTypes {
				/* TODO(ExpressionStatement): fallbackReturnType = neverType; */
			} else if /* TODO(PropertyAccessExpression): returnTypes.length */ TODO > 0 {
				/* TODO(ExpressionStatement): returnType = getUnionType(returnTypes, UnionReduction.Subtype); */
			}
			TODO_IDENTIFIER := checkAndAggregateYieldOperandTypes(func_, checkMode)
			/* TODO(ExpressionStatement): yieldType = some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined; */
			/* TODO(ExpressionStatement): nextType = some(nextTypes) ? getIntersectionType(nextTypes) : undefined; */
		} else {
			types := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !types {
				return /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? createPromiseReturnType(func, neverType) // Async function                     : neverType */ TODO
			}
			if /* TODO(PropertyAccessExpression): types.length */ TODO == 0 {
				contextualReturnType := getContextualReturnType(func_, nil)
				returnType := /* TODO(ConditionalExpression): contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType */ TODO
				return /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, returnType) : // Async function                     returnType */ TODO
			}
			/* TODO(ExpressionStatement): returnType = getUnionType(types, UnionReduction.Subtype); */
		}
		if returnType || yieldType || nextType {
			if yieldType {
				/* TODO(CallExpression): reportErrorsFromWidening(func, yieldType, WideningKind.GeneratorYield) */
			}
			if returnType {
				/* TODO(CallExpression): reportErrorsFromWidening(func, returnType, WideningKind.FunctionReturn) */
			}
			if nextType {
				/* TODO(CallExpression): reportErrorsFromWidening(func, nextType, WideningKind.GeneratorNext) */
			}
			if returnType && isUnitType(returnType) || yieldType && isUnitType(yieldType) || nextType && isUnitType(nextType) {
				contextualSignature := getContextualSignatureForFunctionLikeDeclaration(func_)
				contextualType := /* TODO(ConditionalExpression): !contextualSignature ? undefined :                     contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :                     instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags* / undefined) */ TODO
				if isGenerator {
					/* TODO(ExpressionStatement): yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKind.Yield, isAsync); */
					/* TODO(ExpressionStatement): returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKind.Return, isAsync); */
					/* TODO(ExpressionStatement): nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKind.Next, isAsync); */
				} else {
					/* TODO(ExpressionStatement): returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync); */
				}
			}
			if yieldType {
				/* TODO(BinaryExpression): yieldType = getWidenedType(yieldType) */
			}
			if returnType {
				/* TODO(BinaryExpression): returnType = getWidenedType(returnType) */
			}
			if nextType {
				/* TODO(BinaryExpression): nextType = getWidenedType(nextType) */
			}
		}
		if isGenerator {
			return createGeneratorType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType( /* TODO(PropertyAccessExpression): IterationTypeKind.Next */ TODO, func_) || unknownType, isAsync)
		} else {
			return /* TODO(ConditionalExpression): isAsync                 ? createPromiseType(returnType || fallbackReturnType)                 : returnType || fallbackReturnType */ TODO
		}
	}
	createGeneratorType := func(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		globalGeneratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalGeneratorType */ TODO( /* TODO(FalseKeyword): false */ TODO)
		/* TODO(ExpressionStatement): yieldType = resolver.resolveIterationType(yieldType, /*errorNode* / undefined) || unknownType; */
		/* TODO(ExpressionStatement): returnType = resolver.resolveIterationType(returnType, /*errorNode* / undefined) || unknownType; */
		if globalGeneratorType == emptyGenericType {
			globalIterableIteratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalIterableIteratorType */ TODO( /* TODO(FalseKeyword): false */ TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalIterableIteratorType !== emptyGenericType */ TODO {
				return createTypeFromGenericGlobalType(globalIterableIteratorType /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */, TODO)
			}
			/* TODO(PropertyAccessExpression): resolver.getGlobalIterableIteratorType */ TODO( /* TODO(TrueKeyword): true */ TODO)
			return emptyObjectType
		}
		return createTypeFromGenericGlobalType(globalGeneratorType /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */, TODO)
	}
	checkAndAggregateYieldOperandTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(undefined): { yieldTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; nextTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; } */ TODO {
		var yieldTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var nextTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		isAsync := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getFunctionFlags(func) & FunctionFlags.Async) !== 0 */ TODO
		forEachYieldExpression( /* TODO(PropertyAccessExpression): func.body */ TODO /* as */ /* TODO(TypeReference): Block */ /* TODO(ArrowFunction): yieldExpression => {             const yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;             pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));             let nextType: Type | undefined;             if (yieldExpression.asteriskToken) {                 const iterationTypes = getIterationTypesOfIterable(                     yieldExpressionType,                     isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar,                     yieldExpression.expression,                 );                 nextType = iterationTypes && iterationTypes.nextType;             }             else {                 nextType = getContextualType(yieldExpression, /*contextFlags* / undefined);             }             if (nextType) pushIfUnique(nextTypes, nextType);         } */, TODO)
		return /* TODO(ObjectLiteralExpression): { yieldTypes, nextTypes } */ TODO
	}
	getYieldedTypeOfYieldExpression := func(node YieldExpression, expressionType Type, sentType Type, isAsync bool) *Type {
		errorNode := /* TODO(PropertyAccessExpression): node.expression */ TODO || node
		yieldedType := /* TODO(ConditionalExpression): node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType */ TODO
		return /* TODO(ConditionalExpression): !isAsync ? yieldedType : getAwaitedType(             yieldedType,             errorNode,             node.asteriskToken                 ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member                 : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,         ) */ TODO
	}
	getNotEqualFactsFromTypeofSwitch := func(start number, end number, witnesses [] /* TODO(StringKeyword): string */ any) TypeFacts {
		var facts TypeFacts = /* TODO(PropertyAccessExpression): TypeFacts.None */ TODO
		/* TODO(ForStatement): for (let i = 0; i < witnesses.length; i++) {             const witness = i < start || i >= end ? witnesses[i] : undefined;             facts |= witness !== undefined ? typeofNEFacts.get(witness) || TypeFacts.TypeofNEHostObject : 0;         } */
		return facts
	}
	isExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		links := getNodeLinks(node)
		if /* TODO(PropertyAccessExpression): links.isExhaustive */ TODO == nil {
			/* TODO(ExpressionStatement): links.isExhaustive = 0; */
			exhaustive := computeExhaustiveSwitchStatement(node)
			if /* TODO(PropertyAccessExpression): links.isExhaustive */ TODO == 0 {
				/* TODO(ExpressionStatement): links.isExhaustive = exhaustive; */
			}
		} else if /* TODO(PropertyAccessExpression): links.isExhaustive */ TODO == 0 {
			/* TODO(ExpressionStatement): links.isExhaustive = false; */
		}
		return /* TODO(PropertyAccessExpression): links.isExhaustive */ TODO
	}
	computeExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		if /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeOfExpression */ TODO {
			witnesses := getSwitchClauseTypeOfWitnesses(node)
			if !witnesses {
				return /* TODO(FalseKeyword): false */ TODO
			}
			operandConstraint := getBaseConstraintOrType(checkExpressionCached( /* TODO(PropertyAccessExpression): (node.expression as TypeOfExpression).expression */ TODO))
			notEqualFacts := getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): operandConstraint.flags & TypeFlags.AnyOrUnknown */ TODO {
				return /* TODO(ParenthesizedExpression): (TypeFacts.AllTypeofNE & notEqualFacts) */ TODO == /* TODO(PropertyAccessExpression): TypeFacts.AllTypeofNE */ TODO
			}
			return !someType(operandConstraint /* TODO(ArrowFunction): t => getTypeFacts(t, notEqualFacts) === notEqualFacts */, TODO)
		}
		type_ := checkExpressionCached( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		if !isLiteralType(type_) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		switchTypes := getSwitchClauseTypes(node)
		if ! /* TODO(PropertyAccessExpression): switchTypes.length */ TODO || some(switchTypes, isNeitherUnitTypeNorNever) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return eachTypeContainedIn(mapType(type_, getRegularTypeOfLiteralType), switchTypes)
	}
	functionHasImplicitReturn := func(func_ FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		return /* TODO(PropertyAccessExpression): func.endFlowNode */ TODO && isReachableFlowNode( /* TODO(PropertyAccessExpression): func.endFlowNode */ TODO)
	}
	checkAndAggregateReturnExpressionTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(ArrayType): Type[] */ any {
		functionFlags := getFunctionFlags(func_)
		var aggregatedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		hasReturnWithNoExpression := functionHasImplicitReturn(func_)
		hasReturnOfTypeNever := /* TODO(FalseKeyword): false */ TODO
		forEachReturnStatement( /* TODO(PropertyAccessExpression): func.body */ TODO /* as */ /* TODO(TypeReference): Block */ /* TODO(ArrowFunction): returnStatement => {             let expr = returnStatement.expression;             if (expr) {                 expr = skipParentheses(expr, /*excludeJSDocTypeAssertions* / true);                 // Bare calls to this same function don't contribute to inference                 // and `return await` is also safe to unwrap here                 if (functionFlags & FunctionFlags.Async && expr.kind === SyntaxKind.AwaitExpression) {                     expr = skipParentheses((expr as AwaitExpression).expression, /*excludeJSDocTypeAssertions* / true);                 }                 if (                     expr.kind === SyntaxKind.CallExpression &&                     (expr as CallExpression).expression.kind === SyntaxKind.Identifier &&                     checkExpressionCached((expr as CallExpression).expression).symbol === getMergedSymbol(func.symbol) &&                     (!isFunctionExpressionOrArrowFunction(func.symbol.valueDeclaration!) || isConstantReference((expr as CallExpression).expression))                 ) {                     hasReturnOfTypeNever = true;                     return;                 }                  let type = checkExpressionCached(expr, checkMode && checkMode & ~CheckMode.SkipGenericFunctions);                 if (functionFlags & FunctionFlags.Async) {                     // From within an async function you can return either a non-promise value or a promise. Any                     // Promise/A+ compatible implementation will always assimilate any foreign promise, so the                     // return type of the body should be unwrapped to its awaited type, which should be wrapped in                     // the native Promise<T> type by the caller.                     type = unwrapAwaitedType(checkAwaitedType(type, /*withAlias* / false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));                 }                 if (type.flags & TypeFlags.Never) {                     hasReturnOfTypeNever = true;                 }                 pushIfUnique(aggregatedTypes, type);             }             else {                 hasReturnWithNoExpression = true;             }         } */, TODO)
		if /* TODO(PropertyAccessExpression): aggregatedTypes.length */ TODO == 0 && !hasReturnWithNoExpression && /* TODO(ParenthesizedExpression): (hasReturnOfTypeNever || mayReturnNever(func)) */ TODO {
			return nil
		}
		if strictNullChecks && /* TODO(PropertyAccessExpression): aggregatedTypes.length */ TODO && hasReturnWithNoExpression && ! /* TODO(ParenthesizedExpression): (isJSConstructor(func) && aggregatedTypes.some(t => t.symbol === func.symbol)) */ TODO {
			pushIfUnique(aggregatedTypes, undefinedType)
		}
		return aggregatedTypes
	}
	mayReturnNever := func(func_ FunctionLikeDeclaration) bool {
		/* TODO(SwitchStatement): switch (func.kind) {             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return true;             case SyntaxKind.MethodDeclaration:                 return func.parent.kind === SyntaxKind.ObjectLiteralExpression;             default:                 return false;         } */
	}
	getTypePredicateFromBody := func(func_ FunctionLikeDeclaration) *TypePredicate {
		/* TODO(SwitchStatement): switch (func.kind) {             case SyntaxKind.Constructor:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return undefined;         } */
		functionFlags := getFunctionFlags(func_)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): functionFlags !== FunctionFlags.Normal */ TODO {
			/* TODO(Identifier): undefined */
		}
		var singleReturn *Expression
		if /* TODO(PropertyAccessExpression): func.body */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.body.kind !== SyntaxKind.Block */ TODO {
			/* TODO(ExpressionStatement): singleReturn = func.body; */
		} else {
			bailedEarly := forEachReturnStatement( /* TODO(PropertyAccessExpression): func.body */ TODO /* as */ /* TODO(TypeReference): Block */ /* TODO(ArrowFunction): returnStatement => {                 if (singleReturn || !returnStatement.expression) return true;                 singleReturn = returnStatement.expression;             } */, TODO)
			if bailedEarly || !singleReturn || functionHasImplicitReturn(func_) {
				/* TODO(Identifier): undefined */
			}
		}
		return checkIfExpressionRefinesAnyParameter(func_, singleReturn)
	}
	checkIfExpressionRefinesAnyParameter := func(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
		/* TODO(ExpressionStatement): expr = skipParentheses(expr, /*excludeJSDocTypeAssertions* / true); */
		returnType := checkExpressionCached(expr)
		if ! /* TODO(ParenthesizedExpression): (returnType.flags & TypeFlags.Boolean) */ TODO {
			/* TODO(Identifier): undefined */
		}
		return forEach( /* TODO(PropertyAccessExpression): func.parameters */ TODO /* TODO(ArrowFunction): (param, i) => {             const initType = getTypeOfSymbol(param.symbol);             if (!initType || initType.flags & TypeFlags.Boolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param)) {                 // Refining "x: boolean" to "x is true" or "x is false" isn't useful.                 return;             }             const trueType = checkIfExpressionRefinesParameter(func, expr, param, initType);             if (trueType) {                 return createTypePredicate(TypePredicateKind.Identifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType);             }         } */, TODO)
	}
	checkIfExpressionRefinesParameter := func(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) *Type {
		antecedent := /* TODO(PropertyAccessExpression): (expr as Expression & { flowNode?: FlowNode; }).flowNode */ TODO || /* TODO(PropertyAccessExpression): expr.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ReturnStatement */ TODO && /* TODO(PropertyAccessExpression): (expr.parent as ReturnStatement).flowNode */ TODO || createFlowNode( /* TODO(PropertyAccessExpression): FlowFlags.Start */ TODO, nil, nil)
		trueCondition := createFlowNode( /* TODO(PropertyAccessExpression): FlowFlags.TrueCondition */ TODO, expr, antecedent)
		trueType := getFlowTypeOfReference( /* TODO(PropertyAccessExpression): param.name */ TODO, initType, initType, func_, trueCondition)
		if trueType == initType {
			/* TODO(Identifier): undefined */
		}
		falseCondition := createFlowNode( /* TODO(PropertyAccessExpression): FlowFlags.FalseCondition */ TODO, expr, antecedent)
		falseSubtype := getFlowTypeOfReference( /* TODO(PropertyAccessExpression): param.name */ TODO, initType, trueType, func_, falseCondition)
		return /* TODO(ConditionalExpression): falseSubtype.flags & TypeFlags.Never ? trueType : undefined */ TODO
	}
	checkAllCodePathsInNonVoidFunctionReturnOrThrow := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnType *Type) {
		addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics)
		return
		checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
			functionFlags := getFunctionFlags(func_)
			type_ := returnType && unwrapReturnType(returnType, functionFlags)
			if type_ && /* TODO(ParenthesizedExpression): (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined)) */ TODO {
				return
			}
			if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO || nodeIsMissing( /* TODO(PropertyAccessExpression): func.body */ TODO) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.body!.kind !== SyntaxKind.Block */ TODO || !functionHasImplicitReturn(func_) {
				return
			}
			hasExplicitReturn := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): func.flags & NodeFlags.HasExplicitReturn */ TODO
			errorNode := getEffectiveReturnTypeNode(func_) || func_
			if type_ && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Never */ TODO {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point */, TODO)
			} else if type_ && !hasExplicitReturn {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value */, TODO)
			} else if type_ && strictNullChecks && !isTypeAssignableTo(undefinedType, type_) {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined */, TODO)
			} else if /* TODO(PropertyAccessExpression): compilerOptions.noImplicitReturns */ TODO {
				if !type_ {
					if !hasExplicitReturn {
						return
					}
					inferredReturnType := getReturnTypeOfSignature(getSignatureFromDeclaration(func_))
					if isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {
						return
					}
				}
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Not_all_code_paths_return_a_value */, TODO)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		checkNodeDeferred(node)
		if isFunctionExpression(node) {
			checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
		}
		if checkMode && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.SkipContextSensitive */ TODO && isContextSensitive(node) {
			if !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) {
				contextualSignature := getContextualSignature(node)
				if contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature)) {
					links := getNodeLinks(node)
					if /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO {
						return /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO
					}
					returnType := getReturnTypeFromBody(node, checkMode)
					returnOnlySignature := createSignature(nil, nil, nil, emptyArray, returnType, nil, 0 /* TODO(PropertyAccessExpression): SignatureFlags.IsNonInferrable */, TODO)
					returnOnlyType := createAnonymousType( /* TODO(PropertyAccessExpression): node.symbol */ TODO, emptySymbols /* TODO(ArrayLiteralExpression): [returnOnlySignature] */, TODO, emptyArray, emptyArray)
					/* TODO(ExpressionStatement): returnOnlyType.objectFlags |= ObjectFlags.NonInferrableType; */
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.contextFreeType = returnOnlyType */ TODO
				}
			}
			return anyFunctionType
		}
		hasGrammarError := checkGrammarFunctionLikeDeclaration(node)
		if !hasGrammarError && /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionExpression */ TODO {
			checkGrammarForGenerator(node)
		}
		contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	contextuallyCheckFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
		links := getNodeLinks(node)
		if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.ContextChecked) */ TODO {
			contextualSignature := getContextualSignature(node)
			if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.ContextChecked) */ TODO {
				/* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.ContextChecked; */
				signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)) /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO))
				if !signature {
					return
				}
				if isContextSensitive(node) {
					if contextualSignature {
						inferenceContext := getInferenceContext(node)
						var instantiatedContextualSignature *Signature
						if checkMode && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */ TODO {
							inferFromAnnotatedParameters(signature, contextualSignature /* TODO(NonNullExpression): inferenceContext! */, TODO)
							restType := getEffectiveRestType(contextualSignature)
							if restType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): restType.flags & TypeFlags.TypeParameter */ TODO {
								/* TODO(ExpressionStatement): instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext!.nonFixingMapper); */
							}
						}
						/* TODO(ExpressionStatement): instantiatedContextualSignature ||= inferenceContext ?                             instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature; */
						assignContextualParameterTypes(signature, instantiatedContextualSignature)
					} else {
						assignNonContextualParameterTypes(signature)
					}
				} else if contextualSignature && ! /* TODO(PropertyAccessExpression): node.typeParameters */ TODO && /* TODO(PropertyAccessExpression): contextualSignature.parameters.length */ TODO > /* TODO(PropertyAccessExpression): node.parameters.length */ TODO {
					inferenceContext := getInferenceContext(node)
					if checkMode && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */ TODO {
						inferFromAnnotatedParameters(signature, contextualSignature /* TODO(NonNullExpression): inferenceContext! */, TODO)
					}
				}
				if contextualSignature && !getReturnTypeFromAnnotation(node) && ! /* TODO(PropertyAccessExpression): signature.resolvedReturnType */ TODO {
					returnType := getReturnTypeFromBody(node, checkMode)
					if ! /* TODO(PropertyAccessExpression): signature.resolvedReturnType */ TODO {
						/* TODO(ExpressionStatement): signature.resolvedReturnType = returnType; */
					}
				}
				checkSignatureDeclaration(node)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethodDeferred := func(node /* TODO(UnionType): ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		functionFlags := getFunctionFlags(node)
		returnType := getReturnTypeFromAnnotation(node)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
		if /* TODO(PropertyAccessExpression): node.body */ TODO {
			if !getEffectiveReturnTypeNode(node) {
				getReturnTypeOfSignature(getSignatureFromDeclaration(node))
			}
			if /* TODO(PropertyAccessExpression): node.body.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Block */ TODO {
				checkSourceElement( /* TODO(PropertyAccessExpression): node.body */ TODO)
			} else {
				exprType := checkExpression( /* TODO(PropertyAccessExpression): node.body */ TODO)
				returnOrPromisedType := returnType && unwrapReturnType(returnType, functionFlags)
				if returnOrPromisedType {
					effectiveCheckNode := getEffectiveCheckNode( /* TODO(PropertyAccessExpression): node.body */ TODO)
					if /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.AsyncGenerator) */ TODO == /* TODO(PropertyAccessExpression): FunctionFlags.Async */ TODO {
						awaitedType := checkAwaitedType(exprType /* TODO(FalseKeyword): false */, TODO, effectiveCheckNode /* TODO(PropertyAccessExpression): Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member */, TODO)
						checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					}
				}
			}
		}
	}
	checkArithmeticOperandType := func(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) bool {
		if !isTypeAssignableTo(type_, numberOrBigIntType) {
			awaitedType := isAwaitValid && getAwaitedTypeOfPromise(type_)
			errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic)
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	isReadonlyAssignmentDeclaration := func(d Declaration) /* TODO(undefined): boolean */ TODO {
		if !isCallExpression(d) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if !isBindableObjectDefinePropertyCall(d) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		objectLitType := checkExpressionCached( /* TODO(ElementAccessExpression): d.arguments[2] */ TODO)
		valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as */ /* TODO(TypeReference): __String */)
		if valueType {
			writableProp := getPropertyOfType(objectLitType, "writable" /* as */ /* TODO(TypeReference): __String */)
			writableType := writableProp && getTypeOfSymbol(writableProp)
			if !writableType || writableType == falseType || writableType == regularFalseType {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if writableProp && /* TODO(PropertyAccessExpression): writableProp.valueDeclaration */ TODO && isPropertyAssignment( /* TODO(PropertyAccessExpression): writableProp.valueDeclaration */ TODO) {
				initializer := /* TODO(PropertyAccessExpression): writableProp.valueDeclaration.initializer */ TODO
				rawOriginalType := checkExpression(initializer)
				if rawOriginalType == falseType || rawOriginalType == regularFalseType {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		setProp := getPropertyOfType(objectLitType, "set" /* as */ /* TODO(TypeReference): __String */)
		return !setProp
	}
	isReadonlySymbol := func(symbol Symbol) bool {
		return !! /* TODO(ParenthesizedExpression): (getCheckFlags(symbol) & CheckFlags.Readonly ||             symbol.flags & SymbolFlags.Property && getDeclarationModifierFlagsFromSymbol(symbol) & ModifierFlags.Readonly ||             symbol.flags & SymbolFlags.Variable && getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant ||             symbol.flags & SymbolFlags.Accessor && !(symbol.flags & SymbolFlags.SetAccessor) ||             symbol.flags & SymbolFlags.EnumMember ||             some(symbol.declarations, isReadonlyAssignmentDeclaration)) */ TODO
	}
	isAssignmentToReadonlyEntity := func(expr Expression, symbol Symbol, assignmentKind AssignmentKind) /* TODO(undefined): boolean */ TODO {
		if assignmentKind == /* TODO(PropertyAccessExpression): AssignmentKind.None */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if isReadonlySymbol(symbol) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Property */ TODO && isAccessExpression(expr) && /* TODO(PropertyAccessExpression): expr.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO {
				ctor := getContainingFunction(expr)
				if ! /* TODO(ParenthesizedExpression): (ctor && (ctor.kind === SyntaxKind.Constructor || isJSConstructor(ctor))) */ TODO {
					return /* TODO(TrueKeyword): true */ TODO
				}
				if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
					isAssignmentDeclaration := isBinaryExpression( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
					isLocalPropertyDeclaration := /* TODO(PropertyAccessExpression): ctor.parent */ TODO == /* TODO(PropertyAccessExpression): symbol.valueDeclaration.parent */ TODO
					isLocalParameterProperty := ctor == /* TODO(PropertyAccessExpression): symbol.valueDeclaration.parent */ TODO
					isLocalThisPropertyAssignment := isAssignmentDeclaration && /* TODO(PropertyAccessExpression): symbol.parent?.valueDeclaration */ TODO == /* TODO(PropertyAccessExpression): ctor.parent */ TODO
					isLocalThisPropertyAssignmentConstructorFunction := isAssignmentDeclaration && /* TODO(PropertyAccessExpression): symbol.parent?.valueDeclaration */ TODO == ctor
					isWriteableSymbol := isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction
					return !isWriteableSymbol
				}
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		if isAccessExpression(expr) {
			node := skipParentheses( /* TODO(PropertyAccessExpression): expr.expression */ TODO)
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
				symbol := /* TODO(NonNullExpression): getNodeLinks(node).resolvedSymbol! */ TODO
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO {
					declaration := getDeclarationOfAliasSymbol(symbol)
					return !!declaration && /* TODO(PropertyAccessExpression): declaration.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceImport */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkReferenceExpression := func(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
		node := skipOuterExpressions(expr /* TODO(BarToken): | */ /* TODO(BinaryExpression): OuterExpressionKinds.Assertions | OuterExpressionKinds.Parentheses */, TODO)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.Identifier */ TODO && !isAccessExpression(node) {
			error(expr, invalidReferenceMessage)
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.OptionalChain */ TODO {
			error(expr, invalidOptionalChainMessage)
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	checkDeleteExpression := func(node DeleteExpression) Type {
		checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		expr := skipParentheses( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		if !isAccessExpression(expr) {
			error(expr /* TODO(PropertyAccessExpression): Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference */, TODO)
			return booleanType
		}
		if isPropertyAccessExpression(expr) && isPrivateIdentifier( /* TODO(PropertyAccessExpression): expr.name */ TODO) {
			error(expr /* TODO(PropertyAccessExpression): Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier */, TODO)
		}
		links := getNodeLinks(expr)
		symbol := getExportSymbolOfValueSymbolIfExported( /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO)
		if symbol {
			if isReadonlySymbol(symbol) {
				error(expr /* TODO(PropertyAccessExpression): Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property */, TODO)
			} else {
				checkDeleteExpressionMustBeOptional(expr, symbol)
			}
		}
		return booleanType
	}
	checkDeleteExpressionMustBeOptional := func(expr AccessExpression, symbol Symbol) {
		type_ := getTypeOfSymbol(symbol)
		if strictNullChecks && ! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Never)) */ TODO && ! /* TODO(ParenthesizedExpression): (exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : hasTypeFacts(type, TypeFacts.IsUndefined)) */ TODO {
			error(expr /* TODO(PropertyAccessExpression): Diagnostics.The_operand_of_a_delete_operator_must_be_optional */, TODO)
		}
	}
	checkTypeOfExpression := func(node TypeOfExpression) Type {
		checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		return typeofType
	}
	checkVoidExpression := func(node VoidExpression) Type {
		checkNodeDeferred(node)
		return undefinedWideningType
	}
	checkAwaitGrammar := func(node /* TODO(UnionType): AwaitExpression | VariableDeclarationList */ any) bool {
		hasError := /* TODO(FalseKeyword): false */ TODO
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block :                 Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block */ TODO
			error(node, message)
			/* TODO(ExpressionStatement): hasError = true; */
		} else if ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.AwaitContext) */ TODO {
			if isInTopLevelContext(node) {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					var span *TextSpan
					if !isEffectiveExternalModule(sourceFile, compilerOptions) {
						/* TODO(ExpressionStatement): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos); */
						message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module :                             Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module */ TODO
						diagnostic := createFileDiagnostic(sourceFile /* TODO(PropertyAccessExpression): span.start */, TODO /* TODO(PropertyAccessExpression): span.length */, TODO, message)
						/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
						/* TODO(ExpressionStatement): hasError = true; */
					}
					/* TODO(SwitchStatement): switch (moduleKind) {                         case ModuleKind.Node16:                         case ModuleKind.NodeNext:                             if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {                                 span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);                                 diagnostics.add(                                     createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),                                 );                                 hasError = true;                                 break;                             }                             // fallthrough                         case ModuleKind.ES2022:                         case ModuleKind.ESNext:                         case ModuleKind.Preserve:                         case ModuleKind.System:                             if (languageVersion >= ScriptTarget.ES2017) {                                 break;                             }                             // fallthrough                         default:                             span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);                             const message = isAwaitExpression(node) ? Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher :                                 Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher;                             diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message));                             hasError = true;                             break;                     } */
				}
			} else {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					span := getSpanOfTokenAtPosition(sourceFile /* TODO(PropertyAccessExpression): node.pos */, TODO)
					message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules :                         Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */ TODO
					diagnostic := createFileDiagnostic(sourceFile /* TODO(PropertyAccessExpression): span.start */, TODO /* TODO(PropertyAccessExpression): span.length */, TODO, message)
					if container && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): container.kind !== SyntaxKind.Constructor */ TODO && /* TODO(ParenthesizedExpression): (getFunctionFlags(container) & FunctionFlags.Async) */ TODO == 0 {
						relatedInfo := createDiagnosticForNode(container /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_to_mark_this_function_as_async */, TODO)
						addRelatedInfo(diagnostic, relatedInfo)
					}
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
					/* TODO(ExpressionStatement): hasError = true; */
				}
			}
		}
		if isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer */, TODO)
			/* TODO(ExpressionStatement): hasError = true; */
		}
		return hasError
	}
	checkAwaitExpression := func(node AwaitExpression) Type {
		addLazyDiagnostic( /* TODO(ArrowFunction): () => checkAwaitGrammar(node) */ TODO)
		operandType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		awaitedType := checkAwaitedType(operandType /* TODO(TrueKeyword): true */, TODO, node /* TODO(PropertyAccessExpression): Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member */, TODO)
		if awaitedType == operandType && !isErrorType(awaitedType) && ! /* TODO(ParenthesizedExpression): (operandType.flags & TypeFlags.AnyOrUnknown) */ TODO {
			addErrorOrSuggestion( /* TODO(FalseKeyword): false */ TODO, createDiagnosticForNode(node /* TODO(PropertyAccessExpression): Diagnostics.await_has_no_effect_on_the_type_of_this_expression */, TODO))
		}
		return awaitedType
	}
	checkPrefixUnaryExpression := func(node PrefixUnaryExpression) Type {
		operandType := checkExpression( /* TODO(PropertyAccessExpression): node.operand */ TODO)
		if operandType == silentNeverType {
			return silentNeverType
		}
		/* TODO(SwitchStatement): switch (node.operand.kind) {             case SyntaxKind.NumericLiteral:                 switch (node.operator) {                     case SyntaxKind.MinusToken:                         return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand as NumericLiteral).text));                     case SyntaxKind.PlusToken:                         return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand as NumericLiteral).text));                 }                 break;             case SyntaxKind.BigIntLiteral:                 if (node.operator === SyntaxKind.MinusToken) {                     return getFreshTypeOfLiteralType(getBigIntLiteralType({                         negative: true,                         base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text),                     }));                 }         } */
		/* TODO(SwitchStatement): switch (node.operator) {             case SyntaxKind.PlusToken:             case SyntaxKind.MinusToken:             case SyntaxKind.TildeToken:                 checkNonNullType(operandType, node.operand);                 if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.ESSymbolLike)) {                     error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator));                 }                 if (node.operator === SyntaxKind.PlusToken) {                     if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.BigIntLike)) {                         error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));                     }                     return numberType;                 }                 return getUnaryResultType(operandType);             case SyntaxKind.ExclamationToken:                 checkTruthinessOfType(operandType, node.operand);                 const facts = getTypeFacts(operandType, TypeFacts.Truthy | TypeFacts.Falsy);                 return facts === TypeFacts.Truthy ? falseType :                     facts === TypeFacts.Falsy ? trueType :                     booleanType;             case SyntaxKind.PlusPlusToken:             case SyntaxKind.MinusMinusToken:                 const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);                 if (ok) {                     // run check only if former checks succeeded to avoid reporting cascading errors                     checkReferenceExpression(                         node.operand,                         Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,                         Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,                     );                 }                 return getUnaryResultType(operandType);         } */
		return errorType
	}
	checkPostfixUnaryExpression := func(node PostfixUnaryExpression) Type {
		operandType := checkExpression( /* TODO(PropertyAccessExpression): node.operand */ TODO)
		if operandType == silentNeverType {
			return silentNeverType
		}
		ok := checkArithmeticOperandType( /* TODO(PropertyAccessExpression): node.operand */ TODO, checkNonNullType(operandType /* TODO(PropertyAccessExpression): node.operand */, TODO) /* TODO(PropertyAccessExpression): Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type */, TODO)
		if ok {
			checkReferenceExpression( /* TODO(PropertyAccessExpression): node.operand */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access */, TODO /* TODO(PropertyAccessExpression): Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access */, TODO)
		}
		return getUnaryResultType(operandType)
	}
	getUnaryResultType := func(operandType Type) Type {
		if maybeTypeOfKind(operandType /* TODO(PropertyAccessExpression): TypeFlags.BigIntLike */, TODO) {
			return /* TODO(ConditionalExpression): isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike)                 ? numberOrBigIntType                 : bigintType */ TODO
		}
		return numberType
	}
	maybeTypeOfKindConsideringBaseConstraint := func(type_ Type, kind TypeFlags) bool {
		if maybeTypeOfKind(type_, kind) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		baseConstraint := getBaseConstraintOrType(type_)
		return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind)
	}
	maybeTypeOfKind := func(type_ Type, kind TypeFlags) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & kind */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.UnionOrIntersection */ TODO {
			types := /* TODO(PropertyAccessExpression): (type as UnionOrIntersectionType).types */ TODO
			for _, t := range types {
				if maybeTypeOfKind(t, kind) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isTypeAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & kind */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if strict && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null) */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.NumberLike) */ TODO && isTypeAssignableTo(source, numberType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.BigIntLike) */ TODO && isTypeAssignableTo(source, bigintType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.StringLike) */ TODO && isTypeAssignableTo(source, stringType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.BooleanLike) */ TODO && isTypeAssignableTo(source, booleanType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.Void) */ TODO && isTypeAssignableTo(source, voidType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.Never) */ TODO && isTypeAssignableTo(source, neverType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.Null) */ TODO && isTypeAssignableTo(source, nullType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.Undefined) */ TODO && isTypeAssignableTo(source, undefinedType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.ESSymbol) */ TODO && isTypeAssignableTo(source, esSymbolType) || !! /* TODO(ParenthesizedExpression): (kind & TypeFlags.NonPrimitive) */ TODO && isTypeAssignableTo(source, nonPrimitiveType)
	}
	allTypesAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ?             every((source as UnionType).types, subType => allTypesAssignableToKind(subType, kind, strict)) :             isTypeAssignableToKind(source, kind, strict) */ TODO
	}
	isConstEnumObjectType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Anonymous) */ TODO && !! /* TODO(PropertyAccessExpression): type.symbol */ TODO && isConstEnumSymbol( /* TODO(PropertyAccessExpression): type.symbol */ TODO)
	}
	isConstEnumSymbol := func(symbol Symbol) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.ConstEnum) !== 0 */ TODO
	}
	getSymbolHasInstanceMethodOfObjectType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		hasInstancePropertyName := getPropertyNameForKnownSymbolName("hasInstance")
		if allTypesAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */, TODO) {
			hasInstanceProperty := getPropertyOfType(type_, hasInstancePropertyName)
			if hasInstanceProperty {
				hasInstancePropertyType := getTypeOfSymbol(hasInstanceProperty)
				if hasInstancePropertyType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSignaturesOfType(hasInstancePropertyType, SignatureKind.Call).length !== 0 */ TODO {
					return hasInstancePropertyType
				}
			}
		}
	}
	checkInstanceOfExpression := func(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if !isTypeAny(leftType) && allTypesAssignableToKind(leftType /* TODO(PropertyAccessExpression): TypeFlags.Primitive */, TODO) {
			error(left /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter */, TODO)
		}
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isInstanceOfExpression( /* TODO(PropertyAccessExpression): left.parent */ TODO))
		signature := getResolvedSignature( /* TODO(PropertyAccessExpression): left.parent */ TODO, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		returnType := getReturnTypeOfSignature(signature)
		checkTypeAssignableTo(returnType, booleanType, right /* TODO(PropertyAccessExpression): Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression */, TODO)
		return booleanType
	}
	hasEmptyObjectIntersection := func(type_ Type) bool {
		return someType(type_ /* TODO(ArrowFunction): t => t === unknownEmptyObjectType || !!(t.flags & TypeFlags.Intersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t)) */, TODO)
	}
	checkInExpression := func(left Expression, right Expression, leftType Type, rightType Type) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if isPrivateIdentifier(left) {
			if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks */ TODO || languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO || !useDefineForClassFields {
				checkExternalEmitHelpers(left /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ClassPrivateFieldIn */, TODO)
			}
			if ! /* TODO(PropertyAccessExpression): getNodeLinks(left).resolvedSymbol */ TODO && getContainingClass(left) {
				isUncheckedJS := isUncheckedJSSuggestion(left /* TODO(PropertyAccessExpression): rightType.symbol */, TODO /* TODO(TrueKeyword): true */, TODO)
				reportNonexistentProperty(left, rightType, isUncheckedJS)
			}
		} else {
			checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left)
		}
		if checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right) {
			if hasEmptyObjectIntersection(rightType) {
				error(right /* TODO(PropertyAccessExpression): Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator */, TODO, typeToString(rightType))
			}
		}
		return booleanType
	}
	checkObjectLiteralAssignment := func(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
		properties := /* TODO(PropertyAccessExpression): node.properties */ TODO
		if strictNullChecks && /* TODO(PropertyAccessExpression): properties.length */ TODO == 0 {
			return checkNonNullType(sourceType, node)
		}
		/* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {             checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);         } */
		return sourceType
	}
	checkObjectLiteralDestructuringPropertyAssignment := func(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		properties := /* TODO(PropertyAccessExpression): node.properties */ TODO
		property := /* TODO(ElementAccessExpression): properties[propertyIndex] */ TODO
		if /* TODO(PropertyAccessExpression): property.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO || /* TODO(PropertyAccessExpression): property.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO {
			name := /* TODO(PropertyAccessExpression): property.name */ TODO
			exprType := getLiteralTypeFromPropertyName(name)
			if isTypeUsableAsPropertyName(exprType) {
				text := getPropertyNameFromType(exprType)
				prop := getPropertyOfType(objectLiteralType, text)
				if prop {
					markPropertyAsReferenced(prop, property, rightIsThis)
					checkPropertyAccessibility(property /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO, objectLiteralType, prop)
				}
			}
			elementType := getIndexedAccessType(objectLiteralType, exprType /* TODO(BarToken): | */ /* TODO(BinaryExpression): AccessFlags.ExpressionPosition | (hasDefaultValue(property) ? AccessFlags.AllowMissing : 0) */, TODO, name)
			type_ := getFlowTypeOfDestructuring(property, elementType)
			return checkDestructuringAssignment( /* TODO(ConditionalExpression): property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer */ TODO, type_)
		} else if /* TODO(PropertyAccessExpression): property.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SpreadAssignment */ TODO {
			if propertyIndex < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): properties.length - 1 */ TODO {
				error(property /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern */, TODO)
			} else {
				if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ObjectSpreadRest */ TODO {
					checkExternalEmitHelpers(property /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Rest */, TODO)
				}
				var nonRestNames []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
				if allProperties {
					for _, otherProperty := range allProperties {
						if !isSpreadAssignment(otherProperty) {
							/* TODO(PropertyAccessExpression): nonRestNames.push */ TODO( /* TODO(PropertyAccessExpression): otherProperty.name */ TODO)
						}
					}
				}
				type_ := getRestType(objectLiteralType, nonRestNames /* TODO(PropertyAccessExpression): objectLiteralType.symbol */, TODO)
				checkGrammarForDisallowedTrailingComma(allProperties /* TODO(PropertyAccessExpression): Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma */, TODO)
				return checkDestructuringAssignment( /* TODO(PropertyAccessExpression): property.expression */ TODO, type_)
			}
		} else {
			error(property /* TODO(PropertyAccessExpression): Diagnostics.Property_assignment_expected */, TODO)
		}
	}
	checkArrayLiteralAssignment := func(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
		elements := /* TODO(PropertyAccessExpression): node.elements */ TODO
		if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.DestructuringAssignment */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.downlevelIteration */ TODO {
			checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Read */, TODO)
		}
		possiblyOutOfBoundsType := checkIteratedTypeOrElementType( /* TODO(BarToken): | */ /* TODO(BinaryExpression): IterationUse.Destructuring | IterationUse.PossiblyOutOfBounds */ TODO, sourceType, undefinedType, node) || errorType
		var inBoundsType *Type = /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType */ TODO
		/* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             let type = possiblyOutOfBoundsType;             if (node.elements[i].kind === SyntaxKind.SpreadElement) {                 type = inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType);             }             checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);         } */
		return sourceType
	}
	checkArrayLiteralDestructuringElementAssignment := func(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		elements := /* TODO(PropertyAccessExpression): node.elements */ TODO
		element := /* TODO(ElementAccessExpression): elements[elementIndex] */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): element.kind !== SyntaxKind.OmittedExpression */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): element.kind !== SyntaxKind.SpreadElement */ TODO {
				indexType := getNumberLiteralType(elementIndex)
				if isArrayLikeType(sourceType) {
					accessFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): AccessFlags.ExpressionPosition | (hasDefaultValue(element) ? AccessFlags.AllowMissing : 0) */ TODO
					elementType := getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType
					assignedType := /* TODO(ConditionalExpression): hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType */ TODO
					type_ := getFlowTypeOfDestructuring(element, assignedType)
					return checkDestructuringAssignment(element, type_, checkMode)
				}
				return checkDestructuringAssignment(element, elementType, checkMode)
			}
			if elementIndex < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): elements.length - 1 */ TODO {
				error(element /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern */, TODO)
			} else {
				restExpression := /* TODO(PropertyAccessExpression): (element as SpreadElement).expression */ TODO
				if /* TODO(PropertyAccessExpression): restExpression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (restExpression as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO {
					error( /* TODO(PropertyAccessExpression): (restExpression as BinaryExpression).operatorToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_have_an_initializer */, TODO)
				} else {
					checkGrammarForDisallowedTrailingComma( /* TODO(PropertyAccessExpression): node.elements */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma */, TODO)
					type_ := /* TODO(ConditionalExpression): everyType(sourceType, isTupleType) ?                         mapType(sourceType, t => sliceTupleType(t as TupleTypeReference, elementIndex)) :                         createArrayType(elementType) */ TODO
					return checkDestructuringAssignment(restExpression, type_, checkMode)
				}
			}
		}
		return nil
	}
	checkDestructuringAssignment := func(exprOrAssignment /* TODO(UnionType): Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
		var target Expression
		if /* TODO(PropertyAccessExpression): exprOrAssignment.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO {
			prop := exprOrAssignment /* as */ /* TODO(TypeReference): ShorthandPropertyAssignment */
			if /* TODO(PropertyAccessExpression): prop.objectAssignmentInitializer */ TODO {
				if strictNullChecks && ! /* TODO(ParenthesizedExpression): (hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFacts.IsUndefined)) */ TODO {
					/* TODO(ExpressionStatement): sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined); */
				}
				checkBinaryLikeExpression( /* TODO(PropertyAccessExpression): prop.name */ TODO /* TODO(NonNullExpression): prop.equalsToken! */, TODO /* TODO(PropertyAccessExpression): prop.objectAssignmentInitializer */, TODO, checkMode)
			}
			/* TODO(ExpressionStatement): target = (exprOrAssignment as ShorthandPropertyAssignment).name; */
		} else {
			/* TODO(ExpressionStatement): target = exprOrAssignment; */
		}
		if /* TODO(PropertyAccessExpression): target.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (target as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO {
			checkBinaryExpression(target /* as */ /* TODO(TypeReference): BinaryExpression */, checkMode)
			/* TODO(ExpressionStatement): target = (target as BinaryExpression).left; */
			if strictNullChecks {
				/* TODO(ExpressionStatement): sourceType = getTypeWithFacts(sourceType, TypeFacts.NEUndefined); */
			}
		}
		if /* TODO(PropertyAccessExpression): target.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO {
			return checkObjectLiteralAssignment(target /* as */ /* TODO(TypeReference): ObjectLiteralExpression */, sourceType, rightIsThis)
		}
		if /* TODO(PropertyAccessExpression): target.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayLiteralExpression */ TODO {
			return checkArrayLiteralAssignment(target /* as */ /* TODO(TypeReference): ArrayLiteralExpression */, sourceType, checkMode)
		}
		return checkReferenceAssignment(target, sourceType, checkMode)
	}
	checkReferenceAssignment := func(target Expression, sourceType Type, checkMode CheckMode) Type {
		targetType := checkExpression(target, checkMode)
		error := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */ TODO
		optionalError := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */ TODO
		if checkReferenceExpression(target, error, optionalError) {
			checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target)
		}
		if isPrivateIdentifierPropertyAccessExpression(target) {
			checkExternalEmitHelpers( /* TODO(PropertyAccessExpression): target.parent */ TODO /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ClassPrivateFieldSet */, TODO)
		}
		return sourceType
	}
	isSideEffectFree := func(node Node) bool {
		/* TODO(ExpressionStatement): node = skipParentheses(node); */
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.StringLiteral:             case SyntaxKind.RegularExpressionLiteral:             case SyntaxKind.TaggedTemplateExpression:             case SyntaxKind.TemplateExpression:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.NullKeyword:             case SyntaxKind.UndefinedKeyword:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ClassExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.TypeOfExpression:             case SyntaxKind.NonNullExpression:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.JsxElement:                 return true;              case SyntaxKind.ConditionalExpression:                 return isSideEffectFree((node as ConditionalExpression).whenTrue) &&                     isSideEffectFree((node as ConditionalExpression).whenFalse);              case SyntaxKind.BinaryExpression:                 if (isAssignmentOperator((node as BinaryExpression).operatorToken.kind)) {                     return false;                 }                 return isSideEffectFree((node as BinaryExpression).left) &&                     isSideEffectFree((node as BinaryExpression).right);              case SyntaxKind.PrefixUnaryExpression:             case SyntaxKind.PostfixUnaryExpression:                 // Unary operators ~, !, +, and - have no side effects.                 // The rest do.                 switch ((node as PrefixUnaryExpression).operator) {                     case SyntaxKind.ExclamationToken:                     case SyntaxKind.PlusToken:                     case SyntaxKind.MinusToken:                     case SyntaxKind.TildeToken:                         return true;                 }                 return false;              // Some forms listed here for clarity             case SyntaxKind.VoidExpression: // Explicit opt-out             case SyntaxKind.TypeAssertionExpression: // Not SEF, but can produce useful type warnings             case SyntaxKind.AsExpression: // Not SEF, but can produce useful type warnings             default:                 return false;         } */
	}
	isTypeEqualityComparableTo := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (target.flags & TypeFlags.Nullable) !== 0 */ TODO || isTypeComparableTo(source, target)
	}
	createCheckBinaryExpression := func() /* TODO(undefined): (node: import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression, checkMode: import("/home/jabaile/work/TypeScript/src/compiler/checker").CheckMode | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type WorkArea struct {
			checkMode  *CheckMode
			skip       bool
			stackIndex number
			typeStack  []*Type
		}
		trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)
		return /* TODO(ArrowFunction): (node: BinaryExpression, checkMode: CheckMode | undefined) => {             const result = trampoline(node, checkMode);             Debug.assertIsDefined(result);             return result;         } */ TODO
		onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) /* TODO(undefined): WorkArea */ TODO {
			if state {
				/* TODO(ExpressionStatement): state.stackIndex++; */
				/* TODO(ExpressionStatement): state.skip = false; */
				setLeftType(state, nil)
				setLastResult(state, nil)
			} else {
				/* TODO(ExpressionStatement): state = {                     checkMode,                     skip: false,                     stackIndex: 0,                     typeStack: [undefined, undefined],                 }; */
			}
			if isInJSFile(node) && getAssignedExpandoInitializer(node) {
				/* TODO(ExpressionStatement): state.skip = true; */
				setLastResult(state, checkExpression( /* TODO(PropertyAccessExpression): node.right */ TODO, checkMode))
				return state
			}
			checkNullishCoalesceOperands(node)
			operator := /* TODO(PropertyAccessExpression): node.operatorToken.kind */ TODO
			if operator == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO && /* TODO(ParenthesizedExpression): (node.left.kind === SyntaxKind.ObjectLiteralExpression || node.left.kind === SyntaxKind.ArrayLiteralExpression) */ TODO {
				/* TODO(ExpressionStatement): state.skip = true; */
				setLastResult(state, checkDestructuringAssignment( /* TODO(PropertyAccessExpression): node.left */ TODO, checkExpression( /* TODO(PropertyAccessExpression): node.right */ TODO, checkMode), checkMode /* TODO(PropertyAccessExpression): node.right.kind */, TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO))
				return state
			}
			return state
		}
		onLeft := func(left Expression, state WorkArea, _node BinaryExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
			if ! /* TODO(PropertyAccessExpression): state.skip */ TODO {
				return maybeCheckExpression(state, left)
			}
		}
		onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
			if ! /* TODO(PropertyAccessExpression): state.skip */ TODO {
				leftType := getLastResult(state)
				/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO(leftType)
				setLeftType(state, leftType)
				setLastResult(state, nil)
				operator := /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO
				if isLogicalOrCoalescingBinaryOperator(operator) {
					parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
					/* TODO(WhileStatement): while (parent.kind === SyntaxKind.ParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent)) {                         parent = parent.parent;                     } */
					if operator == /* TODO(PropertyAccessExpression): SyntaxKind.AmpersandAmpersandToken */ TODO || isIfStatement(parent) {
						checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType( /* TODO(PropertyAccessExpression): node.left */ TODO, leftType /* TODO(ConditionalExpression): isIfStatement(parent) ? parent.thenStatement : undefined */, TODO)
					}
					if isBinaryLogicalOperator(operator) {
						checkTruthinessOfType(leftType /* TODO(PropertyAccessExpression): node.left */, TODO)
					}
				}
			}
		}
		onRight := func(right Expression, state WorkArea, _node BinaryExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
			if ! /* TODO(PropertyAccessExpression): state.skip */ TODO {
				return maybeCheckExpression(state, right)
			}
		}
		onExit := func(node BinaryExpression, state WorkArea) *Type {
			var result *Type
			if /* TODO(PropertyAccessExpression): state.skip */ TODO {
				/* TODO(ExpressionStatement): result = getLastResult(state); */
			} else {
				leftType := getLeftType(state)
				/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO(leftType)
				rightType := getLastResult(state)
				/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO(rightType)
				/* TODO(ExpressionStatement): result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node); */
			}
			/* TODO(ExpressionStatement): state.skip = false; */
			setLeftType(state, nil)
			setLastResult(state, nil)
			/* TODO(ExpressionStatement): state.stackIndex--; */
			return result
		}
		foldState := func(state WorkArea, result *Type, _side /* TODO(UnionType): "left" | "right" */ any) /* TODO(undefined): WorkArea */ TODO {
			setLastResult(state, result)
			return state
		}
		maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
			if isBinaryExpression(node) {
				return node
			}
			setLastResult(state, checkExpression(node /* TODO(PropertyAccessExpression): state.checkMode */, TODO))
		}
		getLeftType := func(state WorkArea) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex] */ TODO
		}
		setLeftType := func(state WorkArea, type_ *Type) {
			/* TODO(ExpressionStatement): state.typeStack[state.stackIndex] = type; */
		}
		getLastResult := func(state WorkArea) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex + 1] */ TODO
		}
		setLastResult := func(state WorkArea, type_ *Type) {
			/* TODO(ExpressionStatement): state.typeStack[state.stackIndex + 1] = type; */
		}
	}
	checkNullishCoalesceOperands := func(node BinaryExpression) {
		TODO_IDENTIFIER := node
		if /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.QuestionQuestionToken */ TODO {
			if isBinaryExpression(left) && /* TODO(ParenthesizedExpression): (left.operatorToken.kind === SyntaxKind.BarBarToken || left.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) */ TODO {
				grammarErrorOnNode(left /* TODO(PropertyAccessExpression): Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses */, TODO, tokenToString( /* TODO(PropertyAccessExpression): left.operatorToken.kind */ TODO), tokenToString( /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO))
			}
			if isBinaryExpression(right) && /* TODO(ParenthesizedExpression): (right.operatorToken.kind === SyntaxKind.BarBarToken || right.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) */ TODO {
				grammarErrorOnNode(right /* TODO(PropertyAccessExpression): Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses */, TODO, tokenToString( /* TODO(PropertyAccessExpression): right.operatorToken.kind */ TODO), tokenToString( /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO))
			}
			leftTarget := skipOuterExpressions(left /* TODO(PropertyAccessExpression): OuterExpressionKinds.All */, TODO)
			nullishSemantics := getSyntacticNullishnessSemantics(leftTarget)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nullishSemantics !== PredicateSemantics.Sometimes */ TODO {
				if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO {
					error(leftTarget /* TODO(PropertyAccessExpression): Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses */, TODO)
				} else {
					if nullishSemantics == /* TODO(PropertyAccessExpression): PredicateSemantics.Always */ TODO {
						error(leftTarget /* TODO(PropertyAccessExpression): Diagnostics.This_expression_is_always_nullish */, TODO)
					} else {
						error(leftTarget /* TODO(PropertyAccessExpression): Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish */, TODO)
					}
				}
			}
		}
	}
	getSyntacticNullishnessSemantics := func(node Node) PredicateSemantics {
		/* TODO(ExpressionStatement): node = skipOuterExpressions(node); */
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AwaitExpression:             case SyntaxKind.CallExpression:             case SyntaxKind.ElementAccessExpression:             case SyntaxKind.NewExpression:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.YieldExpression:                 return PredicateSemantics.Sometimes;             case SyntaxKind.BinaryExpression:                 // List of operators that can produce null/undefined:                 // = ??= ?? || ||= && &&=                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.QuestionQuestionToken:                     case SyntaxKind.QuestionQuestionEqualsToken:                     case SyntaxKind.BarBarToken:                     case SyntaxKind.BarBarEqualsToken:                     case SyntaxKind.AmpersandAmpersandToken:                     case SyntaxKind.AmpersandAmpersandEqualsToken:                         return PredicateSemantics.Sometimes;                 }                 return PredicateSemantics.Never;             case SyntaxKind.ConditionalExpression:                 return getSyntacticNullishnessSemantics((node as ConditionalExpression).whenTrue) | getSyntacticNullishnessSemantics((node as ConditionalExpression).whenFalse);             case SyntaxKind.NullKeyword:                 return PredicateSemantics.Always;             case SyntaxKind.Identifier:                 if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {                     return PredicateSemantics.Always;                 }                 return PredicateSemantics.Sometimes;         } */
		return /* TODO(PropertyAccessExpression): PredicateSemantics.Never */ TODO
	}
	checkBinaryLikeExpression := func(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
		operator := /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO
		if operator == /* TODO(PropertyAccessExpression): SyntaxKind.EqualsToken */ TODO && /* TODO(ParenthesizedExpression): (left.kind === SyntaxKind.ObjectLiteralExpression || left.kind === SyntaxKind.ArrayLiteralExpression) */ TODO {
			return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode /* TODO(PropertyAccessExpression): right.kind */, TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO)
		}
		var leftType Type
		if isBinaryLogicalOperator(operator) {
			/* TODO(ExpressionStatement): leftType = checkTruthinessExpression(left, checkMode); */
		} else {
			/* TODO(ExpressionStatement): leftType = checkExpression(left, checkMode); */
		}
		rightType := checkExpression(right, checkMode)
		return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
	}
	checkBinaryLikeExpressionWorker := func(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
		operator := /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO
		/* TODO(SwitchStatement): switch (operator) {             case SyntaxKind.AsteriskToken:             case SyntaxKind.AsteriskAsteriskToken:             case SyntaxKind.AsteriskEqualsToken:             case SyntaxKind.AsteriskAsteriskEqualsToken:             case SyntaxKind.SlashToken:             case SyntaxKind.SlashEqualsToken:             case SyntaxKind.PercentToken:             case SyntaxKind.PercentEqualsToken:             case SyntaxKind.MinusToken:             case SyntaxKind.MinusEqualsToken:             case SyntaxKind.LessThanLessThanToken:             case SyntaxKind.LessThanLessThanEqualsToken:             case SyntaxKind.GreaterThanGreaterThanToken:             case SyntaxKind.GreaterThanGreaterThanEqualsToken:             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:             case SyntaxKind.BarToken:             case SyntaxKind.BarEqualsToken:             case SyntaxKind.CaretToken:             case SyntaxKind.CaretEqualsToken:             case SyntaxKind.AmpersandToken:             case SyntaxKind.AmpersandEqualsToken:                 if (leftType === silentNeverType || rightType === silentNeverType) {                     return silentNeverType;                 }                  leftType = checkNonNullType(leftType, left);                 rightType = checkNonNullType(rightType, right);                  let suggestedOperator: PunctuationSyntaxKind | undefined;                 // if a user tries to apply a bitwise operator to 2 boolean operands                 // try and return them a helpful suggestion                 if (                     (leftType.flags & TypeFlags.BooleanLike) &&                     (rightType.flags & TypeFlags.BooleanLike) &&                     (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined                 ) {                     error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator));                     return numberType;                 }                 else {                     // otherwise just check each operand separately and report errors as normal                     const leftOk = checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid* / true);                     const rightOk = checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid* / true);                     let resultType: Type;                     // If both are any or unknown, allow operation; assume it will resolve to number                     if (                         (isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlags.AnyOrUnknown)) ||                         // Or, if neither could be bigint, implicit coercion results in a number result                         !(maybeTypeOfKind(leftType, TypeFlags.BigIntLike) || maybeTypeOfKind(rightType, TypeFlags.BigIntLike))                     ) {                         resultType = numberType;                     }                     // At least one is assignable to bigint, so check that both are                     else if (bothAreBigIntLike(leftType, rightType)) {                         switch (operator) {                             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:                                 reportOperatorError();                                 break;                             case SyntaxKind.AsteriskAsteriskToken:                             case SyntaxKind.AsteriskAsteriskEqualsToken:                                 if (languageVersion < ScriptTarget.ES2016) {                                     error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);                                 }                         }                         resultType = bigintType;                     }                     // Exactly one of leftType/rightType is assignable to bigint                     else {                         reportOperatorError(bothAreBigIntLike);                         resultType = errorType;                     }                     if (leftOk && rightOk) {                         checkAssignmentOperator(resultType);                         switch (operator) {                             case SyntaxKind.LessThanLessThanToken:                             case SyntaxKind.LessThanLessThanEqualsToken:                             case SyntaxKind.GreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanEqualsToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:                                 const rhsEval = evaluate(right);                                 if (typeof rhsEval.value === "number" && Math.abs(rhsEval.value) >= 32) {                                     errorOrSuggestion(                                         isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), // elevate from suggestion to error within an enum member                                         errorNode || operatorToken,                                         Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2,                                         getTextOfNode(left),                                         tokenToString(operator),                                         rhsEval.value % 32,                                     );                                 }                                 break;                             default:                                 break;                         }                     }                     return resultType;                 }             case SyntaxKind.PlusToken:             case SyntaxKind.PlusEqualsToken:                 if (leftType === silentNeverType || rightType === silentNeverType) {                     return silentNeverType;                 }                  if (!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(rightType, TypeFlags.StringLike)) {                     leftType = checkNonNullType(leftType, left);                     rightType = checkNonNullType(rightType, right);                 }                  let resultType: Type | undefined;                 if (isTypeAssignableToKind(leftType, TypeFlags.NumberLike, /*strict* / true) && isTypeAssignableToKind(rightType, TypeFlags.NumberLike, /*strict* / true)) {                     // Operands of an enum type are treated as having the primitive type Number.                     // If both operands are of the Number primitive type, the result is of the Number primitive type.                     resultType = numberType;                 }                 else if (isTypeAssignableToKind(leftType, TypeFlags.BigIntLike, /*strict* / true) && isTypeAssignableToKind(rightType, TypeFlags.BigIntLike, /*strict* / true)) {                     // If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.                     resultType = bigintType;                 }                 else if (isTypeAssignableToKind(leftType, TypeFlags.StringLike, /*strict* / true) || isTypeAssignableToKind(rightType, TypeFlags.StringLike, /*strict* / true)) {                     // If one or both operands are of the String primitive type, the result is of the String primitive type.                     resultType = stringType;                 }                 else if (isTypeAny(leftType) || isTypeAny(rightType)) {                     // Otherwise, the result is of type Any.                     // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.                     resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;                 }                  // Symbols are not allowed at all in arithmetic expressions                 if (resultType && !checkForDisallowedESSymbolOperand(operator)) {                     return resultType;                 }                  if (!resultType) {                     // Types that have a reasonably good chance of being a valid operand type.                     // If both types have an awaited type of one of these, we'll assume the user                     // might be missing an await without doing an exhaustive check that inserting                     // await(s) will actually be a completely valid binary expression.                     const closeEnoughKind = TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;                     reportOperatorError((left, right) =>                         isTypeAssignableToKind(left, closeEnoughKind) &&                         isTypeAssignableToKind(right, closeEnoughKind)                     );                     return anyType;                 }                  if (operator === SyntaxKind.PlusEqualsToken) {                     checkAssignmentOperator(resultType);                 }                 return resultType;             case SyntaxKind.LessThanToken:             case SyntaxKind.GreaterThanToken:             case SyntaxKind.LessThanEqualsToken:             case SyntaxKind.GreaterThanEqualsToken:                 if (checkForDisallowedESSymbolOperand(operator)) {                     leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));                     rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));                     reportOperatorErrorUnless((left, right) => {                         if (isTypeAny(left) || isTypeAny(right)) {                             return true;                         }                         const leftAssignableToNumber = isTypeAssignableTo(left, numberOrBigIntType);                         const rightAssignableToNumber = isTypeAssignableTo(right, numberOrBigIntType);                         return leftAssignableToNumber && rightAssignableToNumber ||                             !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right);                     });                 }                 return booleanType;             case SyntaxKind.EqualsEqualsToken:             case SyntaxKind.ExclamationEqualsToken:             case SyntaxKind.EqualsEqualsEqualsToken:             case SyntaxKind.ExclamationEqualsEqualsToken:                 // We suppress errors in CheckMode.TypeOnly (meaning the invocation came from getTypeOfExpression). During                 // control flow analysis it is possible for operands to temporarily have narrower types, and those narrower                 // types may cause the operands to not be comparable. We don't want such errors reported (see #46475).                 if (!(checkMode && checkMode & CheckMode.TypeOnly)) {                     if (                         (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) &&                         // only report for === and !== in JS, not == or !=                         (!isInJSFile(left) || (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken))                     ) {                         const eqType = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;                         error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");                     }                     checkNaNEquality(errorNode, operator, left, right);                     reportOperatorErrorUnless((left, right) => isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left));                 }                 return booleanType;             case SyntaxKind.InstanceOfKeyword:                 return checkInstanceOfExpression(left, right, leftType, rightType, checkMode);             case SyntaxKind.InKeyword:                 return checkInExpression(left, right, leftType, rightType);             case SyntaxKind.AmpersandAmpersandToken:             case SyntaxKind.AmpersandAmpersandEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.Truthy) ?                     getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :                     leftType;                 if (operator === SyntaxKind.AmpersandAmpersandEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.BarBarToken:             case SyntaxKind.BarBarEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.Falsy) ?                     getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) :                     leftType;                 if (operator === SyntaxKind.BarBarEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.QuestionQuestionToken:             case SyntaxKind.QuestionQuestionEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ?                     getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) :                     leftType;                 if (operator === SyntaxKind.QuestionQuestionEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.EqualsToken:                 const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None;                 checkAssignmentDeclaration(declKind, rightType);                 if (isAssignmentDeclaration(declKind)) {                     if (                         !(rightType.flags & TypeFlags.Object) ||                         declKind !== AssignmentDeclarationKind.ModuleExports &&                             declKind !== AssignmentDeclarationKind.Prototype &&                             !isEmptyObjectType(rightType) &&                             !isFunctionObjectType(rightType as ObjectType) &&                             !(getObjectFlags(rightType) & ObjectFlags.Class)                     ) {                         // don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete                         checkAssignmentOperator(rightType);                     }                     return leftType;                 }                 else {                     checkAssignmentOperator(rightType);                     return rightType;                 }             case SyntaxKind.CommaToken:                 if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent as BinaryExpression)) {                     const sf = getSourceFileOfNode(left);                     const sourceText = sf.text;                     const start = skipTrivia(sourceText, left.pos);                     const isInDiag2657 = sf.parseDiagnostics.some(diag => {                         if (diag.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code) return false;                         return textSpanContainsPosition(diag, start);                     });                     if (!isInDiag2657) error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);                 }                 return rightType;              default:                 return Debug.fail();         } */
		bothAreBigIntLike := func(left Type, right Type) bool {
			return isTypeAssignableToKind(left /* TODO(PropertyAccessExpression): TypeFlags.BigIntLike */, TODO) && isTypeAssignableToKind(right /* TODO(PropertyAccessExpression): TypeFlags.BigIntLike */, TODO)
		}
		checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
			if kind == /* TODO(PropertyAccessExpression): AssignmentDeclarationKind.ModuleExports */ TODO {
				for _, prop := range getPropertiesOfObjectType(rightType) {
					propType := getTypeOfSymbol(prop)
					if /* TODO(PropertyAccessExpression): propType.symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): propType.symbol.flags & SymbolFlags.Class */ TODO {
						name := /* TODO(PropertyAccessExpression): prop.escapedName */ TODO
						symbol := resolveName( /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO, name /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO, nil /* TODO(FalseKeyword): false */, TODO)
						if /* TODO(PropertyAccessExpression): symbol?.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.some */ TODO(isJSDocTypedefTag) {
							addDuplicateDeclarationErrorsForSymbols(symbol /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, unescapeLeadingUnderscores(name), prop)
							addDuplicateDeclarationErrorsForSymbols(prop /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, unescapeLeadingUnderscores(name), symbol)
						}
					}
				}
			}
		}
		isIndirectCall := func(node BinaryExpression) bool {
			return /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ParenthesizedExpression */ TODO && isNumericLiteral( /* TODO(PropertyAccessExpression): node.left */ TODO) && /* TODO(PropertyAccessExpression): node.left.text */ TODO == "0" && /* TODO(ParenthesizedExpression): (isCallExpression(node.parent.parent) && node.parent.parent.expression === node.parent || node.parent.parent.kind === SyntaxKind.TaggedTemplateExpression) */ TODO && /* TODO(ParenthesizedExpression): (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText === "eval") */ TODO
		}
		checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
			offendingSymbolOperand := /* TODO(ConditionalExpression): maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlags.ESSymbolLike) ? left :                 maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlags.ESSymbolLike) ? right :                 undefined */ TODO
			if offendingSymbolOperand {
				error(offendingSymbolOperand /* TODO(PropertyAccessExpression): Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol */, TODO, tokenToString(operator))
				return /* TODO(FalseKeyword): false */ TODO
			}
			return /* TODO(TrueKeyword): true */ TODO
		}
		getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
			/* TODO(SwitchStatement): switch (operator) {                 case SyntaxKind.BarToken:                 case SyntaxKind.BarEqualsToken:                     return SyntaxKind.BarBarToken;                 case SyntaxKind.CaretToken:                 case SyntaxKind.CaretEqualsToken:                     return SyntaxKind.ExclamationEqualsEqualsToken;                 case SyntaxKind.AmpersandToken:                 case SyntaxKind.AmpersandEqualsToken:                     return SyntaxKind.AmpersandAmpersandToken;                 default:                     return undefined;             } */
		}
		checkAssignmentOperator := func(valueType Type) {
			if isAssignmentOperator(operator) {
				addLazyDiagnostic(checkAssignmentOperatorWorker)
			}
			checkAssignmentOperatorWorker := func() {
				assigneeType := leftType
				if isCompoundAssignment( /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO) && /* TODO(PropertyAccessExpression): left.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO {
					/* TODO(ExpressionStatement): assigneeType = checkPropertyAccessExpression(left as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true); */
				}
				if checkReferenceExpression(left /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */, TODO /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */, TODO) {
					var headMessage *DiagnosticMessage
					if exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, TODO) {
						target := getTypeOfPropertyOfType(getTypeOfExpression( /* TODO(PropertyAccessExpression): left.expression */ TODO) /* TODO(PropertyAccessExpression): left.name.escapedText */, TODO)
						if isExactOptionalPropertyMismatch(valueType, target) {
							/* TODO(ExpressionStatement): headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target; */
						}
					}
					checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage)
				}
			}
		}
		isAssignmentDeclaration := func(kind AssignmentDeclarationKind) /* TODO(undefined): boolean */ TODO {
			/* TODO(SwitchStatement): switch (kind) {                 case AssignmentDeclarationKind.ModuleExports:                     return true;                 case AssignmentDeclarationKind.ExportsProperty:                 case AssignmentDeclarationKind.Property:                 case AssignmentDeclarationKind.Prototype:                 case AssignmentDeclarationKind.PrototypeProperty:                 case AssignmentDeclarationKind.ThisProperty:                     const symbol = getSymbolOfNode(left);                     const init = getAssignedExpandoInitializer(right);                     return !!init && isObjectLiteralExpression(init) &&                         !!symbol?.exports?.size;                 default:                     return false;             } */
		}
		reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
			if !typesAreCompatible(leftType, rightType) {
				reportOperatorError(typesAreCompatible)
				return /* TODO(TrueKeyword): true */ TODO
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
		reportOperatorError := func(isRelated func(left Type, right Type) bool) {
			wouldWorkWithAwait := /* TODO(FalseKeyword): false */ TODO
			errNode := errorNode || operatorToken
			if isRelated {
				awaitedLeftType := getAwaitedTypeNoAlias(leftType)
				awaitedRightType := getAwaitedTypeNoAlias(rightType)
				/* TODO(ExpressionStatement): wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType)                     && !!(awaitedLeftType && awaitedRightType)                     && isRelated(awaitedLeftType, awaitedRightType); */
			}
			effectiveLeft := leftType
			effectiveRight := rightType
			if !wouldWorkWithAwait && isRelated {
				/* TODO(ExpressionStatement): [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated); */
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
			if !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) {
				errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait /* TODO(PropertyAccessExpression): Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2 */, TODO, tokenToString( /* TODO(PropertyAccessExpression): operatorToken.kind */ TODO), leftStr, rightStr)
			}
		}
		tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic | undefined */ TODO {
			/* TODO(SwitchStatement): switch (operatorToken.kind) {                 case SyntaxKind.EqualsEqualsEqualsToken:                 case SyntaxKind.EqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsToken:                     return errorAndMaybeSuggestAwait(                         errNode,                         maybeMissingAwait,                         Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap,                         leftStr,                         rightStr,                     );                 default:                     return undefined;             } */
		}
		checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
			isLeftNaN := isGlobalNaN(skipParentheses(left))
			isRightNaN := isGlobalNaN(skipParentheses(right))
			if isLeftNaN || isRightNaN {
				err := error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.This_condition_will_always_return_0 */, TODO, tokenToString( /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword */ TODO))
				if isLeftNaN && isRightNaN {
				}
				operatorString := /* TODO(ConditionalExpression): operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "" */ TODO
				location := /* TODO(ConditionalExpression): isLeftNaN ? right : left */ TODO
				expression := skipParentheses(location)
				addRelatedInfo(err, createDiagnosticForNode(location /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_0 */, TODO /* TODO(TemplateExpression): `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})` */, TODO))
			}
		}
		isGlobalNaN := func(expr Expression) bool {
			if isIdentifier(expr) && /* TODO(PropertyAccessExpression): expr.escapedText */ TODO == "NaN" {
				globalNaNSymbol := getGlobalNaNSymbol()
				return !!globalNaNSymbol && globalNaNSymbol == getResolvedSymbol(expr)
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	getBaseTypesIfUnrelated := func(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TupleType): [Type, Type] */ TODO {
		effectiveLeft := leftType
		effectiveRight := rightType
		leftBase := getBaseTypeOfLiteralType(leftType)
		rightBase := getBaseTypeOfLiteralType(rightType)
		if !isRelated(leftBase, rightBase) {
			/* TODO(ExpressionStatement): effectiveLeft = leftBase; */
			/* TODO(ExpressionStatement): effectiveRight = rightBase; */
		}
		return /* TODO(ArrayLiteralExpression): [effectiveLeft, effectiveRight] */ TODO
	}
	checkYieldExpression := func(node YieldExpression) Type {
		addLazyDiagnostic(checkYieldExpressionGrammar)
		func_ := getContainingFunction(node)
		if !func_ {
			/* TODO(Identifier): anyType */
		}
		functionFlags := getFunctionFlags(func_)
		if ! /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.Generator) */ TODO {
			return anyType
		}
		isAsync := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
		if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
			if isAsync && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.AsyncGenerators */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.AsyncDelegatorIncludes */, TODO)
			}
			if !isAsync && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.Generators */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.downlevelIteration */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Values */, TODO)
			}
		}
		returnType := getReturnTypeFromAnnotation(func_)
		if returnType && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): returnType.flags & TypeFlags.Union */ TODO {
			/* TODO(ExpressionStatement): returnType = filterType(returnType, t => checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, /*errorNode* / undefined)); */
		}
		iterationTypes := returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync)
		signatureYieldType := iterationTypes && /* TODO(PropertyAccessExpression): iterationTypes.yieldType */ TODO || anyType
		signatureNextType := iterationTypes && /* TODO(PropertyAccessExpression): iterationTypes.nextType */ TODO || anyType
		yieldExpressionType := /* TODO(ConditionalExpression): node.expression ? checkExpression(node.expression) : undefinedWideningType */ TODO
		yieldedType := getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
		if returnType && yieldedType {
			checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType /* TODO(PropertyAccessExpression): node.expression */, TODO || node /* TODO(PropertyAccessExpression): node.expression */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
			use := /* TODO(ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */ TODO
			return getIterationTypeOfIterable(use /* TODO(PropertyAccessExpression): IterationTypeKind.Return */, TODO, yieldExpressionType /* TODO(PropertyAccessExpression): node.expression */, TODO) || anyType
		} else if returnType {
			return getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Next */ TODO, returnType, isAsync) || anyType
		}
		type_ := getContextualIterationType( /* TODO(PropertyAccessExpression): IterationTypeKind.Next */ TODO, func_)
		if !type_ {
			/* TODO(ExpressionStatement): type = anyType; */
			addLazyDiagnostic( /* TODO(ArrowFunction): () => {                 if (noImplicitAny && !expressionResultIsUnused(node)) {                     const contextualType = getContextualType(node, /*contextFlags* / undefined);                     if (!contextualType || isTypeAny(contextualType)) {                         error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation);                     }                 }             } */ TODO)
		}
		return type_
		checkYieldExpressionGrammar := func() {
			if ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.YieldContext) */ TODO {
				grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body */, TODO)
			}
			if isInParameterInitializerBeforeContainingFunction(node) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer */, TODO)
			}
		}
	}
	checkConditionalExpression := func(node ConditionalExpression, checkMode CheckMode) Type {
		type_ := checkTruthinessExpression( /* TODO(PropertyAccessExpression): node.condition */ TODO, checkMode)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType( /* TODO(PropertyAccessExpression): node.condition */ TODO, type_ /* TODO(PropertyAccessExpression): node.whenTrue */, TODO)
		type1 := checkExpression( /* TODO(PropertyAccessExpression): node.whenTrue */ TODO, checkMode)
		type2 := checkExpression( /* TODO(PropertyAccessExpression): node.whenFalse */ TODO, checkMode)
		return getUnionType( /* TODO(ArrayLiteralExpression): [type1, type2] */ TODO /* TODO(PropertyAccessExpression): UnionReduction.Subtype */, TODO)
	}
	isTemplateLiteralContext := func(node Node) bool {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && /* TODO(PropertyAccessExpression): parent.argumentExpression */ TODO == node
	}
	checkTemplateExpression := func(node TemplateExpression) Type {
		texts := /* TODO(ArrayLiteralExpression): [node.head.text] */ TODO
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, span := range /* TODO(PropertyAccessExpression): node.templateSpans */ TODO {
			type_ := checkExpression( /* TODO(PropertyAccessExpression): span.expression */ TODO)
			if maybeTypeOfKindConsideringBaseConstraint(type_ /* TODO(PropertyAccessExpression): TypeFlags.ESSymbolLike */, TODO) {
				error( /* TODO(PropertyAccessExpression): span.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String */, TODO)
			}
			/* TODO(PropertyAccessExpression): texts.push */ TODO( /* TODO(PropertyAccessExpression): span.literal.text */ TODO)
			/* TODO(PropertyAccessExpression): types.push */ TODO( /* TODO(ConditionalExpression): isTypeAssignableTo(type, templateConstraintType) ? type : stringType */ TODO)
		}
		evaluated := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.TaggedTemplateExpression */ TODO && /* TODO(PropertyAccessExpression): evaluate(node).value */ TODO
		if evaluated {
			return getFreshTypeOfLiteralType(getStringLiteralType(evaluated))
		}
		if isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node, nil) || unknownType, isTemplateLiteralContextualType) {
			return getTemplateLiteralType(texts, types)
		}
		return stringType
	}
	isTemplateLiteralContextualType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral) ||             type.flags & TypeFlags.InstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, TypeFlags.StringLike)) */ TODO
	}
	getContextNode := func(node Expression) Expression {
		if isJsxAttributes(node) && !isJsxSelfClosingElement( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			return /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
		}
		return node
	}
	checkExpressionWithContextualType := func(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
		contextNode := getContextNode(node)
		pushContextualType(contextNode, contextualType /* TODO(FalseKeyword): false */, TODO)
		pushInferenceContext(contextNode, inferenceContext)
		type_ := checkExpression(node /* TODO(BarToken): | */ /* TODO(BinaryExpression): checkMode | CheckMode.Contextual | (inferenceContext ? CheckMode.Inferential : 0) */, TODO)
		if inferenceContext && /* TODO(PropertyAccessExpression): inferenceContext.intraExpressionInferenceSites */ TODO {
			/* TODO(ExpressionStatement): inferenceContext.intraExpressionInferenceSites = undefined; */
		}
		result := /* TODO(ConditionalExpression): maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags* / undefined)) ?             getRegularTypeOfLiteralType(type) : type */ TODO
		popInferenceContext()
		popContextualType()
		return result
	}
	checkExpressionCached := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode) Type {
		if checkMode {
			return checkExpression(node, checkMode)
		}
		links := getNodeLinks(node)
		if ! /* TODO(PropertyAccessExpression): links.resolvedType */ TODO {
			saveFlowLoopStart := flowLoopStart
			saveFlowTypeCache := flowTypeCache
			/* TODO(ExpressionStatement): flowLoopStart = flowLoopCount; */
			/* TODO(ExpressionStatement): flowTypeCache = undefined; */
			/* TODO(ExpressionStatement): links.resolvedType = checkExpression(node, checkMode); */
			/* TODO(ExpressionStatement): flowTypeCache = saveFlowTypeCache; */
			/* TODO(ExpressionStatement): flowLoopStart = saveFlowLoopStart; */
		}
		return /* TODO(PropertyAccessExpression): links.resolvedType */ TODO
	}
	isTypeAssertion := func(node Expression) /* TODO(undefined): boolean */ TODO {
		/* TODO(ExpressionStatement): node = skipParentheses(node, /*excludeJSDocTypeAssertions* / true); */
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeAssertionExpression */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.AsExpression */ TODO || isJSDocTypeAssertion(node)
	}
	checkDeclarationInitializer := func(declaration HasExpressionInitializer, checkMode CheckMode, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		initializer := /* TODO(NonNullExpression): getEffectiveInitializer(declaration)! */ TODO
		if isInJSFile(declaration) {
			typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
			if typeNode {
				return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
			}
		}
		type_ := getQuickTypeOfExpression(initializer) || /* TODO(ParenthesizedExpression): (contextualType ?             checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext* / undefined, checkMode || CheckMode.Normal) :             checkExpressionCached(initializer, checkMode)) */ TODO
		if isParameter( /* TODO(ConditionalExpression): isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration */ TODO) {
			if /* TODO(PropertyAccessExpression): declaration.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectBindingPattern */ TODO && isObjectLiteralType(type_) {
				return padObjectLiteralType(type_ /* as */ /* TODO(TypeReference): ObjectType */ /* TODO(PropertyAccessExpression): declaration.name */, TODO)
			}
			if /* TODO(PropertyAccessExpression): declaration.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayBindingPattern */ TODO && isTupleType(type_) {
				return padTupleType(type_ /* TODO(PropertyAccessExpression): declaration.name */, TODO)
			}
		}
		return type_
	}
	padObjectLiteralType := func(type_ ObjectType, pattern ObjectBindingPattern) Type {
		var missingElements /* TODO(ArrayType): BindingElement[] */ any
		for _, e := range /* TODO(PropertyAccessExpression): pattern.elements */ TODO {
			if /* TODO(PropertyAccessExpression): e.initializer */ TODO {
				name := getPropertyNameFromBindingElement(e)
				if name && !getPropertyOfType(type_, name) {
					/* TODO(ExpressionStatement): missingElements = append(missingElements, e); */
				}
			}
		}
		if !missingElements {
			return type_
		}
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			/* TODO(PropertyAccessExpression): members.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO, prop)
		}
		for _, e := range missingElements {
			symbol := createSymbol( /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Property | SymbolFlags.Optional */ TODO /* TODO(NonNullExpression): getPropertyNameFromBindingElement(e)! */, TODO)
			/* TODO(ExpressionStatement): symbol.links.type = getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false); */
			/* TODO(PropertyAccessExpression): members.set */
			TODO( /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO, symbol)
		}
		result := createAnonymousType( /* TODO(PropertyAccessExpression): type.symbol */ TODO, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
		/* TODO(ExpressionStatement): result.objectFlags = type.objectFlags; */
		return result
	}
	getPropertyNameFromBindingElement := func(e BindingElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		exprType := getLiteralTypeFromPropertyName( /* TODO(PropertyAccessExpression): e.propertyName */ TODO || /* TODO(PropertyAccessExpression): e.name */ TODO /* as */ /* TODO(TypeReference): Identifier */)
		return /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(exprType) ? getPropertyNameFromType(exprType) : undefined */ TODO
	}
	padTupleType := func(type_ TupleTypeReference, pattern ArrayBindingPattern) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.target.combinedFlags & ElementFlags.Variable */ TODO || getTypeReferenceArity(type_) >= /* TODO(PropertyAccessExpression): pattern.elements.length */ TODO {
			return type_
		}
		patternElements := /* TODO(PropertyAccessExpression): pattern.elements */ TODO
		elementTypes := /* TODO(PropertyAccessExpression): getElementTypes(type).slice */ TODO()
		elementFlags := /* TODO(PropertyAccessExpression): type.target.elementFlags.slice */ TODO()
		/* TODO(ForStatement): for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {             const e = patternElements[i];             if (i < patternElements.length - 1 || !(e.kind === SyntaxKind.BindingElement && e.dotDotDotToken)) {                 elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false) : anyType);                 elementFlags.push(ElementFlags.Optional);                 if (!isOmittedExpression(e) && !hasDefaultValue(e)) {                     reportImplicitAny(e, anyType);                 }             }         } */
		return createTupleType(elementTypes, elementFlags /* TODO(PropertyAccessExpression): type.target.readonly */, TODO)
	}
	widenTypeInferredFromInitializer := func(declaration HasExpressionInitializer, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		widened := /* TODO(ConditionalExpression): getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type) */ TODO
		if isInJSFile(declaration) {
			if isEmptyLiteralType(widened) {
				reportImplicitAny(declaration, anyType)
				return anyType
			} else if isEmptyArrayLiteralType(widened) {
				reportImplicitAny(declaration, anyArrayType)
				return anyArrayType
			}
		}
		return widened
	}
	isLiteralOfContextualType := func(candidateType Type, contextualType *Type) bool {
		if contextualType {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): contextualType.flags & TypeFlags.UnionOrIntersection */ TODO {
				types := /* TODO(PropertyAccessExpression): (contextualType as UnionType).types */ TODO
				return some(types /* TODO(ArrowFunction): t => isLiteralOfContextualType(candidateType, t) */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): contextualType.flags & TypeFlags.InstantiableNonPrimitive */ TODO {
				constraint := getBaseConstraintOfType(contextualType) || unknownType
				return maybeTypeOfKind(constraint /* TODO(PropertyAccessExpression): TypeFlags.String */, TODO) && maybeTypeOfKind(candidateType /* TODO(PropertyAccessExpression): TypeFlags.StringLiteral */, TODO) || maybeTypeOfKind(constraint /* TODO(PropertyAccessExpression): TypeFlags.Number */, TODO) && maybeTypeOfKind(candidateType /* TODO(PropertyAccessExpression): TypeFlags.NumberLiteral */, TODO) || maybeTypeOfKind(constraint /* TODO(PropertyAccessExpression): TypeFlags.BigInt */, TODO) && maybeTypeOfKind(candidateType /* TODO(PropertyAccessExpression): TypeFlags.BigIntLiteral */, TODO) || maybeTypeOfKind(constraint /* TODO(PropertyAccessExpression): TypeFlags.ESSymbol */, TODO) && maybeTypeOfKind(candidateType /* TODO(PropertyAccessExpression): TypeFlags.UniqueESSymbol */, TODO) || isLiteralOfContextualType(candidateType, constraint)
			}
			return !! /* TODO(ParenthesizedExpression): (contextualType.flags & (TypeFlags.StringLiteral | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && maybeTypeOfKind(candidateType, TypeFlags.StringLiteral) ||                 contextualType.flags & TypeFlags.NumberLiteral && maybeTypeOfKind(candidateType, TypeFlags.NumberLiteral) ||                 contextualType.flags & TypeFlags.BigIntLiteral && maybeTypeOfKind(candidateType, TypeFlags.BigIntLiteral) ||                 contextualType.flags & TypeFlags.BooleanLiteral && maybeTypeOfKind(candidateType, TypeFlags.BooleanLiteral) ||                 contextualType.flags & TypeFlags.UniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlags.UniqueESSymbol)) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isConstContext := func(node Expression) bool {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		return isAssertionExpression(parent) && isConstTypeReference( /* TODO(PropertyAccessExpression): parent.type */ TODO) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node /* TODO(PropertyAccessExpression): ContextFlags.None */, TODO)) || /* TODO(ParenthesizedExpression): (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) */ TODO && isConstContext(parent) || /* TODO(ParenthesizedExpression): (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) */ TODO && isConstContext( /* TODO(PropertyAccessExpression): parent.parent */ TODO)
	}
	checkExpressionForMutableLocation := func(node Expression, checkMode *CheckMode, forceTuple bool) Type {
		type_ := checkExpression(node, checkMode, forceTuple)
		return /* TODO(ConditionalExpression): isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) :             isTypeAssertion(node) ? type :             getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType(node, /*contextFlags* / undefined), node, /*contextFlags* / undefined)) */ TODO
	}
	checkPropertyAssignment := func(node PropertyAssignment, checkMode CheckMode) Type {
		if /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
			checkComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO)
		}
		return checkExpressionForMutableLocation( /* TODO(PropertyAccessExpression): node.initializer */ TODO, checkMode)
	}
	checkObjectLiteralMethod := func(node MethodDeclaration, checkMode CheckMode) Type {
		checkGrammarMethod(node)
		if /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
			checkComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO)
		}
		uninstantiatedType := checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
	}
	instantiateTypeWithSingleGenericCallSignature := func(node /* TODO(UnionType): Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if checkMode && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & (CheckMode.Inferential | CheckMode.SkipGenericFunctions) */ TODO {
			callSignature := getSingleSignature(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO /* TODO(TrueKeyword): true */, TODO)
			constructSignature := getSingleSignature(type_ /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO /* TODO(TrueKeyword): true */, TODO)
			signature := callSignature || constructSignature
			if signature && /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO {
				contextualType := getApparentTypeOfContextualType(node /* as */ /* TODO(TypeReference): Expression */ /* TODO(PropertyAccessExpression): ContextFlags.NoConstraints */, TODO)
				if contextualType {
					contextualSignature := getSingleSignature(getNonNullableType(contextualType) /* TODO(ConditionalExpression): callSignature ? SignatureKind.Call : SignatureKind.Construct */, TODO /* TODO(FalseKeyword): false */, TODO)
					if contextualSignature && ! /* TODO(PropertyAccessExpression): contextualSignature.typeParameters */ TODO {
						if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.SkipGenericFunctions */ TODO {
							skippedGenericFunction(node, checkMode)
							return anyFunctionType
						}
						context := /* TODO(NonNullExpression): getInferenceContext(node)! */ TODO
						returnType := /* TODO(PropertyAccessExpression): context.signature */ TODO && getReturnTypeOfSignature( /* TODO(PropertyAccessExpression): context.signature */ TODO)
						returnSignature := returnType && getSingleCallOrConstructSignature(returnType)
						if returnSignature && ! /* TODO(PropertyAccessExpression): returnSignature.typeParameters */ TODO && !every( /* TODO(PropertyAccessExpression): context.inferences */ TODO, hasInferenceCandidates) {
							uniqueTypeParameters := getUniqueTypeParameters(context /* TODO(PropertyAccessExpression): signature.typeParameters */, TODO)
							instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
							inferences := map_( /* TODO(PropertyAccessExpression): context.inferences */ TODO /* TODO(ArrowFunction): info => createInferenceInfo(info.typeParameter) */, TODO)
							applyToParameterTypes(instantiatedSignature, contextualSignature /* TODO(ArrowFunction): (source, target) => {                                 inferTypes(inferences, source, target, /*priority* / 0, /*contravariant* / true);                             } */, TODO)
							if some(inferences, hasInferenceCandidates) {
								applyToReturnTypes(instantiatedSignature, contextualSignature /* TODO(ArrowFunction): (source, target) => {                                     inferTypes(inferences, source, target);                                 } */, TODO)
								if !hasOverlappingInferences( /* TODO(PropertyAccessExpression): context.inferences */ TODO, inferences) {
									mergeInferences( /* TODO(PropertyAccessExpression): context.inferences */ TODO, inferences)
									/* TODO(ExpressionStatement): context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters); */
									return getOrCreateTypeFromSignature(instantiatedSignature)
								}
							}
						}
						return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context) /* TODO(PropertyAccessExpression): flatMap(inferenceContexts, c => c && map(c.inferences, i => i.typeParameter)).slice */, TODO())
					}
				}
			}
		}
		return type_
	}
	skippedGenericFunction := func(node Node, checkMode CheckMode) {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): checkMode & CheckMode.Inferential */ TODO {
			context := /* TODO(NonNullExpression): getInferenceContext(node)! */ TODO
			/* TODO(ExpressionStatement): context.flags |= InferenceFlags.SkippedGenericFunction; */
		}
	}
	hasInferenceCandidates := func(info InferenceInfo) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (info.candidates || info.contraCandidates) */ TODO
	}
	hasInferenceCandidatesOrDefault := func(info InferenceInfo) /* TODO(undefined): boolean */ TODO {
		return !! /* TODO(ParenthesizedExpression): (info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter)) */ TODO
	}
	hasOverlappingInferences := func(a []InferenceInfo, b []InferenceInfo) /* TODO(undefined): boolean */ TODO {
		/* TODO(ForStatement): for (let i = 0; i < a.length; i++) {             if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {                 return true;             }         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	mergeInferences := func(target []InferenceInfo, source []InferenceInfo) {
		/* TODO(ForStatement): for (let i = 0; i < target.length; i++) {             if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {                 target[i] = source[i];             }         } */
	}
	getUniqueTypeParameters := func(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
		var result []TypeParameter = /* TODO(ArrayLiteralExpression): [] */ TODO
		var oldTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		var newTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		for _, tp := range typeParameters {
			name := /* TODO(PropertyAccessExpression): tp.symbol.escapedName */ TODO
			if hasTypeParameterByName( /* TODO(PropertyAccessExpression): context.inferredTypeParameters */ TODO, name) || hasTypeParameterByName(result, name) {
				newName := getUniqueTypeParameterName(concatenate( /* TODO(PropertyAccessExpression): context.inferredTypeParameters */ TODO, result), name)
				symbol := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.TypeParameter */ TODO, newName)
				newTypeParameter := createTypeParameter(symbol)
				/* TODO(ExpressionStatement): newTypeParameter.target = tp; */
				/* TODO(ExpressionStatement): oldTypeParameters = append(oldTypeParameters, tp); */
				/* TODO(ExpressionStatement): newTypeParameters = append(newTypeParameters, newTypeParameter); */
				/* TODO(PropertyAccessExpression): result.push */
				TODO(newTypeParameter)
			} else {
				/* TODO(PropertyAccessExpression): result.push */ TODO(tp)
			}
		}
		if newTypeParameters {
			mapper := createTypeMapper( /* TODO(NonNullExpression): oldTypeParameters! */ TODO, newTypeParameters)
			for _, tp := range newTypeParameters {
				/* TODO(ExpressionStatement): tp.mapper = mapper; */
			}
		}
		return result
	}
	hasTypeParameterByName := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, name __String) /* TODO(undefined): boolean */ TODO {
		return some(typeParameters /* TODO(ArrowFunction): tp => tp.symbol.escapedName === name */, TODO)
	}
	getUniqueTypeParameterName := func(typeParameters []TypeParameter, baseName __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		len := /* TODO(PropertyAccessExpression): (baseName as string).length */ TODO
		/* TODO(WhileStatement): while (len > 1 && (baseName as string).charCodeAt(len - 1) >= CharacterCodes._0 && (baseName as string).charCodeAt(len - 1) <= CharacterCodes._9) len--; */
		s := /* TODO(PropertyAccessExpression): (baseName as string).slice */ TODO(0, len)
		/* TODO(ForStatement): for (let index = 1; true; index++) {             const augmentedName = s + index as __String;             if (!hasTypeParameterByName(typeParameters, augmentedName)) {                 return augmentedName;             }         } */
	}
	getReturnTypeOfSingleNonGenericCallSignature := func(funcType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSingleCallSignature(funcType)
		if signature && ! /* TODO(PropertyAccessExpression): signature.typeParameters */ TODO {
			return getReturnTypeOfSignature(signature)
		}
	}
	getReturnTypeOfSingleNonGenericSignatureOfCallChain := func(expr CallChain) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		funcType := checkExpression( /* TODO(PropertyAccessExpression): expr.expression */ TODO)
		nonOptionalType := getOptionalExpressionType(funcType /* TODO(PropertyAccessExpression): expr.expression */, TODO)
		returnType := getReturnTypeOfSingleNonGenericCallSignature(funcType)
		return returnType && propagateOptionalTypeMarker(returnType, expr /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== funcType */, TODO)
	}
	getTypeOfExpression := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		quickType := getQuickTypeOfExpression(node)
		if quickType {
			return quickType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.TypeCached */ TODO && flowTypeCache {
			cachedType := /* TODO(ElementAccessExpression): flowTypeCache[getNodeId(node)] */ TODO
			if cachedType {
				return cachedType
			}
		}
		startInvocationCount := flowInvocationCount
		type_ := checkExpression(node /* TODO(PropertyAccessExpression): CheckMode.TypeOnly */, TODO)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): flowInvocationCount !== startInvocationCount */ TODO {
			cache := flowTypeCache || /* TODO(ParenthesizedExpression): (flowTypeCache = []) */ TODO
			/* TODO(ExpressionStatement): cache[getNodeId(node)] = type; */
			setNodeFlags(node /* TODO(BarToken): | */ /* TODO(BinaryExpression): node.flags | NodeFlags.TypeCached */, TODO)
		}
		return type_
	}
	getQuickTypeOfExpression := func(node Expression) *Type {
		expr := skipParentheses(node /* TODO(TrueKeyword): true */, TODO)
		if isJSDocTypeAssertion(expr) {
			type_ := getJSDocTypeAssertionType(expr)
			if !isConstTypeReference(type_) {
				return getTypeFromTypeNode(type_)
			}
		}
		/* TODO(ExpressionStatement): expr = skipParentheses(node); */
		if isAwaitExpression(expr) {
			type_ := getQuickTypeOfExpression( /* TODO(PropertyAccessExpression): expr.expression */ TODO)
			return /* TODO(ConditionalExpression): type ? getAwaitedType(type) : undefined */ TODO
		}
		if isCallExpression(expr) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): expr.expression.kind !== SyntaxKind.SuperKeyword */ TODO && !isRequireCall(expr /* TODO(TrueKeyword): true */, TODO) && !isSymbolOrSymbolForCall(expr) {
			return /* TODO(ConditionalExpression): isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :                 getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression)) */ TODO
		} else if isAssertionExpression(expr) && !isConstTypeReference( /* TODO(PropertyAccessExpression): expr.type */ TODO) {
			return getTypeFromTypeNode( /* TODO(PropertyAccessExpression): (expr as TypeAssertion).type */ TODO)
		} else if isLiteralExpression(node) || isBooleanLiteral(node) {
			return checkExpression(node)
		}
		return nil
	}
	getContextFreeTypeOfExpression := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO {
			return /* TODO(PropertyAccessExpression): links.contextFreeType */ TODO
		}
		pushContextualType(node, anyType /* TODO(FalseKeyword): false */, TODO)
		type_ := /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
		popContextualType()
		return type_
	}
	checkExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
		/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.Check */ TODO, "checkExpression" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		/* TODO(ExpressionStatement): currentNode = node; */
		/* TODO(ExpressionStatement): instantiationCount = 0; */
		uninstantiatedType := checkExpressionWorker(node, checkMode, forceTuple)
		type_ := instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
		if isConstEnumObjectType(type_) {
			checkConstEnumAccess(node, type_)
		}
		/* TODO(ExpressionStatement): currentNode = saveCurrentNode; */
		/* TODO(PropertyAccessExpression): tracing?.pop */
		TODO()
		return type_
	}
	checkConstEnumAccess := func(node /* TODO(UnionType): Expression | QualifiedName */ any, type_ Type) {
		ok := /* TODO(ParenthesizedExpression): (node.parent.kind === SyntaxKind.PropertyAccessExpression && (node.parent as PropertyAccessExpression).expression === node) */ TODO || /* TODO(ParenthesizedExpression): (node.parent.kind === SyntaxKind.ElementAccessExpression && (node.parent as ElementAccessExpression).expression === node) */ TODO || /* TODO(ParenthesizedExpression): ((node.kind === SyntaxKind.Identifier || node.kind === SyntaxKind.QualifiedName) && isInRightSideOfImportOrExportAssignment(node as Identifier) ||                 (node.parent.kind === SyntaxKind.TypeQuery && (node.parent as TypeQueryNode).exprName === node)) */ TODO || /* TODO(ParenthesizedExpression): (node.parent.kind === SyntaxKind.ExportSpecifier) */ TODO
		if !ok {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query */, TODO)
		}
		if /* TODO(PropertyAccessExpression): compilerOptions.isolatedModules */ TODO || /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && ok && !resolveName(node, getFirstIdentifier(node /* as */ /* TODO(TypeReference): EntityNameOrEntityNameExpression */) /* TODO(PropertyAccessExpression): SymbolFlags.Alias */, TODO, nil /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO) {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!! /* TODO(ParenthesizedExpression): (type.symbol.flags & SymbolFlags.ConstEnum) */ TODO)
			constEnumDeclaration := /* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): EnumDeclaration */
			redirect := /* TODO(PropertyAccessExpression): host.getRedirectReferenceForResolutionFromSourceOfProject */ TODO( /* TODO(PropertyAccessExpression): getSourceFileOfNode(constEnumDeclaration).resolvedPath */ TODO)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constEnumDeclaration.flags & NodeFlags.Ambient */ TODO && !isValidTypeOnlyAliasUseSite(node) && /* TODO(ParenthesizedExpression): (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled */, TODO, isolatedModulesLikeFlagName)
			}
		}
	}
	checkParenthesizedExpression := func(node ParenthesizedExpression, checkMode CheckMode) Type {
		if hasJSDocNodes(node) {
			if isJSDocSatisfiesExpression(node) {
				return checkSatisfiesExpressionWorker( /* TODO(PropertyAccessExpression): node.expression */ TODO, getJSDocSatisfiesExpressionType(node), checkMode)
			}
			if isJSDocTypeAssertion(node) {
				return checkAssertionWorker(node, checkMode)
			}
		}
		return checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO, checkMode)
	}
	checkExpressionWorker := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
		kind := /* TODO(PropertyAccessExpression): node.kind */ TODO
		if cancellationToken {
			/* TODO(SwitchStatement): switch (kind) {                 case SyntaxKind.ClassExpression:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                     cancellationToken.throwIfCancellationRequested();             } */
		}
		/* TODO(SwitchStatement): switch (kind) {             case SyntaxKind.Identifier:                 return checkIdentifier(node as Identifier, checkMode);             case SyntaxKind.PrivateIdentifier:                 return checkPrivateIdentifierExpression(node as PrivateIdentifier);             case SyntaxKind.ThisKeyword:                 return checkThisExpression(node);             case SyntaxKind.SuperKeyword:                 return checkSuperExpression(node);             case SyntaxKind.NullKeyword:                 return nullWideningType;             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.StringLiteral:                 return hasSkipDirectInferenceFlag(node) ?                     blockedStringType :                     getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteralLike).text));             case SyntaxKind.NumericLiteral:                 checkGrammarNumericLiteral(node as NumericLiteral);                 return getFreshTypeOfLiteralType(getNumberLiteralType(+(node as NumericLiteral).text));             case SyntaxKind.BigIntLiteral:                 checkGrammarBigIntLiteral(node as BigIntLiteral);                 return getFreshTypeOfLiteralType(getBigIntLiteralType({                     negative: false,                     base10Value: parsePseudoBigInt((node as BigIntLiteral).text),                 }));             case SyntaxKind.TrueKeyword:                 return trueType;             case SyntaxKind.FalseKeyword:                 return falseType;             case SyntaxKind.TemplateExpression:                 return checkTemplateExpression(node as TemplateExpression);             case SyntaxKind.RegularExpressionLiteral:                 return checkRegularExpressionLiteral(node as RegularExpressionLiteral);             case SyntaxKind.ArrayLiteralExpression:                 return checkArrayLiteral(node as ArrayLiteralExpression, checkMode, forceTuple);             case SyntaxKind.ObjectLiteralExpression:                 return checkObjectLiteral(node as ObjectLiteralExpression, checkMode);             case SyntaxKind.PropertyAccessExpression:                 return checkPropertyAccessExpression(node as PropertyAccessExpression, checkMode);             case SyntaxKind.QualifiedName:                 return checkQualifiedName(node as QualifiedName, checkMode);             case SyntaxKind.ElementAccessExpression:                 return checkIndexedAccess(node as ElementAccessExpression, checkMode);             case SyntaxKind.CallExpression:                 if ((node as CallExpression).expression.kind === SyntaxKind.ImportKeyword) {                     return checkImportCallExpression(node as ImportCall);                 }                 // falls through             case SyntaxKind.NewExpression:                 return checkCallExpression(node as CallExpression, checkMode);             case SyntaxKind.TaggedTemplateExpression:                 return checkTaggedTemplateExpression(node as TaggedTemplateExpression);             case SyntaxKind.ParenthesizedExpression:                 return checkParenthesizedExpression(node as ParenthesizedExpression, checkMode);             case SyntaxKind.ClassExpression:                 return checkClassExpression(node as ClassExpression);             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return checkFunctionExpressionOrObjectLiteralMethod(node as FunctionExpression | ArrowFunction, checkMode);             case SyntaxKind.TypeOfExpression:                 return checkTypeOfExpression(node as TypeOfExpression);             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:                 return checkAssertion(node as AssertionExpression, checkMode);             case SyntaxKind.NonNullExpression:                 return checkNonNullAssertion(node as NonNullExpression);             case SyntaxKind.ExpressionWithTypeArguments:                 return checkExpressionWithTypeArguments(node as ExpressionWithTypeArguments);             case SyntaxKind.SatisfiesExpression:                 return checkSatisfiesExpression(node as SatisfiesExpression);             case SyntaxKind.MetaProperty:                 return checkMetaProperty(node as MetaProperty);             case SyntaxKind.DeleteExpression:                 return checkDeleteExpression(node as DeleteExpression);             case SyntaxKind.VoidExpression:                 return checkVoidExpression(node as VoidExpression);             case SyntaxKind.AwaitExpression:                 return checkAwaitExpression(node as AwaitExpression);             case SyntaxKind.PrefixUnaryExpression:                 return checkPrefixUnaryExpression(node as PrefixUnaryExpression);             case SyntaxKind.PostfixUnaryExpression:                 return checkPostfixUnaryExpression(node as PostfixUnaryExpression);             case SyntaxKind.BinaryExpression:                 return checkBinaryExpression(node as BinaryExpression, checkMode);             case SyntaxKind.ConditionalExpression:                 return checkConditionalExpression(node as ConditionalExpression, checkMode);             case SyntaxKind.SpreadElement:                 return checkSpreadExpression(node as SpreadElement, checkMode);             case SyntaxKind.OmittedExpression:                 return undefinedWideningType;             case SyntaxKind.YieldExpression:                 return checkYieldExpression(node as YieldExpression);             case SyntaxKind.SyntheticExpression:                 return checkSyntheticExpression(node as SyntheticExpression);             case SyntaxKind.JsxExpression:                 return checkJsxExpression(node as JsxExpression, checkMode);             case SyntaxKind.JsxElement:                 return checkJsxElement(node as JsxElement, checkMode);             case SyntaxKind.JsxSelfClosingElement:                 return checkJsxSelfClosingElement(node as JsxSelfClosingElement, checkMode);             case SyntaxKind.JsxFragment:                 return checkJsxFragment(node as JsxFragment);             case SyntaxKind.JsxAttributes:                 return checkJsxAttributes(node as JsxAttributes, checkMode);             case SyntaxKind.JsxOpeningElement:                 Debug.fail("Shouldn't ever directly check a JsxOpeningElement");         } */
		return errorType
	}
	checkTypeParameter := func(node TypeParameterDeclaration) {
		checkGrammarModifiers(node)
		if /* TODO(PropertyAccessExpression): node.expression */ TODO {
			grammarErrorOnFirstToken( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_expected */, TODO)
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.constraint */ TODO)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.default */ TODO)
		typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
		getBaseConstraintOfType(typeParameter)
		if !hasNonCircularTypeParameterDefault(typeParameter) {
			error( /* TODO(PropertyAccessExpression): node.default */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_parameter_0_has_a_circular_default */, TODO, typeToString(typeParameter))
		}
		constraintType := getConstraintOfTypeParameter(typeParameter)
		defaultType := getDefaultFromTypeParameter(typeParameter)
		if constraintType && defaultType {
			checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType) /* TODO(PropertyAccessExpression): node.default */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_0_does_not_satisfy_the_constraint_1 */, TODO)
		}
		checkNodeDeferred(node)
		addLazyDiagnostic( /* TODO(ArrowFunction): () => checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0) */ TODO)
	}
	checkTypeParameterDeferred := func(node TypeParameterDeclaration) {
		if isInterfaceDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO) || isClassLike( /* TODO(PropertyAccessExpression): node.parent */ TODO) || isTypeAliasDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
			modifiers := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getTypeParameterModifiers(typeParameter) & (ModifierFlags.In | ModifierFlags.Out) */ TODO
			if modifiers {
				symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO)
				if isTypeAliasDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO) && ! /* TODO(ParenthesizedExpression): (getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlags.Reference | ObjectFlags.Anonymous | ObjectFlags.Mapped)) */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types */, TODO)
				} else if modifiers == /* TODO(PropertyAccessExpression): ModifierFlags.In */ TODO || modifiers == /* TODO(PropertyAccessExpression): ModifierFlags.Out */ TODO {
					/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.CheckTypes */ TODO, "checkTypeParameterDeferred" /* TODO(ObjectLiteralExpression): { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) } */, TODO)
					source := createMarkerType(symbol, typeParameter /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck */, TODO)
					target := createMarkerType(symbol, typeParameter /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck */, TODO)
					saveVarianceTypeParameter := typeParameter
					/* TODO(ExpressionStatement): varianceTypeParameter = typeParameter; */
					checkTypeAssignableTo(source, target, node /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation */, TODO)
					/* TODO(ExpressionStatement): varianceTypeParameter = saveVarianceTypeParameter; */
					/* TODO(PropertyAccessExpression): tracing?.pop */
					TODO()
				}
			}
		}
	}
	checkParameter := func(node ParameterDeclaration) {
		checkGrammarModifiers(node)
		checkVariableLikeDeclaration(node)
		func_ := /* TODO(NonNullExpression): getContainingFunction(node)! */ TODO
		if hasSyntacticModifier(node /* TODO(PropertyAccessExpression): ModifierFlags.ParameterPropertyModifier */, TODO) {
			if ! /* TODO(ParenthesizedExpression): (func.kind === SyntaxKind.Constructor && nodeIsPresent(func.body)) */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation */, TODO)
			}
			if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO && isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && /* TODO(PropertyAccessExpression): node.name.escapedText */ TODO == "constructor" {
				error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name */, TODO)
			}
		}
		if ! /* TODO(PropertyAccessExpression): node.initializer */ TODO && isOptionalDeclaration(node) && isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) && /* TODO(PropertyAccessExpression): (func as FunctionLikeDeclaration).body */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.name */ TODO && isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && /* TODO(ParenthesizedExpression): (node.name.escapedText === "this" || node.name.escapedText === "new") */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.parameters.indexOf(node) !== 0 */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.A_0_parameter_must_be_the_first_parameter */, TODO /* TODO(PropertyAccessExpression): node.name.escapedText */, TODO /* as */ /* TODO(StringKeyword): string */)
			}
			if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO || /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ConstructSignature */ TODO || /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ConstructorType */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.A_constructor_cannot_have_a_this_parameter */, TODO)
			}
			if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrowFunction */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.An_arrow_function_cannot_have_a_this_parameter */, TODO)
			}
			if /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO || /* TODO(PropertyAccessExpression): func.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.get_and_set_accessors_cannot_declare_this_parameters */, TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO && !isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol( /* TODO(PropertyAccessExpression): node.symbol */ TODO)), anyReadonlyArrayType) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.A_rest_parameter_must_be_of_an_array_type */, TODO)
		}
	}
	checkTypePredicate := func(node TypePredicateNode) {
		parent := getTypePredicateParent(node)
		if !parent {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods */, TODO)
			return
		}
		signature := getSignatureFromDeclaration(parent)
		typePredicate := getTypePredicateOfSignature(signature)
		if !typePredicate {
			return
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		TODO_IDENTIFIER := node
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typePredicate.kind !== TypePredicateKind.This */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typePredicate.kind !== TypePredicateKind.AssertsThis */ TODO {
			if /* TODO(PropertyAccessExpression): typePredicate.parameterIndex */ TODO >= 0 {
				if signatureHasRestParameter(signature) && /* TODO(PropertyAccessExpression): typePredicate.parameterIndex */ TODO == /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO {
					error(parameterName /* TODO(PropertyAccessExpression): Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter */, TODO)
				} else {
					if /* TODO(PropertyAccessExpression): typePredicate.type */ TODO {
						leadingError := /* TODO(ArrowFunction): () => chainDiagnosticMessages(/*details* / undefined, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type) */ TODO
						checkTypeAssignableTo( /* TODO(PropertyAccessExpression): typePredicate.type */ TODO, getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[typePredicate.parameterIndex] */ TODO) /* TODO(PropertyAccessExpression): node.type */, TODO, nil, leadingError)
					}
				}
			} else if parameterName {
				hasReportedError := /* TODO(FalseKeyword): false */ TODO
				for _, TODO_IDENTIFIER := range /* TODO(PropertyAccessExpression): parent.parameters */ TODO {
					if isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName /* TODO(PropertyAccessExpression): typePredicate.parameterName */, TODO) {
						/* TODO(ExpressionStatement): hasReportedError = true; */
						/* TODO(BreakStatement): break; */
					}
				}
				if !hasReportedError {
					error( /* TODO(PropertyAccessExpression): node.parameterName */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Cannot_find_parameter_0 */, TODO /* TODO(PropertyAccessExpression): typePredicate.parameterName */, TODO)
				}
			}
		}
	}
	getTypePredicateParent := func(node Node) *SignatureDeclaration {
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ArrowFunction:             case SyntaxKind.CallSignature:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.FunctionType:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 const parent = node.parent as SignatureDeclaration;                 if (node === parent.type) {                     return parent;                 }         } */
	}
	checkIfTypePredicateVariableIsDeclaredInBindingPattern := func(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) /* TODO(undefined): true | undefined */ TODO {
		for _, element := range /* TODO(PropertyAccessExpression): pattern.elements */ TODO {
			if isOmittedExpression(element) {
				/* TODO(ContinueStatement): continue; */
			}
			name := /* TODO(PropertyAccessExpression): element.name */ TODO
			if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO && /* TODO(PropertyAccessExpression): name.escapedText */ TODO == predicateVariableName {
				error(predicateVariableNode /* TODO(PropertyAccessExpression): Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern */, TODO, predicateVariableName)
				return /* TODO(TrueKeyword): true */ TODO
			} else if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayBindingPattern */ TODO || /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectBindingPattern */ TODO {
				if checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
	}
	checkSignatureDeclaration := func(node SignatureDeclaration) {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.IndexSignature */ TODO {
			checkGrammarIndexSignature(node)
		} else if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionType */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ConstructorType */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CallSignature */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ConstructSignature */ TODO {
			checkGrammarFunctionLikeDeclaration(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
		}
		functionFlags := getFunctionFlags(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
		if ! /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.Invalid) */ TODO {
			if /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.AsyncGenerator) */ TODO == /* TODO(PropertyAccessExpression): FunctionFlags.AsyncGenerator */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.AsyncGenerators */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.AsyncGeneratorIncludes */, TODO)
			}
			if /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.AsyncGenerator) */ TODO == /* TODO(PropertyAccessExpression): FunctionFlags.Async */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.AsyncFunctions */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Awaiter */, TODO)
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) !== FunctionFlags.Normal */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.Generators */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Generator */, TODO)
			}
		}
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkUnmatchedJSDocParameters(node)
		forEach( /* TODO(PropertyAccessExpression): node.parameters */ TODO, checkParameter)
		if /* TODO(PropertyAccessExpression): node.type */ TODO {
			checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		}
		addLazyDiagnostic(checkSignatureDeclarationDiagnostics)
		checkSignatureDeclarationDiagnostics := func() {
			checkCollisionWithArgumentsInGeneratedCode(node)
			returnTypeNode := getEffectiveReturnTypeNode(node)
			returnTypeErrorLocation := returnTypeNode
			if isInJSFile(node) {
				typeTag := getJSDocTypeTag(node)
				if typeTag && /* TODO(PropertyAccessExpression): typeTag.typeExpression */ TODO && isTypeReferenceNode( /* TODO(PropertyAccessExpression): typeTag.typeExpression.type */ TODO) {
					signature := getSingleCallSignature(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): typeTag.typeExpression */ TODO))
					if signature && /* TODO(PropertyAccessExpression): signature.declaration */ TODO {
						/* TODO(ExpressionStatement): returnTypeNode = getEffectiveReturnTypeNode(signature.declaration); */
						/* TODO(ExpressionStatement): returnTypeErrorLocation = typeTag.typeExpression.type; */
					}
				}
			}
			if noImplicitAny && !returnTypeNode {
				/* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.ConstructSignature:                         error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);                         break;                     case SyntaxKind.CallSignature:                         error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);                         break;                 } */
			}
			if returnTypeNode && returnTypeErrorLocation {
				functionFlags := getFunctionFlags(node /* as */ /* TODO(TypeReference): FunctionDeclaration */)
				if /* TODO(ParenthesizedExpression): (functionFlags & (FunctionFlags.Invalid | FunctionFlags.Generator)) */ TODO == /* TODO(PropertyAccessExpression): FunctionFlags.Generator */ TODO {
					returnType := getTypeFromTypeNode(returnTypeNode)
					if returnType == voidType {
						error(returnTypeErrorLocation /* TODO(PropertyAccessExpression): Diagnostics.A_generator_cannot_have_a_void_type_annotation */, TODO)
					} else {
						checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation)
					}
				} else if /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.AsyncGenerator) */ TODO == /* TODO(PropertyAccessExpression): FunctionFlags.Async */ TODO {
					checkAsyncFunctionReturnType(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */, returnTypeNode, returnTypeErrorLocation)
				}
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.IndexSignature */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.JSDocFunctionType */ TODO {
				registerForUnusedIdentifiersCheck(node)
			}
		}
	}
	checkGeneratorInstantiationAssignabilityToReturnType := func(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) /* TODO(undefined): boolean */ TODO {
		generatorYieldType := getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Yield */ TODO, returnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO) || anyType
		generatorReturnType := getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Return */ TODO, returnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO) || generatorYieldType
		generatorNextType := getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Next */ TODO, returnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO) || unknownType
		generatorInstantiation := createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !! /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.Async) */ TODO)
		return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
	}
	checkClassForDuplicateDeclarations := func(node ClassLikeDeclaration) {
		instanceNames := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		staticNames := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		privateIdentifiers := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			if /* TODO(PropertyAccessExpression): member.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
				for _, param := range /* TODO(PropertyAccessExpression): (member as ConstructorDeclaration).parameters */ TODO {
					if isParameterPropertyDeclaration(param, member) && !isBindingPattern( /* TODO(PropertyAccessExpression): param.name */ TODO) {
						addName(instanceNames /* TODO(PropertyAccessExpression): param.name */, TODO /* TODO(PropertyAccessExpression): param.name.escapedText */, TODO /* TODO(PropertyAccessExpression): DeclarationMeaning.GetOrSetAccessor */, TODO)
					}
				}
			} else {
				isStaticMember := isStatic(member)
				name := /* TODO(PropertyAccessExpression): member.name */ TODO
				if !name {
					/* TODO(ContinueStatement): continue; */
				}
				isPrivate := isPrivateIdentifier(name)
				privateStaticFlags := /* TODO(ConditionalExpression): isPrivate && isStaticMember ? DeclarationMeaning.PrivateStatic : 0 */ TODO
				names := /* TODO(ConditionalExpression): isPrivate ? privateIdentifiers :                     isStaticMember ? staticNames :                     instanceNames */ TODO
				memberName := name && getEffectivePropertyNameForPropertyNameNode(name)
				if memberName {
					/* TODO(SwitchStatement): switch (member.kind) {                         case SyntaxKind.GetAccessor:                             addName(names, name, memberName, DeclarationMeaning.GetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.SetAccessor:                             addName(names, name, memberName, DeclarationMeaning.SetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.PropertyDeclaration:                             addName(names, name, memberName, DeclarationMeaning.GetOrSetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.MethodDeclaration:                             addName(names, name, memberName, DeclarationMeaning.Method | privateStaticFlags);                             break;                     } */
				}
			}
		}
		addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
			prev := /* TODO(PropertyAccessExpression): names.get */ TODO(name)
			if prev {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (prev & DeclarationMeaning.PrivateStatic) !== (meaning & DeclarationMeaning.PrivateStatic) */ TODO {
					error(location /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name */, TODO, getTextOfNode(location))
				} else {
					prevIsMethod := !! /* TODO(ParenthesizedExpression): (prev & DeclarationMeaning.Method) */ TODO
					isMethod := !! /* TODO(ParenthesizedExpression): (meaning & DeclarationMeaning.Method) */ TODO
					if prevIsMethod || isMethod {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prevIsMethod !== isMethod */ TODO {
							error(location /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, getTextOfNode(location))
						}
					} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): prev & meaning & ~DeclarationMeaning.PrivateStatic */ TODO {
						error(location /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, getTextOfNode(location))
					} else {
						/* TODO(PropertyAccessExpression): names.set */ TODO(name /* TODO(BarToken): | */ /* TODO(BinaryExpression): prev | meaning */, TODO)
					}
				}
			} else {
				/* TODO(PropertyAccessExpression): names.set */ TODO(name, meaning)
			}
		}
	}
	checkClassForStaticPropertyNameConflicts := func(node ClassLikeDeclaration) {
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			memberNameNode := /* TODO(PropertyAccessExpression): member.name */ TODO
			isStaticMember := isStatic(member)
			if isStaticMember && memberNameNode {
				memberName := getEffectivePropertyNameForPropertyNameNode(memberNameNode)
				/* TODO(SwitchStatement): switch (memberName) {                     case "name":                     case "length":                     case "caller":                     case "arguments":                         if (useDefineForClassFields) {                             break;                         }                         // fall through                     case "prototype":                         const message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;                         const className = getNameOfSymbolAsWritten(getSymbolOfDeclaration(node));                         error(memberNameNode, message, memberName, className);                         break;                 } */
			}
		}
	}
	checkObjectTypeForDuplicateDeclarations := func(node /* TODO(UnionType): TypeLiteralNode | InterfaceDeclaration */ any) {
		names := /* TODO(NewExpression): new Map<string, boolean>() */ TODO
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			if /* TODO(PropertyAccessExpression): member.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertySignature */ TODO {
				var memberName string
				name := /* TODO(NonNullExpression): member.name! */ TODO
				/* TODO(SwitchStatement): switch (name.kind) {                     case SyntaxKind.StringLiteral:                     case SyntaxKind.NumericLiteral:                         memberName = name.text;                         break;                     case SyntaxKind.Identifier:                         memberName = idText(name);                         break;                     default:                         continue;                 } */
				if /* TODO(PropertyAccessExpression): names.get */ TODO(memberName) {
					error(getNameOfDeclaration( /* TODO(PropertyAccessExpression): member.symbol.valueDeclaration */ TODO) /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, memberName)
					error( /* TODO(PropertyAccessExpression): member.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, memberName)
				} else {
					/* TODO(PropertyAccessExpression): names.set */ TODO(memberName /* TODO(TrueKeyword): true */, TODO)
				}
			}
		}
	}
	checkTypeForDuplicateIndexSignatures := func(node /* TODO(UnionType): ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO {
			nodeSymbol := getSymbolOfDeclaration(node)
			if /* TODO(PropertyAccessExpression): nodeSymbol.declarations */ TODO && /* TODO(PropertyAccessExpression): nodeSymbol.declarations.length */ TODO > 0 && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nodeSymbol.declarations[0] !== node */ TODO {
				return
			}
		}
		indexSymbol := getIndexSymbol(getSymbolOfDeclaration(node))
		if /* TODO(PropertyAccessExpression): indexSymbol?.declarations */ TODO {
			indexSignatureMap := /* TODO(NewExpression): new Map<TypeId, { type: Type; declarations: IndexSignatureDeclaration[]; }>() */ TODO
			for _, declaration := range /* TODO(ParenthesizedExpression): (indexSymbol.declarations as IndexSignatureDeclaration[]) */ TODO {
				if /* TODO(PropertyAccessExpression): declaration.parameters.length */ TODO == 1 && /* TODO(PropertyAccessExpression): declaration.parameters[0].type */ TODO {
					forEachType(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): declaration.parameters[0].type */ TODO) /* TODO(ArrowFunction): type => {                         const entry = indexSignatureMap.get(getTypeId(type));                         if (entry) {                             entry.declarations.push(declaration);                         }                         else {                             indexSignatureMap.set(getTypeId(type), { type, declarations: [declaration] });                         }                     } */, TODO)
				}
			}
			/* TODO(PropertyAccessExpression): indexSignatureMap.forEach */ TODO( /* TODO(ArrowFunction): entry => {                 if (entry.declarations.length > 1) {                     for (const declaration of entry.declarations) {                         error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));                     }                 }             } */ TODO)
		}
	}
	checkPropertyDeclaration := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) {
		if !checkGrammarModifiers(node) && !checkGrammarProperty(node) {
			/* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
		}
		checkVariableLikeDeclaration(node)
		setNodeLinksForPrivateIdentifierScope(node)
		if hasSyntacticModifier(node /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) && /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO && /* TODO(PropertyAccessExpression): node.initializer */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO))
		}
	}
	checkPropertySignature := func(node PropertySignature) {
		if isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies */, TODO)
		}
		return checkPropertyDeclaration(node)
	}
	checkMethodDeclaration := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) {
		if !checkGrammarMethod(node) {
			/* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
		}
		if isMethodDeclaration(node) && /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO && isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && idText( /* TODO(PropertyAccessExpression): node.name */ TODO) == "constructor" {
			error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Class_constructor_may_not_be_a_generator */, TODO)
		}
		checkFunctionOrMethodDeclaration(node)
		if hasSyntacticModifier(node /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) && /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO && /* TODO(PropertyAccessExpression): node.body */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO))
		}
		if isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && !getContainingClass(node) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies */, TODO)
		}
		setNodeLinksForPrivateIdentifierScope(node)
	}
	setNodeLinksForPrivateIdentifierScope := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
		if isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks */ TODO || languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO || !useDefineForClassFields {
				/* TODO(ForStatement): for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {                     getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;                 } */
				if isClassExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
					enclosingIterationStatement := getEnclosingIterationStatement( /* TODO(PropertyAccessExpression): node.parent */ TODO)
					if enclosingIterationStatement {
						/* TODO(ExpressionStatement): getNodeLinks(node.name).flags |= NodeCheckFlags.BlockScopedBindingInLoop; */
						/* TODO(ExpressionStatement): getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding; */
					}
				}
			}
		}
	}
	checkClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
		checkGrammarModifiers(node)
		forEachChild(node, checkSourceElement)
	}
	checkConstructorDeclaration := func(node ConstructorDeclaration) {
		checkSignatureDeclaration(node)
		if !checkGrammarConstructorTypeParameters(node) {
			/* TODO(CallExpression): checkGrammarConstructorTypeAnnotation(node) */
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.body */ TODO)
		symbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): node.kind */, TODO)
		if node == firstDeclaration {
			checkFunctionOrConstructorSymbol(symbol)
		}
		if nodeIsMissing( /* TODO(PropertyAccessExpression): node.body */ TODO) {
			return
		}
		addLazyDiagnostic(checkConstructorDeclarationDiagnostics)
		return
		isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
			if isPrivateIdentifierClassElementDeclaration(n) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			return /* TODO(PropertyAccessExpression): n.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO && !isStatic(n) && !! /* TODO(PropertyAccessExpression): (n as PropertyDeclaration).initializer */ TODO
		}
		checkConstructorDeclarationDiagnostics := func() {
			containingClassDecl := /* TODO(PropertyAccessExpression): node.parent */ TODO
			if getClassExtendsHeritageElement(containingClassDecl) {
				captureLexicalThis( /* TODO(PropertyAccessExpression): node.parent */ TODO, containingClassDecl)
				classExtendsNull := classDeclarationExtendsNull(containingClassDecl)
				superCall := findFirstSuperCall( /* TODO(NonNullExpression): node.body! */ TODO)
				if superCall {
					if classExtendsNull {
						error(superCall /* TODO(PropertyAccessExpression): Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null */, TODO)
					}
					superCallShouldBeRootLevel := !emitStandardClassFields && /* TODO(ParenthesizedExpression): (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) ||                             some(node.parameters, p => hasSyntacticModifier(p, ModifierFlags.ParameterPropertyModifier))) */ TODO
					if superCallShouldBeRootLevel {
						if !superCallIsRootLevelInConstructor(superCall /* TODO(NonNullExpression): node.body! */, TODO) {
							error(superCall /* TODO(PropertyAccessExpression): Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers */, TODO)
						} else {
							var superCallStatement *ExpressionStatement
							for _, statement := range /* TODO(PropertyAccessExpression): node.body!.statements */ TODO {
								if isExpressionStatement(statement) && isSuperCall(skipOuterExpressions( /* TODO(PropertyAccessExpression): statement.expression */ TODO)) {
									/* TODO(ExpressionStatement): superCallStatement = statement; */
									/* TODO(BreakStatement): break; */
								}
								if nodeImmediatelyReferencesSuperOrThis(statement) {
									/* TODO(BreakStatement): break; */
								}
							}
							if superCallStatement == nil {
								error(node /* TODO(PropertyAccessExpression): Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers */, TODO)
							}
						}
					}
				} else if !classExtendsNull {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call */, TODO)
				}
			}
		}
	}
	superCallIsRootLevelInConstructor := func(superCall Node, body Block) /* TODO(undefined): boolean */ TODO {
		superCallParent := walkUpParenthesizedExpressions( /* TODO(PropertyAccessExpression): superCall.parent */ TODO)
		return isExpressionStatement(superCallParent) && /* TODO(PropertyAccessExpression): superCallParent.parent */ TODO == body
	}
	nodeImmediatelyReferencesSuperOrThis := func(node Node) bool {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if isThisContainerOrFunctionBlock(node) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis)
	}
	checkAccessorDeclaration := func(node AccessorDeclaration) {
		if isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && idText( /* TODO(PropertyAccessExpression): node.name */ TODO) == "constructor" && isClassLike( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Class_constructor_may_not_be_an_accessor */, TODO)
		}
		addLazyDiagnostic(checkAccessorDeclarationDiagnostics)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.body */ TODO)
		setNodeLinksForPrivateIdentifierScope(node)
		checkAccessorDeclarationDiagnostics := func() {
			if !checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node) {
				/* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
			}
			checkDecorators(node)
			checkSignatureDeclaration(node)
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO {
				if ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && nodeIsPresent( /* TODO(PropertyAccessExpression): node.body */ TODO) && /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.HasImplicitReturn) */ TODO {
					if ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.HasExplicitReturn) */ TODO {
						error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_get_accessor_must_return_a_value */, TODO)
					}
				}
			}
			if /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
				checkComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO)
			}
			if hasBindableName(node) {
				symbol := getSymbolOfDeclaration(node)
				getter := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */, TODO)
				setter := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */, TODO)
				if getter && setter && ! /* TODO(ParenthesizedExpression): (getNodeCheckFlags(getter) & NodeCheckFlags.TypeChecked) */ TODO {
					/* TODO(ExpressionStatement): getNodeLinks(getter).flags |= NodeCheckFlags.TypeChecked; */
					getterFlags := getEffectiveModifierFlags(getter)
					setterFlags := getEffectiveModifierFlags(setter)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getterFlags & ModifierFlags.Abstract) !== (setterFlags & ModifierFlags.Abstract) */ TODO {
						error( /* TODO(PropertyAccessExpression): getter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Accessors_must_both_be_abstract_or_non_abstract */, TODO)
						error( /* TODO(PropertyAccessExpression): setter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Accessors_must_both_be_abstract_or_non_abstract */, TODO)
					}
					if /* TODO(ParenthesizedExpression): ((getterFlags & ModifierFlags.Protected) && !(setterFlags & (ModifierFlags.Protected | ModifierFlags.Private))) */ TODO || /* TODO(ParenthesizedExpression): ((getterFlags & ModifierFlags.Private) && !(setterFlags & ModifierFlags.Private)) */ TODO {
						error( /* TODO(PropertyAccessExpression): getter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter */, TODO)
						error( /* TODO(PropertyAccessExpression): setter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter */, TODO)
					}
				}
			}
			returnType := getTypeOfAccessors(getSymbolOfDeclaration(node))
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO {
				checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
			}
		}
	}
	checkMissingDeclaration := func(node Node) {
		checkDecorators(node)
	}
	getEffectiveTypeArgumentAtIndex := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
		if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO && index < /* TODO(PropertyAccessExpression): node.typeArguments.length */ TODO {
			return getTypeFromTypeNode( /* TODO(ElementAccessExpression): node.typeArguments[index] */ TODO)
		}
		return /* TODO(ElementAccessExpression): getEffectiveTypeArguments(node, typeParameters)[index] */ TODO
	}
	getEffectiveTypeArguments := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
		return fillMissingTypeArguments(map_( /* TODO(NonNullExpression): node.typeArguments! */ TODO, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node))
	}
	checkTypeArgumentConstraints := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
		var typeArguments /* TODO(ArrayType): Type[] */ any
		var mapper *TypeMapper
		result := /* TODO(TrueKeyword): true */ TODO
		/* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 if (!typeArguments) {                     typeArguments = getEffectiveTypeArguments(node, typeParameters);                     mapper = createTypeMapper(typeParameters, typeArguments);                 }                 result = result && checkTypeAssignableTo(                     typeArguments[i],                     instantiateType(constraint, mapper),                     node.typeArguments![i],                     Diagnostics.Type_0_does_not_satisfy_the_constraint_1,                 );             }         } */
		return result
	}
	getTypeParametersForTypeAndSymbol := func(type_ Type, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		if !isErrorType(type_) {
			return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.TypeAlias */ TODO && /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).typeParameters */ TODO || /* TODO(ParenthesizedExpression): (getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined) */ TODO
		}
		return nil
	}
	getTypeParametersForTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			symbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
			if symbol {
				return getTypeParametersForTypeAndSymbol(type_, symbol)
			}
		}
		return nil
	}
	checkTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any) {
		checkGrammarTypeArguments(node /* TODO(PropertyAccessExpression): node.typeArguments */, TODO)
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeReference */ TODO && !isInJSFile(node) && !isInJSDoc(node) && /* TODO(PropertyAccessExpression): node.typeArguments */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.typeName.end !== node.typeArguments.pos */ TODO {
			sourceFile := getSourceFileOfNode(node)
			if scanTokenAtPosition(sourceFile /* TODO(PropertyAccessExpression): node.typeName.end */, TODO) == /* TODO(PropertyAccessExpression): SyntaxKind.DotToken */ TODO {
				grammarErrorAtPos(node, skipTrivia( /* TODO(PropertyAccessExpression): sourceFile.text */ TODO /* TODO(PropertyAccessExpression): node.typeName.end */, TODO), 1 /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments */, TODO)
			}
		}
		forEach( /* TODO(PropertyAccessExpression): node.typeArguments */ TODO, checkSourceElement)
		checkTypeReferenceOrImport(node)
	}
	checkTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
				addLazyDiagnostic( /* TODO(ArrowFunction): () => {                     const typeParameters = getTypeParametersForTypeReferenceOrImport(node);                     if (typeParameters) {                         checkTypeArgumentConstraints(node, typeParameters);                     }                 } */ TODO)
			}
			symbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO
			if symbol {
				if some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => isTypeDeclaration(d) && !!(d.flags & NodeFlags.Deprecated) */, TODO) {
					addDeprecatedSuggestion(getDeprecatedSuggestionNode(node) /* TODO(NonNullExpression): symbol.declarations! */, TODO /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO /* as */ /* TODO(StringKeyword): string */)
				}
			}
		}
	}
	getTypeArgumentConstraint := func(node TypeNode) *Type {
		typeReferenceNode := tryCast( /* TODO(PropertyAccessExpression): node.parent */ TODO, isTypeReferenceType)
		if !typeReferenceNode {
			/* TODO(Identifier): undefined */
		}
		typeParameters := getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
		if !typeParameters {
			/* TODO(Identifier): undefined */
		}
		constraint := getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[typeReferenceNode.typeArguments!.indexOf(node)] */ TODO)
		return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)))
	}
	checkTypeQuery := func(node TypeQueryNode) {
		getTypeFromTypeQueryNode(node)
	}
	checkTypeLiteral := func(node TypeLiteralNode) {
		forEach( /* TODO(PropertyAccessExpression): node.members */ TODO, checkSourceElement)
		addLazyDiagnostic(checkTypeLiteralDiagnostics)
		checkTypeLiteralDiagnostics := func() {
			type_ := getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
			checkIndexConstraints(type_ /* TODO(PropertyAccessExpression): type.symbol */, TODO)
			checkTypeForDuplicateIndexSignatures(node)
			checkObjectTypeForDuplicateDeclarations(node)
		}
	}
	checkArrayType := func(node ArrayTypeNode) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.elementType */ TODO)
	}
	checkTupleType := func(node TupleTypeNode) {
		seenOptionalElement := /* TODO(FalseKeyword): false */ TODO
		seenRestElement := /* TODO(FalseKeyword): false */ TODO
		for _, e := range /* TODO(PropertyAccessExpression): node.elements */ TODO {
			flags := getTupleElementFlags(e)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ElementFlags.Variadic */ TODO {
				type_ := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): (e as RestTypeNode | NamedTupleMember).type */ TODO)
				if !isArrayLikeType(type_) {
					error(e /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_type_must_be_an_array_type */, TODO)
					/* TODO(BreakStatement): break; */
				}
				if isArrayType(type_) || isTupleType(type_) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.target.combinedFlags & ElementFlags.Rest */ TODO {
					/* TODO(ExpressionStatement): flags |= ElementFlags.Rest; */
				}
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ElementFlags.Rest */ TODO {
				if seenRestElement {
					grammarErrorOnNode(e /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_follow_another_rest_element */, TODO)
					/* TODO(BreakStatement): break; */
				}
				/* TODO(ExpressionStatement): seenRestElement = true; */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ElementFlags.Optional */ TODO {
				if seenRestElement {
					grammarErrorOnNode(e /* TODO(PropertyAccessExpression): Diagnostics.An_optional_element_cannot_follow_a_rest_element */, TODO)
					/* TODO(BreakStatement): break; */
				}
				/* TODO(ExpressionStatement): seenOptionalElement = true; */
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ElementFlags.Required */ TODO && seenOptionalElement {
				grammarErrorOnNode(e /* TODO(PropertyAccessExpression): Diagnostics.A_required_element_cannot_follow_an_optional_element */, TODO)
				/* TODO(BreakStatement): break; */
			}
		}
		forEach( /* TODO(PropertyAccessExpression): node.elements */ TODO, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkUnionOrIntersectionType := func(node UnionOrIntersectionTypeNode) {
		forEach( /* TODO(PropertyAccessExpression): node.types */ TODO, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkIndexedAccessIndexType := func(type_ Type, accessNode /* TODO(UnionType): IndexedAccessTypeNode | ElementAccessExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.IndexedAccess) */ TODO {
			return type_
		}
		objectType := /* TODO(PropertyAccessExpression): (type as IndexedAccessType).objectType */ TODO
		indexType := /* TODO(PropertyAccessExpression): (type as IndexedAccessType).indexType */ TODO
		objectIndexType := /* TODO(ConditionalExpression): isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping             ? getIndexTypeForMappedType(objectType, IndexFlags.None)             : getIndexType(objectType, IndexFlags.None) */ TODO
		hasNumberIndexInfo := !!getIndexInfoOfType(objectType, numberType)
		if everyType(indexType /* TODO(ArrowFunction): t => isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType) */, TODO) {
			if /* TODO(PropertyAccessExpression): accessNode.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ElementAccessExpression */ TODO && isAssignmentTarget(accessNode) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(objectType) & ObjectFlags.Mapped */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getMappedTypeModifiers(objectType as MappedType) & MappedTypeModifiers.IncludeReadonly */ TODO {
				error(accessNode /* TODO(PropertyAccessExpression): Diagnostics.Index_signature_in_type_0_only_permits_reading */, TODO, typeToString(objectType))
			}
			return type_
		}
		if isGenericObjectType(objectType) {
			propertyName := getPropertyNameFromIndex(indexType, accessNode)
			if propertyName {
				propertySymbol := forEachType(getApparentType(objectType) /* TODO(ArrowFunction): t => getPropertyOfType(t, propertyName) */, TODO)
				if propertySymbol && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(propertySymbol) & ModifierFlags.NonPublicAccessibilityModifier */ TODO {
					error(accessNode /* TODO(PropertyAccessExpression): Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter */, TODO, unescapeLeadingUnderscores(propertyName))
					return errorType
				}
			}
		}
		error(accessNode /* TODO(PropertyAccessExpression): Diagnostics.Type_0_cannot_be_used_to_index_type_1 */, TODO, typeToString(indexType), typeToString(objectType))
		return errorType
	}
	checkIndexedAccessType := func(node IndexedAccessTypeNode) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.objectType */ TODO)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.indexType */ TODO)
		checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node)
	}
	checkMappedType := func(node MappedTypeNode) {
		checkGrammarMappedType(node)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeParameter */ TODO)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.nameType */ TODO)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		if ! /* TODO(PropertyAccessExpression): node.type */ TODO {
			reportImplicitAny(node, anyType)
		}
		type_ := getTypeFromMappedTypeNode(node) /* as */ /* TODO(TypeReference): MappedType */
		nameType := getNameTypeFromMappedType(type_)
		if nameType {
			checkTypeAssignableTo(nameType, stringNumberSymbolType /* TODO(PropertyAccessExpression): node.nameType */, TODO)
		} else {
			constraintType := getConstraintTypeFromMappedType(type_)
			checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter( /* TODO(PropertyAccessExpression): node.typeParameter */ TODO))
		}
	}
	checkGrammarMappedType := func(node MappedTypeNode) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): node.members?.length */ TODO {
			return grammarErrorOnNode( /* TODO(ElementAccessExpression): node.members[0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_mapped_type_may_not_declare_properties_or_methods */, TODO)
		}
	}
	checkThisType := func(node ThisTypeNode) {
		getTypeFromThisTypeNode(node)
	}
	checkTypeOperator := func(node TypeOperatorNode) {
		checkGrammarTypeOperatorNode(node)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
	}
	checkConditionalType := func(node ConditionalTypeNode) {
		forEachChild(node, checkSourceElement)
	}
	checkInferType := func(node InferTypeNode) {
		if !findAncestor(node /* TODO(ArrowFunction): n => n.parent && n.parent.kind === SyntaxKind.ConditionalType && (n.parent as ConditionalTypeNode).extendsType === n */, TODO) {
			grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type */, TODO)
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeParameter */ TODO)
		symbol := getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): node.typeParameter */ TODO)
		if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.length */ TODO > 1 {
			links := getSymbolLinks(symbol)
			if ! /* TODO(PropertyAccessExpression): links.typeParametersChecked */ TODO {
				/* TODO(ExpressionStatement): links.typeParametersChecked = true; */
				typeParameter := getDeclaredTypeOfTypeParameter(symbol)
				var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.TypeParameter */, TODO)
				if !areTypeParametersIdentical(declarations /* TODO(ArrayLiteralExpression): [typeParameter] */, TODO /* TODO(ArrowFunction): decl => [decl] */, TODO) {
					name := symbolToString(symbol)
					for _, declaration := range declarations {
						error( /* TODO(PropertyAccessExpression): declaration.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.All_declarations_of_0_must_have_identical_constraints */, TODO, name)
					}
				}
			}
		}
		registerForUnusedIdentifiersCheck(node)
	}
	checkTemplateLiteralType := func(node TemplateLiteralTypeNode) {
		for _, span := range /* TODO(PropertyAccessExpression): node.templateSpans */ TODO {
			checkSourceElement( /* TODO(PropertyAccessExpression): span.type */ TODO)
			type_ := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): span.type */ TODO)
			checkTypeAssignableTo(type_, templateConstraintType /* TODO(PropertyAccessExpression): span.type */, TODO)
		}
		getTypeFromTypeNode(node)
	}
	checkImportType := func(node ImportTypeNode) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.argument */ TODO)
		if /* TODO(PropertyAccessExpression): node.attributes */ TODO {
			getResolutionModeOverride( /* TODO(PropertyAccessExpression): node.attributes */ TODO, grammarErrorOnNode)
		}
		checkTypeReferenceOrImport(node)
	}
	checkNamedTupleMember := func(node NamedTupleMember) {
		if /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO && /* TODO(PropertyAccessExpression): node.questionToken */ TODO {
			grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.type.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.OptionalType */ TODO {
			grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.type */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.type.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.RestType */ TODO {
			grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.type */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type */, TODO)
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		getTypeFromTypeNode(node)
	}
	isPrivateWithinAmbient := func(node Node) bool {
		return /* TODO(ParenthesizedExpression): (hasEffectiveModifier(node, ModifierFlags.Private) || isPrivateIdentifierClassElementDeclaration(node)) */ TODO && !! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO
	}
	getEffectiveDeclarationFlags := func(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
		flags := getCombinedModifierFlagsCached(n)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.InterfaceDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.ClassDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.ClassExpression */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): n.flags & NodeFlags.Ambient */ TODO {
			container := getEnclosingContainer(n)
			if /* TODO(ParenthesizedExpression): (container && container.flags & NodeFlags.ExportContext) */ TODO && ! /* TODO(ParenthesizedExpression): (flags & ModifierFlags.Ambient) */ TODO && ! /* TODO(ParenthesizedExpression): (isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) */ TODO {
				/* TODO(ExpressionStatement): flags |= ModifierFlags.Export; */
			}
			/* TODO(ExpressionStatement): flags |= ModifierFlags.Ambient; */
		}
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & flagsToCheck */ TODO
	}
	checkFunctionOrConstructorSymbol := func(symbol Symbol) {
		addLazyDiagnostic( /* TODO(ArrowFunction): () => checkFunctionOrConstructorSymbolWorker(symbol) */ TODO)
	}
	checkFunctionOrConstructorSymbolWorker := func(symbol Symbol) {
		getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
			implementationSharesContainerWithFirstOverload := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): implementation !== undefined */ TODO && /* TODO(PropertyAccessExpression): implementation.parent */ TODO == /* TODO(PropertyAccessExpression): overloads[0].parent */ TODO
			return /* TODO(ConditionalExpression): implementationSharesContainerWithFirstOverload ? implementation : overloads[0] */ TODO
		}
		checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
			someButNotAllOverloadFlags := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): someOverloadFlags ^ allOverloadFlags */ TODO
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): someButNotAllOverloadFlags !== 0 */ TODO {
				canonicalFlags := getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
				/* TODO(PropertyAccessExpression): group(overloads, o => getSourceFileOfNode(o).fileName).forEach */ TODO( /* TODO(ArrowFunction): overloadsInFile => {                     const canonicalFlagsForFile = getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck);                     for (const o of overloadsInFile) {                         const deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags;                         const deviationInFile = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile;                         if (deviationInFile & ModifierFlags.Export) {                             // Overloads in different files need not all have export modifiers. This is ok:                             //   // lib.d.ts                             //   declare function foo(s: number): string;                             //   declare function foo(s: string): number;                             //   export { foo };                             //                             //   // app.ts                             //   declare module "lib" {                             //     export function foo(s: boolean): boolean;                             //   }                             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);                         }                         else if (deviationInFile & ModifierFlags.Ambient) {                             // Though rare, a module augmentation (necessarily ambient) is allowed to add overloads                             // to a non-ambient function in an implementation file.                             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);                         }                         else if (deviation & (ModifierFlags.Private | ModifierFlags.Protected)) {                             error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);                         }                         else if (deviation & ModifierFlags.Abstract) {                             error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);                         }                     }                 } */ TODO)
			}
		}
		checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): someHaveQuestionToken !== allHaveQuestionToken */ TODO {
				canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
				forEach(overloads /* TODO(ArrowFunction): o => {                     const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;                     if (deviation) {                         error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required);                     }                 } */, TODO)
			}
		}
		var flagsToCheck ModifierFlags = /* TODO(BarToken): | */ /* TODO(BinaryExpression): ModifierFlags.Export | ModifierFlags.Ambient | ModifierFlags.Private | ModifierFlags.Protected | ModifierFlags.Abstract */ TODO
		var someNodeFlags ModifierFlags = /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
		allNodeFlags := flagsToCheck
		someHaveQuestionToken := /* TODO(FalseKeyword): false */ TODO
		allHaveQuestionToken := /* TODO(TrueKeyword): true */ TODO
		hasOverloads := /* TODO(FalseKeyword): false */ TODO
		var bodyDeclaration *FunctionLikeDeclaration
		var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
		var previousDeclaration *SignatureDeclaration
		declarations := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO
		isConstructor := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Constructor) !== 0 */ TODO
		reportImplementationExpectedError := func(node SignatureDeclaration) {
			if /* TODO(PropertyAccessExpression): node.name */ TODO && nodeIsMissing( /* TODO(PropertyAccessExpression): node.name */ TODO) {
				return
			}
			seen := /* TODO(FalseKeyword): false */ TODO
			subsequentNode := forEachChild( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): c => {                 if (seen) {                     return c;                 }                 else {                     seen = c === node;                 }             } */, TODO)
			if subsequentNode && /* TODO(PropertyAccessExpression): subsequentNode.pos */ TODO == /* TODO(PropertyAccessExpression): node.end */ TODO {
				if /* TODO(PropertyAccessExpression): subsequentNode.kind */ TODO == /* TODO(PropertyAccessExpression): node.kind */ TODO {
					var errorNode Node = /* TODO(PropertyAccessExpression): (subsequentNode as FunctionLikeDeclaration).name */ TODO || subsequentNode
					subsequentName := /* TODO(PropertyAccessExpression): (subsequentNode as FunctionLikeDeclaration).name */ TODO
					if /* TODO(PropertyAccessExpression): node.name */ TODO && subsequentName && /* TODO(ParenthesizedExpression): (                             // both are private identifiers                             isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText ||                             // Both are computed property names                             isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) ||                             // Both are literal property names that are the same.                             isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) &&                                 getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(subsequentName)                         ) */ TODO {
						reportError := /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.MethodDeclaration || node.kind === SyntaxKind.MethodSignature) */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isStatic(node) !== isStatic(subsequentNode) */ TODO
						if reportError {
							diagnostic := /* TODO(ConditionalExpression): isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static */ TODO
							error(errorNode, diagnostic)
						}
						return
					}
					if nodeIsPresent( /* TODO(PropertyAccessExpression): (subsequentNode as FunctionLikeDeclaration).body */ TODO) {
						error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Function_implementation_name_must_be_0 */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO))
						return
					}
				}
			}
			var errorNode Node = /* TODO(PropertyAccessExpression): node.name */ TODO || node
			if isConstructor {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Constructor_implementation_is_missing */, TODO)
			} else {
				if hasSyntacticModifier(node /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive */, TODO)
				} else {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration */, TODO)
				}
			}
		}
		duplicateFunctionDeclaration := /* TODO(FalseKeyword): false */ TODO
		multipleConstructorImplementation := /* TODO(FalseKeyword): false */ TODO
		hasNonAmbientClass := /* TODO(FalseKeyword): false */ TODO
		functionDeclarations := /* TODO(ArrayLiteralExpression): [] */ TODO /* as */ /* TODO(ArrayType): Declaration[] */
		if declarations {
			for _, current := range declarations {
				node := current /* as */ /* TODO(UnionType): SignatureDeclaration | ClassDeclaration | ClassExpression */
				inAmbientContext := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO
				inAmbientContextOrInterface := /* TODO(PropertyAccessExpression): node.parent */ TODO && /* TODO(ParenthesizedExpression): (node.parent.kind === SyntaxKind.InterfaceDeclaration || node.parent.kind === SyntaxKind.TypeLiteral) */ TODO || inAmbientContext
				if inAmbientContextOrInterface {
					/* TODO(ExpressionStatement): previousDeclaration = undefined; */
				}
				if /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.ClassDeclaration || node.kind === SyntaxKind.ClassExpression) */ TODO && !inAmbientContext {
					/* TODO(ExpressionStatement): hasNonAmbientClass = true; */
				}
				if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
					/* TODO(PropertyAccessExpression): functionDeclarations.push */ TODO(node)
					currentNodeFlags := getEffectiveDeclarationFlags(node, flagsToCheck)
					/* TODO(ExpressionStatement): someNodeFlags |= currentNodeFlags; */
					/* TODO(ExpressionStatement): allNodeFlags &= currentNodeFlags; */
					/* TODO(ExpressionStatement): someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node); */
					/* TODO(ExpressionStatement): allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node); */
					bodyIsPresent := nodeIsPresent( /* TODO(PropertyAccessExpression): (node as FunctionLikeDeclaration).body */ TODO)
					if bodyIsPresent && bodyDeclaration {
						if isConstructor {
							/* TODO(ExpressionStatement): multipleConstructorImplementation = true; */
						} else {
							/* TODO(ExpressionStatement): duplicateFunctionDeclaration = true; */
						}
					} else if /* TODO(PropertyAccessExpression): previousDeclaration?.parent */ TODO == /* TODO(PropertyAccessExpression): node.parent */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): previousDeclaration.end !== node.pos */ TODO {
						reportImplementationExpectedError(previousDeclaration)
					}
					if bodyIsPresent {
						if !bodyDeclaration {
							/* TODO(ExpressionStatement): bodyDeclaration = node as FunctionLikeDeclaration; */
						}
					} else {
						/* TODO(ExpressionStatement): hasOverloads = true; */
					}
					/* TODO(ExpressionStatement): previousDeclaration = node; */
					if !inAmbientContextOrInterface {
						/* TODO(ExpressionStatement): lastSeenNonAmbientDeclaration = node as FunctionLikeDeclaration; */
					}
				}
				if isInJSFile(current) && isFunctionLike(current) && /* TODO(PropertyAccessExpression): current.jsDoc */ TODO {
					/* TODO(ExpressionStatement): hasOverloads = length(getJSDocOverloadTags(current)) > 0; */
				}
			}
		}
		if multipleConstructorImplementation {
			forEach(functionDeclarations /* TODO(ArrowFunction): declaration => {                 error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed);             } */, TODO)
		}
		if duplicateFunctionDeclaration {
			forEach(functionDeclarations /* TODO(ArrowFunction): declaration => {                 error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation);             } */, TODO)
		}
		if hasNonAmbientClass && !isConstructor && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Function */ TODO && declarations {
			relatedDiagnostics := /* TODO(PropertyAccessExpression): filter(declarations, d => d.kind === SyntaxKind.ClassDeclaration)                 .map */ TODO( /* TODO(ArrowFunction): d => createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class) */ TODO)
			forEach(declarations /* TODO(ArrowFunction): declaration => {                 const diagnostic = declaration.kind === SyntaxKind.ClassDeclaration                     ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0                     : declaration.kind === SyntaxKind.FunctionDeclaration                     ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient                     : undefined;                 if (diagnostic) {                     addRelatedInfo(                         error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)),                         ...relatedDiagnostics,                     );                 }             } */, TODO)
		}
		if lastSeenNonAmbientDeclaration && ! /* TODO(PropertyAccessExpression): lastSeenNonAmbientDeclaration.body */ TODO && !hasSyntacticModifier(lastSeenNonAmbientDeclaration /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) && ! /* TODO(PropertyAccessExpression): lastSeenNonAmbientDeclaration.questionToken */ TODO {
			reportImplementationExpectedError(lastSeenNonAmbientDeclaration)
		}
		if hasOverloads {
			if declarations {
				checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags)
				checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken)
			}
			if bodyDeclaration {
				signatures := getSignaturesOfSymbol(symbol)
				bodySignature := getSignatureFromDeclaration(bodyDeclaration)
				for _, signature := range signatures {
					if !isImplementationCompatibleWithOverload(bodySignature, signature) {
						errorNode := /* TODO(ConditionalExpression): signature.declaration && isJSDocSignature(signature.declaration)                             ? (signature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName                             : signature.declaration */ TODO
						addRelatedInfo(error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature */, TODO), createDiagnosticForNode(bodyDeclaration /* TODO(PropertyAccessExpression): Diagnostics.The_implementation_signature_is_declared_here */, TODO))
						/* TODO(BreakStatement): break; */
					}
				}
			}
		}
	}
	checkExportsOnMergedDeclarations := func(node Declaration) {
		addLazyDiagnostic( /* TODO(ArrowFunction): () => checkExportsOnMergedDeclarationsWorker(node) */ TODO)
	}
	checkExportsOnMergedDeclarationsWorker := func(node Declaration) {
		symbol := /* TODO(PropertyAccessExpression): node.localSymbol */ TODO
		if !symbol {
			/* TODO(ExpressionStatement): symbol = getSymbolOfDeclaration(node)!; */
			if ! /* TODO(PropertyAccessExpression): symbol.exportSymbol */ TODO {
				return
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getDeclarationOfKind(symbol, node.kind) !== node */ TODO {
			return
		}
		exportedDeclarationSpaces := /* TODO(PropertyAccessExpression): DeclarationSpaces.None */ TODO
		nonExportedDeclarationSpaces := /* TODO(PropertyAccessExpression): DeclarationSpaces.None */ TODO
		defaultExportedDeclarationSpaces := /* TODO(PropertyAccessExpression): DeclarationSpaces.None */ TODO
		for _, d := range /* TODO(NonNullExpression): symbol.declarations! */ TODO {
			declarationSpaces := getDeclarationSpaces(d)
			effectiveDeclarationFlags := getEffectiveDeclarationFlags(d /* TODO(BarToken): | */ /* TODO(BinaryExpression): ModifierFlags.Export | ModifierFlags.Default */, TODO)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): effectiveDeclarationFlags & ModifierFlags.Export */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): effectiveDeclarationFlags & ModifierFlags.Default */ TODO {
					/* TODO(ExpressionStatement): defaultExportedDeclarationSpaces |= declarationSpaces; */
				} else {
					/* TODO(ExpressionStatement): exportedDeclarationSpaces |= declarationSpaces; */
				}
			} else {
				/* TODO(ExpressionStatement): nonExportedDeclarationSpaces |= declarationSpaces; */
			}
		}
		nonDefaultExportedDeclarationSpaces := /* TODO(BarToken): | */ /* TODO(BinaryExpression): exportedDeclarationSpaces | nonExportedDeclarationSpaces */ TODO
		commonDeclarationSpacesForExportsAndLocals := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): exportedDeclarationSpaces & nonExportedDeclarationSpaces */ TODO
		commonDeclarationSpacesForDefaultAndNonDefault := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces */ TODO
		if commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault {
			for _, d := range /* TODO(NonNullExpression): symbol.declarations! */ TODO {
				declarationSpaces := getDeclarationSpaces(d)
				name := getNameOfDeclaration(d)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault */ TODO {
					error(name /* TODO(PropertyAccessExpression): Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead */, TODO, declarationNameToString(name))
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declarationSpaces & commonDeclarationSpacesForExportsAndLocals */ TODO {
					error(name /* TODO(PropertyAccessExpression): Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local */, TODO, declarationNameToString(name))
				}
			}
		}
		getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
			d := decl /* as */ /* TODO(TypeReference): Node */
			/* TODO(SwitchStatement): switch (d.kind) {                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.TypeAliasDeclaration:                  // A jsdoc typedef and callback are, by definition, type aliases.                 // falls through                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.JSDocEnumTag:                     return DeclarationSpaces.ExportType;                 case SyntaxKind.ModuleDeclaration:                     return isAmbientModule(d as ModuleDeclaration) || getModuleInstanceState(d as ModuleDeclaration) !== ModuleInstanceState.NonInstantiated                         ? DeclarationSpaces.ExportNamespace | DeclarationSpaces.ExportValue                         : DeclarationSpaces.ExportNamespace;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.EnumDeclaration:                 case SyntaxKind.EnumMember:                     return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue;                 case SyntaxKind.SourceFile:                     return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue | DeclarationSpaces.ExportNamespace;                 case SyntaxKind.ExportAssignment:                 case SyntaxKind.BinaryExpression:                     const node = d as ExportAssignment | BinaryExpression;                     const expression = isExportAssignment(node) ? node.expression : node.right;                     // Export assigned entity name expressions act as aliases and should fall through, otherwise they export values                     if (!isEntityNameExpression(expression)) {                         return DeclarationSpaces.ExportValue;                     }                     d = expression;                  // The below options all declare an Alias, which is allowed to merge with other values within the importing module.                 // falls through                 case SyntaxKind.ImportEqualsDeclaration:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportClause:                     let result = DeclarationSpaces.None;                     const target = resolveAlias(getSymbolOfDeclaration(d as ImportEqualsDeclaration | NamespaceImport | ImportClause | ExportAssignment | BinaryExpression));                     forEach(target.declarations, d => {                         result |= getDeclarationSpaces(d);                     });                     return result;                 case SyntaxKind.VariableDeclaration:                 case SyntaxKind.BindingElement:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.ImportSpecifier: // https://github.com/Microsoft/TypeScript/pull/7591                 case SyntaxKind.Identifier: // https://github.com/microsoft/TypeScript/issues/36098                     // Identifiers are used as declarations of assignment declarations whose parents may be                     // SyntaxKind.CallExpression - `Object.defineProperty(thing, "aField", {value: 42});`                     // SyntaxKind.ElementAccessExpression - `thing["aField"] = 42;` or `thing["aField"];` (with a doc comment on it)                     // or SyntaxKind.PropertyAccessExpression - `thing.aField = 42;`                     // all of which are pretty much always values, or at least imply a value meaning.                     // It may be apprpriate to treat these as aliases in the future.                     return DeclarationSpaces.ExportValue;                 case SyntaxKind.MethodSignature:                 case SyntaxKind.PropertySignature:                     return DeclarationSpaces.ExportType;                 default:                     return Debug.failBadSyntaxKind(d);             } */
		}
	}
	getAwaitedTypeOfPromise := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		promisedType := getPromisedTypeOfPromise(type_, errorNode)
		return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
	}
	getPromisedTypeOfPromise := func(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TypeLiteral): { value?: Type; } */ TODO) *Type {
		if isTypeAny(type_) {
			return nil
		}
		typeAsPromise := type_ /* as */ /* TODO(TypeReference): PromiseOrAwaitableType */
		if /* TODO(PropertyAccessExpression): typeAsPromise.promisedTypeOfPromise */ TODO {
			return /* TODO(PropertyAccessExpression): typeAsPromise.promisedTypeOfPromise */ TODO
		}
		if isReferenceToType(type_, getGlobalPromiseType( /* TODO(FalseKeyword): false */ TODO)) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getTypeArguments(type as GenericType)[0] */ TODO
		}
		if allTypesAssignableToKind(getBaseConstraintOrType(type_) /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.Primitive | TypeFlags.Never */, TODO) {
			return nil
		}
		thenFunction := /* TODO(NonNullExpression): getTypeOfPropertyOfType(type, "then" as __String)! */ TODO
		if isTypeAny(thenFunction) {
			return nil
		}
		thenSignatures := /* TODO(ConditionalExpression): thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : emptyArray */ TODO
		if /* TODO(PropertyAccessExpression): thenSignatures.length */ TODO == 0 {
			if errorNode {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.A_promise_must_have_a_then_method */, TODO)
			}
			return nil
		}
		var thisTypeForError *Type
		var candidates /* TODO(ArrayType): Signature[] */ any
		for _, thenSignature := range thenSignatures {
			thisType := getThisTypeOfSignature(thenSignature)
			if thisType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): thisType !== voidType */ TODO && !isTypeRelatedTo(type_, thisType, subtypeRelation) {
				/* TODO(ExpressionStatement): thisTypeForError = thisType; */
			} else {
				/* TODO(ExpressionStatement): candidates = append(candidates, thenSignature); */
			}
		}
		if !candidates {
			/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO(thisTypeForError)
			if thisTypeForErrorOut {
				/* TODO(ExpressionStatement): thisTypeForErrorOut.value = thisTypeForError; */
			}
			if errorNode {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1 */, TODO, typeToString(type_), typeToString(thisTypeForError))
			}
			return nil
		}
		onfulfilledParameterType := getTypeWithFacts(getUnionType(map_(candidates, getTypeOfFirstParameterOfSignature)) /* TODO(PropertyAccessExpression): TypeFacts.NEUndefinedOrNull */, TODO)
		if isTypeAny(onfulfilledParameterType) {
			return nil
		}
		onfulfilledParameterSignatures := getSignaturesOfType(onfulfilledParameterType /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
		if /* TODO(PropertyAccessExpression): onfulfilledParameterSignatures.length */ TODO == 0 {
			if errorNode {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback */, TODO)
			}
			return nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReduction.Subtype) */ TODO
	}
	checkAwaitedType := func(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		awaitedType := /* TODO(ConditionalExpression): withAlias ?             getAwaitedType(type, errorNode, diagnosticMessage, ...args) :             getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args) */ TODO
		return awaitedType || errorType
	}
	isThenableType := func(type_ Type) bool {
		if allTypesAssignableToKind(getBaseConstraintOrType(type_) /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.Primitive | TypeFlags.Never */, TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then" /* as */ /* TODO(TypeReference): __String */)
		return !!thenFunction && /* TODO(PropertyAccessExpression): getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFacts.NEUndefinedOrNull), SignatureKind.Call).length */ TODO > 0
	}
	type AwaitedTypeInstantiation struct {
		_awaitedTypeBrand/* TODO(NeverKeyword): never */ TODO
		aliasSymbol        Symbol
		aliasTypeArguments []Type
	}
	isAwaitedTypeInstantiation := func(type_ Type) /* TODO(TypePredicate): type is AwaitedTypeInstantiation */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Conditional */ TODO {
			awaitedSymbol := getGlobalAwaitedSymbol( /* TODO(FalseKeyword): false */ TODO)
			return !!awaitedSymbol && /* TODO(PropertyAccessExpression): type.aliasSymbol */ TODO == awaitedSymbol && /* TODO(PropertyAccessExpression): type.aliasTypeArguments?.length */ TODO == 1
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	unwrapAwaitedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, unwrapAwaitedType) :             isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] :             type */ TODO
	}
	isAwaitedTypeNeeded := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		if isTypeAny(type_) || isAwaitedTypeInstantiation(type_) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if isGenericObjectType(type_) {
			baseConstraint := getBaseConstraintOfType(type_)
			if /* TODO(ConditionalExpression): baseConstraint ?                     baseConstraint.flags & TypeFlags.AnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) :                     maybeTypeOfKind(type, TypeFlags.TypeVariable) */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	tryCreateAwaitedType := func(type_ Type) *Type {
		awaitedSymbol := getGlobalAwaitedSymbol( /* TODO(TrueKeyword): true */ TODO)
		if awaitedSymbol {
			return getTypeAliasInstantiation(awaitedSymbol /* TODO(ArrayLiteralExpression): [unwrapAwaitedType(type)] */, TODO)
		}
		return nil
	}
	createAwaitedTypeIfNeeded := func(type_ Type) Type {
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): tryCreateAwaitedType(type) ?? type */ TODO
		}
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isAwaitedTypeInstantiation(type_) || getPromisedTypeOfPromise(type_) == nil, "type provided should not be a non-generic 'promise'-like.")
		return type_
	}
	getAwaitedType := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		awaitedType := getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
		return awaitedType && createAwaitedTypeIfNeeded(awaitedType)
	}
	getAwaitedTypeNoAlias := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		if isTypeAny(type_) {
			return type_
		}
		if isAwaitedTypeInstantiation(type_) {
			return type_
		}
		typeAsAwaitable := type_ /* as */ /* TODO(TypeReference): PromiseOrAwaitableType */
		if /* TODO(PropertyAccessExpression): typeAsAwaitable.awaitedTypeOfType */ TODO {
			return /* TODO(PropertyAccessExpression): typeAsAwaitable.awaitedTypeOfType */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Union */ TODO {
			if /* TODO(PropertyAccessExpression): awaitedTypeStack.lastIndexOf */ TODO( /* TODO(PropertyAccessExpression): type.id */ TODO) >= 0 {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method */, TODO)
				}
				return nil
			}
			mapper := /* TODO(ConditionalExpression): errorNode ? (constituentType: Type) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias */ TODO
			/* TODO(PropertyAccessExpression): awaitedTypeStack.push */ TODO( /* TODO(PropertyAccessExpression): type.id */ TODO)
			mapped := mapType(type_, mapper)
			/* TODO(PropertyAccessExpression): awaitedTypeStack.pop */ TODO()
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = mapped */ TODO
		}
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
		}
		var thisTypeForErrorOut /* TODO(TypeLiteral): { value: Type | undefined; } */ TODO = /* TODO(ObjectLiteralExpression): { value: undefined } */ TODO
		promisedType := getPromisedTypeOfPromise(type_, nil, thisTypeForErrorOut)
		if promisedType {
			if /* TODO(PropertyAccessExpression): type.id */ TODO == /* TODO(PropertyAccessExpression): promisedType.id */ TODO || /* TODO(PropertyAccessExpression): awaitedTypeStack.lastIndexOf */ TODO( /* TODO(PropertyAccessExpression): promisedType.id */ TODO) >= 0 {
				if errorNode {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method */, TODO)
				}
				return nil
			}
			/* TODO(PropertyAccessExpression): awaitedTypeStack.push */ TODO( /* TODO(PropertyAccessExpression): type.id */ TODO)
			awaitedType := getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
			/* TODO(PropertyAccessExpression): awaitedTypeStack.pop */ TODO()
			if !awaitedType {
				return nil
			}
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = awaitedType */ TODO
		}
		if isThenableType(type_) {
			if errorNode {
				/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO(diagnosticMessage)
				var chain *DiagnosticMessageChain
				if /* TODO(PropertyAccessExpression): thisTypeForErrorOut.value */ TODO {
					/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForErrorOut.value)); */
				}
				/* TODO(ExpressionStatement): chain = chainDiagnosticMessages(chain, diagnosticMessage, ...args); */
				/* TODO(PropertyAccessExpression): diagnostics.add */
				TODO(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain))
			}
			return nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
	}
	checkAsyncFunctionReturnType := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
		returnType := getTypeFromTypeNode(returnTypeNode)
		if languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO {
			if isErrorType(returnType) {
				return
			}
			globalPromiseType := getGlobalPromiseType( /* TODO(TrueKeyword): true */ TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalPromiseType !== emptyGenericType */ TODO && !isReferenceToType(returnType, globalPromiseType) {
				reportErrorForInvalidReturnType( /* TODO(PropertyAccessExpression): Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0 */ TODO, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType))
				return
			}
		} else {
			markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.AsyncFunction */, TODO)
			if isErrorType(returnType) {
				return
			}
			promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
			if promiseConstructorName == nil {
				reportErrorForInvalidReturnType( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value */ TODO, returnTypeNode, returnTypeErrorLocation, typeToString(returnType))
				return
			}
			promiseConstructorSymbol := resolveEntityName(promiseConstructorName /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO)
			promiseConstructorType := /* TODO(ConditionalExpression): promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType */ TODO
			if isErrorType(promiseConstructorType) {
				if /* TODO(PropertyAccessExpression): promiseConstructorName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO && /* TODO(PropertyAccessExpression): promiseConstructorName.escapedText */ TODO == "Promise" && getTargetType(returnType) == getGlobalPromiseType( /* TODO(FalseKeyword): false */ TODO) {
					error(returnTypeErrorLocation /* TODO(PropertyAccessExpression): Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option */, TODO)
				} else {
					reportErrorForInvalidReturnType( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value */ TODO, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				}
				return
			}
			globalPromiseConstructorLikeType := getGlobalPromiseConstructorLikeType( /* TODO(TrueKeyword): true */ TODO)
			if globalPromiseConstructorLikeType == emptyObjectType {
				reportErrorForInvalidReturnType( /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value */ TODO, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				return
			}
			headMessage := /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value */ TODO
			errorInfo := /* TODO(ArrowFunction): () => returnTypeNode === returnTypeErrorLocation ? undefined : chainDiagnosticMessages(/*details* / undefined, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type) */ TODO
			if !checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) {
				return
			}
			rootName := promiseConstructorName && getFirstIdentifier(promiseConstructorName)
			collidingSymbol := getSymbol( /* TODO(NonNullExpression): node.locals! */ TODO /* TODO(PropertyAccessExpression): rootName.escapedText */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
			if collidingSymbol {
				error( /* TODO(PropertyAccessExpression): collidingSymbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions */, TODO, idText(rootName), entityNameToString(promiseConstructorName))
				return
			}
		}
		checkAwaitedType(returnType /* TODO(FalseKeyword): false */, TODO, node /* TODO(PropertyAccessExpression): Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member */, TODO)
		reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
			if returnTypeNode == returnTypeErrorLocation {
				error(returnTypeErrorLocation, message, typeName)
			} else {
				diag := error(returnTypeErrorLocation /* TODO(PropertyAccessExpression): Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type */, TODO)
				addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName))
			}
		}
	}
	checkGrammarDecorator := func(decorator Decorator) bool {
		sourceFile := getSourceFileOfNode(decorator)
		if !hasParseDiagnostics(sourceFile) {
			var node Expression = /* TODO(PropertyAccessExpression): decorator.expression */ TODO
			if isParenthesizedExpression(node) {
				return /* TODO(FalseKeyword): false */ TODO
			}
			canHaveCallExpression := /* TODO(TrueKeyword): true */ TODO
			var errorNode Node
			/* TODO(WhileStatement): while (true) {                 // Allow TS syntax such as non-null assertions and instantiation expressions                 if (isExpressionWithTypeArguments(node) || isNonNullExpression(node)) {                     node = node.expression;                     continue;                 }                  // DecoratorCallExpression :                 //   DecoratorMemberExpression Arguments                  if (isCallExpression(node)) {                     if (!canHaveCallExpression) {                         errorNode = node;                     }                     if (node.questionDotToken) {                         // Even if we already have an error node, error at the `?.` token since it appears earlier.                         errorNode = node.questionDotToken;                     }                     node = node.expression;                     canHaveCallExpression = false;                     continue;                 }                  // DecoratorMemberExpression :                 //   IdentifierReference                 //   DecoratorMemberExpression `.` IdentifierName                 //   DecoratorMemberExpression `.` PrivateIdentifier                  if (isPropertyAccessExpression(node)) {                     if (node.questionDotToken) {                         // Even if we already have an error node, error at the `?.` token since it appears earlier.                         errorNode = node.questionDotToken;                     }                     node = node.expression;                     canHaveCallExpression = false;                     continue;                 }                  if (!isIdentifier(node)) {                     // Even if we already have an error node, error at this node since it appears earlier.                     errorNode = node;                 }                  break;             } */
			if errorNode {
				addRelatedInfo(error( /* TODO(PropertyAccessExpression): decorator.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator */, TODO), createDiagnosticForNode(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Invalid_syntax_in_decorator */, TODO))
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkDecorator := func(node Decorator) {
		checkGrammarDecorator(node)
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		returnType := getReturnTypeOfSignature(signature)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): returnType.flags & TypeFlags.Any */ TODO {
			return
		}
		decoratorSignature := getDecoratorCallSignature(node)
		if ! /* TODO(PropertyAccessExpression): decoratorSignature?.resolvedReturnType */ TODO {
		}
		var headMessage DiagnosticMessage
		expectedReturnType := /* TODO(PropertyAccessExpression): decoratorSignature.resolvedReturnType */ TODO
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                 break;              case SyntaxKind.PropertyDeclaration:                 if (!legacyDecorators) {                     headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                     break;                 }                 // falls through              case SyntaxKind.Parameter:                 headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any;                 break;              case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                 break;              default:                 return Debug.failBadSyntaxKind(node.parent);         } */
		checkTypeAssignableTo(returnType, expectedReturnType /* TODO(PropertyAccessExpression): node.expression */, TODO, headMessage)
	}
	createCallSignature := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /* = */ /* TODO(PropertyAccessExpression): parameters.length */, flags SignatureFlags /* = */ /* TODO(PropertyAccessExpression): SignatureFlags.None */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		decl := /* TODO(PropertyAccessExpression): factory.createFunctionTypeNode */ TODO(nil, emptyArray /* TODO(PropertyAccessExpression): factory.createKeywordTypeNode */, TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO))
		return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
	}
	createFunctionType := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		signature := createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
		return getOrCreateTypeFromSignature(signature)
	}
	createGetterFunctionType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return createFunctionType(nil, nil, emptyArray, type_)
	}
	createSetterFunctionType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		valueParam := createParameter("value" /* as */ /* TODO(TypeReference): __String */, type_)
		return createFunctionType(nil, nil /* TODO(ArrayLiteralExpression): [valueParam] */, TODO, voidType)
	}
	getEntityNameForDecoratorMetadata := func(node *TypeNode) *EntityName {
		if node {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.IntersectionType:                 case SyntaxKind.UnionType:                     return getEntityNameForDecoratorMetadataFromTypeList((node as UnionOrIntersectionTypeNode).types);                  case SyntaxKind.ConditionalType:                     return getEntityNameForDecoratorMetadataFromTypeList([(node as ConditionalTypeNode).trueType, (node as ConditionalTypeNode).falseType]);                  case SyntaxKind.ParenthesizedType:                 case SyntaxKind.NamedTupleMember:                     return getEntityNameForDecoratorMetadata((node as ParenthesizedTypeNode).type);                  case SyntaxKind.TypeReference:                     return (node as TypeReferenceNode).typeName;             } */
		}
	}
	getEntityNameForDecoratorMetadataFromTypeList := func(types []TypeNode) *EntityName {
		var commonEntityName *EntityName
		for _, typeNode := range types {
			/* TODO(WhileStatement): while (typeNode.kind === SyntaxKind.ParenthesizedType || typeNode.kind === SyntaxKind.NamedTupleMember) {                 typeNode = (typeNode as ParenthesizedTypeNode | NamedTupleMember).type; // Skip parens if need be             } */
			if /* TODO(PropertyAccessExpression): typeNode.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NeverKeyword */ TODO {
				/* TODO(ContinueStatement): continue; */
			}
			if !strictNullChecks && /* TODO(ParenthesizedExpression): (typeNode.kind === SyntaxKind.LiteralType && (typeNode as LiteralTypeNode).literal.kind === SyntaxKind.NullKeyword || typeNode.kind === SyntaxKind.UndefinedKeyword) */ TODO {
				/* TODO(ContinueStatement): continue; */
			}
			individualEntityName := getEntityNameForDecoratorMetadata(typeNode)
			if !individualEntityName {
				return nil
			}
			if commonEntityName {
				if !isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): commonEntityName.escapedText !== individualEntityName.escapedText */ TODO {
					return nil
				}
			} else {
				/* TODO(ExpressionStatement): commonEntityName = individualEntityName; */
			}
		}
		return commonEntityName
	}
	getParameterTypeNodeForDecoratorCheck := func(node ParameterDeclaration) *TypeNode {
		typeNode := getEffectiveTypeAnnotationNode(node)
		return /* TODO(ConditionalExpression): isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode */ TODO
	}
	checkDecorators := func(node Node) {
		if !canHaveDecorators(node) || !hasDecorators(node) || ! /* TODO(PropertyAccessExpression): node.modifiers */ TODO || !nodeCanBeDecorated(legacyDecorators, node /* TODO(PropertyAccessExpression): node.parent */, TODO /* TODO(PropertyAccessExpression): node.parent.parent */, TODO) {
			return
		}
		firstDecorator := find( /* TODO(PropertyAccessExpression): node.modifiers */ TODO, isDecorator)
		if !firstDecorator {
			return
		}
		if legacyDecorators {
			checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Decorate */, TODO)
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO {
				checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Param */, TODO)
			}
		} else if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO {
			checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ESDecorateAndRunInitializers */, TODO)
			if isClassDeclaration(node) {
				if ! /* TODO(PropertyAccessExpression): node.name */ TODO {
					checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.SetFunctionName */, TODO)
				} else {
					member := getFirstTransformableStaticClassElement(node)
					if member {
						checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.SetFunctionName */, TODO)
					}
				}
			} else if !isClassExpression(node) {
				if isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && /* TODO(ParenthesizedExpression): (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) */ TODO {
					checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.SetFunctionName */, TODO)
				}
				if isComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO) {
					checkExternalEmitHelpers(firstDecorator /* TODO(PropertyAccessExpression): ExternalEmitHelpers.PropKey */, TODO)
				}
			}
		}
		markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.Decorator */, TODO)
		for _, modifier := range /* TODO(PropertyAccessExpression): node.modifiers */ TODO {
			if isDecorator(modifier) {
				checkDecorator(modifier)
			}
		}
	}
	checkFunctionDeclaration := func(node FunctionDeclaration) {
		addLazyDiagnostic(checkFunctionDeclarationDiagnostics)
		checkFunctionDeclarationDiagnostics := func() {
			checkFunctionOrMethodDeclaration(node)
			checkGrammarForGenerator(node)
			checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
		}
	}
	checkJSDocTypeAliasTag := func(node /* TODO(UnionType): JSDocTypedefTag | JSDocCallbackTag */ any) {
		if ! /* TODO(PropertyAccessExpression): node.typeExpression */ TODO {
			error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.name */ TODO {
			checkTypeNameIsReserved( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_alias_name_cannot_be_0 */, TODO)
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeExpression */ TODO)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	}
	checkJSDocTemplateTag := func(node JSDocTemplateTag) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.constraint */ TODO)
		for _, tp := range /* TODO(PropertyAccessExpression): node.typeParameters */ TODO {
			checkSourceElement(tp)
		}
	}
	checkJSDocTypeTag := func(node JSDocTypeTag) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeExpression */ TODO)
	}
	checkJSDocSatisfiesTag := func(node JSDocSatisfiesTag) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeExpression */ TODO)
		host := getEffectiveJSDocHost(node)
		if host {
			tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
			if length(tags) > 1 {
				/* TODO(ForStatement): for (let i = 1; i < length(tags); i++) {                     const tagName = tags[i].tagName;                     error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));                 } */
			}
		}
	}
	checkJSDocLinkLikeTag := func(node /* TODO(UnionType): JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
		if /* TODO(PropertyAccessExpression): node.name */ TODO {
			resolveJSDocMemberName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(TrueKeyword): true */, TODO)
		}
	}
	checkJSDocParameterTag := func(node JSDocParameterTag) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeExpression */ TODO)
	}
	checkJSDocPropertyTag := func(node JSDocPropertyTag) {
		checkSourceElement( /* TODO(PropertyAccessExpression): node.typeExpression */ TODO)
	}
	checkJSDocFunctionType := func(node JSDocFunctionType) {
		addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny)
		checkSignatureDeclaration(node)
		checkJSDocFunctionTypeImplicitAny := func() {
			if ! /* TODO(PropertyAccessExpression): node.type */ TODO && !isJSDocConstructSignature(node) {
				reportImplicitAny(node, anyType)
			}
		}
	}
	checkJSDocThisTag := func(node JSDocThisTag) {
		host := getEffectiveJSDocHost(node)
		if host && isArrowFunction(host) {
			error( /* TODO(PropertyAccessExpression): node.tagName */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_arrow_function_cannot_have_a_this_parameter */, TODO)
		}
	}
	checkJSDocImportTag := func(node JSDocImportTag) {
		checkImportAttributes(node)
	}
	checkJSDocImplementsTag := func(node JSDocImplementsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_0_is_not_attached_to_a_class */, TODO, idText( /* TODO(PropertyAccessExpression): node.tagName */ TODO))
		}
	}
	checkJSDocAugmentsTag := func(node JSDocAugmentsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_0_is_not_attached_to_a_class */, TODO, idText( /* TODO(PropertyAccessExpression): node.tagName */ TODO))
			return
		}
		augmentsTags := /* TODO(PropertyAccessExpression): getJSDocTags(classLike).filter */ TODO(isJSDocAugmentsTag)
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): augmentsTags.length */ TODO > 0)
		if /* TODO(PropertyAccessExpression): augmentsTags.length */ TODO > 1 {
			error( /* TODO(ElementAccessExpression): augmentsTags[1] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag */, TODO)
		}
		name := getIdentifierFromEntityNameExpression( /* TODO(PropertyAccessExpression): node.class.expression */ TODO)
		extend := getClassExtendsHeritageElement(classLike)
		if extend {
			className := getIdentifierFromEntityNameExpression( /* TODO(PropertyAccessExpression): extend.expression */ TODO)
			if className && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name.escapedText !== className.escapedText */ TODO {
				error(name /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause */, TODO, idText( /* TODO(PropertyAccessExpression): node.tagName */ TODO), idText(name), idText(className))
			}
		}
	}
	checkJSDocAccessibilityModifiers := func(node /* TODO(UnionType): JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
		host := getJSDocHost(node)
		if host && isPrivateIdentifierClassElementDeclaration(host) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier */, TODO)
		}
	}
	// OVERLOAD: getIdentifierFromEntityNameExpression := func(node /* TODO(UnionType): Identifier | PropertyAccessExpression */ any) /* TODO(UnionType): Identifier | PrivateIdentifier */ any
	// OVERLOAD: getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any
	getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 return node as Identifier;             case SyntaxKind.PropertyAccessExpression:                 return (node as PropertyAccessExpression).name;             default:                 return undefined;         } */
	}
	checkFunctionOrMethodDeclaration := func(node /* TODO(UnionType): FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
		checkDecorators(node)
		checkSignatureDeclaration(node)
		functionFlags := getFunctionFlags(node)
		if /* TODO(PropertyAccessExpression): node.name */ TODO && /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
			checkComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO)
		}
		if hasBindableName(node) {
			symbol := getSymbolOfDeclaration(node)
			localSymbol := /* TODO(PropertyAccessExpression): node.localSymbol */ TODO || symbol
			firstDeclaration := /* TODO(PropertyAccessExpression): localSymbol.declarations?.find */ TODO( /* TODO(ArrowFunction): declaration => declaration.kind === node.kind && !(declaration.flags & NodeFlags.JavaScriptFile) */ TODO)
			if node == firstDeclaration {
				checkFunctionOrConstructorSymbol(localSymbol)
			}
			if /* TODO(PropertyAccessExpression): symbol.parent */ TODO {
				checkFunctionOrConstructorSymbol(symbol)
			}
		}
		body := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodSignature ? undefined : node.body */ TODO
		checkSourceElement(body)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node))
		addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics)
		if isInJSFile(node) {
			typeTag := getJSDocTypeTag(node)
			if typeTag && /* TODO(PropertyAccessExpression): typeTag.typeExpression */ TODO && !getContextualCallSignature(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): typeTag.typeExpression */ TODO), node) {
				error( /* TODO(PropertyAccessExpression): typeTag.typeExpression.type */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature */, TODO)
			}
		}
		checkFunctionOrMethodDeclarationDiagnostics := func() {
			if !getEffectiveReturnTypeNode(node) {
				if nodeIsMissing(body) && !isPrivateWithinAmbient(node) {
					reportImplicitAny(node, anyType)
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): functionFlags & FunctionFlags.Generator */ TODO && nodeIsPresent(body) {
					getReturnTypeOfSignature(getSignatureFromDeclaration(node))
				}
			}
		}
	}
	registerForUnusedIdentifiersCheck := func(node PotentiallyUnusedIdentifier) {
		addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics)
		registerForUnusedIdentifiersCheckDiagnostics := func() {
			sourceFile := getSourceFileOfNode(node)
			potentiallyUnusedIdentifiers := /* TODO(PropertyAccessExpression): allPotentiallyUnusedIdentifiers.get */ TODO( /* TODO(PropertyAccessExpression): sourceFile.path */ TODO)
			if !potentiallyUnusedIdentifiers {
				/* TODO(ExpressionStatement): potentiallyUnusedIdentifiers = []; */
				/* TODO(PropertyAccessExpression): allPotentiallyUnusedIdentifiers.set */
				TODO( /* TODO(PropertyAccessExpression): sourceFile.path */ TODO, potentiallyUnusedIdentifiers)
			}
			/* TODO(PropertyAccessExpression): potentiallyUnusedIdentifiers.push */ TODO(node)
		}
	}
	type PotentiallyUnusedIdentifier /* TODO(UnionType): SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any
	checkUnusedIdentifiers := func(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
		for _, node := range potentiallyUnusedIdentifiers {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                     checkUnusedClassMembers(node, addDiagnostic);                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.SourceFile:                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.Block:                 case SyntaxKind.CaseBlock:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForInStatement:                 case SyntaxKind.ForOfStatement:                     checkUnusedLocalsAndParameters(node, addDiagnostic);                     break;                 case SyntaxKind.Constructor:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     // Only report unused parameters on the implementation, not overloads.                     if (node.body) {                         checkUnusedLocalsAndParameters(node, addDiagnostic);                     }                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.MethodSignature:                 case SyntaxKind.CallSignature:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.InterfaceDeclaration:                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.InferType:                     checkUnusedInferTypeParameter(node, addDiagnostic);                     break;                 default:                     Debug.assertNever(node, "Node should not have been registered for unused identifiers check");             } */
		}
	}
	errorUnusedLocal := func(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
		node := getNameOfDeclaration(declaration) || declaration
		message := /* TODO(ConditionalExpression): isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read */ TODO
		addDiagnostic(declaration /* TODO(PropertyAccessExpression): UnusedKind.Local */, TODO, createDiagnosticForNode(node, message, name))
	}
	isIdentifierThatStartsWithUnderscore := func(node Node) /* TODO(undefined): boolean */ TODO {
		return isIdentifier(node) && /* TODO(PropertyAccessExpression): idText(node).charCodeAt */ TODO(0) == /* TODO(PropertyAccessExpression): CharacterCodes._ */ TODO
	}
	checkUnusedClassMembers := func(node /* TODO(UnionType): ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			/* TODO(SwitchStatement): switch (member.kind) {                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     if (member.kind === SyntaxKind.SetAccessor && member.symbol.flags & SymbolFlags.GetAccessor) {                         // Already would have reported an error on the getter.                         break;                     }                     const symbol = getSymbolOfDeclaration(member);                     if (                         !symbol.isReferenced                         && (hasEffectiveModifier(member, ModifierFlags.Private) || isNamedDeclaration(member) && isPrivateIdentifier(member.name))                         && !(member.flags & NodeFlags.Ambient)                     ) {                         addDiagnostic(member, UnusedKind.Local, createDiagnosticForNode(member.name!, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));                     }                     break;                 case SyntaxKind.Constructor:                     for (const parameter of (member as ConstructorDeclaration).parameters) {                         if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlags.Private)) {                             addDiagnostic(parameter, UnusedKind.Local, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));                         }                     }                     break;                 case SyntaxKind.IndexSignature:                 case SyntaxKind.SemicolonClassElement:                 case SyntaxKind.ClassStaticBlockDeclaration:                     // Can't be private                     break;                 default:                     Debug.fail("Unexpected class member");             } */
		}
	}
	checkUnusedInferTypeParameter := func(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
		TODO_IDENTIFIER := node
		if isTypeParameterUnused(typeParameter) {
			addDiagnostic(node /* TODO(PropertyAccessExpression): UnusedKind.Parameter */, TODO, createDiagnosticForNode(node /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_but_its_value_is_never_read */, TODO, idText( /* TODO(PropertyAccessExpression): typeParameter.name */ TODO)))
		}
	}
	checkUnusedTypeParameters := func(node /* TODO(UnionType): ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
		declarations := /* TODO(PropertyAccessExpression): getSymbolOfDeclaration(node).declarations */ TODO
		if !declarations || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): last(declarations) !== node */ TODO {
		}
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		seenParentsWithEveryUnused := /* TODO(NewExpression): new Set<DeclarationWithTypeParameterChildren>() */ TODO
		for _, typeParameter := range typeParameters {
			if !isTypeParameterUnused(typeParameter) {
			}
			name := idText( /* TODO(PropertyAccessExpression): typeParameter.name */ TODO)
			TODO_IDENTIFIER := typeParameter
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): parent.kind !== SyntaxKind.InferType */ TODO && /* TODO(PropertyAccessExpression): parent.typeParameters!.every */ TODO(isTypeParameterUnused) {
				if tryAddToSet(seenParentsWithEveryUnused, parent) {
					sourceFile := getSourceFileOfNode(parent)
					range_ := /* TODO(ConditionalExpression): isJSDocTemplateTag(parent)                         // Whole @template tag                         ? rangeOfNode(parent)                         // Include the `<>` in the error message                         : rangeOfTypeParameters(sourceFile, parent.typeParameters!) */ TODO
					only := /* TODO(PropertyAccessExpression): parent.typeParameters!.length */ TODO == 1
					var messageAndArg DiagnosticAndArguments = /* TODO(ConditionalExpression): only                         ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name]                         : [Diagnostics.All_type_parameters_are_unused] */ TODO
					addDiagnostic(typeParameter /* TODO(PropertyAccessExpression): UnusedKind.Parameter */, TODO, createFileDiagnostic(sourceFile /* TODO(PropertyAccessExpression): range.pos */, TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): range.end - range.pos */, TODO /* TODO(SpreadElement): ...messageAndArg */, TODO))
				}
			} else {
				addDiagnostic(typeParameter /* TODO(PropertyAccessExpression): UnusedKind.Parameter */, TODO, createDiagnosticForNode(typeParameter /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_but_its_value_is_never_read */, TODO, name))
			}
		}
	}
	isTypeParameterUnused := func(typeParameter TypeParameterDeclaration) bool {
		return ! /* TODO(ParenthesizedExpression): (getMergedSymbol(typeParameter.symbol).isReferenced! & SymbolFlags.TypeParameter) */ TODO && !isIdentifierThatStartsWithUnderscore( /* TODO(PropertyAccessExpression): typeParameter.name */ TODO)
	}
	addToGroup := func(map_ Map[string /* TODO(TupleType): [K, V[]] */, TODO], key K, value V, getKey func(key K) /* TODO(UnionType): number | string */ any) {
		keyString := String(getKey(key))
		group := /* TODO(PropertyAccessExpression): map.get */ TODO(keyString)
		if group {
			/* TODO(PropertyAccessExpression): group[1].push */ TODO(value)
		} else {
			/* TODO(PropertyAccessExpression): map.set */ TODO(keyString /* TODO(ArrayLiteralExpression): [key, [value]] */, TODO)
		}
	}
	tryGetRootParameterDeclaration := func(node Node) *ParameterDeclaration {
		return tryCast(getRootDeclaration(node), isParameter)
	}
	isValidUnusedLocalDeclaration := func(declaration Declaration) bool {
		if isBindingElement(declaration) {
			if isObjectBindingPattern( /* TODO(PropertyAccessExpression): declaration.parent */ TODO) {
				return !! /* TODO(ParenthesizedExpression): (declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name)) */ TODO
			}
			return isIdentifierThatStartsWithUnderscore( /* TODO(PropertyAccessExpression): declaration.name */ TODO)
		}
		return isAmbientModule(declaration) || /* TODO(ParenthesizedExpression): (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) */ TODO && isIdentifierThatStartsWithUnderscore( /* TODO(NonNullExpression): declaration.name! */ TODO)
	}
	checkUnusedLocalsAndParameters := func(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
		unusedImports := /* TODO(NewExpression): new Map<string, [ImportClause, ImportedDeclaration[]]>() */ TODO
		unusedDestructures := /* TODO(NewExpression): new Map<string, [BindingPattern, BindingElement[]]>() */ TODO
		unusedVariables := /* TODO(NewExpression): new Map<string, [VariableDeclarationList, VariableDeclaration[]]>() */ TODO
		/* TODO(PropertyAccessExpression): nodeWithLocals.locals!.forEach */ TODO( /* TODO(ArrowFunction): local => {             // If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.             // If it's a type parameter merged with a parameter, check if the parameter-side is used.             if (local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol) {                 return;             }              if (local.declarations) {                 for (const declaration of local.declarations) {                     if (isValidUnusedLocalDeclaration(declaration)) {                         continue;                     }                      if (isImportedDeclaration(declaration)) {                         addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);                     }                     else if (isBindingElement(declaration) && isObjectBindingPattern(declaration.parent)) {                         // In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.                         const lastElement = last(declaration.parent.elements);                         if (declaration === lastElement || !last(declaration.parent.elements).dotDotDotToken) {                             addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);                         }                     }                     else if (isVariableDeclaration(declaration)) {                         const blockScopeKind = getCombinedNodeFlagsCached(declaration) & NodeFlags.BlockScoped;                         const name = getNameOfDeclaration(declaration);                         if (blockScopeKind !== NodeFlags.Using && blockScopeKind !== NodeFlags.AwaitUsing || !name || !isIdentifierThatStartsWithUnderscore(name)) {                             addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);                         }                     }                     else {                         const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);                         const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);                         if (parameter && name) {                             if (!isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {                                 if (isBindingElement(declaration) && isArrayBindingPattern(declaration.parent)) {                                     addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);                                 }                                 else {                                     addDiagnostic(parameter, UnusedKind.Parameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)));                                 }                             }                         }                         else {                             errorUnusedLocal(declaration, symbolName(local), addDiagnostic);                         }                     }                 }             }         } */ TODO)
		/* TODO(PropertyAccessExpression): unusedImports.forEach */ TODO( /* TODO(ArrowFunction): ([importClause, unuseds]) => {             const importDecl = importClause.parent;             const nDeclarations = (importClause.name ? 1 : 0) +                 (importClause.namedBindings ?                     (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length)                     : 0);             if (nDeclarations === unuseds.length) {                 addDiagnostic(                     importDecl,                     UnusedKind.Local,                     unuseds.length === 1                         ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))                         : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused),                 );             }             else {                 for (const unused of unuseds) errorUnusedLocal(unused, idText(unused.name!), addDiagnostic);             }         } */ TODO)
		/* TODO(PropertyAccessExpression): unusedDestructures.forEach */ TODO( /* TODO(ArrowFunction): ([bindingPattern, bindingElements]) => {             const kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local;             if (bindingPattern.elements.length === bindingElements.length) {                 if (bindingElements.length === 1 && bindingPattern.parent.kind === SyntaxKind.VariableDeclaration && bindingPattern.parent.parent.kind === SyntaxKind.VariableDeclarationList) {                     addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);                 }                 else {                     addDiagnostic(                         bindingPattern,                         kind,                         bindingElements.length === 1                             ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name))                             : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused),                     );                 }             }             else {                 for (const e of bindingElements) {                     addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));                 }             }         } */ TODO)
		/* TODO(PropertyAccessExpression): unusedVariables.forEach */ TODO( /* TODO(ArrowFunction): ([declarationList, declarations]) => {             if (declarationList.declarations.length === declarations.length) {                 addDiagnostic(                     declarationList,                     UnusedKind.Local,                     declarations.length === 1                         ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))                         : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused),                 );             }             else {                 for (const decl of declarations) {                     addDiagnostic(decl, UnusedKind.Local, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));                 }             }         } */ TODO)
	}
	checkPotentialUncheckedRenamedBindingElementsInTypes := func() {
		for _, node := range potentialUnusedRenamedBindingElementsInTypes {
			if ! /* TODO(PropertyAccessExpression): getSymbolOfDeclaration(node)?.isReferenced */ TODO {
				wrappingDeclaration := walkUpBindingElementsAndPatterns(node)
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here")
				diagnostic := createDiagnosticForNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO), declarationNameToString( /* TODO(PropertyAccessExpression): node.propertyName */ TODO))
				if ! /* TODO(PropertyAccessExpression): wrappingDeclaration.type */ TODO {
					addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration) /* TODO(PropertyAccessExpression): wrappingDeclaration.end */, TODO, 0 /* TODO(PropertyAccessExpression): Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.propertyName */ TODO)))
				}
				/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
			}
		}
	}
	bindingNameText := func(name BindingName) string {
		/* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.Identifier:                 return idText(name);             case SyntaxKind.ArrayBindingPattern:             case SyntaxKind.ObjectBindingPattern:                 return bindingNameText(cast(first(name.elements), isBindingElement).name);             default:                 return Debug.assertNever(name);         } */
	}
	type ImportedDeclaration /* TODO(UnionType): ImportClause | ImportSpecifier | NamespaceImport */ any
	isImportedDeclaration := func(node Node) /* TODO(TypePredicate): node is ImportedDeclaration */ TODO {
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportClause */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportSpecifier */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceImport */ TODO
	}
	importClauseFromImported := func(decl ImportedDeclaration) ImportClause {
		return /* TODO(ConditionalExpression): decl.kind === SyntaxKind.ImportClause ? decl : decl.kind === SyntaxKind.NamespaceImport ? decl.parent : decl.parent.parent */ TODO
	}
	checkBlock := func(node Block) {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Block */ TODO {
			checkGrammarStatementInAmbientContext(node)
		}
		if isFunctionOrModuleBlock(node) {
			saveFlowAnalysisDisabled := flowAnalysisDisabled
			forEach( /* TODO(PropertyAccessExpression): node.statements */ TODO, checkSourceElement)
			/* TODO(ExpressionStatement): flowAnalysisDisabled = saveFlowAnalysisDisabled; */
		} else {
			forEach( /* TODO(PropertyAccessExpression): node.statements */ TODO, checkSourceElement)
		}
		if /* TODO(PropertyAccessExpression): node.locals */ TODO {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkCollisionWithArgumentsInGeneratedCode := func(node SignatureDeclaration) {
		if languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO || !hasRestParameter(node) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO || nodeIsMissing( /* TODO(PropertyAccessExpression): (node as FunctionLikeDeclaration).body */ TODO) {
			return
		}
		forEach( /* TODO(PropertyAccessExpression): node.parameters */ TODO /* TODO(ArrowFunction): p => {             if (p.name && !isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {                 errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);             }         } */, TODO)
	}
	needCollisionCheckForIdentifier := func(node Node, identifier *Identifier, name string) bool {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): identifier?.escapedText !== name */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertySignature */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) {
			if isTypeOnlyImportOrExportDeclaration(node) {
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		root := getRootDeclaration(node)
		if isParameter(root) && nodeIsMissing( /* TODO(PropertyAccessExpression): (root.parent as FunctionLikeDeclaration).body */ TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	checkIfThisIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node /* TODO(ArrowFunction): current => {             if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureThis) {                 const isDeclaration = node.kind !== SyntaxKind.Identifier;                 if (isDeclaration) {                     error(getNameOfDeclaration(node as Declaration), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);                 }                 else {                     error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);                 }                 return true;             }             return false;         } */, TODO)
	}
	checkIfNewTargetIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node /* TODO(ArrowFunction): current => {             if (getNodeCheckFlags(current) & NodeCheckFlags.CaptureNewTarget) {                 const isDeclaration = node.kind !== SyntaxKind.Identifier;                 if (isDeclaration) {                     error(getNameOfDeclaration(node as Declaration), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);                 }                 else {                     error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);                 }                 return true;             }             return false;         } */, TODO)
	}
	checkCollisionWithRequireExportsInGeneratedCode := func(node Node, name *Identifier) {
		if /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) >= /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO {
			return
		}
		if !name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports") {
			return
		}
		if isModuleDeclaration(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getModuleInstanceState(node) !== ModuleInstanceState.Instantiated */ TODO {
			return
		}
		parent := getDeclarationContainer(node)
		if /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO && isExternalOrCommonJsModule(parent /* as */ /* TODO(TypeReference): SourceFile */) {
			errorSkippedOn("noEmit", name /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module */, TODO, declarationNameToString(name), declarationNameToString(name))
		}
	}
	checkCollisionWithGlobalPromiseInGeneratedCode := func(node Node, name *Identifier) {
		if !name || languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2017 */ TODO || !needCollisionCheckForIdentifier(node, name, "Promise") {
			return
		}
		if isModuleDeclaration(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getModuleInstanceState(node) !== ModuleInstanceState.Instantiated */ TODO {
			return
		}
		parent := getDeclarationContainer(node)
		if /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO && isExternalOrCommonJsModule(parent /* as */ /* TODO(TypeReference): SourceFile */) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): parent.flags & NodeFlags.HasAsyncFunctions */ TODO {
			errorSkippedOn("noEmit", name /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions */, TODO, declarationNameToString(name), declarationNameToString(name))
		}
	}
	recordPotentialCollisionWithWeakMapSetInGeneratedCode := func(node Node, name Identifier) {
		if languageVersion <= /* TODO(PropertyAccessExpression): ScriptTarget.ES2021 */ TODO && /* TODO(ParenthesizedExpression): (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet")) */ TODO {
			/* TODO(PropertyAccessExpression): potentialWeakMapSetCollisions.push */ TODO(node)
		}
	}
	checkWeakMapSetCollision := func(node Node) {
		enclosingBlockScope := getEnclosingBlockScopeContainer(node)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlags.ContainsClassWithPrivateIdentifiers */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isNamedDeclaration(node) && isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && /* TODO(TypeOfExpression): typeof node.name.escapedText */ TODO == "string", "The target of a WeakMap/WeakSet collision check should be an identifier")
			errorSkippedOn("noEmit", node /* TODO(PropertyAccessExpression): Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel */, TODO /* TODO(PropertyAccessExpression): node.name.escapedText */, TODO)
		}
	}
	recordPotentialCollisionWithReflectInGeneratedCode := func(node Node, name *Identifier) {
		if name && languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO && languageVersion <= /* TODO(PropertyAccessExpression): ScriptTarget.ES2021 */ TODO && needCollisionCheckForIdentifier(node, name, "Reflect") {
			/* TODO(PropertyAccessExpression): potentialReflectCollisions.push */ TODO(node)
		}
	}
	checkReflectCollision := func(node Node) {
		hasCollision := /* TODO(FalseKeyword): false */ TODO
		if isClassExpression(node) {
			for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getNodeCheckFlags(member) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */ TODO {
					/* TODO(ExpressionStatement): hasCollision = true; */
					/* TODO(BreakStatement): break; */
				}
			}
		} else if isFunctionExpression(node) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getNodeCheckFlags(node) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */ TODO {
				/* TODO(ExpressionStatement): hasCollision = true; */
			}
		} else {
			container := getEnclosingBlockScopeContainer(node)
			if container && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getNodeCheckFlags(container) & NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */ TODO {
				/* TODO(ExpressionStatement): hasCollision = true; */
			}
		}
		if hasCollision {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(isNamedDeclaration(node) && isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO), "The target of a Reflect collision check should be an identifier")
			errorSkippedOn("noEmit", node /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO), "Reflect")
		}
	}
	checkCollisionsForDeclarationName := func(node Node, name *Identifier) {
		if !name {
		}
		checkCollisionWithRequireExportsInGeneratedCode(node, name)
		checkCollisionWithGlobalPromiseInGeneratedCode(node, name)
		recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name)
		recordPotentialCollisionWithReflectInGeneratedCode(node, name)
		if isClassLike(node) {
			checkTypeNameIsReserved(name /* TODO(PropertyAccessExpression): Diagnostics.Class_name_cannot_be_0 */, TODO)
			if ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO {
				checkClassNameCollisionWithObject(name)
			}
		} else if isEnumDeclaration(node) {
			checkTypeNameIsReserved(name /* TODO(PropertyAccessExpression): Diagnostics.Enum_name_cannot_be_0 */, TODO)
		}
	}
	checkVarDeclaredNamesNotShadowed := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): undefined */ TODO {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped) !== 0 */ TODO || isPartOfParameterDeclaration(node) {
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.FunctionScopedVariable */ TODO {
			if !isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
				/* TODO(CallExpression): Debug.fail() */
			}
			localDeclarationSymbol := resolveName(node /* TODO(PropertyAccessExpression): node.name.escapedText */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Variable */, TODO, nil /* TODO(FalseKeyword): false */, TODO)
			if localDeclarationSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): localDeclarationSymbol !== symbol */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): localDeclarationSymbol.flags & SymbolFlags.BlockScopedVariable */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlags.BlockScoped */ TODO {
					varDeclList := /* TODO(NonNullExpression): getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKind.VariableDeclarationList)! */ TODO
					container := /* TODO(ConditionalExpression): varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent                         ? varDeclList.parent.parent                         : undefined */ TODO
					namesShareScope := container && /* TODO(ParenthesizedExpression): (container.kind === SyntaxKind.Block && isFunctionLike(container.parent) ||                             container.kind === SyntaxKind.ModuleBlock ||                             container.kind === SyntaxKind.ModuleDeclaration ||                             container.kind === SyntaxKind.SourceFile) */ TODO
					if !namesShareScope {
						name := symbolToString(localDeclarationSymbol)
						error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1 */, TODO, name, name)
					}
				}
			}
		}
	}
	convertAutoToAny := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type === autoType ? anyType : type === autoArrayType ? anyArrayType : type */ TODO
	}
	checkVariableLikeDeclaration := func(node /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
		checkDecorators(node)
		if !isBindingElement(node) {
			checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		}
		if ! /* TODO(PropertyAccessExpression): node.name */ TODO {
			return
		}
		if /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
			checkComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO)
			if hasOnlyExpressionInitializer(node) && /* TODO(PropertyAccessExpression): node.initializer */ TODO {
				checkExpressionCached( /* TODO(PropertyAccessExpression): node.initializer */ TODO)
			}
		}
		if isBindingElement(node) {
			if /* TODO(PropertyAccessExpression): node.propertyName */ TODO && isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) && isPartOfParameterDeclaration(node) && nodeIsMissing( /* TODO(PropertyAccessExpression): (getContainingFunction(node) as FunctionLikeDeclaration).body */ TODO) {
				/* TODO(PropertyAccessExpression): potentialUnusedRenamedBindingElementsInTypes.push */ TODO(node)
				return
			}
			if isObjectBindingPattern( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ObjectSpreadRest */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Rest */, TODO)
			}
			if /* TODO(PropertyAccessExpression): node.propertyName */ TODO && /* TODO(PropertyAccessExpression): node.propertyName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
				checkComputedPropertyName( /* TODO(PropertyAccessExpression): node.propertyName */ TODO)
			}
			parent := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
			parentCheckMode := /* TODO(ConditionalExpression): node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
			parentType := getTypeForBindingElementParent(parent, parentCheckMode)
			name := /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO
			if parentType && !isBindingPattern(name) {
				exprType := getLiteralTypeFromPropertyName(name)
				if isTypeUsableAsPropertyName(exprType) {
					nameText := getPropertyNameFromType(exprType)
					property := getPropertyOfType(parentType, nameText)
					if property {
						markPropertyAsReferenced(property, nil /* TODO(FalseKeyword): false */, TODO)
						checkPropertyAccessibility(node, !! /* TODO(PropertyAccessExpression): parent.initializer */ TODO && /* TODO(PropertyAccessExpression): parent.initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO /* TODO(FalseKeyword): false */, TODO, parentType, property)
					}
				}
			}
		}
		if isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			if /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayBindingPattern */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.BindingPatterns */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.downlevelIteration */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Read */, TODO)
			}
			forEach( /* TODO(PropertyAccessExpression): node.name.elements */ TODO, checkSourceElement)
		}
		if /* TODO(PropertyAccessExpression): node.initializer */ TODO && isPartOfParameterDeclaration(node) && nodeIsMissing( /* TODO(PropertyAccessExpression): (getContainingFunction(node) as FunctionLikeDeclaration).body */ TODO) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation */, TODO)
			return
		}
		if isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			if isInAmbientOrTypeNode(node) {
				return
			}
			needCheckInitializer := hasOnlyExpressionInitializer(node) && /* TODO(PropertyAccessExpression): node.initializer */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO
			needCheckWidenedType := !some( /* TODO(PropertyAccessExpression): node.name.elements */ TODO, not(isOmittedExpression))
			if needCheckInitializer || needCheckWidenedType {
				widenedType := getWidenedTypeForVariableLikeDeclaration(node)
				if needCheckInitializer {
					initializerType := checkExpressionCached( /* TODO(PropertyAccessExpression): node.initializer */ TODO)
					if strictNullChecks && needCheckWidenedType {
						checkNonNullNonVoidType(initializerType, node)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node /* TODO(PropertyAccessExpression): node.initializer */, TODO)
					}
				}
				if needCheckWidenedType {
					if isArrayBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) {
						checkIteratedTypeOrElementType( /* TODO(PropertyAccessExpression): IterationUse.Destructuring */ TODO, widenedType, undefinedType, node)
					} else if strictNullChecks {
						checkNonNullNonVoidType(widenedType, node)
					}
				}
			}
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Alias */ TODO && /* TODO(ParenthesizedExpression): (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) */ TODO {
			checkAliasSymbol(node)
			return
		}
		if /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BigIntLiteral */ TODO {
			error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name */, TODO)
		}
		type_ := convertAutoToAny(getTypeOfSymbol(symbol))
		if node == /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO {
			initializer := hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node)
			if initializer {
				isJSObjectLiteralInitializer := isInJSFile(node) && isObjectLiteralExpression(initializer) && /* TODO(ParenthesizedExpression): (initializer.properties.length === 0 || isPrototypeAccess(node.name)) */ TODO && !! /* TODO(PropertyAccessExpression): symbol.exports?.size */ TODO
				if !isJSObjectLiteralInitializer && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO {
					initializerType := checkExpressionCached(initializer)
					checkTypeAssignableToAndOptionallyElaborate(initializerType, type_, node, initializer, nil)
					blockScopeKind := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped */ TODO
					if blockScopeKind == /* TODO(PropertyAccessExpression): NodeFlags.AwaitUsing */ TODO {
						globalAsyncDisposableType := getGlobalAsyncDisposableType( /* TODO(TrueKeyword): true */ TODO)
						globalDisposableType := getGlobalDisposableType( /* TODO(TrueKeyword): true */ TODO)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalAsyncDisposableType !== emptyObjectType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalDisposableType !== emptyObjectType */ TODO {
							optionalDisposableType := getUnionType( /* TODO(ArrayLiteralExpression): [globalAsyncDisposableType, globalDisposableType, nullType, undefinedType] */ TODO)
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer /* TODO(PropertyAccessExpression): Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined */, TODO)
						}
					} else if blockScopeKind == /* TODO(PropertyAccessExpression): NodeFlags.Using */ TODO {
						globalDisposableType := getGlobalDisposableType( /* TODO(TrueKeyword): true */ TODO)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalDisposableType !== emptyObjectType */ TODO {
							optionalDisposableType := getUnionType( /* TODO(ArrayLiteralExpression): [globalDisposableType, nullType, undefinedType] */ TODO)
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer /* TODO(PropertyAccessExpression): Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined */, TODO)
						}
					}
				}
			}
			if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.length */ TODO > 1 {
				if some( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): d => d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node) */, TODO) {
					error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.All_declarations_of_0_must_have_identical_modifiers */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO))
				}
			}
		} else {
			declarationType := convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node))
			if !isErrorType(type_) && !isErrorType(declarationType) && !isTypeIdenticalTo(type_, declarationType) && ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Assignment) */ TODO {
				errorNextVariableOrPropertyDeclarationMustHaveSameType( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO, type_, node, declarationType)
			}
			if hasOnlyExpressionInitializer(node) && /* TODO(PropertyAccessExpression): node.initializer */ TODO {
				checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached( /* TODO(PropertyAccessExpression): node.initializer */ TODO), declarationType, node /* TODO(PropertyAccessExpression): node.initializer */, TODO, nil)
			}
			if /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && !areDeclarationFlagsIdentical(node /* TODO(PropertyAccessExpression): symbol.valueDeclaration */, TODO) {
				error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.All_declarations_of_0_must_have_identical_modifiers */, TODO, declarationNameToString( /* TODO(PropertyAccessExpression): node.name */ TODO))
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.PropertyDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.PropertySignature */ TODO {
			checkExportsOnMergedDeclarations(node)
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO {
				checkVarDeclaredNamesNotShadowed(node)
			}
			checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
		}
	}
	errorNextVariableOrPropertyDeclarationMustHaveSameType := func(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
		nextDeclarationName := getNameOfDeclaration(nextDeclaration)
		message := /* TODO(ConditionalExpression): nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature             ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2             : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 */ TODO
		declName := declarationNameToString(nextDeclarationName)
		err := error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType))
		if firstDeclaration {
			addRelatedInfo(err, createDiagnosticForNode(firstDeclaration /* TODO(PropertyAccessExpression): Diagnostics._0_was_also_declared_here */, TODO, declName))
		}
	}
	areDeclarationFlagsIdentical := func(left Declaration, right Declaration) /* TODO(undefined): boolean */ TODO {
		if /* TODO(ParenthesizedExpression): (left.kind === SyntaxKind.Parameter && right.kind === SyntaxKind.VariableDeclaration) */ TODO || /* TODO(ParenthesizedExpression): (left.kind === SyntaxKind.VariableDeclaration && right.kind === SyntaxKind.Parameter) */ TODO {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): hasQuestionToken(left) !== hasQuestionToken(right) */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		interestingFlags := /* TODO(BarToken): | */ /* TODO(BinaryExpression): ModifierFlags.Private |             ModifierFlags.Protected |             ModifierFlags.Async |             ModifierFlags.Abstract |             ModifierFlags.Readonly |             ModifierFlags.Static */ TODO
		return getSelectedEffectiveModifierFlags(left, interestingFlags) == getSelectedEffectiveModifierFlags(right, interestingFlags)
	}
	checkVariableDeclaration := func(node VariableDeclaration) {
		/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.Check */ TODO, "checkVariableDeclaration" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		checkGrammarVariableDeclaration(node)
		checkVariableLikeDeclaration(node)
		/* TODO(PropertyAccessExpression): tracing?.pop */ TODO()
	}
	checkBindingElement := func(node BindingElement) {
		checkGrammarBindingElement(node)
		return checkVariableLikeDeclaration(node)
	}
	checkVariableDeclarationList := func(node VariableDeclarationList) {
		blockScopeKind := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCombinedNodeFlags(node) & NodeFlags.BlockScoped */ TODO
		if /* TODO(ParenthesizedExpression): (blockScopeKind === NodeFlags.Using || blockScopeKind === NodeFlags.AwaitUsing) */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.UsingAndAwaitUsing */ TODO {
			checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.AddDisposableResourceAndDisposeResources */, TODO)
		}
		forEach( /* TODO(PropertyAccessExpression): node.declarations */ TODO, checkSourceElement)
	}
	checkVariableStatement := func(node VariableStatement) {
		if !checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList( /* TODO(PropertyAccessExpression): node.declarationList */ TODO) {
			/* TODO(CallExpression): checkGrammarForDisallowedBlockScopedVariableStatement(node) */
		}
		checkVariableDeclarationList( /* TODO(PropertyAccessExpression): node.declarationList */ TODO)
	}
	checkExpressionStatement := func(node ExpressionStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
	}
	checkIfStatement := func(node IfStatement) {
		checkGrammarStatementInAmbientContext(node)
		type_ := checkTruthinessExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType( /* TODO(PropertyAccessExpression): node.expression */ TODO, type_ /* TODO(PropertyAccessExpression): node.thenStatement */, TODO)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.thenStatement */ TODO)
		if /* TODO(PropertyAccessExpression): node.thenStatement.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EmptyStatement */ TODO {
			error( /* TODO(PropertyAccessExpression): node.thenStatement */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement */, TODO)
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.elseStatement */ TODO)
	}
	checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType := func(condExpr Expression, condType Type, body /* TODO(UnionType): Statement | Expression */ any) {
		if !strictNullChecks {
		}
		bothHelper(condExpr, body)
		bothHelper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
			/* TODO(ExpressionStatement): condExpr = skipParentheses(condExpr); */
			helper(condExpr, body)
			/* TODO(WhileStatement): while (isBinaryExpression(condExpr) && (condExpr.operatorToken.kind === SyntaxKind.BarBarToken || condExpr.operatorToken.kind === SyntaxKind.QuestionQuestionToken)) {                 condExpr = skipParentheses(condExpr.left);                 helper(condExpr, body);             } */
		}
		helper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
			location := /* TODO(ConditionalExpression): isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr */ TODO
			if isModuleExportsAccessExpression(location) {
				return
			}
			if isLogicalOrCoalescingBinaryExpression(location) {
				bothHelper(location, body)
				return
			}
			type_ := /* TODO(ConditionalExpression): location === condExpr ? condType : checkExpression(location) */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.EnumLiteral */ TODO && isPropertyAccessExpression(location) && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): (getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol).flags & SymbolFlags.Enum */ TODO {
				error(location /* TODO(PropertyAccessExpression): Diagnostics.This_condition_will_always_return_0 */, TODO /* TODO(ConditionalExpression): !!(type as LiteralType).value ? "true" : "false" */, TODO)
				return
			}
			isPropertyExpressionCast := isPropertyAccessExpression(location) && isTypeAssertion( /* TODO(PropertyAccessExpression): location.expression */ TODO)
			if !hasTypeFacts(type_ /* TODO(PropertyAccessExpression): TypeFacts.Truthy */, TODO) || isPropertyExpressionCast {
			}
			callSignatures := getSignaturesOfType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Call */, TODO)
			isPromise := !!getAwaitedTypeOfPromise(type_)
			if /* TODO(PropertyAccessExpression): callSignatures.length */ TODO == 0 && !isPromise {
				return
			}
			testedNode := /* TODO(ConditionalExpression): isIdentifier(location) ? location                 : isPropertyAccessExpression(location) ? location.name                 : undefined */ TODO
			testedSymbol := testedNode && getSymbolAtLocation(testedNode)
			if !testedSymbol && !isPromise {
				return
			}
			isUsed := testedSymbol && isBinaryExpression( /* TODO(PropertyAccessExpression): condExpr.parent */ TODO) && isSymbolUsedInBinaryExpressionChain( /* TODO(PropertyAccessExpression): condExpr.parent */ TODO, testedSymbol) || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol)
			if !isUsed {
				if isPromise {
					errorAndMaybeSuggestAwait(location /* TODO(TrueKeyword): true */, TODO /* TODO(PropertyAccessExpression): Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined */, TODO, getTypeNameForErrorDisplay(type_))
				} else {
					error(location /* TODO(PropertyAccessExpression): Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead */, TODO)
				}
			}
		}
	}
	isSymbolUsedInConditionBody := func(expr Expression, body /* TODO(UnionType): Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
		return !!forEachChild(body /* TODO(FunctionExpression): function check(childNode): boolean | undefined {             if (isIdentifier(childNode)) {                 const childSymbol = getSymbolAtLocation(childNode);                 if (childSymbol && childSymbol === testedSymbol) {                     // If the test was a simple identifier, the above check is sufficient                     if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {                         return true;                     }                     // Otherwise we need to ensure the symbol is called on the same target                     let testedExpression = testedNode.parent;                     let childExpression = childNode.parent;                     while (testedExpression && childExpression) {                         if (                             isIdentifier(testedExpression) && isIdentifier(childExpression) ||                             testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword                         ) {                             return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);                         }                         else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {                             if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {                                 return false;                             }                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else {                             return false;                         }                     }                 }             }             return forEachChild(childNode, check);         } */, TODO)
	}
	isSymbolUsedInBinaryExpressionChain := func(node Node, testedSymbol Symbol) bool {
		/* TODO(WhileStatement): while (isBinaryExpression(node) && node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {             const isUsed = forEachChild(node.right, function visit(child): boolean | undefined {                 if (isIdentifier(child)) {                     const symbol = getSymbolAtLocation(child);                     if (symbol && symbol === testedSymbol) {                         return true;                     }                 }                 return forEachChild(child, visit);             });             if (isUsed) {                 return true;             }             node = node.parent;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkDoStatement := func(node DoStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.statement */ TODO)
		checkTruthinessExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
	}
	checkWhileStatement := func(node WhileStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkTruthinessExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.statement */ TODO)
	}
	checkTruthinessOfType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.Void */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness */, TODO)
		} else {
			semantics := getSyntacticTruthySemantics(node)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): semantics !== PredicateSemantics.Sometimes */ TODO {
				error(node /* TODO(ConditionalExpression): semantics === PredicateSemantics.Always ?                         Diagnostics.This_kind_of_expression_is_always_truthy :                         Diagnostics.This_kind_of_expression_is_always_falsy */, TODO)
			}
		}
		return type_
	}
	getSyntacticTruthySemantics := func(node Node) PredicateSemantics {
		/* TODO(ExpressionStatement): node = skipOuterExpressions(node); */
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.NumericLiteral:                 // Allow `while(0)` or `while(1)`                 if ((node as NumericLiteral).text === "0" || (node as NumericLiteral).text === "1") {                     return PredicateSemantics.Sometimes;                 }                 return PredicateSemantics.Always;             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.ClassExpression:             case SyntaxKind.FunctionExpression:             case SyntaxKind.JsxElement:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.RegularExpressionLiteral:                 return PredicateSemantics.Always;             case SyntaxKind.VoidExpression:             case SyntaxKind.NullKeyword:                 return PredicateSemantics.Never;             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.StringLiteral:                 return !!(node as StringLiteral | NoSubstitutionTemplateLiteral).text ? PredicateSemantics.Always : PredicateSemantics.Never;             case SyntaxKind.ConditionalExpression:                 return getSyntacticTruthySemantics((node as ConditionalExpression).whenTrue) | getSyntacticTruthySemantics((node as ConditionalExpression).whenFalse);             case SyntaxKind.Identifier:                 if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {                     return PredicateSemantics.Never;                 }                 return PredicateSemantics.Sometimes;         } */
		return /* TODO(PropertyAccessExpression): PredicateSemantics.Sometimes */ TODO
	}
	checkTruthinessExpression := func(node Expression, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkTruthinessOfType(checkExpression(node, checkMode), node)
	}
	checkForStatement := func(node ForStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if /* TODO(PropertyAccessExpression): node.initializer */ TODO && /* TODO(PropertyAccessExpression): node.initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO {
				checkGrammarVariableDeclarationList( /* TODO(PropertyAccessExpression): node.initializer */ TODO /* as */ /* TODO(TypeReference): VariableDeclarationList */)
			}
		}
		if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
			if /* TODO(PropertyAccessExpression): node.initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO {
				checkVariableDeclarationList( /* TODO(PropertyAccessExpression): node.initializer */ TODO /* as */ /* TODO(TypeReference): VariableDeclarationList */)
			} else {
				checkExpression( /* TODO(PropertyAccessExpression): node.initializer */ TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): node.condition */ TODO {
			/* TODO(CallExpression): checkTruthinessExpression(node.condition) */
		}
		if /* TODO(PropertyAccessExpression): node.incrementor */ TODO {
			/* TODO(CallExpression): checkExpression(node.incrementor) */
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.statement */ TODO)
		if /* TODO(PropertyAccessExpression): node.locals */ TODO {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForOfStatement := func(node ForOfStatement) {
		checkGrammarForInOrForOfStatement(node)
		container := getContainingFunctionOrClassStaticBlock(node)
		if /* TODO(PropertyAccessExpression): node.awaitModifier */ TODO {
			if container && isClassStaticBlockDeclaration(container) {
				grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.awaitModifier */ TODO /* TODO(PropertyAccessExpression): Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block */, TODO)
			} else {
				functionFlags := getFunctionFlags(container)
				if /* TODO(ParenthesizedExpression): (functionFlags & (FunctionFlags.Invalid | FunctionFlags.Async)) */ TODO == /* TODO(PropertyAccessExpression): FunctionFlags.Async */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ForAwaitOf */ TODO {
					checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ForAwaitOfIncludes */, TODO)
				}
			}
		} else if /* TODO(PropertyAccessExpression): compilerOptions.downlevelIteration */ TODO && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ForOf */ TODO {
			checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ForOfIncludes */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO {
			checkVariableDeclarationList( /* TODO(PropertyAccessExpression): node.initializer */ TODO /* as */ /* TODO(TypeReference): VariableDeclarationList */)
		} else {
			varExpr := /* TODO(PropertyAccessExpression): node.initializer */ TODO
			iteratedType := checkRightHandSideOfForOf(node)
			if /* TODO(PropertyAccessExpression): varExpr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayLiteralExpression */ TODO || /* TODO(PropertyAccessExpression): varExpr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO {
				checkDestructuringAssignment(varExpr, iteratedType || errorType)
			} else {
				leftType := checkExpression(varExpr)
				checkReferenceExpression(varExpr /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access */, TODO /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access */, TODO)
				if iteratedType {
					checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr /* TODO(PropertyAccessExpression): node.expression */, TODO)
				}
			}
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.statement */ TODO)
		if /* TODO(PropertyAccessExpression): node.locals */ TODO {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForInStatement := func(node ForInStatement) {
		checkGrammarForInOrForOfStatement(node)
		rightType := getNonNullableTypeIfNeeded(checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO))
		if /* TODO(PropertyAccessExpression): node.initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO {
			variable := /* TODO(ElementAccessExpression): (node.initializer as VariableDeclarationList).declarations[0] */ TODO
			if variable && isBindingPattern( /* TODO(PropertyAccessExpression): variable.name */ TODO) {
				error( /* TODO(PropertyAccessExpression): variable.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern */, TODO)
			}
			checkVariableDeclarationList( /* TODO(PropertyAccessExpression): node.initializer */ TODO /* as */ /* TODO(TypeReference): VariableDeclarationList */)
		} else {
			varExpr := /* TODO(PropertyAccessExpression): node.initializer */ TODO
			leftType := checkExpression(varExpr)
			if /* TODO(PropertyAccessExpression): varExpr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayLiteralExpression */ TODO || /* TODO(PropertyAccessExpression): varExpr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO {
				error(varExpr /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern */, TODO)
			} else if !isTypeAssignableTo(getIndexTypeOrString(rightType), leftType) {
				error(varExpr /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any */, TODO)
			} else {
				checkReferenceExpression(varExpr /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access */, TODO /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access */, TODO)
			}
		}
		if rightType == neverType || !isTypeAssignableToKind(rightType /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.NonPrimitive | TypeFlags.InstantiableNonPrimitive */, TODO) {
			error( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0 */, TODO, typeToString(rightType))
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.statement */ TODO)
		if /* TODO(PropertyAccessExpression): node.locals */ TODO {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkRightHandSideOfForOf := func(statement ForOfStatement) Type {
		use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
		return checkIteratedTypeOrElementType(use, checkNonNullExpression( /* TODO(PropertyAccessExpression): statement.expression */ TODO), undefinedType /* TODO(PropertyAccessExpression): statement.expression */, TODO)
	}
	checkIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
		if isTypeAny(inputType) {
			return inputType
		}
		return getIteratedTypeOrElementType(use, inputType, sentType, errorNode /* TODO(TrueKeyword): true */, TODO) || anyType
	}
	getIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) *Type {
		allowAsyncIterables := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (use & IterationUse.AllowsAsyncIterablesFlag) !== 0 */ TODO
		if inputType == neverType {
			if errorNode {
				reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables)
			}
			return nil
		}
		uplevelIteration := languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO
		downlevelIteration := !uplevelIteration && /* TODO(PropertyAccessExpression): compilerOptions.downlevelIteration */ TODO
		possibleOutOfBounds := /* TODO(PropertyAccessExpression): compilerOptions.noUncheckedIndexedAccess */ TODO && !! /* TODO(ParenthesizedExpression): (use & IterationUse.PossiblyOutOfBounds) */ TODO
		if uplevelIteration || downlevelIteration || allowAsyncIterables {
			iterationTypes := getIterationTypesOfIterable(inputType, use /* TODO(ConditionalExpression): uplevelIteration ? errorNode : undefined */, TODO)
			if checkAssignability {
				if iterationTypes {
					diagnostic := /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :                         use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :                         use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :                         use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :                         undefined */ TODO
					if diagnostic {
						checkTypeAssignableTo(sentType /* TODO(PropertyAccessExpression): iterationTypes.nextType */, TODO, errorNode, diagnostic)
					}
				}
			}
			if iterationTypes || uplevelIteration {
				return /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType) */ TODO
			}
		}
		arrayType := inputType
		hasStringConstituent := /* TODO(FalseKeyword): false */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsStringInputFlag */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): arrayType.flags & TypeFlags.Union */ TODO {
				arrayTypes := /* TODO(PropertyAccessExpression): (inputType as UnionType).types */ TODO
				filteredTypes := filter(arrayTypes /* TODO(ArrowFunction): t => !(t.flags & TypeFlags.StringLike) */, TODO)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): filteredTypes !== arrayTypes */ TODO {
					/* TODO(ExpressionStatement): arrayType = getUnionType(filteredTypes, UnionReduction.Subtype); */
				}
			} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): arrayType.flags & TypeFlags.StringLike */ TODO {
				/* TODO(ExpressionStatement): arrayType = neverType; */
			}
			/* TODO(ExpressionStatement): hasStringConstituent = arrayType !== inputType; */
			if hasStringConstituent {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): arrayType.flags & TypeFlags.Never */ TODO {
					return /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType */ TODO
				}
			}
		}
		if !isArrayLikeType(arrayType) {
			if errorNode {
				allowsStrings := !! /* TODO(ParenthesizedExpression): (use & IterationUse.AllowsStringInputFlag) */ TODO && !hasStringConstituent
				TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
				errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType))
			}
			return /* TODO(ConditionalExpression): hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined */ TODO
		}
		arrayElementType := getIndexTypeOfType(arrayType, numberType)
		if hasStringConstituent && arrayElementType {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): arrayElementType.flags & TypeFlags.StringLike */ TODO && ! /* TODO(PropertyAccessExpression): compilerOptions.noUncheckedIndexedAccess */ TODO {
				return stringType
			}
			return getUnionType( /* TODO(ConditionalExpression): possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType] */ TODO /* TODO(PropertyAccessExpression): UnionReduction.Subtype */, TODO)
		}
		return /* TODO(ConditionalExpression): (use & IterationUse.PossiblyOutOfBounds) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType */ TODO
		getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration /* TODO(BooleanKeyword): boolean */ any) /* TODO(TupleType): [error: DiagnosticMessage, maybeMissingAwait: boolean] */ TODO {
			if downlevelIteration {
				return /* TODO(ConditionalExpression): allowsStrings                     ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]                     : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true] */ TODO
			}
			yieldType := getIterationTypeOfIterable(use /* TODO(PropertyAccessExpression): IterationTypeKind.Yield */, TODO, inputType, nil)
			if yieldType {
				return /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false] */ TODO
			}
			if isES2015OrLaterIterable( /* TODO(PropertyAccessExpression): inputType.symbol?.escapedName */ TODO) {
				return /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true] */ TODO
			}
			return /* TODO(ConditionalExpression): allowsStrings                 ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]                 : [Diagnostics.Type_0_is_not_an_array_type, true] */ TODO
		}
	}
	isES2015OrLaterIterable := func(n __String) /* TODO(undefined): boolean */ TODO {
		/* TODO(SwitchStatement): switch (n) {             case "Float32Array":             case "Float64Array":             case "Int16Array":             case "Int32Array":             case "Int8Array":             case "NodeList":             case "Uint16Array":             case "Uint32Array":             case "Uint8Array":             case "Uint8ClampedArray":                 return true;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	getIterationTypeOfIterable := func(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) *Type {
		if isTypeAny(inputType) {
			return nil
		}
		iterationTypes := getIterationTypesOfIterable(inputType, use, errorNode)
		return iterationTypes && /* TODO(ElementAccessExpression): iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)] */ TODO
	}
	createIterationTypes := func(yieldType Type /* = */ /* TODO(Identifier): neverType */, returnType Type /* = */ /* TODO(Identifier): neverType */, nextType Type /* = */ /* TODO(Identifier): unknownType */) IterationTypes {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): yieldType.flags & TypeFlags.Intrinsic */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): returnType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nextType.flags & (TypeFlags.Any | TypeFlags.Never | TypeFlags.Unknown | TypeFlags.Void | TypeFlags.Undefined) */ TODO {
			id := getTypeListId( /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */ TODO)
			iterationTypes := /* TODO(PropertyAccessExpression): iterationTypesCache.get */ TODO(id)
			if !iterationTypes {
				/* TODO(ExpressionStatement): iterationTypes = { yieldType, returnType, nextType }; */
				/* TODO(PropertyAccessExpression): iterationTypesCache.set */
				TODO(id, iterationTypes)
			}
			return iterationTypes
		}
		return /* TODO(ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
	}
	combineIterationTypes := func(array []*IterationTypes) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		var yieldTypes /* TODO(ArrayType): Type[] */ any
		var returnTypes /* TODO(ArrayType): Type[] */ any
		var nextTypes /* TODO(ArrayType): Type[] */ any
		for _, iterationTypes := range array {
			if iterationTypes == nil || iterationTypes == noIterationTypes {
				/* TODO(ContinueStatement): continue; */
			}
			if iterationTypes == anyIterationTypes {
				return anyIterationTypes
			}
			/* TODO(ExpressionStatement): yieldTypes = append(yieldTypes, iterationTypes.yieldType); */
			/* TODO(ExpressionStatement): returnTypes = append(returnTypes, iterationTypes.returnType); */
			/* TODO(ExpressionStatement): nextTypes = append(nextTypes, iterationTypes.nextType); */
		}
		if yieldTypes || returnTypes || nextTypes {
			return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes))
		}
		return noIterationTypes
	}
	getCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return /* TODO(ElementAccessExpression): (type as IterableOrIteratorType)[cacheKey] */ TODO
	}
	setCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as IterableOrIteratorType)[cacheKey] = cachedTypes */ TODO
	}
	getIterationTypesOfIterable := func(type_ Type, use IterationUse, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Union) */ TODO {
			var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !! /* TODO(ParenthesizedExpression): (use & IterationUse.AllowsAsyncIterablesFlag) */ TODO)
					if /* TODO(PropertyAccessExpression): errorOutputContainer?.errors */ TODO {
						addRelatedInfo(rootDiag /* TODO(SpreadElement): ...errorOutputContainer.errors */, TODO)
					}
				}
				return nil
			} else if /* TODO(PropertyAccessExpression): errorOutputContainer?.errors?.length */ TODO {
				for _, diag := range /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO {
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
				}
			}
			return iterationTypes
		}
		cacheKey := /* TODO(ConditionalExpression): use & IterationUse.AllowsAsyncIterablesFlag ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable" */ TODO
		cachedTypes := getCachedIterationTypes(type_, cacheKey)
		if cachedTypes {
			/* TODO(ConditionalExpression): cachedTypes === noIterationTypes ? undefined : cachedTypes */
		}
		var allIterationTypes /* TODO(ArrayType): IterationTypes[] */ any
		for _, constituent := range /* TODO(PropertyAccessExpression): (type as UnionType).types */ TODO {
			var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !! /* TODO(ParenthesizedExpression): (use & IterationUse.AllowsAsyncIterablesFlag) */ TODO)
					if /* TODO(PropertyAccessExpression): errorOutputContainer?.errors */ TODO {
						addRelatedInfo(rootDiag /* TODO(SpreadElement): ...errorOutputContainer.errors */, TODO)
					}
				}
				setCachedIterationTypes(type_, cacheKey, noIterationTypes)
				return nil
			} else if /* TODO(PropertyAccessExpression): errorOutputContainer?.errors?.length */ TODO {
				for _, diag := range /* TODO(PropertyAccessExpression): errorOutputContainer.errors */ TODO {
					/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diag)
				}
			}
			/* TODO(ExpressionStatement): allIterationTypes = append(allIterationTypes, iterationTypes); */
		}
		iterationTypes := /* TODO(ConditionalExpression): allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes */ TODO
		setCachedIterationTypes(type_, cacheKey, iterationTypes)
		return /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
	}
	getAsyncFromSyncIterationTypes := func(iterationTypes IterationTypes, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if iterationTypes == noIterationTypes {
			/* TODO(Identifier): noIterationTypes */
		}
		if iterationTypes == anyIterationTypes {
			/* TODO(Identifier): anyIterationTypes */
		}
		TODO_IDENTIFIER := iterationTypes
		if errorNode {
			getGlobalAwaitedSymbol( /* TODO(TrueKeyword): true */ TODO)
		}
		return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType)
	}
	getIterationTypesOfIterableWorker := func(type_ Type, use IterationUse, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		noCache := /* TODO(FalseKeyword): false */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
			iterationTypes := getIterationTypesOfIterableCached(type_, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, asyncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					/* TODO(ExpressionStatement): noCache = true; */
				} else {
					return /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ?                         getAsyncFromSyncIterationTypes(iterationTypes, errorNode) :                         iterationTypes */ TODO
				}
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsSyncIterablesFlag */ TODO {
			iterationTypes := getIterationTypesOfIterableCached(type_, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, syncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					/* TODO(ExpressionStatement): noCache = true; */
				} else {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
							/* TODO(ExpressionStatement): iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode); */
							return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
						}
					} else {
						return iterationTypes
					}
				}
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
			iterationTypes := getIterationTypesOfIterableSlow(type_, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
				return iterationTypes
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsSyncIterablesFlag */ TODO {
			iterationTypes := getIterationTypesOfIterableSlow(type_, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): use & IterationUse.AllowsAsyncIterablesFlag */ TODO {
					/* TODO(ExpressionStatement): iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode); */
					return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
				} else {
					return iterationTypes
				}
			}
		}
		return noIterationTypes
	}
	getIterationTypesOfIterableCached := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getCachedIterationTypes(type_ /* TODO(PropertyAccessExpression): resolver.iterableCacheKey */, TODO)
	}
	getIterationTypesOfIterableFast := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalIterableType */, TODO( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalIteratorObjectType */, TODO( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalIterableIteratorType */, TODO( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalGeneratorType */, TODO( /* TODO(FalseKeyword): false */ TODO)) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			return setCachedIterationTypes(type_ /* TODO(PropertyAccessExpression): resolver.iterableCacheKey */, TODO, createIterationTypes( /* TODO(PropertyAccessExpression): resolver.resolveIterationType */ TODO(yieldType, nil) || yieldType /* TODO(PropertyAccessExpression): resolver.resolveIterationType */, TODO(returnType, nil) || returnType, nextType))
		}
		if isReferenceToSomeType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalBuiltinIteratorTypes */, TODO()) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_ /* TODO(PropertyAccessExpression): resolver.iterableCacheKey */, TODO, createIterationTypes( /* TODO(PropertyAccessExpression): resolver.resolveIterationType */ TODO(yieldType, nil) || yieldType /* TODO(PropertyAccessExpression): resolver.resolveIterationType */, TODO(returnType, nil) || returnType, nextType))
		}
	}
	getPropertyNameForKnownSymbolName := func(symbolName string) __String {
		ctorType := getGlobalESSymbolConstructorSymbol( /* TODO(FalseKeyword): false */ TODO)
		uniqueType := ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName))
		return /* TODO(ConditionalExpression): uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName}` as __String */ TODO
	}
	getIterationTypesOfIterableSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		method := getPropertyOfType(type_, getPropertyNameForKnownSymbolName( /* TODO(PropertyAccessExpression): resolver.iteratorSymbolName */ TODO))
		methodType := /* TODO(ConditionalExpression): method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined */ TODO
		if isTypeAny(methodType) {
			return /* TODO(ConditionalExpression): noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes) */ TODO
		}
		signatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined */ TODO
		if !some(signatures) {
			return /* TODO(ConditionalExpression): noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes) */ TODO
		}
		iteratorType := getIntersectionType(map_(signatures, getReturnTypeOfSignature))
		iterationTypes := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
		return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes) */ TODO
	}
	reportTypeNotIterableError := func(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
		message := /* TODO(ConditionalExpression): allowAsyncIterables             ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator             : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator */ TODO
		suggestAwait := !!getAwaitedTypeOfPromise(type_) || /* TODO(ParenthesizedExpression): (                 !allowAsyncIterables &&                 isForOfStatement(errorNode.parent) &&                 errorNode.parent.expression === errorNode &&                 getGlobalAsyncIterableType(/*reportErrors* / false) !== emptyGenericType &&                 isTypeAssignableTo(type, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(/*reportErrors* / false), [anyType, anyType, anyType]))             ) */ TODO
		return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type_))
	}
	getIterationTypesOfIterator := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer /* TODO(FalseKeyword): false */, TODO)
	}
	getIterationTypesOfIteratorWorker := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		iterationTypes := getIterationTypesOfIteratorCached(type_, resolver) || getIterationTypesOfIteratorFast(type_, resolver)
		if iterationTypes == noIterationTypes && errorNode {
			/* TODO(ExpressionStatement): iterationTypes = undefined; */
			/* TODO(ExpressionStatement): noCache = true; */
		}
		/* TODO(ExpressionStatement): iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache); */
		return /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
	}
	getIterationTypesOfIteratorCached := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getCachedIterationTypes(type_ /* TODO(PropertyAccessExpression): resolver.iteratorCacheKey */, TODO)
	}
	getIterationTypesOfIteratorFast := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalIterableIteratorType */, TODO( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalIteratorType */, TODO( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalIteratorObjectType */, TODO( /* TODO(FalseKeyword): false */ TODO)) || isReferenceToType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalGeneratorType */, TODO( /* TODO(FalseKeyword): false */ TODO)) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			return setCachedIterationTypes(type_ /* TODO(PropertyAccessExpression): resolver.iteratorCacheKey */, TODO, createIterationTypes(yieldType, returnType, nextType))
		}
		if isReferenceToSomeType(type_ /* TODO(PropertyAccessExpression): resolver.getGlobalBuiltinIteratorTypes */, TODO()) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_ /* TODO(PropertyAccessExpression): resolver.iteratorCacheKey */, TODO, createIterationTypes(yieldType, returnType, nextType))
		}
	}
	isIteratorResult := func(type_ Type, kind /* TODO(UnionType): IterationTypeKind.Yield | IterationTypeKind.Return */ any) /* TODO(undefined): boolean */ TODO {
		doneType := getTypeOfPropertyOfType(type_, "done" /* as */ /* TODO(TypeReference): __String */) || falseType
		return isTypeAssignableTo( /* TODO(ConditionalExpression): kind === IterationTypeKind.Yield ? falseType : trueType */ TODO, doneType)
	}
	isYieldIteratorResult := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return isIteratorResult(type_ /* TODO(PropertyAccessExpression): IterationTypeKind.Yield */, TODO)
	}
	isReturnIteratorResult := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return isIteratorResult(type_ /* TODO(PropertyAccessExpression): IterationTypeKind.Return */, TODO)
	}
	getIterationTypesOfIteratorResult := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		cachedTypes := getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
		if cachedTypes {
			return cachedTypes
		}
		if isReferenceToType(type_, getGlobalIteratorYieldResultType( /* TODO(FalseKeyword): false */ TODO)) {
			yieldType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, nil, nil))
		}
		if isReferenceToType(type_, getGlobalIteratorReturnResultType( /* TODO(FalseKeyword): false */ TODO)) {
			returnType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(nil, returnType, nil))
		}
		yieldIteratorResult := filterType(type_, isYieldIteratorResult)
		yieldType := /* TODO(ConditionalExpression): yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value" as __String) : undefined */ TODO
		returnIteratorResult := filterType(type_, isReturnIteratorResult)
		returnType := /* TODO(ConditionalExpression): returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value" as __String) : undefined */ TODO
		if !yieldType && !returnType {
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", noIterationTypes)
		}
		return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, nil))
	}
	getIterationTypesOfMethod := func(type_ Type, resolver IterationTypesResolver, methodName /* TODO(UnionType): "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
		method := getPropertyOfType(type_, methodName /* as */ /* TODO(TypeReference): __String */)
		if !method && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): methodName !== "next" */ TODO {
			return nil
		}
		methodType := /* TODO(ConditionalExpression): method && !(methodName === "next" && (method.flags & SymbolFlags.Optional))             ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull)             : undefined */ TODO
		if isTypeAny(methodType) {
			return anyIterationTypes
		}
		methodSignatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : emptyArray */ TODO
		if /* TODO(PropertyAccessExpression): methodSignatures.length */ TODO == 0 {
			if errorNode {
				diagnostic := /* TODO(ConditionalExpression): methodName === "next"                     ? resolver.mustHaveANextMethodDiagnostic                     : resolver.mustBeAMethodDiagnostic */ TODO
				if errorOutputContainer {
					/* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
					/* TODO(PropertyAccessExpression): errorOutputContainer.errors.push */
					TODO(createDiagnosticForNode(errorNode, diagnostic, methodName))
				} else {
					error(errorNode, diagnostic, methodName)
				}
			}
			return /* TODO(ConditionalExpression): methodName === "next" ? noIterationTypes : undefined */ TODO
		}
		if /* TODO(PropertyAccessExpression): methodType?.symbol */ TODO && /* TODO(PropertyAccessExpression): methodSignatures.length */ TODO == 1 {
			globalGeneratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalGeneratorType */ TODO( /* TODO(FalseKeyword): false */ TODO)
			globalIteratorType := /* TODO(PropertyAccessExpression): resolver.getGlobalIteratorType */ TODO( /* TODO(FalseKeyword): false */ TODO)
			isGeneratorMethod := /* TODO(PropertyAccessExpression): globalGeneratorType.symbol?.members?.get */ TODO(methodName /* as */ /* TODO(TypeReference): __String */) == /* TODO(PropertyAccessExpression): methodType.symbol */ TODO
			isIteratorMethod := !isGeneratorMethod && /* TODO(PropertyAccessExpression): globalIteratorType.symbol?.members?.get */ TODO(methodName /* as */ /* TODO(TypeReference): __String */) == /* TODO(PropertyAccessExpression): methodType.symbol */ TODO
			if isGeneratorMethod || isIteratorMethod {
				globalType := /* TODO(ConditionalExpression): isGeneratorMethod ? globalGeneratorType : globalIteratorType */ TODO
				TODO_IDENTIFIER := methodType /* as */ /* TODO(TypeReference): AnonymousType */
				return createIterationTypes(getMappedType( /* TODO(ElementAccessExpression): globalType.typeParameters![0] */ TODO /* TODO(NonNullExpression): mapper! */, TODO), getMappedType( /* TODO(ElementAccessExpression): globalType.typeParameters![1] */ TODO /* TODO(NonNullExpression): mapper! */, TODO) /* TODO(ConditionalExpression): methodName === "next" ? getMappedType(globalType.typeParameters![2], mapper!) : undefined */, TODO)
			}
		}
		var methodParameterTypes /* TODO(ArrayType): Type[] */ any
		var methodReturnTypes /* TODO(ArrayType): Type[] */ any
		for _, signature := range methodSignatures {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): methodName !== "throw" */ TODO && some( /* TODO(PropertyAccessExpression): signature.parameters */ TODO) {
				/* TODO(ExpressionStatement): methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0)); */
			}
			/* TODO(ExpressionStatement): methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature)); */
		}
		var returnTypes /* TODO(ArrayType): Type[] */ any
		var nextType *Type
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): methodName !== "throw" */ TODO {
			methodParameterType := /* TODO(ConditionalExpression): methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType */ TODO
			if methodName == "next" {
				/* TODO(ExpressionStatement): nextType = methodParameterType; */
			} else if methodName == "return" {
				resolvedMethodParameterType := /* TODO(PropertyAccessExpression): resolver.resolveIterationType */ TODO(methodParameterType, errorNode) || anyType
				/* TODO(ExpressionStatement): returnTypes = append(returnTypes, resolvedMethodParameterType); */
			}
		}
		var yieldType Type
		methodReturnType := /* TODO(ConditionalExpression): methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType */ TODO
		resolvedMethodReturnType := /* TODO(PropertyAccessExpression): resolver.resolveIterationType */ TODO(methodReturnType, errorNode) || anyType
		iterationTypes := getIterationTypesOfIteratorResult(resolvedMethodReturnType)
		if iterationTypes == noIterationTypes {
			if errorNode {
				if errorOutputContainer {
					/* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
					/* TODO(PropertyAccessExpression): errorOutputContainer.errors.push */
					TODO(createDiagnosticForNode(errorNode /* TODO(PropertyAccessExpression): resolver.mustHaveAValueDiagnostic */, TODO, methodName))
				} else {
					error(errorNode /* TODO(PropertyAccessExpression): resolver.mustHaveAValueDiagnostic */, TODO, methodName)
				}
			}
			/* TODO(ExpressionStatement): yieldType = anyType; */
			/* TODO(ExpressionStatement): returnTypes = append(returnTypes, anyType); */
		} else {
			/* TODO(ExpressionStatement): yieldType = iterationTypes.yieldType; */
			/* TODO(ExpressionStatement): returnTypes = append(returnTypes, iterationTypes.returnType); */
		}
		return createIterationTypes(yieldType, getUnionType(returnTypes), nextType)
	}
	getIterationTypesOfIteratorSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		iterationTypes := combineIterationTypes( /* TODO(ArrayLiteralExpression): [             getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer),         ] */ TODO)
		return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes) */ TODO
	}
	getIterationTypeOfGeneratorFunctionReturnType := func(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) *Type {
		if isTypeAny(returnType) {
			return nil
		}
		iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
		return iterationTypes && /* TODO(ElementAccessExpression): iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)] */ TODO
	}
	getIterationTypesOfGeneratorFunctionReturnType := func(type_ Type, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		use := /* TODO(ConditionalExpression): isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType */ TODO
		resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		return getIterationTypesOfIterable(type_, use, nil) || getIterationTypesOfIterator(type_, resolver, nil, nil)
	}
	checkBreakOrContinueStatement := func(node BreakOrContinueStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			/* TODO(CallExpression): checkGrammarBreakOrContinueStatement(node) */
		}
	}
	unwrapReturnType := func(returnType Type, functionFlags FunctionFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		isGenerator := !! /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.Generator) */ TODO
		isAsync := !! /* TODO(ParenthesizedExpression): (functionFlags & FunctionFlags.Async) */ TODO
		if isGenerator {
			returnIterationType := getIterationTypeOfGeneratorFunctionReturnType( /* TODO(PropertyAccessExpression): IterationTypeKind.Return */ TODO, returnType, isAsync)
			if !returnIterationType {
				return errorType
			}
			return /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType */ TODO
		}
		return /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType */ TODO
	}
	isUnwrappedReturnTypeUndefinedVoidOrAny := func(func_ SignatureDeclaration, returnType Type) bool {
		type_ := unwrapReturnType(returnType, getFunctionFlags(func_))
		return !! /* TODO(ParenthesizedExpression): (type && (maybeTypeOfKind(type, TypeFlags.Void) || type.flags & (TypeFlags.Any | TypeFlags.Undefined))) */ TODO
	}
	checkReturnStatement := func(node ReturnStatement) {
		if checkGrammarStatementInAmbientContext(node) {
			return
		}
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block */, TODO)
			return
		}
		if !container {
			grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.A_return_statement_can_only_be_used_within_a_function_body */, TODO)
			return
		}
		signature := getSignatureFromDeclaration(container)
		returnType := getReturnTypeOfSignature(signature)
		functionFlags := getFunctionFlags(container)
		if strictNullChecks || /* TODO(PropertyAccessExpression): node.expression */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): returnType.flags & TypeFlags.Never */ TODO {
			exprType := /* TODO(ConditionalExpression): node.expression ? checkExpressionCached(node.expression) : undefinedType */ TODO
			if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO {
				if /* TODO(PropertyAccessExpression): node.expression */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Setters_cannot_return_a_value */, TODO)
				}
			} else if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
				if /* TODO(PropertyAccessExpression): node.expression */ TODO && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node /* TODO(PropertyAccessExpression): node.expression */, TODO) {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class */, TODO)
				}
			} else if getReturnTypeFromAnnotation(container) {
				unwrappedReturnType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
				unwrappedExprType := /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? checkAwaitedType(exprType, /*withAlias* / false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)                     : exprType */ TODO
				if unwrappedReturnType {
					checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node /* TODO(PropertyAccessExpression): node.expression */, TODO)
				}
			}
		} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): container.kind !== SyntaxKind.Constructor */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.noImplicitReturns */ TODO && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.Not_all_code_paths_return_a_value */, TODO)
		}
	}
	checkWithStatement := func(node WithStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.AwaitContext */ TODO {
				grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.with_statements_are_not_allowed_in_an_async_function_block */, TODO)
			}
		}
		checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			start := /* TODO(PropertyAccessExpression): getSpanOfTokenAtPosition(sourceFile, node.pos).start */ TODO
			end := /* TODO(PropertyAccessExpression): node.statement.pos */ TODO
			grammarErrorAtPos(sourceFile, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO /* TODO(PropertyAccessExpression): Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any */, TODO)
		}
	}
	checkSwitchStatement := func(node SwitchStatement) {
		checkGrammarStatementInAmbientContext(node)
		var firstDefaultClause CaseOrDefaultClause
		hasDuplicateDefaultClause := /* TODO(FalseKeyword): false */ TODO
		expressionType := checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		forEach( /* TODO(PropertyAccessExpression): node.caseBlock.clauses */ TODO /* TODO(ArrowFunction): clause => {             // Grammar check for duplicate default clauses, skip if we already report duplicate default clause             if (clause.kind === SyntaxKind.DefaultClause && !hasDuplicateDefaultClause) {                 if (firstDefaultClause === undefined) {                     firstDefaultClause = clause;                 }                 else {                     grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);                     hasDuplicateDefaultClause = true;                 }             }              if (clause.kind === SyntaxKind.CaseClause) {                 addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));             }             forEach(clause.statements, checkSourceElement);             if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {                 error(clause, Diagnostics.Fallthrough_case_in_switch);             }              function createLazyCaseClauseDiagnostics(clause: CaseClause) {                 return () => {                     // TypeScript 1.0 spec (April 2014): 5.9                     // In a 'switch' statement, each 'case' expression must be of a type that is comparable                     // to or from the type of the 'switch' expression.                     const caseType = checkExpression(clause.expression);                      if (!isTypeEqualityComparableTo(expressionType, caseType)) {                         // expressionType is not comparable to caseType, try the reversed check and report errors if it fails                         checkTypeComparableTo(caseType, expressionType, clause.expression, /*headMessage* / undefined);                     }                 };             }         } */, TODO)
		if /* TODO(PropertyAccessExpression): node.caseBlock.locals */ TODO {
			registerForUnusedIdentifiersCheck( /* TODO(PropertyAccessExpression): node.caseBlock */ TODO)
		}
	}
	checkLabeledStatement := func(node LabeledStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			findAncestor( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): current => {                 if (isFunctionLike(current)) {                     return "quit";                 }                 if (current.kind === SyntaxKind.LabeledStatement && (current as LabeledStatement).label.escapedText === node.label.escapedText) {                     grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label));                     return true;                 }                 return false;             } */, TODO)
		}
		checkSourceElement( /* TODO(PropertyAccessExpression): node.statement */ TODO)
	}
	checkThrowStatement := func(node ThrowStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if isIdentifier( /* TODO(PropertyAccessExpression): node.expression */ TODO) && ! /* TODO(PropertyAccessExpression): node.expression.escapedText */ TODO {
				grammarErrorAfterFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.Line_break_not_permitted_here */, TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): node.expression */ TODO {
			checkExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		}
	}
	checkTryStatement := func(node TryStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkBlock( /* TODO(PropertyAccessExpression): node.tryBlock */ TODO)
		catchClause := /* TODO(PropertyAccessExpression): node.catchClause */ TODO
		if catchClause {
			if /* TODO(PropertyAccessExpression): catchClause.variableDeclaration */ TODO {
				declaration := /* TODO(PropertyAccessExpression): catchClause.variableDeclaration */ TODO
				checkVariableLikeDeclaration(declaration)
				typeNode := getEffectiveTypeAnnotationNode(declaration)
				if typeNode {
					type_ := getTypeFromTypeNode(typeNode)
					if type_ && ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.AnyOrUnknown) */ TODO {
						grammarErrorOnFirstToken(typeNode /* TODO(PropertyAccessExpression): Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified */, TODO)
					}
				} else if /* TODO(PropertyAccessExpression): declaration.initializer */ TODO {
					grammarErrorOnFirstToken( /* TODO(PropertyAccessExpression): declaration.initializer */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Catch_clause_variable_cannot_have_an_initializer */, TODO)
				} else {
					blockLocals := /* TODO(PropertyAccessExpression): catchClause.block.locals */ TODO
					if blockLocals {
						forEachKey( /* TODO(NonNullExpression): catchClause.locals! */ TODO /* TODO(ArrowFunction): caughtName => {                             const blockLocal = blockLocals.get(caughtName);                             if (blockLocal?.valueDeclaration && (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0) {                                 grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName));                             }                         } */, TODO)
					}
				}
			}
			checkBlock( /* TODO(PropertyAccessExpression): catchClause.block */ TODO)
		}
		if /* TODO(PropertyAccessExpression): node.finallyBlock */ TODO {
			checkBlock( /* TODO(PropertyAccessExpression): node.finallyBlock */ TODO)
		}
	}
	checkIndexConstraints := func(type_ Type, symbol Symbol, isStaticIndex bool) {
		indexInfos := getIndexInfosOfType(type_)
		if /* TODO(PropertyAccessExpression): indexInfos.length */ TODO == 0 {
			return
		}
		for _, prop := range getPropertiesOfObjectType(type_) {
			if ! /* TODO(ParenthesizedExpression): (isStaticIndex && prop.flags & SymbolFlags.Prototype) */ TODO {
				checkIndexConstraintForProperty(type_, prop, getLiteralTypeFromProperty(prop /* TODO(PropertyAccessExpression): TypeFlags.StringOrNumberLiteralOrUnique */, TODO /* TODO(TrueKeyword): true */, TODO), getNonMissingTypeOfSymbol(prop))
			}
		}
		typeDeclaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if typeDeclaration && isClassLike(typeDeclaration) {
			for _, member := range /* TODO(PropertyAccessExpression): typeDeclaration.members */ TODO {
				if !isStatic(member) && !hasBindableName(member) {
					symbol := getSymbolOfDeclaration(member)
					checkIndexConstraintForProperty(type_, symbol, getTypeOfExpression( /* TODO(PropertyAccessExpression): (member as DynamicNamedDeclaration).name.expression */ TODO), getNonMissingTypeOfSymbol(symbol))
				}
			}
		}
		if /* TODO(PropertyAccessExpression): indexInfos.length */ TODO > 1 {
			for _, info := range indexInfos {
				checkIndexConstraintForIndexSignature(type_, info)
			}
		}
	}
	checkIndexConstraintForProperty := func(type_ Type, prop Symbol, propNameType Type, propType Type) {
		declaration := /* TODO(PropertyAccessExpression): prop.valueDeclaration */ TODO
		name := getNameOfDeclaration(declaration)
		if name && isPrivateIdentifier(name) {
			return
		}
		indexInfos := getApplicableIndexInfos(type_, propNameType)
		interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		propDeclaration := /* TODO(ConditionalExpression): declaration && declaration.kind === SyntaxKind.BinaryExpression ||                 name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined */ TODO
		localPropDeclaration := /* TODO(ConditionalExpression): getParentOfSymbol(prop) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			localIndexDeclaration := /* TODO(ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localPropDeclaration || localIndexDeclaration || /* TODO(ParenthesizedExpression): (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined) */ TODO
			if errorNode && !isTypeAssignableTo(propType /* TODO(PropertyAccessExpression): info.type */, TODO) {
				diagnostic := createError(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3 */, TODO, symbolToString(prop), typeToString(propType), typeToString( /* TODO(PropertyAccessExpression): info.keyType */ TODO), typeToString( /* TODO(PropertyAccessExpression): info.type */ TODO))
				if propDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorNode !== propDeclaration */ TODO {
					addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration /* TODO(PropertyAccessExpression): Diagnostics._0_is_declared_here */, TODO, symbolToString(prop)))
				}
				/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
			}
		}
	}
	checkIndexConstraintForIndexSignature := func(type_ Type, checkInfo IndexInfo) {
		declaration := /* TODO(PropertyAccessExpression): checkInfo.declaration */ TODO
		indexInfos := getApplicableIndexInfos(type_ /* TODO(PropertyAccessExpression): checkInfo.keyType */, TODO)
		interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		localCheckDeclaration := /* TODO(ConditionalExpression): declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			if info == checkInfo {
			}
			localIndexDeclaration := /* TODO(ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localCheckDeclaration || localIndexDeclaration || /* TODO(ParenthesizedExpression): (interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined) */ TODO
			if errorNode && !isTypeAssignableTo( /* TODO(PropertyAccessExpression): checkInfo.type */ TODO /* TODO(PropertyAccessExpression): info.type */, TODO) {
				error(errorNode /* TODO(PropertyAccessExpression): Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3 */, TODO, typeToString( /* TODO(PropertyAccessExpression): checkInfo.keyType */ TODO), typeToString( /* TODO(PropertyAccessExpression): checkInfo.type */ TODO), typeToString( /* TODO(PropertyAccessExpression): info.keyType */ TODO), typeToString( /* TODO(PropertyAccessExpression): info.type */ TODO))
			}
		}
	}
	checkTypeNameIsReserved := func(name Identifier, message DiagnosticMessage) {
		/* TODO(SwitchStatement): switch (name.escapedText) {             case "any":             case "unknown":             case "never":             case "number":             case "bigint":             case "boolean":             case "string":             case "symbol":             case "void":             case "object":             case "undefined":                 error(name, message, name.escapedText as string);         } */
	}
	checkClassNameCollisionWithObject := func(name Identifier) {
		if languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES5 */ TODO && /* TODO(PropertyAccessExpression): name.escapedText */ TODO == "Object" && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(name)) < /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO {
			error(name /* TODO(PropertyAccessExpression): Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0 */, TODO /* TODO(ElementAccessExpression): ModuleKind[moduleKind] */, TODO)
		}
	}
	checkUnmatchedJSDocParameters := func(node SignatureDeclaration) {
		jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
		if !length(jsdocParameters) {
		}
		isJs := isInJSFile(node)
		parameters := /* TODO(NewExpression): new Set<__String>() */ TODO
		excludedParameters := /* TODO(NewExpression): new Set<number>() */ TODO
		forEach( /* TODO(PropertyAccessExpression): node.parameters */ TODO /* TODO(ArrowFunction): ({ name }, index) => {             if (isIdentifier(name)) {                 parameters.add(name.escapedText);             }             if (isBindingPattern(name)) {                 excludedParameters.add(index);             }         } */, TODO)
		containsArguments := containsArgumentsReference(node)
		if containsArguments {
			lastJSDocParamIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): jsdocParameters.length - 1 */ TODO
			lastJSDocParam := /* TODO(ElementAccessExpression): jsdocParameters[lastJSDocParamIndex] */ TODO
			if isJs && lastJSDocParam && isIdentifier( /* TODO(PropertyAccessExpression): lastJSDocParam.name */ TODO) && /* TODO(PropertyAccessExpression): lastJSDocParam.typeExpression */ TODO && /* TODO(PropertyAccessExpression): lastJSDocParam.typeExpression.type */ TODO && ! /* TODO(PropertyAccessExpression): parameters.has */ TODO( /* TODO(PropertyAccessExpression): lastJSDocParam.name.escapedText */ TODO) && ! /* TODO(PropertyAccessExpression): excludedParameters.has */ TODO(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode( /* TODO(PropertyAccessExpression): lastJSDocParam.typeExpression.type */ TODO)) {
				error( /* TODO(PropertyAccessExpression): lastJSDocParam.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type */, TODO, idText( /* TODO(PropertyAccessExpression): lastJSDocParam.name */ TODO))
			}
		} else {
			forEach(jsdocParameters /* TODO(ArrowFunction): ({ name, isNameFirst }, index) => {                 if (excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText)) {                     return;                 }                 if (isQualifiedName(name)) {                     if (isJs) {                         error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left));                     }                 }                 else {                     if (!isNameFirst) {                         errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name));                     }                 }             } */, TODO)
		}
	}
	checkTypeParameters := func(typeParameterDeclarations /* TODO(TypeOperator): readonly TypeParameterDeclaration[] */ any) {
		seenDefault := /* TODO(FalseKeyword): false */ TODO
		if typeParameterDeclarations {
			/* TODO(ForStatement): for (let i = 0; i < typeParameterDeclarations.length; i++) {                 const node = typeParameterDeclarations[i];                 checkTypeParameter(node);                  addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));             } */
		}
		createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO(undefined): () => void */ TODO {
			return /* TODO(ArrowFunction): () => {                 if (node.default) {                     seenDefault = true;                     checkTypeParametersNotReferenced(node.default, typeParameterDeclarations!, i);                 }                 else if (seenDefault) {                     error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);                 }                 for (let j = 0; j < i; j++) {                     if (typeParameterDeclarations![j].symbol === node.symbol) {                         error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));                     }                 }             } */ TODO
		}
	}
	checkTypeParametersNotReferenced := func(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
		visit(root)
		visit := func(node Node) {
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeReference */ TODO {
				type_ := getTypeFromTypeReference(node /* as */ /* TODO(TypeReference): TypeReferenceNode */)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.TypeParameter */ TODO {
					/* TODO(ForStatement): for (let i = index; i < typeParameters.length; i++) {                         if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {                             error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);                         }                     } */
				}
			}
			forEachChild(node, visit)
		}
	}
	checkTypeParameterListsIdentical := func(symbol Symbol) {
		if /* TODO(PropertyAccessExpression): symbol.declarations */ TODO && /* TODO(PropertyAccessExpression): symbol.declarations.length */ TODO == 1 {
			return
		}
		links := getSymbolLinks(symbol)
		if ! /* TODO(PropertyAccessExpression): links.typeParametersChecked */ TODO {
			/* TODO(ExpressionStatement): links.typeParametersChecked = true; */
			declarations := getClassOrInterfaceDeclarationsOfSymbol(symbol)
			if !declarations || /* TODO(PropertyAccessExpression): declarations.length */ TODO <= 1 {
				return
			}
			type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
			if !areTypeParametersIdentical(declarations /* TODO(NonNullExpression): type.localTypeParameters! */, TODO, getEffectiveTypeParameterDeclarations) {
				name := symbolToString(symbol)
				for _, declaration := range declarations {
					error( /* TODO(PropertyAccessExpression): declaration.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.All_declarations_of_0_must_have_identical_type_parameters */, TODO, name)
				}
			}
		}
	}
	areTypeParametersIdentical := func(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) /* TODO(undefined): boolean */ TODO {
		maxTypeArgumentCount := length(targetParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(targetParameters)
		for _, declaration := range declarations {
			sourceParameters := getTypeParameterDeclarations(declaration)
			numTypeParameters := /* TODO(PropertyAccessExpression): sourceParameters.length */ TODO
			if numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount {
				return /* TODO(FalseKeyword): false */ TODO
			}
			/* TODO(ForStatement): for (let i = 0; i < numTypeParameters; i++) {                 const source = sourceParameters[i];                 const target = targetParameters[i];                  // If the type parameter node does not have the same as the resolved type                 // parameter at this position, we report an error.                 if (source.name.escapedText !== target.symbol.escapedName) {                     return false;                 }                  // If the type parameter node does not have an identical constraint as the resolved                 // type parameter at this position, we report an error.                 const constraint = getEffectiveConstraintOfTypeParameter(source);                 const sourceConstraint = constraint && getTypeFromTypeNode(constraint);                 const targetConstraint = getConstraintOfTypeParameter(target);                 // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with                 // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)                 if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {                     return false;                 }                  // If the type parameter node has a default and it is not identical to the default                 // for the type parameter at this position, we report an error.                 const sourceDefault = source.default && getTypeFromTypeNode(source.default);                 const targetDefault = getDefaultFromTypeParameter(target);                 if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {                     return false;                 }             } */
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	getFirstTransformableStaticClassElement := func(node ClassLikeDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").Decorator | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassStaticBlockDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierPropertyDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierMethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierGetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierSetAccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyDeclaration & { initializer: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }) | undefined */ TODO {
		willTransformStaticElementsOfDecoratedClass := !legacyDecorators && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO && classOrConstructorParameterIsDecorated( /* TODO(FalseKeyword): false */ TODO, node)
		willTransformPrivateElementsOrClassStaticBlocks := languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.PrivateNamesAndClassStaticBlocks */ TODO || languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO
		willTransformInitializers := !emitStandardClassFields
		if willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks {
			for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
				if willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated( /* TODO(FalseKeyword): false */ TODO, member, node) {
					return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
				} else if willTransformPrivateElementsOrClassStaticBlocks {
					if isClassStaticBlockDeclaration(member) {
						return member
					} else if isStatic(member) {
						if isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member) {
							return member
						}
					}
				}
			}
		}
	}
	checkClassExpressionExternalHelpers := func(node ClassExpression) {
		if /* TODO(PropertyAccessExpression): node.name */ TODO {
		}
		parent := walkUpOuterExpressions(node)
		if !isNamedEvaluationSource(parent) {
		}
		willTransformESDecorators := !legacyDecorators && languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.ClassAndClassElementDecorators */ TODO
		var location Node
		if willTransformESDecorators && classOrConstructorParameterIsDecorated( /* TODO(FalseKeyword): false */ TODO, node) {
			/* TODO(ExpressionStatement): location = firstOrUndefined(getDecorators(node)) ?? node; */
		} else {
			/* TODO(ExpressionStatement): location = getFirstTransformableStaticClassElement(node); */
		}
		if location {
			checkExternalEmitHelpers(location /* TODO(PropertyAccessExpression): ExternalEmitHelpers.SetFunctionName */, TODO)
			if /* TODO(ParenthesizedExpression): (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) */ TODO && isComputedPropertyName( /* TODO(PropertyAccessExpression): parent.name */ TODO) {
				checkExternalEmitHelpers(location /* TODO(PropertyAccessExpression): ExternalEmitHelpers.PropKey */, TODO)
			}
		}
	}
	checkClassExpression := func(node ClassExpression) Type {
		checkClassLikeDeclaration(node)
		checkNodeDeferred(node)
		checkClassExpressionExternalHelpers(node)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	checkClassExpressionDeferred := func(node ClassExpression) {
		forEach( /* TODO(PropertyAccessExpression): node.members */ TODO, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassDeclaration := func(node ClassDeclaration) {
		firstDecorator := find( /* TODO(PropertyAccessExpression): node.modifiers */ TODO, isDecorator)
		if legacyDecorators && firstDecorator && some( /* TODO(PropertyAccessExpression): node.members */ TODO /* TODO(ArrowFunction): p => hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p) */, TODO) {
			grammarErrorOnNode(firstDecorator /* TODO(PropertyAccessExpression): Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator */, TODO)
		}
		if ! /* TODO(PropertyAccessExpression): node.name */ TODO && !hasSyntacticModifier(node /* TODO(PropertyAccessExpression): ModifierFlags.Default */, TODO) {
			grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name */, TODO)
		}
		checkClassLikeDeclaration(node)
		forEach( /* TODO(PropertyAccessExpression): node.members */ TODO, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassLikeDeclaration := func(node ClassLikeDeclaration) {
		checkGrammarClassLikeDeclaration(node)
		checkDecorators(node)
		checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkExportsOnMergedDeclarations(node)
		symbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): ObjectType */
		checkTypeParameterListsIdentical(symbol)
		checkFunctionOrConstructorSymbol(symbol)
		checkClassForDuplicateDeclarations(node)
		nodeInAmbientContext := !! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO
		if !nodeInAmbientContext {
			checkClassForStaticPropertyNameConflicts(node)
		}
		baseTypeNode := getEffectiveBaseTypeNode(node)
		if baseTypeNode {
			forEach( /* TODO(PropertyAccessExpression): baseTypeNode.typeArguments */ TODO, checkSourceElement)
			if languageVersion < /* TODO(PropertyAccessExpression): LanguageFeatureMinimumTarget.Classes */ TODO {
				checkExternalEmitHelpers( /* TODO(PropertyAccessExpression): baseTypeNode.parent */ TODO /* TODO(PropertyAccessExpression): ExternalEmitHelpers.Extends */, TODO)
			}
			extendsNode := getClassExtendsHeritageElement(node)
			if extendsNode && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): extendsNode !== baseTypeNode */ TODO {
				checkExpression( /* TODO(PropertyAccessExpression): extendsNode.expression */ TODO)
			}
			baseTypes := getBaseTypes(type_)
			if /* TODO(PropertyAccessExpression): baseTypes.length */ TODO {
				addLazyDiagnostic( /* TODO(ArrowFunction): () => {                     const baseType = baseTypes[0];                     const baseConstructorType = getBaseConstructorTypeOfClass(type);                     const staticBaseType = getApparentType(baseConstructorType);                     checkBaseTypeAccessibility(staticBaseType, baseTypeNode);                     checkSourceElement(baseTypeNode.expression);                     if (some(baseTypeNode.typeArguments)) {                         forEach(baseTypeNode.typeArguments, checkSourceElement);                         for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {                             if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters!)) {                                 break;                             }                         }                     }                     const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);                     if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode* / undefined)) {                         issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1);                     }                     else {                         // Report static side error only when instance type is assignable                         checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);                     }                     if (baseConstructorType.flags & TypeFlags.TypeVariable) {                         if (!isMixinConstructorType(staticType)) {                             error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);                         }                         else {                             const constructSignatures = getSignaturesOfType(baseConstructorType, SignatureKind.Construct);                             if (constructSignatures.some(signature => signature.flags & SignatureFlags.Abstract) && !hasSyntacticModifier(node, ModifierFlags.Abstract)) {                                 error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);                             }                         }                     }                      if (!(staticBaseType.symbol && staticBaseType.symbol.flags & SymbolFlags.Class) && !(baseConstructorType.flags & TypeFlags.TypeVariable)) {                         // When the static base type is a "class-like" constructor function (but not actually a class), we verify                         // that all instantiated base constructor signatures return the same type.                         const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);                         if (forEach(constructors, sig => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType))) {                             error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);                         }                     }                     checkKindsOfPropertyMemberOverrides(type, baseType);                 } */ TODO)
			}
		}
		checkMembersForOverrideModifier(node, type_, typeWithThis, staticType)
		implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
		if implementedTypeNodes {
			for _, typeRefNode := range implementedTypeNodes {
				if !isEntityNameExpression( /* TODO(PropertyAccessExpression): typeRefNode.expression */ TODO) || isOptionalChain( /* TODO(PropertyAccessExpression): typeRefNode.expression */ TODO) {
					error( /* TODO(PropertyAccessExpression): typeRefNode.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments */, TODO)
				}
				checkTypeReferenceNode(typeRefNode)
				addLazyDiagnostic(createImplementsDiagnostics(typeRefNode))
			}
		}
		addLazyDiagnostic( /* TODO(ArrowFunction): () => {             checkIndexConstraints(type, symbol);             checkIndexConstraints(staticType, symbol, /*isStaticIndex* / true);             checkTypeForDuplicateIndexSignatures(node);             checkPropertyInitialization(node);         } */ TODO)
		createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO(undefined): () => void */ TODO {
			return /* TODO(ArrowFunction): () => {                 const t = getReducedType(getTypeFromTypeNode(typeRefNode));                 if (!isErrorType(t)) {                     if (isValidBaseType(t)) {                         const genericDiag = t.symbol && t.symbol.flags & SymbolFlags.Class ?                             Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :                             Diagnostics.Class_0_incorrectly_implements_interface_1;                         const baseWithThis = getTypeWithThisArgument(t, type.thisType);                         if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode* / undefined)) {                             issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);                         }                     }                     else {                         error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);                     }                 }             } */ TODO
		}
	}
	checkMembersForOverrideModifier := func(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			if hasAmbientModifier(member) {
				/* TODO(ContinueStatement): continue; */
			}
			if isConstructorDeclaration(member) {
				forEach( /* TODO(PropertyAccessExpression): member.parameters */ TODO /* TODO(ArrowFunction): param => {                     if (isParameterPropertyDeclaration(param, member)) {                         checkExistingMemberForOverrideModifier(                             node,                             staticType,                             baseStaticType,                             baseWithThis,                             type,                             typeWithThis,                             param,                             /*memberIsParameterProperty* / true,                         );                     }                 } */, TODO)
			}
			checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, member /* TODO(FalseKeyword): false */, TODO)
		}
	}
	checkExistingMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, member /* TODO(UnionType): ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) MemberOverrideStatus {
		declaredProp := /* TODO(PropertyAccessExpression): member.name */ TODO && getSymbolAtLocation( /* TODO(PropertyAccessExpression): member.name */ TODO) || getSymbolAtLocation(member)
		if !declaredProp {
			return /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
		}
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp /* TODO(ConditionalExpression): reportErrors ? member : undefined */, TODO)
	}
	checkMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
		isJs := isInJSFile(node)
		nodeInAmbientContext := !! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO
		if baseWithThis && /* TODO(ParenthesizedExpression): (memberHasOverrideModifier || compilerOptions.noImplicitOverride) */ TODO {
			thisType := /* TODO(ConditionalExpression): memberIsStatic ? staticType : typeWithThis */ TODO
			baseType := /* TODO(ConditionalExpression): memberIsStatic ? baseStaticType : baseWithThis */ TODO
			prop := getPropertyOfType(thisType /* TODO(PropertyAccessExpression): member.escapedName */, TODO)
			baseProp := getPropertyOfType(baseType /* TODO(PropertyAccessExpression): member.escapedName */, TODO)
			baseClassName := typeToString(baseWithThis)
			if prop && !baseProp && memberHasOverrideModifier {
				if errorNode {
					suggestion := getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
					/* TODO(ExpressionStatement): suggestion ?                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,                             baseClassName,                             symbolToString(suggestion),                         ) :                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,                             baseClassName,                         ); */
				}
				return /* TODO(PropertyAccessExpression): MemberOverrideStatus.HasInvalidOverride */ TODO
			} else if prop && /* TODO(PropertyAccessExpression): baseProp?.declarations */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.noImplicitOverride */ TODO && !nodeInAmbientContext {
				baseHasAbstract := some( /* TODO(PropertyAccessExpression): baseProp.declarations */ TODO, hasAbstractModifier)
				if memberHasOverrideModifier {
					return /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
				}
				if !baseHasAbstract {
					if errorNode {
						diag := /* TODO(ConditionalExpression): memberIsParameterProperty ?                             isJs ?                                 Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                                 Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :                             isJs ?                             Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                             Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0 */ TODO
						error(errorNode, diag, baseClassName)
					}
					return /* TODO(PropertyAccessExpression): MemberOverrideStatus.NeedsOverride */ TODO
				} else if memberHasAbstractModifier && baseHasAbstract {
					if errorNode {
						error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0 */, TODO, baseClassName)
					}
					return /* TODO(PropertyAccessExpression): MemberOverrideStatus.NeedsOverride */ TODO
				}
			}
		} else if memberHasOverrideModifier {
			if errorNode {
				className := typeToString(type_)
				error(errorNode /* TODO(ConditionalExpression): isJs ?                         Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class :                         Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class */, TODO, className)
			}
			return /* TODO(PropertyAccessExpression): MemberOverrideStatus.HasInvalidOverride */ TODO
		}
		return /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
	}
	issueMemberSpecificError := func(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
		issuedMemberError := /* TODO(FalseKeyword): false */ TODO
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			if isStatic(member) {
				/* TODO(ContinueStatement): continue; */
			}
			declaredProp := /* TODO(PropertyAccessExpression): member.name */ TODO && getSymbolAtLocation( /* TODO(PropertyAccessExpression): member.name */ TODO) || getSymbolAtLocation(member)
			if declaredProp {
				prop := getPropertyOfType(typeWithThis /* TODO(PropertyAccessExpression): declaredProp.escapedName */, TODO)
				baseProp := getPropertyOfType(baseWithThis /* TODO(PropertyAccessExpression): declaredProp.escapedName */, TODO)
				if prop && baseProp {
					rootChain := /* TODO(ArrowFunction): () =>                         chainDiagnosticMessages(                             /*details* / undefined,                             Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2,                             symbolToString(declaredProp),                             typeToString(typeWithThis),                             typeToString(baseWithThis),                         ) */ TODO
					if !checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp) /* TODO(PropertyAccessExpression): member.name */, TODO || member, nil, rootChain) {
						/* TODO(ExpressionStatement): issuedMemberError = true; */
					}
				}
			}
		}
		if !issuedMemberError {
			checkTypeAssignableTo(typeWithThis, baseWithThis /* TODO(PropertyAccessExpression): node.name */, TODO || node, broadDiag)
		}
	}
	checkBaseTypeAccessibility := func(type_ Type, node ExpressionWithTypeArguments) {
		signatures := getSignaturesOfType(type_ /* TODO(PropertyAccessExpression): SignatureKind.Construct */, TODO)
		if /* TODO(PropertyAccessExpression): signatures.length */ TODO {
			declaration := /* TODO(PropertyAccessExpression): signatures[0].declaration */ TODO
			if declaration && hasEffectiveModifier(declaration /* TODO(PropertyAccessExpression): ModifierFlags.Private */, TODO) {
				typeClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(type.symbol)! */ TODO
				if !isNodeWithinClass(node, typeClassDeclaration) {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private */, TODO, getFullyQualifiedName( /* TODO(PropertyAccessExpression): type.symbol */ TODO))
				}
			}
		}
	}
	getMemberOverrideModifierStatus := func(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
		if ! /* TODO(PropertyAccessExpression): member.name */ TODO {
			return /* TODO(PropertyAccessExpression): MemberOverrideStatus.Ok */ TODO
		}
		classSymbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): ObjectType */
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		memberHasOverrideModifier := /* TODO(ConditionalExpression): member.parent             ? hasOverrideModifier(member)             : hasSyntacticModifier(member, ModifierFlags.Override) */ TODO
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member) /* TODO(FalseKeyword): false */, TODO, memberSymbol)
	}
	getTargetSymbol := func(s Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		return /* TODO(ConditionalExpression): getCheckFlags(s) & CheckFlags.Instantiated ? (s as TransientSymbol).links.target! : s */ TODO
	}
	getClassOrInterfaceDeclarationsOfSymbol := func(symbol Symbol) /* TODO(undefined): (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration)[] | undefined */ TODO {
		return filter( /* TODO(PropertyAccessExpression): symbol.declarations */ TODO /* TODO(ArrowFunction): (d: Declaration): d is ClassDeclaration | InterfaceDeclaration => d.kind === SyntaxKind.ClassDeclaration || d.kind === SyntaxKind.InterfaceDeclaration */, TODO)
	}
	checkKindsOfPropertyMemberOverrides := func(type_ InterfaceType, baseType BaseType) {
		baseProperties := getPropertiesOfType(baseType)
		type MemberInfo struct {
			missedProperties []string
			baseTypeName     string
			typeName         string
		}
		notImplementedInfo := /* TODO(NewExpression): new Map<ClassLikeDeclaration, MemberInfo>() */ TODO
		/* TODO(LabeledStatement): basePropertyCheck: for (const baseProperty of baseProperties) {             const base = getTargetSymbol(baseProperty);              if (base.flags & SymbolFlags.Prototype) {                 continue;             }             const baseSymbol = getPropertyOfObjectType(type, base.escapedName);             if (!baseSymbol) {                 continue;             }             const derived = getTargetSymbol(baseSymbol);             const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);              Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");              // In order to resolve whether the inherited method was overridden in the base class or not,             // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*             // type declaration, derived and base resolve to the same symbol even in the case of generic classes.             if (derived === base) {                 // derived class inherits base without override/redeclaration                 const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!;                  // It is an error to inherit an abstract member without implementing it or being declared abstract.                 // If there is no declaration for the derived class (as in the case of class expressions),                 // then the class cannot be declared abstract.                 if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) {                     // Searches other base types for a declaration that would satisfy the inherited abstract member.                     // (The class may have more than one base type via declaration merging with an interface with the                     // same name.)                     for (const otherBaseType of getBaseTypes(type)) {                         if (otherBaseType === baseType) continue;                         const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escapedName);                         const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol);                         if (derivedElsewhere && derivedElsewhere !== base) {                             continue basePropertyCheck;                         }                     }                     const baseTypeName = typeToString(baseType);                     const typeName = typeToString(type);                     const basePropertyName = symbolToString(baseProperty);                     const missedProperties = append(notImplementedInfo.get(derivedClassDecl)?.missedProperties, basePropertyName);                     notImplementedInfo.set(derivedClassDecl, { baseTypeName, typeName, missedProperties });                 }             }             else {                 // derived overrides base.                 const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);                 if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) {                     // either base or derived property is private - not override, skip it                     continue;                 }                  let errorMessage: DiagnosticMessage;                 const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;                 const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;                 if (basePropertyFlags && derivedPropertyFlags) {                     // property/accessor is overridden with property/accessor                     if (                         (getCheckFlags(base) & CheckFlags.Synthetic                             ? base.declarations?.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))                             : base.declarations?.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)))                         || getCheckFlags(base) & CheckFlags.Mapped                         || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)                     ) {                         // when the base property is abstract or from an interface, base/derived flags don't need to match                         // for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*                         // same when the derived property is from an assignment                         continue;                     }                      const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;                     const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;                     if (overriddenInstanceProperty || overriddenInstanceAccessor) {                         const errorMessage = overriddenInstanceProperty ?                             Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property :                             Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;                         error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type));                     }                     else if (useDefineForClassFields) {                         const uninitialized = derived.declarations?.find(d => d.kind === SyntaxKind.PropertyDeclaration && !(d as PropertyDeclaration).initializer);                         if (                             uninitialized                             && !(derived.flags & SymbolFlags.Transient)                             && !(baseDeclarationFlags & ModifierFlags.Abstract)                             && !(derivedDeclarationFlags & ModifierFlags.Abstract)                             && !derived.declarations?.some(d => !!(d.flags & NodeFlags.Ambient))                         ) {                             const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!);                             const propName = (uninitialized as PropertyDeclaration).name;                             if (                                 (uninitialized as PropertyDeclaration).exclamationToken                                 || !constructor                                 || !isIdentifier(propName)                                 || !strictNullChecks                                 || !isPropertyInitializedInConstructor(propName, type, constructor)                             ) {                                 const errorMessage = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;                                 error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType));                             }                         }                     }                      // correct case                     continue;                 }                 else if (isPrototypeProperty(base)) {                     if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) {                         // method is overridden with method or property -- correct case                         continue;                     }                     else {                         Debug.assert(!!(derived.flags & SymbolFlags.Accessor));                         errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;                     }                 }                 else if (base.flags & SymbolFlags.Accessor) {                     errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                 else {                     errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                  error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));             }         } */
		for _, TODO_IDENTIFIER := range notImplementedInfo {
			if length( /* TODO(PropertyAccessExpression): memberInfo.missedProperties */ TODO) == 1 {
				if isClassExpression(errorNode) {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1 */, TODO, first( /* TODO(PropertyAccessExpression): memberInfo.missedProperties */ TODO) /* TODO(PropertyAccessExpression): memberInfo.baseTypeName */, TODO)
				} else {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2 */, TODO /* TODO(PropertyAccessExpression): memberInfo.typeName */, TODO, first( /* TODO(PropertyAccessExpression): memberInfo.missedProperties */ TODO) /* TODO(PropertyAccessExpression): memberInfo.baseTypeName */, TODO)
				}
			} else if length( /* TODO(PropertyAccessExpression): memberInfo.missedProperties */ TODO) > 5 {
				missedProperties := /* TODO(PropertyAccessExpression): map(memberInfo.missedProperties.slice(0, 4), prop => `'${prop}'`).join */ TODO(", ")
				remainingMissedProperties := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): length(memberInfo.missedProperties) - 4 */ TODO
				if isClassExpression(errorNode) {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more */, TODO /* TODO(PropertyAccessExpression): memberInfo.baseTypeName */, TODO, missedProperties, remainingMissedProperties)
				} else {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more */, TODO /* TODO(PropertyAccessExpression): memberInfo.typeName */, TODO /* TODO(PropertyAccessExpression): memberInfo.baseTypeName */, TODO, missedProperties, remainingMissedProperties)
				}
			} else {
				missedProperties := /* TODO(PropertyAccessExpression): map(memberInfo.missedProperties, prop => `'${prop}'`).join */ TODO(", ")
				if isClassExpression(errorNode) {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1 */, TODO /* TODO(PropertyAccessExpression): memberInfo.baseTypeName */, TODO, missedProperties)
				} else {
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2 */, TODO /* TODO(PropertyAccessExpression): memberInfo.typeName */, TODO /* TODO(PropertyAccessExpression): memberInfo.baseTypeName */, TODO, missedProperties)
				}
			}
		}
	}
	isPropertyAbstractOrInterface := func(declaration Declaration, baseDeclarationFlags ModifierFlags) /* TODO(undefined): boolean */ TODO {
		return /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): baseDeclarationFlags & ModifierFlags.Abstract */ TODO && /* TODO(ParenthesizedExpression): (!isPropertyDeclaration(declaration) || !declaration.initializer) */ TODO || isInterfaceDeclaration( /* TODO(PropertyAccessExpression): declaration.parent */ TODO)
	}
	getNonInheritedProperties := func(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		if !length(baseTypes) {
			return properties
		}
		seen := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
		forEach(properties /* TODO(ArrowFunction): p => {             seen.set(p.escapedName, p);         } */, TODO)
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base /* TODO(PropertyAccessExpression): type.thisType */, TODO))
			for _, prop := range properties {
				existing := /* TODO(PropertyAccessExpression): seen.get */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO)
				if existing && /* TODO(PropertyAccessExpression): prop.parent */ TODO == /* TODO(PropertyAccessExpression): existing.parent */ TODO {
					/* TODO(PropertyAccessExpression): seen.delete */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO)
				}
			}
		}
		return arrayFrom( /* TODO(PropertyAccessExpression): seen.values */ TODO())
	}
	checkInheritedPropertiesAreIdentical := func(type_ InterfaceType, typeNode Node) bool {
		baseTypes := getBaseTypes(type_)
		if /* TODO(PropertyAccessExpression): baseTypes.length */ TODO < 2 {
			return /* TODO(TrueKeyword): true */ TODO
		}
		type InheritanceInfoMap struct {
			prop           Symbol
			containingType Type
		}
		seen := /* TODO(NewExpression): new Map<__String, InheritanceInfoMap>() */ TODO
		forEach( /* TODO(PropertyAccessExpression): resolveDeclaredMembers(type).declaredProperties */ TODO /* TODO(ArrowFunction): p => {             seen.set(p.escapedName, { prop: p, containingType: type });         } */, TODO)
		ok := /* TODO(TrueKeyword): true */ TODO
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base /* TODO(PropertyAccessExpression): type.thisType */, TODO))
			for _, prop := range properties {
				existing := /* TODO(PropertyAccessExpression): seen.get */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO)
				if !existing {
					/* TODO(PropertyAccessExpression): seen.set */ TODO( /* TODO(PropertyAccessExpression): prop.escapedName */ TODO /* TODO(ObjectLiteralExpression): { prop, containingType: base } */, TODO)
				} else {
					isInheritedProperty := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existing.containingType !== type */ TODO
					if isInheritedProperty && !isPropertyIdenticalTo( /* TODO(PropertyAccessExpression): existing.prop */ TODO, prop) {
						/* TODO(ExpressionStatement): ok = false; */
						typeName1 := typeToString( /* TODO(PropertyAccessExpression): existing.containingType */ TODO)
						typeName2 := typeToString(base)
						errorInfo := chainDiagnosticMessages(nil /* TODO(PropertyAccessExpression): Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical */, TODO, symbolToString(prop), typeName1, typeName2)
						/* TODO(ExpressionStatement): errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2); */
						/* TODO(PropertyAccessExpression): diagnostics.add */
						TODO(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo))
					}
				}
			}
		}
		return ok
	}
	checkPropertyInitialization := func(node ClassLikeDeclaration) {
		if !strictNullChecks || !strictPropertyInitialization || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
			return
		}
		constructor := findConstructorDeclaration(node)
		for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getEffectiveModifierFlags(member) & ModifierFlags.Ambient */ TODO {
				/* TODO(ContinueStatement): continue; */
			}
			if !isStatic(member) && isPropertyWithoutInitializer(member) {
				propName := /* TODO(PropertyAccessExpression): (member as PropertyDeclaration).name */ TODO
				if isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName) {
					type_ := getTypeOfSymbol(getSymbolOfDeclaration(member))
					if ! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.AnyOrUnknown || containsUndefinedType(type)) */ TODO {
						if !constructor || !isPropertyInitializedInConstructor(propName, type_, constructor) {
							error( /* TODO(PropertyAccessExpression): member.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor */, TODO, declarationNameToString(propName))
						}
					}
				}
			}
		}
	}
	isPropertyWithoutInitializer := func(node Node) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyDeclaration */ TODO && !hasAbstractModifier(node) && ! /* TODO(PropertyAccessExpression): (node as PropertyDeclaration).exclamationToken */ TODO && ! /* TODO(PropertyAccessExpression): (node as PropertyDeclaration).initializer */ TODO
	}
	isPropertyInitializedInStaticBlocks := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) /* TODO(undefined): boolean */ TODO {
		for _, staticBlock := range staticBlocks {
			if /* TODO(PropertyAccessExpression): staticBlock.pos */ TODO >= startPos && /* TODO(PropertyAccessExpression): staticBlock.pos */ TODO <= endPos {
				reference := /* TODO(PropertyAccessExpression): factory.createPropertyAccessExpression */ TODO( /* TODO(PropertyAccessExpression): factory.createThis */ TODO(), propName)
				setParent( /* TODO(PropertyAccessExpression): reference.expression */ TODO, reference)
				setParent(reference, staticBlock)
				/* TODO(ExpressionStatement): reference.flowNode = staticBlock.returnFlowNode; */
				flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
				if !containsUndefinedType(flowType) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isPropertyInitializedInConstructor := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) /* TODO(undefined): boolean */ TODO {
		reference := /* TODO(ConditionalExpression): isComputedPropertyName(propName)             ? factory.createElementAccessExpression(factory.createThis(), propName.expression)             : factory.createPropertyAccessExpression(factory.createThis(), propName) */ TODO
		setParent( /* TODO(PropertyAccessExpression): reference.expression */ TODO, reference)
		setParent(reference, constructor)
		/* TODO(ExpressionStatement): reference.flowNode = constructor.returnFlowNode; */
		flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
		return !containsUndefinedType(flowType)
	}
	checkInterfaceDeclaration := func(node InterfaceDeclaration) {
		if !checkGrammarModifiers(node) {
			/* TODO(CallExpression): checkGrammarInterfaceDeclaration(node) */
		}
		checkTypeParameters( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO)
		addLazyDiagnostic( /* TODO(ArrowFunction): () => {             checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0);              checkExportsOnMergedDeclarations(node);             const symbol = getSymbolOfDeclaration(node);             checkTypeParameterListsIdentical(symbol);              // Only check this symbol once             const firstInterfaceDecl = getDeclarationOfKind<InterfaceDeclaration>(symbol, SyntaxKind.InterfaceDeclaration);             if (node === firstInterfaceDecl) {                 const type = getDeclaredTypeOfSymbol(symbol) as InterfaceType;                 const typeWithThis = getTypeWithThisArgument(type);                 // run subsequent checks only if first set succeeded                 if (checkInheritedPropertiesAreIdentical(type, node.name)) {                     for (const baseType of getBaseTypes(type)) {                         checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1);                     }                     checkIndexConstraints(type, symbol);                 }             }             checkObjectTypeForDuplicateDeclarations(node);         } */ TODO)
		forEach(getInterfaceBaseTypeNodes(node) /* TODO(ArrowFunction): heritageElement => {             if (!isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression)) {                 error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);             }             checkTypeReferenceNode(heritageElement);         } */, TODO)
		forEach( /* TODO(PropertyAccessExpression): node.members */ TODO, checkSourceElement)
		addLazyDiagnostic( /* TODO(ArrowFunction): () => {             checkTypeForDuplicateIndexSignatures(node);             registerForUnusedIdentifiersCheck(node);         } */ TODO)
	}
	checkTypeAliasDeclaration := func(node TypeAliasDeclaration) {
		checkGrammarModifiers(node)
		checkTypeNameIsReserved( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_alias_name_cannot_be_0 */, TODO)
		checkExportsOnMergedDeclarations(node)
		checkTypeParameters( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO)
		if /* TODO(PropertyAccessExpression): node.type.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.IntrinsicKeyword */ TODO {
			typeParameterCount := length( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO)
			valid := /* TODO(ConditionalExpression): typeParameterCount === 0 ? node.name.escapedText === "BuiltinIteratorReturn" :                 typeParameterCount === 1 && intrinsicTypeKinds.has(node.name.escapedText as string) */ TODO
			if !valid {
				error( /* TODO(PropertyAccessExpression): node.type */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types */, TODO)
			}
		} else {
			checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
			registerForUnusedIdentifiersCheck(node)
		}
	}
	computeEnumMemberValues := func(node EnumDeclaration) {
		nodeLinks := getNodeLinks(node)
		if ! /* TODO(ParenthesizedExpression): (nodeLinks.flags & NodeCheckFlags.EnumValuesComputed) */ TODO {
			/* TODO(ExpressionStatement): nodeLinks.flags |= NodeCheckFlags.EnumValuesComputed; */
			var autoValue /* TODO(NumberKeyword): number */ any = 0
			var previous *EnumMember
			for _, member := range /* TODO(PropertyAccessExpression): node.members */ TODO {
				result := computeEnumMemberValue(member, autoValue, previous)
				/* TODO(ExpressionStatement): getNodeLinks(member).enumMemberValue = result; */
				/* TODO(ExpressionStatement): autoValue = typeof result.value === "number" ? result.value + 1 : undefined; */
				/* TODO(ExpressionStatement): previous = member; */
			}
		}
	}
	computeEnumMemberValue := func(member EnumMember, autoValue /* TODO(NumberKeyword): number */ any, previous *EnumMember) EvaluatorResult {
		if isComputedNonLiteralName( /* TODO(PropertyAccessExpression): member.name */ TODO) {
			error( /* TODO(PropertyAccessExpression): member.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Computed_property_names_are_not_allowed_in_enums */, TODO)
		} else {
			text := getTextOfPropertyName( /* TODO(PropertyAccessExpression): member.name */ TODO)
			if isNumericLiteralName(text) && !isInfinityOrNaNString(text) {
				error( /* TODO(PropertyAccessExpression): member.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_enum_member_cannot_have_a_numeric_name */, TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): member.initializer */ TODO {
			return computeConstantEnumMemberValue(member)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): member.parent.flags & NodeFlags.Ambient */ TODO && !isEnumConst( /* TODO(PropertyAccessExpression): member.parent */ TODO) {
			return evaluatorResult(nil)
		}
		if autoValue == nil {
			error( /* TODO(PropertyAccessExpression): member.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Enum_member_must_have_initializer */, TODO)
			return evaluatorResult(nil)
		}
		if getIsolatedModules(compilerOptions) && /* TODO(PropertyAccessExpression): previous?.initializer */ TODO {
			prevValue := getEnumMemberValue(previous)
			if ! /* TODO(ParenthesizedExpression): (typeof prevValue.value === "number" && !prevValue.resolvedOtherFiles) */ TODO {
				error( /* TODO(PropertyAccessExpression): member.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled */, TODO)
			}
		}
		return evaluatorResult(autoValue)
	}
	computeConstantEnumMemberValue := func(member EnumMember) EvaluatorResult {
		isConstEnum := isEnumConst( /* TODO(PropertyAccessExpression): member.parent */ TODO)
		initializer := /* TODO(NonNullExpression): member.initializer! */ TODO
		result := evaluate(initializer, member)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result.value !== undefined */ TODO {
			if isConstEnum && /* TODO(TypeOfExpression): typeof result.value */ TODO == "number" && !isFinite( /* TODO(PropertyAccessExpression): result.value */ TODO) {
				error(initializer /* TODO(ConditionalExpression): isNaN(result.value) ?                         Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :                         Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value */, TODO)
			} else if getIsolatedModules(compilerOptions) && /* TODO(TypeOfExpression): typeof result.value */ TODO == "string" && ! /* TODO(PropertyAccessExpression): result.isSyntacticallyString */ TODO {
				error(initializer /* TODO(PropertyAccessExpression): Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled */, TODO /* TODO(TemplateExpression): `${idText(member.parent.name)}.${getTextOfPropertyName(member.name)}` */, TODO)
			}
		} else if isConstEnum {
			error(initializer /* TODO(PropertyAccessExpression): Diagnostics.const_enum_member_initializers_must_be_constant_expressions */, TODO)
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): member.parent.flags & NodeFlags.Ambient */ TODO {
			error(initializer /* TODO(PropertyAccessExpression): Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression */, TODO)
		} else {
			checkTypeAssignableTo(checkExpression(initializer), numberType, initializer /* TODO(PropertyAccessExpression): Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values */, TODO)
		}
		return result
	}
	evaluateEntityNameExpression := func(expr EntityNameExpression, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		symbol := resolveEntityName(expr /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO)
		if !symbol {
			/* TODO(CallExpression): evaluatorResult(/*value* / undefined) */
		}
		if /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			identifier := expr
			if isInfinityOrNaNString( /* TODO(PropertyAccessExpression): identifier.escapedText */ TODO) && /* TODO(ParenthesizedExpression): (symbol === getGlobalSymbol(identifier.escapedText, SymbolFlags.Value, /*diagnostic* / undefined)) */ TODO {
				return evaluatorResult(+ /* TODO(ParenthesizedExpression): (identifier.escapedText) */ TODO /* TODO(FalseKeyword): false */, TODO)
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.EnumMember */ TODO {
			return /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, symbol, location) : getEnumMemberValue(symbol.valueDeclaration as EnumMember) */ TODO
		}
		if isConstantVariable(symbol) {
			declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
			if declaration && isVariableDeclaration(declaration) && ! /* TODO(PropertyAccessExpression): declaration.type */ TODO && /* TODO(PropertyAccessExpression): declaration.initializer */ TODO && /* TODO(ParenthesizedExpression): (!location || declaration !== location && isBlockScopedNameDeclaredBeforeUse(declaration, location)) */ TODO {
				result := evaluate( /* TODO(PropertyAccessExpression): declaration.initializer */ TODO, declaration)
				if location && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(location) !== getSourceFileOfNode(declaration) */ TODO {
					return evaluatorResult( /* TODO(PropertyAccessExpression): result.value */ TODO /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO)
				}
				return evaluatorResult( /* TODO(PropertyAccessExpression): result.value */ TODO /* TODO(PropertyAccessExpression): result.isSyntacticallyString */, TODO /* TODO(PropertyAccessExpression): result.resolvedOtherFiles */, TODO /* TODO(TrueKeyword): true */, TODO)
			}
		}
		return evaluatorResult(nil)
	}
	evaluateElementAccessExpression := func(expr ElementAccessExpression, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		root := /* TODO(PropertyAccessExpression): expr.expression */ TODO
		if isEntityNameExpression(root) && isStringLiteralLike( /* TODO(PropertyAccessExpression): expr.argumentExpression */ TODO) {
			rootSymbol := resolveEntityName(root /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO)
			if rootSymbol && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): rootSymbol.flags & SymbolFlags.Enum */ TODO {
				name := escapeLeadingUnderscores( /* TODO(PropertyAccessExpression): expr.argumentExpression.text */ TODO)
				member := /* TODO(PropertyAccessExpression): rootSymbol.exports!.get */ TODO(name)
				if member {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO(getSourceFileOfNode( /* TODO(PropertyAccessExpression): member.valueDeclaration */ TODO) == getSourceFileOfNode( /* TODO(PropertyAccessExpression): rootSymbol.valueDeclaration */ TODO))
					return /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration as EnumMember) */ TODO
				}
			}
		}
		return evaluatorResult(nil)
	}
	evaluateEnumMember := func(expr Expression, symbol Symbol, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		declaration := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
		if !declaration || declaration == location {
			error(expr /* TODO(PropertyAccessExpression): Diagnostics.Property_0_is_used_before_being_assigned */, TODO, symbolToString(symbol))
			return evaluatorResult(nil)
		}
		if !isBlockScopedNameDeclaredBeforeUse(declaration, location) {
			error(expr /* TODO(PropertyAccessExpression): Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums */, TODO)
			return evaluatorResult(0)
		}
		value := getEnumMemberValue(declaration /* as */ /* TODO(TypeReference): EnumMember */)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): location.parent !== declaration.parent */ TODO {
			return evaluatorResult( /* TODO(PropertyAccessExpression): value.value */ TODO /* TODO(PropertyAccessExpression): value.isSyntacticallyString */, TODO /* TODO(PropertyAccessExpression): value.resolvedOtherFiles */, TODO /* TODO(TrueKeyword): true */, TODO)
		}
		return value
	}
	checkEnumDeclaration := func(node EnumDeclaration) {
		addLazyDiagnostic( /* TODO(ArrowFunction): () => checkEnumDeclarationWorker(node) */ TODO)
	}
	checkEnumDeclarationWorker := func(node EnumDeclaration) {
		checkGrammarModifiers(node)
		checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
		checkExportsOnMergedDeclarations(node)
		/* TODO(PropertyAccessExpression): node.members.forEach */ TODO(checkEnumMember)
		computeEnumMemberValues(node)
		enumSymbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(enumSymbol /* TODO(PropertyAccessExpression): node.kind */, TODO)
		if node == firstDeclaration {
			if /* TODO(PropertyAccessExpression): enumSymbol.declarations */ TODO && /* TODO(PropertyAccessExpression): enumSymbol.declarations.length */ TODO > 1 {
				enumIsConst := isEnumConst(node)
				forEach( /* TODO(PropertyAccessExpression): enumSymbol.declarations */ TODO /* TODO(ArrowFunction): decl => {                     if (isEnumDeclaration(decl) && isEnumConst(decl) !== enumIsConst) {                         error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const);                     }                 } */, TODO)
			}
			seenEnumMissingInitialInitializer := /* TODO(FalseKeyword): false */ TODO
			forEach( /* TODO(PropertyAccessExpression): enumSymbol.declarations */ TODO /* TODO(ArrowFunction): declaration => {                 // return true if we hit a violation of the rule, false otherwise                 if (declaration.kind !== SyntaxKind.EnumDeclaration) {                     return false;                 }                  const enumDeclaration = declaration as EnumDeclaration;                 if (!enumDeclaration.members.length) {                     return false;                 }                  const firstEnumMember = enumDeclaration.members[0];                 if (!firstEnumMember.initializer) {                     if (seenEnumMissingInitialInitializer) {                         error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);                     }                     else {                         seenEnumMissingInitialInitializer = true;                     }                 }             } */, TODO)
		}
	}
	checkEnumMember := func(node EnumMember) {
		if isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
			checkExpression( /* TODO(PropertyAccessExpression): node.initializer */ TODO)
		}
	}
	getFirstNonAmbientClassOrFunctionDeclaration := func(symbol Symbol) Declaration {
		declarations := /* TODO(PropertyAccessExpression): symbol.declarations */ TODO
		if declarations {
			for _, declaration := range declarations {
				if /* TODO(ParenthesizedExpression): (declaration.kind === SyntaxKind.ClassDeclaration ||                         (declaration.kind === SyntaxKind.FunctionDeclaration && nodeIsPresent((declaration as FunctionLikeDeclaration).body))) */ TODO && ! /* TODO(ParenthesizedExpression): (declaration.flags & NodeFlags.Ambient) */ TODO {
					return declaration
				}
			}
		}
		return nil
	}
	inSameLexicalScope := func(node1 Node, node2 Node) /* TODO(undefined): boolean */ TODO {
		container1 := getEnclosingBlockScopeContainer(node1)
		container2 := getEnclosingBlockScopeContainer(node2)
		if isGlobalSourceFile(container1) {
			return isGlobalSourceFile(container2)
		} else if isGlobalSourceFile(container2) {
			return /* TODO(FalseKeyword): false */ TODO
		} else {
			return container1 == container2
		}
	}
	checkModuleDeclaration := func(node ModuleDeclaration) {
		if /* TODO(PropertyAccessExpression): node.body */ TODO {
			checkSourceElement( /* TODO(PropertyAccessExpression): node.body */ TODO)
			if !isGlobalScopeAugmentation(node) {
				registerForUnusedIdentifiersCheck(node)
			}
		}
		addLazyDiagnostic(checkModuleDeclarationDiagnostics)
		checkModuleDeclarationDiagnostics := func() {
			isGlobalAugmentation := isGlobalScopeAugmentation(node)
			inAmbientContext := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO
			if isGlobalAugmentation && !inAmbientContext {
				error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context */, TODO)
			}
			var isAmbientExternalModule bool = isAmbientModule(node)
			contextErrorMessage := /* TODO(ConditionalExpression): isAmbientExternalModule                 ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file                 : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module */ TODO
			if checkGrammarModuleElementContext(node, contextErrorMessage) {
				return
			}
			if !checkGrammarModifiers(node) {
				if !inAmbientContext && /* TODO(PropertyAccessExpression): node.name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.StringLiteral */ TODO {
					grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Only_ambient_modules_can_use_quoted_names */, TODO)
				}
			}
			if isIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
				checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
				if ! /* TODO(ParenthesizedExpression): (node.flags & (NodeFlags.Namespace | NodeFlags.GlobalAugmentation)) */ TODO {
					sourceFile := getSourceFileOfNode(node)
					pos := getNonModifierTokenPosOfNode(node)
					span := getSpanOfTokenAtPosition(sourceFile, pos)
					/* TODO(PropertyAccessExpression): suggestionDiagnostics.add */ TODO(createFileDiagnostic(sourceFile /* TODO(PropertyAccessExpression): span.start */, TODO /* TODO(PropertyAccessExpression): span.length */, TODO /* TODO(PropertyAccessExpression): Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead */, TODO))
				}
			}
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ValueModule */ TODO && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions)) {
				if getIsolatedModules(compilerOptions) && ! /* TODO(PropertyAccessExpression): getSourceFileOfNode(node).externalModuleIndicator */ TODO {
					error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement */, TODO, isolatedModulesLikeFlagName)
				}
				if /* TODO(NonNullExpression): symbol.declarations?.length! */ TODO > 1 {
					firstNonAmbientClassOrFunc := getFirstNonAmbientClassOrFunctionDeclaration(symbol)
					if firstNonAmbientClassOrFunc {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(node) !== getSourceFileOfNode(firstNonAmbientClassOrFunc) */ TODO {
							error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged */, TODO)
						} else if /* TODO(PropertyAccessExpression): node.pos */ TODO < /* TODO(PropertyAccessExpression): firstNonAmbientClassOrFunc.pos */ TODO {
							error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged */, TODO)
						}
					}
					mergedClass := getDeclarationOfKind(symbol /* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */, TODO)
					if mergedClass && inSameLexicalScope(node, mergedClass) {
						/* TODO(ExpressionStatement): getNodeLinks(node).flags |= NodeCheckFlags.LexicalModuleMergesWithClass; */
					}
				}
				if /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO( /* TODO(PropertyAccessExpression): node.parent */ TODO) == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO {
					exportModifier := /* TODO(PropertyAccessExpression): node.modifiers?.find */ TODO( /* TODO(ArrowFunction): m => m.kind === SyntaxKind.ExportKeyword */ TODO)
					if exportModifier {
						error(exportModifier /* TODO(PropertyAccessExpression): Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled */, TODO)
					}
				}
			}
			if isAmbientExternalModule {
				if isExternalModuleAugmentation(node) {
					checkBody := isGlobalAugmentation || /* TODO(ParenthesizedExpression): (getSymbolOfDeclaration(node).flags & SymbolFlags.Transient) */ TODO
					if checkBody && /* TODO(PropertyAccessExpression): node.body */ TODO {
						for _, statement := range /* TODO(PropertyAccessExpression): node.body.statements */ TODO {
							checkModuleAugmentationElement(statement, isGlobalAugmentation)
						}
					}
				} else if isGlobalSourceFile( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
					if isGlobalAugmentation {
						error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations */, TODO)
					} else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral( /* TODO(PropertyAccessExpression): node.name */ TODO)) {
						error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name */, TODO)
					}
				} else {
					if isGlobalAugmentation {
						error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations */, TODO)
					} else {
						error( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces */, TODO)
					}
				}
			}
		}
	}
	checkModuleAugmentationElement := func(node Node, isGlobalAugmentation bool) {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.VariableStatement:                 // error each individual name in variable statement instead of marking the entire variable statement                 for (const decl of (node as VariableStatement).declarationList.declarations) {                     checkModuleAugmentationElement(decl, isGlobalAugmentation);                 }                 break;             case SyntaxKind.ExportAssignment:             case SyntaxKind.ExportDeclaration:                 grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);                 break;             case SyntaxKind.ImportEqualsDeclaration:                 // import a = e.x; in module augmentation is ok, but not import a = require('fs)                 if (isInternalModuleImportEqualsDeclaration(node)) break;                 // falls through             case SyntaxKind.ImportDeclaration:                 grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);                 break;             case SyntaxKind.BindingElement:             case SyntaxKind.VariableDeclaration:                 const name = (node as VariableDeclaration | BindingElement).name;                 if (isBindingPattern(name)) {                     for (const el of name.elements) {                         // mark individual names in binding pattern                         checkModuleAugmentationElement(el, isGlobalAugmentation);                     }                     break;                 }                 // falls through             case SyntaxKind.ClassDeclaration:             case SyntaxKind.EnumDeclaration:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.InterfaceDeclaration:             case SyntaxKind.ModuleDeclaration:             case SyntaxKind.TypeAliasDeclaration:                 if (isGlobalAugmentation) {                     return;                 }                 break;         } */
	}
	getFirstNonModuleExportsIdentifier := func(node EntityNameOrEntityNameExpression) Identifier {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 return node;             case SyntaxKind.QualifiedName:                 do {                     node = node.left;                 }                 while (node.kind !== SyntaxKind.Identifier);                 return node;             case SyntaxKind.PropertyAccessExpression:                 do {                     if (isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name)) {                         return node.name;                     }                     node = node.expression;                 }                 while (node.kind !== SyntaxKind.Identifier);                 return node;         } */
	}
	checkExternalImportOrExportDeclaration := func(node /* TODO(UnionType): ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
		moduleName := getExternalModuleName(node)
		if !moduleName || nodeIsMissing(moduleName) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if !isStringLiteral(moduleName) {
			error(moduleName /* TODO(PropertyAccessExpression): Diagnostics.String_literal_expected */, TODO)
			return /* TODO(FalseKeyword): false */ TODO
		}
		inAmbientExternalModule := /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleBlock */ TODO && isAmbientModule( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile */ TODO && !inAmbientExternalModule {
			error(moduleName /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportDeclaration ?                     Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :                     Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module */, TODO)
			return /* TODO(FalseKeyword): false */ TODO
		}
		if inAmbientExternalModule && isExternalModuleNameRelative( /* TODO(PropertyAccessExpression): moduleName.text */ TODO) {
			if !isTopLevelInExternalModuleAugmentation(node) {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name */, TODO)
				return /* TODO(FalseKeyword): false */ TODO
			}
		}
		if !isImportEqualsDeclaration(node) && /* TODO(PropertyAccessExpression): node.attributes */ TODO {
			diagnostic := /* TODO(ConditionalExpression): node.attributes.token === SyntaxKind.WithKeyword ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions */ TODO
			hasError := /* TODO(FalseKeyword): false */ TODO
			for _, attr := range /* TODO(PropertyAccessExpression): node.attributes.elements */ TODO {
				if !isStringLiteral( /* TODO(PropertyAccessExpression): attr.value */ TODO) {
					/* TODO(ExpressionStatement): hasError = true; */
					error( /* TODO(PropertyAccessExpression): attr.value */ TODO, diagnostic)
				}
			}
			return !hasError
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	checkModuleExportName := func(name *ModuleExportName, allowStringLiteral /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) {
		if name == nil || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name.kind !== SyntaxKind.StringLiteral */ TODO {
			return
		}
		if !allowStringLiteral {
			grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.Identifier_expected */, TODO)
		} else if moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO || moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.ES2020 */ TODO {
			grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020 */, TODO)
		}
	}
	checkAliasSymbol := func(node AliasDeclarationNode) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== unknownSymbol */ TODO {
			/* TODO(ExpressionStatement): symbol = getMergedSymbol(symbol.exportSymbol || symbol); */
			if isInJSFile(node) && ! /* TODO(ParenthesizedExpression): (target.flags & SymbolFlags.Value) */ TODO && !isTypeOnlyImportOrExportDeclaration(node) {
				errorNode := /* TODO(ConditionalExpression): isImportOrExportSpecifier(node) ? node.propertyName || node.name :                     isNamedDeclaration(node) ? node.name :                     node */ TODO
				/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.NamespaceExport */ TODO)
				if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportSpecifier */ TODO {
					diag := error(errorNode /* TODO(PropertyAccessExpression): Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files */, TODO)
					alreadyExportedSymbol := /* TODO(PropertyAccessExpression): getSourceFileOfNode(node).symbol?.exports?.get */ TODO(moduleExportNameTextEscaped( /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO))
					if alreadyExportedSymbol == target {
						exportingDeclaration := /* TODO(PropertyAccessExpression): alreadyExportedSymbol.declarations?.find */ TODO(isJSDocNode)
						if exportingDeclaration {
							addRelatedInfo(diag, createDiagnosticForNode(exportingDeclaration /* TODO(PropertyAccessExpression): Diagnostics._0_is_automatically_exported_here */, TODO, unescapeLeadingUnderscores( /* TODO(PropertyAccessExpression): alreadyExportedSymbol.escapedName */ TODO)))
						}
					}
				} else {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.VariableDeclaration */ TODO)
					importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
					moduleSpecifier := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
					importedIdentifier := unescapeLeadingUnderscores( /* TODO(ConditionalExpression): isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName */ TODO)
					error(errorNode /* TODO(PropertyAccessExpression): Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation */, TODO, importedIdentifier /* TODO(TemplateExpression): `import("${moduleSpecifier}").${importedIdentifier}` */, TODO)
				}
				return
			}
			targetFlags := getSymbolFlags(target)
			excludedMeanings := /* TODO(BarToken): | */ /* TODO(BinaryExpression): (symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0) |                 (symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0) |                 (symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0) */ TODO
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & excludedMeanings */ TODO {
				message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportSpecifier ?                     Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :                     Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0 */ TODO
				error(node, message, symbolToString(symbol))
			} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ExportSpecifier */ TODO {
				appearsValueyToTranspiler := /* TODO(PropertyAccessExpression): compilerOptions.isolatedModules */ TODO && !findAncestor(node, isTypeOnlyImportOrExportDeclaration)
				if appearsValueyToTranspiler && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled */, TODO, symbolToString(symbol), isolatedModulesLikeFlagName)
				}
			}
			if getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO {
				typeOnlyAlias := getTypeOnlyAliasDeclaration(symbol)
				isType := ! /* TODO(ParenthesizedExpression): (targetFlags & SymbolFlags.Value) */ TODO
				if isType || typeOnlyAlias {
					/* TODO(SwitchStatement): switch (node.kind) {                         case SyntaxKind.ImportClause:                         case SyntaxKind.ImportSpecifier:                         case SyntaxKind.ImportEqualsDeclaration: {                             if (compilerOptions.verbatimModuleSyntax) {                                 Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");                                 const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node)                                     ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled                                     : isType                                     ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled;                                 const name = moduleExportNameTextUnescaped(node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name);                                 addTypeOnlyDeclarationRelatedInfo(                                     error(node, message, name),                                     isType ? undefined : typeOnlyAlias,                                     name,                                 );                             }                             if (isType && node.kind === SyntaxKind.ImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlags.Export)) {                                 error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);                             }                             break;                         }                         case SyntaxKind.ExportSpecifier: {                             // Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.                             // The exception is that `import type { A } from './a'; export { A }` is allowed                             // because single-file analysis can determine that the export should be dropped.                             if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {                                 const name = moduleExportNameTextUnescaped(node.propertyName || node.name);                                 const diagnostic = isType                                     ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)                                     : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);                                 addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? undefined : typeOnlyAlias, name);                                 break;                             }                         }                     } */
				}
				if /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ImportEqualsDeclaration */ TODO && !isInJSFile(node) && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled */, TODO)
				} else if moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.Preserve */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ImportEqualsDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.VariableDeclaration */ TODO && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve */, TODO)
				}
				if /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && !isTypeOnlyImportOrExportDeclaration(node) && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & SymbolFlags.ConstEnum */ TODO {
					constEnumDeclaration := /* TODO(PropertyAccessExpression): target.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): EnumDeclaration */
					redirect := /* TODO(PropertyAccessExpression): host.getRedirectReferenceForResolutionFromSourceOfProject */ TODO( /* TODO(PropertyAccessExpression): getSourceFileOfNode(constEnumDeclaration).resolvedPath */ TODO)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): constEnumDeclaration.flags & NodeFlags.Ambient */ TODO && /* TODO(ParenthesizedExpression): (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) */ TODO {
						error(node /* TODO(PropertyAccessExpression): Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled */, TODO, isolatedModulesLikeFlagName)
					}
				}
			}
			if isImportSpecifier(node) {
				targetSymbol := resolveAliasWithDeprecationCheck(symbol, node)
				if isDeprecatedSymbol(targetSymbol) && /* TODO(PropertyAccessExpression): targetSymbol.declarations */ TODO {
					addDeprecatedSuggestion(node /* TODO(PropertyAccessExpression): targetSymbol.declarations */, TODO /* TODO(PropertyAccessExpression): targetSymbol.escapedName */, TODO /* as */ /* TODO(StringKeyword): string */)
				}
			}
		}
	}
	resolveAliasWithDeprecationCheck := func(symbol Symbol, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		if ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Alias) */ TODO || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol) {
			return symbol
		}
		targetSymbol := resolveAlias(symbol)
		if targetSymbol == unknownSymbol {
			/* TODO(Identifier): targetSymbol */
		}
		/* TODO(WhileStatement): while (symbol.flags & SymbolFlags.Alias) {             const target = getImmediateAliasedSymbol(symbol);             if (target) {                 if (target === targetSymbol) break;                 if (target.declarations && length(target.declarations)) {                     if (isDeprecatedSymbol(target)) {                         addDeprecatedSuggestion(location, target.declarations, target.escapedName as string);                         break;                     }                     else {                         if (symbol === targetSymbol) break;                         symbol = target;                     }                 }             }             else {                 break;             }         } */
		return targetSymbol
	}
	checkImportBinding := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
		checkCollisionsForDeclarationName(node /* TODO(PropertyAccessExpression): node.name */, TODO)
		checkAliasSymbol(node)
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportSpecifier */ TODO {
			checkModuleExportName( /* TODO(PropertyAccessExpression): node.propertyName */ TODO)
			if moduleExportNameIsDefault( /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO) && getESModuleInterop(compilerOptions) && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) < /* TODO(PropertyAccessExpression): ModuleKind.System */ TODO {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ImportDefault */, TODO)
			}
		}
	}
	checkImportAttributes := func(declaration /* TODO(UnionType): ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) /* TODO(undefined): boolean | undefined */ TODO {
		node := /* TODO(PropertyAccessExpression): declaration.attributes */ TODO
		if node {
			importAttributesType := getGlobalImportAttributesType( /* TODO(TrueKeyword): true */ TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): importAttributesType !== emptyObjectType */ TODO {
				checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType /* TODO(PropertyAccessExpression): TypeFlags.Undefined */, TODO), node)
			}
			validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
			override := getResolutionModeOverride(node /* TODO(ConditionalExpression): validForTypeAttributes ? grammarErrorOnNode : undefined */, TODO)
			isImportAttributes := /* TODO(PropertyAccessExpression): declaration.attributes.token */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.WithKeyword */ TODO
			if validForTypeAttributes && override {
				return
			}
			mode := /* TODO(ParenthesizedExpression): (moduleKind === ModuleKind.NodeNext) */ TODO && /* TODO(PropertyAccessExpression): declaration.moduleSpecifier */ TODO && getEmitSyntaxForModuleSpecifierExpression( /* TODO(PropertyAccessExpression): declaration.moduleSpecifier */ TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): mode !== ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Preserve */ TODO {
				message := /* TODO(ConditionalExpression): isImportAttributes                     ? moduleKind === ModuleKind.NodeNext                         ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                         : Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve                     : moduleKind === ModuleKind.NodeNext                     ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                     : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve */ TODO
				return grammarErrorOnNode(node, message)
			}
			isTypeOnly := isJSDocImportTag(declaration) || /* TODO(ParenthesizedExpression): (isImportDeclaration(declaration) ? declaration.importClause?.isTypeOnly : declaration.isTypeOnly) */ TODO
			if isTypeOnly {
				return grammarErrorOnNode(node /* TODO(ConditionalExpression): isImportAttributes ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports */, TODO)
			}
			if override {
				return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports */, TODO)
			}
		}
	}
	checkImportAttribute := func(node ImportAttribute) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getRegularTypeOfLiteralType(checkExpressionCached( /* TODO(PropertyAccessExpression): node.value */ TODO))
	}
	checkImportDeclaration := func(node ImportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && /* TODO(PropertyAccessExpression): node.modifiers */ TODO {
			grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.An_import_declaration_cannot_have_modifiers */, TODO)
		}
		if checkExternalImportOrExportDeclaration(node) {
			importClause := /* TODO(PropertyAccessExpression): node.importClause */ TODO
			if importClause && !checkGrammarImportClause(importClause) {
				if /* TODO(PropertyAccessExpression): importClause.name */ TODO {
					checkImportBinding(importClause)
				}
				if /* TODO(PropertyAccessExpression): importClause.namedBindings */ TODO {
					if /* TODO(PropertyAccessExpression): importClause.namedBindings.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceImport */ TODO {
						checkImportBinding( /* TODO(PropertyAccessExpression): importClause.namedBindings */ TODO)
						if /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) < /* TODO(PropertyAccessExpression): ModuleKind.System */ TODO && getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ImportStar */, TODO)
						}
					} else {
						moduleExisted := resolveExternalModuleName(node /* TODO(PropertyAccessExpression): node.moduleSpecifier */, TODO)
						if moduleExisted {
							forEach( /* TODO(PropertyAccessExpression): importClause.namedBindings.elements */ TODO, checkImportBinding)
						}
					}
				}
			} else if noUncheckedSideEffectImports && !importClause {
				/* TODO(ExpressionStatement): void resolveExternalModuleName(node, node.moduleSpecifier); */
			}
		}
		checkImportAttributes(node)
	}
	checkImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		checkGrammarModifiers(node)
		if isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node) {
			checkImportBinding(node)
			markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.ExportImportEquals */, TODO)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.moduleReference.kind !== SyntaxKind.ExternalModuleReference */ TODO {
				target := resolveAlias(getSymbolOfDeclaration(node))
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== unknownSymbol */ TODO {
					targetFlags := getSymbolFlags(target)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & SymbolFlags.Value */ TODO {
						moduleName := getFirstIdentifier( /* TODO(PropertyAccessExpression): node.moduleReference */ TODO)
						if ! /* TODO(ParenthesizedExpression): (resolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace)!.flags & SymbolFlags.Namespace) */ TODO {
							error(moduleName /* TODO(PropertyAccessExpression): Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name */, TODO, declarationNameToString(moduleName))
						}
					}
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): targetFlags & SymbolFlags.Type */ TODO {
						checkTypeNameIsReserved( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Import_name_cannot_be_0 */, TODO)
					}
				}
				if /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO {
					grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.An_import_alias_cannot_use_import_type */, TODO)
				}
			} else {
				if /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO <= moduleKind && moduleKind <= /* TODO(PropertyAccessExpression): ModuleKind.ESNext */ TODO && ! /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO {
					grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead */, TODO)
				}
			}
		}
	}
	checkExportDeclaration := func(node ExportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && hasSyntacticModifiers(node) {
			grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.An_export_declaration_cannot_have_modifiers */, TODO)
		}
		checkGrammarExportDeclaration(node)
		if ! /* TODO(PropertyAccessExpression): node.moduleSpecifier */ TODO || checkExternalImportOrExportDeclaration(node) {
			if /* TODO(PropertyAccessExpression): node.exportClause */ TODO && !isNamespaceExport( /* TODO(PropertyAccessExpression): node.exportClause */ TODO) {
				forEach( /* TODO(PropertyAccessExpression): node.exportClause.elements */ TODO, checkExportSpecifier)
				inAmbientExternalModule := /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleBlock */ TODO && isAmbientModule( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
				inAmbientNamespaceDeclaration := !inAmbientExternalModule && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleBlock */ TODO && ! /* TODO(PropertyAccessExpression): node.moduleSpecifier */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile */ TODO && !inAmbientExternalModule && !inAmbientNamespaceDeclaration {
					error(node /* TODO(PropertyAccessExpression): Diagnostics.Export_declarations_are_not_permitted_in_a_namespace */, TODO)
				}
			} else {
				moduleSymbol := resolveExternalModuleName(node /* TODO(NonNullExpression): node.moduleSpecifier! */, TODO)
				if moduleSymbol && hasExportAssignmentSymbol(moduleSymbol) {
					error( /* TODO(PropertyAccessExpression): node.moduleSpecifier */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk */, TODO, symbolToString(moduleSymbol))
				} else if /* TODO(PropertyAccessExpression): node.exportClause */ TODO {
					checkAliasSymbol( /* TODO(PropertyAccessExpression): node.exportClause */ TODO)
					checkModuleExportName( /* TODO(PropertyAccessExpression): node.exportClause.name */ TODO)
				}
				if /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) < /* TODO(PropertyAccessExpression): ModuleKind.System */ TODO {
					if /* TODO(PropertyAccessExpression): node.exportClause */ TODO {
						if getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ImportStar */, TODO)
						}
					} else {
						checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ExportStar */, TODO)
					}
				}
			}
		}
		checkImportAttributes(node)
	}
	checkGrammarExportDeclaration := func(node ExportDeclaration) bool {
		if /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO && /* TODO(PropertyAccessExpression): node.exportClause?.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamedExports */ TODO {
			return checkGrammarNamedImportsOrExports( /* TODO(PropertyAccessExpression): node.exportClause */ TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarModuleElementContext := func(node Statement, errorMessage DiagnosticMessage) bool {
		isInAppropriateContext := /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO || /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleBlock */ TODO || /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleDeclaration */ TODO
		if !isInAppropriateContext {
			grammarErrorOnFirstToken(node, errorMessage)
		}
		return !isInAppropriateContext
	}
	checkExportSpecifier := func(node ExportSpecifier) {
		checkAliasSymbol(node)
		hasModuleSpecifier := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.moduleSpecifier !== undefined */ TODO
		checkModuleExportName( /* TODO(PropertyAccessExpression): node.propertyName */ TODO, hasModuleSpecifier)
		checkModuleExportName( /* TODO(PropertyAccessExpression): node.name */ TODO)
		if getEmitDeclarations(compilerOptions) {
			collectLinkedAliases( /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(TrueKeyword): true */, TODO)
		}
		if !hasModuleSpecifier {
			exportedName := /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO
			if /* TODO(PropertyAccessExpression): exportedName.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.StringLiteral */ TODO {
				return
			}
			symbol := resolveName(exportedName /* TODO(PropertyAccessExpression): exportedName.escapedText */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */, TODO, nil /* TODO(TrueKeyword): true */, TODO)
			if symbol && /* TODO(ParenthesizedExpression): (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) */ TODO {
				error(exportedName /* TODO(PropertyAccessExpression): Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module */, TODO, idText(exportedName))
			} else {
				markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.ExportSpecifier */, TODO)
			}
		} else {
			if getESModuleInterop(compilerOptions) && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) < /* TODO(PropertyAccessExpression): ModuleKind.System */ TODO && moduleExportNameIsDefault( /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO) {
				checkExternalEmitHelpers(node /* TODO(PropertyAccessExpression): ExternalEmitHelpers.ImportDefault */, TODO)
			}
		}
	}
	checkExportAssignment := func(node ExportAssignment) {
		illegalContextMessage := /* TODO(ConditionalExpression): node.isExportEquals             ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration             : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration */ TODO
		if checkGrammarModuleElementContext(node, illegalContextMessage) {
			return
		}
		container := /* TODO(ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent as ModuleDeclaration */ TODO
		if /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleDeclaration */ TODO && !isAmbientModule(container) {
			if /* TODO(PropertyAccessExpression): node.isExportEquals */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace */, TODO)
			} else {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module */, TODO)
			}
			return
		}
		if !checkGrammarModifiers(node) && hasEffectiveModifiers(node) {
			grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.An_export_assignment_cannot_have_modifiers */, TODO)
		}
		typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
		if typeAnnotationNode {
			checkTypeAssignableTo(checkExpressionCached( /* TODO(PropertyAccessExpression): node.expression */ TODO), getTypeFromTypeNode(typeAnnotationNode) /* TODO(PropertyAccessExpression): node.expression */, TODO)
		}
		isIllegalExportDefaultInCJS := ! /* TODO(PropertyAccessExpression): node.isExportEquals */ TODO && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO
		if /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			id := /* TODO(PropertyAccessExpression): node.expression */ TODO /* as */ /* TODO(TypeReference): Identifier */
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id /* TODO(PropertyAccessExpression): SymbolFlags.All */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, node))
			if sym {
				markLinkedReferences(node /* TODO(PropertyAccessExpression): ReferenceHint.ExportAssignment */, TODO)
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(sym /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO)
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getSymbolFlags(sym) & SymbolFlags.Value */ TODO {
					checkExpressionCached(id)
					if !isIllegalExportDefaultInCJS && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && typeOnlyDeclaration {
						error(id /* TODO(ConditionalExpression): node.isExportEquals                                 ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration                                 : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration */, TODO, idText(id))
					}
				} else if !isIllegalExportDefaultInCJS && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO {
					error(id /* TODO(ConditionalExpression): node.isExportEquals                             ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type                             : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type */, TODO, idText(id))
				}
				if !isIllegalExportDefaultInCJS && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && getIsolatedModules(compilerOptions) && ! /* TODO(ParenthesizedExpression): (sym.flags & SymbolFlags.Value) */ TODO {
					nonLocalMeanings := getSymbolFlags(sym /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sym.flags & SymbolFlags.Alias */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nonLocalMeanings & SymbolFlags.Type */ TODO && ! /* TODO(ParenthesizedExpression): (nonLocalMeanings & SymbolFlags.Value) */ TODO && /* TODO(ParenthesizedExpression): (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node)) */ TODO {
						error(id /* TODO(ConditionalExpression): node.isExportEquals ?                                 Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                 : Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName)
					} else if typeOnlyDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node) */ TODO {
						addTypeOnlyDeclarationRelatedInfo(error(id /* TODO(ConditionalExpression): node.isExportEquals ?                                     Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName), typeOnlyDeclaration, idText(id))
					}
				}
			} else {
				checkExpressionCached(id)
			}
			if getEmitDeclarations(compilerOptions) {
				collectLinkedAliases(id /* TODO(TrueKeyword): true */, TODO)
			}
		} else {
			checkExpressionCached( /* TODO(PropertyAccessExpression): node.expression */ TODO)
		}
		if isIllegalExportDefaultInCJS {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled */, TODO)
		}
		checkExternalModuleExports(container)
		if /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && !isEntityNameExpression( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.isExportEquals */ TODO {
			if moduleKind >= /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Preserve */ TODO && /* TODO(ParenthesizedExpression): ((node.flags & NodeFlags.Ambient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) === ModuleKind.ESNext) ||                     (!(node.flags & NodeFlags.Ambient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) !== ModuleKind.CommonJS)) */ TODO {
				grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead */, TODO)
			} else if moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.System */ TODO && ! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO {
				grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system */, TODO)
			}
		}
	}
	hasExportedMembers := func(moduleSymbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		return forEachEntry( /* TODO(NonNullExpression): moduleSymbol.exports! */ TODO /* TODO(ArrowFunction): (_, id) => id !== "export=" */, TODO)
	}
	checkExternalModuleExports := func(node /* TODO(UnionType): SourceFile | ModuleDeclaration */ any) {
		moduleSymbol := getSymbolOfDeclaration(node)
		links := getSymbolLinks(moduleSymbol)
		if ! /* TODO(PropertyAccessExpression): links.exportsChecked */ TODO {
			exportEqualsSymbol := /* TODO(PropertyAccessExpression): moduleSymbol.exports!.get */ TODO("export=" /* as */ /* TODO(TypeReference): __String */)
			if exportEqualsSymbol && hasExportedMembers(moduleSymbol) {
				declaration := getDeclarationOfAliasSymbol(exportEqualsSymbol) || /* TODO(PropertyAccessExpression): exportEqualsSymbol.valueDeclaration */ TODO
				if declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) {
					error(declaration /* TODO(PropertyAccessExpression): Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements */, TODO)
				}
			}
			exports := getExportsOfModule(moduleSymbol)
			if exports {
				/* TODO(PropertyAccessExpression): exports.forEach */ TODO( /* TODO(ArrowFunction): ({ declarations, flags }, id) => {                     if (id === "__export") {                         return;                     }                     // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.                     // (TS Exceptions: namespaces, function overloads, enums, and interfaces)                     if (flags & (SymbolFlags.Namespace | SymbolFlags.Enum)) {                         return;                     }                     const exportedDeclarationsCount = countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)));                     if (flags & SymbolFlags.TypeAlias && exportedDeclarationsCount <= 2) {                         // it is legal to merge type alias with other values                         // so count should be either 1 (just type alias) or 2 (type alias + merged value)                         return;                     }                     if (exportedDeclarationsCount > 1) {                         if (!isDuplicatedCommonJSExport(declarations)) {                             for (const declaration of declarations!) {                                 if (isNotOverload(declaration)) {                                     diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)));                                 }                             }                         }                     }                 } */ TODO)
			}
			/* TODO(ExpressionStatement): links.exportsChecked = true; */
		}
	}
	isDuplicatedCommonJSExport := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO(undefined): boolean | undefined */ TODO {
		return declarations && /* TODO(PropertyAccessExpression): declarations.length */ TODO > 1 && /* TODO(PropertyAccessExpression): declarations.every */ TODO( /* TODO(ArrowFunction): d => isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression)) */ TODO)
	}
	checkSourceElement := func(node Node) {
		if node {
			saveCurrentNode := currentNode
			/* TODO(ExpressionStatement): currentNode = node; */
			/* TODO(ExpressionStatement): instantiationCount = 0; */
			checkSourceElementWorker(node)
			/* TODO(ExpressionStatement): currentNode = saveCurrentNode; */
		}
	}
	checkSourceElementWorker := func(node Node) {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getNodeCheckFlags(node) & NodeCheckFlags.PartiallyTypeChecked */ TODO {
			return
		}
		if canHaveJSDoc(node) {
			forEach( /* TODO(PropertyAccessExpression): node.jsDoc */ TODO /* TODO(ArrowFunction): ({ comment, tags }) => {                 checkJSDocCommentWorker(comment);                 forEach(tags, tag => {                     checkJSDocCommentWorker(tag.comment);                     if (isInJSFile(node)) {                         checkSourceElement(tag);                     }                 });             } */, TODO)
		}
		kind := /* TODO(PropertyAccessExpression): node.kind */ TODO
		if cancellationToken {
			/* TODO(SwitchStatement): switch (kind) {                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.FunctionDeclaration:                     cancellationToken.throwIfCancellationRequested();             } */
		}
		if kind >= /* TODO(PropertyAccessExpression): SyntaxKind.FirstStatement */ TODO && kind <= /* TODO(PropertyAccessExpression): SyntaxKind.LastStatement */ TODO && canHaveFlowNode(node) && /* TODO(PropertyAccessExpression): node.flowNode */ TODO && !isReachableFlowNode( /* TODO(PropertyAccessExpression): node.flowNode */ TODO) {
			errorOrSuggestion( /* TODO(PropertyAccessExpression): compilerOptions.allowUnreachableCode */ TODO == /* TODO(FalseKeyword): false */ TODO, node /* TODO(PropertyAccessExpression): Diagnostics.Unreachable_code_detected */, TODO)
		}
		/* TODO(SwitchStatement): switch (kind) {             case SyntaxKind.TypeParameter:                 return checkTypeParameter(node as TypeParameterDeclaration);             case SyntaxKind.Parameter:                 return checkParameter(node as ParameterDeclaration);             case SyntaxKind.PropertyDeclaration:                 return checkPropertyDeclaration(node as PropertyDeclaration);             case SyntaxKind.PropertySignature:                 return checkPropertySignature(node as PropertySignature);             case SyntaxKind.ConstructorType:             case SyntaxKind.FunctionType:             case SyntaxKind.CallSignature:             case SyntaxKind.ConstructSignature:             case SyntaxKind.IndexSignature:                 return checkSignatureDeclaration(node as SignatureDeclaration);             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 return checkMethodDeclaration(node as MethodDeclaration | MethodSignature);             case SyntaxKind.ClassStaticBlockDeclaration:                 return checkClassStaticBlockDeclaration(node as ClassStaticBlockDeclaration);             case SyntaxKind.Constructor:                 return checkConstructorDeclaration(node as ConstructorDeclaration);             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return checkAccessorDeclaration(node as AccessorDeclaration);             case SyntaxKind.TypeReference:                 return checkTypeReferenceNode(node as TypeReferenceNode);             case SyntaxKind.TypePredicate:                 return checkTypePredicate(node as TypePredicateNode);             case SyntaxKind.TypeQuery:                 return checkTypeQuery(node as TypeQueryNode);             case SyntaxKind.TypeLiteral:                 return checkTypeLiteral(node as TypeLiteralNode);             case SyntaxKind.ArrayType:                 return checkArrayType(node as ArrayTypeNode);             case SyntaxKind.TupleType:                 return checkTupleType(node as TupleTypeNode);             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:                 return checkUnionOrIntersectionType(node as UnionOrIntersectionTypeNode);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.OptionalType:             case SyntaxKind.RestType:                 return checkSourceElement((node as ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode).type);             case SyntaxKind.ThisType:                 return checkThisType(node as ThisTypeNode);             case SyntaxKind.TypeOperator:                 return checkTypeOperator(node as TypeOperatorNode);             case SyntaxKind.ConditionalType:                 return checkConditionalType(node as ConditionalTypeNode);             case SyntaxKind.InferType:                 return checkInferType(node as InferTypeNode);             case SyntaxKind.TemplateLiteralType:                 return checkTemplateLiteralType(node as TemplateLiteralTypeNode);             case SyntaxKind.ImportType:                 return checkImportType(node as ImportTypeNode);             case SyntaxKind.NamedTupleMember:                 return checkNamedTupleMember(node as NamedTupleMember);             case SyntaxKind.JSDocAugmentsTag:                 return checkJSDocAugmentsTag(node as JSDocAugmentsTag);             case SyntaxKind.JSDocImplementsTag:                 return checkJSDocImplementsTag(node as JSDocImplementsTag);             case SyntaxKind.JSDocTypedefTag:             case SyntaxKind.JSDocCallbackTag:             case SyntaxKind.JSDocEnumTag:                 return checkJSDocTypeAliasTag(node as JSDocTypedefTag);             case SyntaxKind.JSDocTemplateTag:                 return checkJSDocTemplateTag(node as JSDocTemplateTag);             case SyntaxKind.JSDocTypeTag:                 return checkJSDocTypeTag(node as JSDocTypeTag);             case SyntaxKind.JSDocLink:             case SyntaxKind.JSDocLinkCode:             case SyntaxKind.JSDocLinkPlain:                 return checkJSDocLinkLikeTag(node as JSDocLink | JSDocLinkCode | JSDocLinkPlain);             case SyntaxKind.JSDocParameterTag:                 return checkJSDocParameterTag(node as JSDocParameterTag);             case SyntaxKind.JSDocPropertyTag:                 return checkJSDocPropertyTag(node as JSDocPropertyTag);             case SyntaxKind.JSDocFunctionType:                 checkJSDocFunctionType(node as JSDocFunctionType);                 // falls through             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocNullableType:             case SyntaxKind.JSDocAllType:             case SyntaxKind.JSDocUnknownType:             case SyntaxKind.JSDocTypeLiteral:                 checkJSDocTypeIsInJsFile(node);                 forEachChild(node, checkSourceElement);                 return;             case SyntaxKind.JSDocVariadicType:                 checkJSDocVariadicType(node as JSDocVariadicType);                 return;             case SyntaxKind.JSDocTypeExpression:                 return checkSourceElement((node as JSDocTypeExpression).type);             case SyntaxKind.JSDocPublicTag:             case SyntaxKind.JSDocProtectedTag:             case SyntaxKind.JSDocPrivateTag:                 return checkJSDocAccessibilityModifiers(node as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag);             case SyntaxKind.JSDocSatisfiesTag:                 return checkJSDocSatisfiesTag(node as JSDocSatisfiesTag);             case SyntaxKind.JSDocThisTag:                 return checkJSDocThisTag(node as JSDocThisTag);             case SyntaxKind.JSDocImportTag:                 return checkJSDocImportTag(node as JSDocImportTag);             case SyntaxKind.IndexedAccessType:                 return checkIndexedAccessType(node as IndexedAccessTypeNode);             case SyntaxKind.MappedType:                 return checkMappedType(node as MappedTypeNode);             case SyntaxKind.FunctionDeclaration:                 return checkFunctionDeclaration(node as FunctionDeclaration);             case SyntaxKind.Block:             case SyntaxKind.ModuleBlock:                 return checkBlock(node as Block);             case SyntaxKind.VariableStatement:                 return checkVariableStatement(node as VariableStatement);             case SyntaxKind.ExpressionStatement:                 return checkExpressionStatement(node as ExpressionStatement);             case SyntaxKind.IfStatement:                 return checkIfStatement(node as IfStatement);             case SyntaxKind.DoStatement:                 return checkDoStatement(node as DoStatement);             case SyntaxKind.WhileStatement:                 return checkWhileStatement(node as WhileStatement);             case SyntaxKind.ForStatement:                 return checkForStatement(node as ForStatement);             case SyntaxKind.ForInStatement:                 return checkForInStatement(node as ForInStatement);             case SyntaxKind.ForOfStatement:                 return checkForOfStatement(node as ForOfStatement);             case SyntaxKind.ContinueStatement:             case SyntaxKind.BreakStatement:                 return checkBreakOrContinueStatement(node as BreakOrContinueStatement);             case SyntaxKind.ReturnStatement:                 return checkReturnStatement(node as ReturnStatement);             case SyntaxKind.WithStatement:                 return checkWithStatement(node as WithStatement);             case SyntaxKind.SwitchStatement:                 return checkSwitchStatement(node as SwitchStatement);             case SyntaxKind.LabeledStatement:                 return checkLabeledStatement(node as LabeledStatement);             case SyntaxKind.ThrowStatement:                 return checkThrowStatement(node as ThrowStatement);             case SyntaxKind.TryStatement:                 return checkTryStatement(node as TryStatement);             case SyntaxKind.VariableDeclaration:                 return checkVariableDeclaration(node as VariableDeclaration);             case SyntaxKind.BindingElement:                 return checkBindingElement(node as BindingElement);             case SyntaxKind.ClassDeclaration:                 return checkClassDeclaration(node as ClassDeclaration);             case SyntaxKind.InterfaceDeclaration:                 return checkInterfaceDeclaration(node as InterfaceDeclaration);             case SyntaxKind.TypeAliasDeclaration:                 return checkTypeAliasDeclaration(node as TypeAliasDeclaration);             case SyntaxKind.EnumDeclaration:                 return checkEnumDeclaration(node as EnumDeclaration);             case SyntaxKind.ModuleDeclaration:                 return checkModuleDeclaration(node as ModuleDeclaration);             case SyntaxKind.ImportDeclaration:                 return checkImportDeclaration(node as ImportDeclaration);             case SyntaxKind.ImportEqualsDeclaration:                 return checkImportEqualsDeclaration(node as ImportEqualsDeclaration);             case SyntaxKind.ExportDeclaration:                 return checkExportDeclaration(node as ExportDeclaration);             case SyntaxKind.ExportAssignment:                 return checkExportAssignment(node as ExportAssignment);             case SyntaxKind.EmptyStatement:             case SyntaxKind.DebuggerStatement:                 checkGrammarStatementInAmbientContext(node);                 return;             case SyntaxKind.MissingDeclaration:                 return checkMissingDeclaration(node);         } */
	}
	checkJSDocCommentWorker := func(node /* TODO(UnionType): string | readonly JSDocComment[] | undefined */ any) {
		if isArray(node) {
			forEach(node /* TODO(ArrowFunction): tag => {                 if (isJSDocLinkLike(tag)) {                     checkSourceElement(tag);                 }             } */, TODO)
		}
	}
	checkJSDocTypeIsInJsFile := func(node Node) {
		if !isInJSFile(node) {
			if isJSDocNonNullableType(node) || isJSDocNullableType(node) {
				token := tokenToString( /* TODO(ConditionalExpression): isJSDocNonNullableType(node) ? SyntaxKind.ExclamationToken : SyntaxKind.QuestionToken */ TODO)
				diagnostic := /* TODO(ConditionalExpression): node.postfix                     ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1                     : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 */ TODO
				typeNode := /* TODO(PropertyAccessExpression): node.type */ TODO
				type_ := getTypeFromTypeNode(typeNode)
				grammarErrorOnNode(node, diagnostic, token, typeToString( /* TODO(ConditionalExpression): isJSDocNullableType(node) && !(type === neverType || type === voidType)                             ? getUnionType(append([type, undefinedType], node.postfix ? undefined : nullType)) : type */ TODO))
			} else {
				grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments */, TODO)
			}
		}
	}
	checkJSDocVariadicType := func(node JSDocVariadicType) {
		checkJSDocTypeIsInJsFile(node)
		checkSourceElement( /* TODO(PropertyAccessExpression): node.type */ TODO)
		TODO_IDENTIFIER := node
		if isParameter(parent) && isJSDocFunctionType( /* TODO(PropertyAccessExpression): parent.parent */ TODO) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): last(parent.parent.parameters) !== parent */ TODO {
				error(node /* TODO(PropertyAccessExpression): Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list */, TODO)
			}
			return
		}
		if !isJSDocTypeExpression(parent) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature */, TODO)
		}
		paramTag := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
		if !isJSDocParameterTag(paramTag) {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature */, TODO)
			return
		}
		param := getParameterSymbolFromJSDoc(paramTag)
		if !param {
			return
		}
		host := getHostSignatureFromJSDoc(paramTag)
		if !host || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): last(host.parameters).symbol !== param */ TODO {
			error(node /* TODO(PropertyAccessExpression): Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list */, TODO)
		}
	}
	getTypeFromJSDocVariadicType := func(node JSDocVariadicType) Type {
		type_ := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): node.type */ TODO)
		TODO_IDENTIFIER := node
		paramTag := /* TODO(PropertyAccessExpression): node.parent.parent */ TODO
		if isJSDocTypeExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) && isJSDocParameterTag(paramTag) {
			host := getHostSignatureFromJSDoc(paramTag)
			isCallbackTag := isJSDocCallbackTag( /* TODO(PropertyAccessExpression): paramTag.parent.parent */ TODO)
			if host || isCallbackTag {
				lastParamDeclaration := /* TODO(ConditionalExpression): isCallbackTag                     ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters)                     : lastOrUndefined(host!.parameters) */ TODO
				symbol := getParameterSymbolFromJSDoc(paramTag)
				if !lastParamDeclaration || symbol && /* TODO(PropertyAccessExpression): lastParamDeclaration.symbol */ TODO == symbol && isRestParameter(lastParamDeclaration) {
					return createArrayType(type_)
				}
			}
		}
		if isParameter(parent) && isJSDocFunctionType( /* TODO(PropertyAccessExpression): parent.parent */ TODO) {
			return createArrayType(type_)
		}
		return addOptionality(type_)
	}
	checkNodeDeferred := func(node Node) {
		enclosingFile := getSourceFileOfNode(node)
		links := getNodeLinks(enclosingFile)
		if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.TypeChecked) */ TODO {
			/* TODO(ExpressionStatement): links.deferredNodes ||= new Set(); */
			/* TODO(PropertyAccessExpression): links.deferredNodes.add */
			TODO(node)
		} else {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(! /* TODO(PropertyAccessExpression): links.deferredNodes */ TODO, "A type-checked file should have no deferred nodes.")
		}
	}
	checkDeferredNodes := func(context SourceFile) {
		links := getNodeLinks(context)
		if /* TODO(PropertyAccessExpression): links.deferredNodes */ TODO {
			/* TODO(PropertyAccessExpression): links.deferredNodes.forEach */ TODO(checkDeferredNode)
		}
		/* TODO(ExpressionStatement): links.deferredNodes = undefined; */
	}
	checkDeferredNode := func(node Node) {
		/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.Check */ TODO, "checkDeferredNode" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		/* TODO(ExpressionStatement): currentNode = node; */
		/* TODO(ExpressionStatement): instantiationCount = 0; */
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:             case SyntaxKind.NewExpression:             case SyntaxKind.TaggedTemplateExpression:             case SyntaxKind.Decorator:             case SyntaxKind.JsxOpeningElement:                 // These node kinds are deferred checked when overload resolution fails                 // To save on work, we ensure the arguments are checked just once, in                 // a deferred way                 resolveUntypedCall(node as CallLikeExpression);                 break;             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 checkFunctionExpressionOrObjectLiteralMethodDeferred(node as FunctionExpression);                 break;             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 checkAccessorDeclaration(node as AccessorDeclaration);                 break;             case SyntaxKind.ClassExpression:                 checkClassExpressionDeferred(node as ClassExpression);                 break;             case SyntaxKind.TypeParameter:                 checkTypeParameterDeferred(node as TypeParameterDeclaration);                 break;             case SyntaxKind.JsxSelfClosingElement:                 checkJsxSelfClosingElementDeferred(node as JsxSelfClosingElement);                 break;             case SyntaxKind.JsxElement:                 checkJsxElementDeferred(node as JsxElement);                 break;             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:             case SyntaxKind.ParenthesizedExpression:                 checkAssertionDeferred(node as AssertionExpression | JSDocTypeAssertion);                 break;             case SyntaxKind.VoidExpression:                 checkExpression((node as VoidExpression).expression);                 break;             case SyntaxKind.BinaryExpression:                 if (isInstanceOfExpression(node)) {                     resolveUntypedCall(node);                 }                 break;         } */
		/* TODO(ExpressionStatement): currentNode = saveCurrentNode; */
		/* TODO(PropertyAccessExpression): tracing?.pop */
		TODO()
	}
	checkSourceFile := func(node SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) {
		/* TODO(PropertyAccessExpression): tracing?.push */ TODO( /* TODO(PropertyAccessExpression): tracing.Phase.Check */ TODO /* TODO(ConditionalExpression): nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile" */, TODO /* TODO(ObjectLiteralExpression): { path: node.path } */, TODO /* TODO(TrueKeyword): true */, TODO)
		beforeMark := /* TODO(ConditionalExpression): nodesToCheck ? "beforeCheckNodes" : "beforeCheck" */ TODO
		afterMark := /* TODO(ConditionalExpression): nodesToCheck ? "afterCheckNodes" : "afterCheck" */ TODO
		/* TODO(PropertyAccessExpression): performance.mark */ TODO(beforeMark)
		/* TODO(ExpressionStatement): nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node); */
		/* TODO(PropertyAccessExpression): performance.mark */
		TODO(afterMark)
		/* TODO(PropertyAccessExpression): performance.measure */ TODO("Check", beforeMark, afterMark)
		/* TODO(PropertyAccessExpression): tracing?.pop */ TODO()
	}
	unusedIsError := func(kind UnusedKind, isAmbient bool) bool {
		if isAmbient {
			return /* TODO(FalseKeyword): false */ TODO
		}
		/* TODO(SwitchStatement): switch (kind) {             case UnusedKind.Local:                 return !!compilerOptions.noUnusedLocals;             case UnusedKind.Parameter:                 return !!compilerOptions.noUnusedParameters;             default:                 return Debug.assertNever(kind);         } */
	}
	getPotentiallyUnusedIdentifiers := func(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
		return /* TODO(PropertyAccessExpression): allPotentiallyUnusedIdentifiers.get */ TODO( /* TODO(PropertyAccessExpression): sourceFile.path */ TODO) || emptyArray
	}
	checkSourceFileWorker := func(node SourceFile) {
		links := getNodeLinks(node)
		if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.TypeChecked) */ TODO {
			if skipTypeChecking(node, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(node)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.flags & NodeCheckFlags.PartiallyTypeChecked */ TODO {
				/* TODO(ExpressionStatement): potentialThisCollisions = links.potentialThisCollisions!; */
				/* TODO(ExpressionStatement): potentialNewTargetCollisions = links.potentialNewTargetCollisions!; */
				/* TODO(ExpressionStatement): potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions!; */
				/* TODO(ExpressionStatement): potentialReflectCollisions = links.potentialReflectCollisions!; */
				/* TODO(ExpressionStatement): potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes!; */
			}
			forEach( /* TODO(PropertyAccessExpression): node.statements */ TODO, checkSourceElement)
			checkSourceElement( /* TODO(PropertyAccessExpression): node.endOfFileToken */ TODO)
			checkDeferredNodes(node)
			if isExternalOrCommonJsModule(node) {
				registerForUnusedIdentifiersCheck(node)
			}
			addLazyDiagnostic( /* TODO(ArrowFunction): () => {                 // This relies on the results of other lazy diagnostics, so must be computed after them                 if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {                     checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), (containingNode, kind, diag) => {                         if (!containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                             diagnostics.add(diag);                         }                     });                 }                 if (!node.isDeclarationFile) {                     checkPotentialUncheckedRenamedBindingElementsInTypes();                 }             } */ TODO)
			if isExternalOrCommonJsModule(node) {
				checkExternalModuleExports(node)
			}
			if /* TODO(PropertyAccessExpression): potentialThisCollisions.length */ TODO {
				forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope)
				clear(potentialThisCollisions)
			}
			if /* TODO(PropertyAccessExpression): potentialNewTargetCollisions.length */ TODO {
				forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope)
				clear(potentialNewTargetCollisions)
			}
			if /* TODO(PropertyAccessExpression): potentialWeakMapSetCollisions.length */ TODO {
				forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision)
				clear(potentialWeakMapSetCollisions)
			}
			if /* TODO(PropertyAccessExpression): potentialReflectCollisions.length */ TODO {
				forEach(potentialReflectCollisions, checkReflectCollision)
				clear(potentialReflectCollisions)
			}
			/* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.TypeChecked; */
		}
	}
	checkSourceFileNodesWorker := func(file SourceFile, nodes []Node) {
		links := getNodeLinks(file)
		if ! /* TODO(ParenthesizedExpression): (links.flags & NodeCheckFlags.TypeChecked) */ TODO {
			if skipTypeChecking(file, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(file)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			forEach(nodes, checkSourceElement)
			checkDeferredNodes(file)
			/* TODO(PropertyAccessExpression): (links.potentialThisCollisions || (links.potentialThisCollisions = [])).push */ TODO( /* TODO(SpreadElement): ...potentialThisCollisions */ TODO)
			/* TODO(PropertyAccessExpression): (links.potentialNewTargetCollisions || (links.potentialNewTargetCollisions = [])).push */ TODO( /* TODO(SpreadElement): ...potentialNewTargetCollisions */ TODO)
			/* TODO(PropertyAccessExpression): (links.potentialWeakMapSetCollisions || (links.potentialWeakMapSetCollisions = [])).push */ TODO( /* TODO(SpreadElement): ...potentialWeakMapSetCollisions */ TODO)
			/* TODO(PropertyAccessExpression): (links.potentialReflectCollisions || (links.potentialReflectCollisions = [])).push */ TODO( /* TODO(SpreadElement): ...potentialReflectCollisions */ TODO)
			/* TODO(PropertyAccessExpression): (links.potentialUnusedRenamedBindingElementsInTypes || (links.potentialUnusedRenamedBindingElementsInTypes = [])).push */ TODO( /* TODO(SpreadElement): ...potentialUnusedRenamedBindingElementsInTypes */ TODO)
			/* TODO(ExpressionStatement): links.flags |= NodeCheckFlags.PartiallyTypeChecked; */
			for _, node := range nodes {
				nodeLinks := getNodeLinks(node)
				/* TODO(ExpressionStatement): nodeLinks.flags |= NodeCheckFlags.PartiallyTypeChecked; */
			}
		}
	}
	getDiagnostics := func(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
		/* TODO(TryStatement): try {             // Record the cancellation token so it can be checked later on during checkSourceElement.             // Do this in a finally block so we can ensure that it gets reset back to nothing after             // this call is done.             cancellationToken = ct;             return getDiagnosticsWorker(sourceFile, nodesToCheck);         }         finally {             cancellationToken = undefined;         } */
	}
	ensurePendingDiagnosticWorkComplete := func() {
		for _, cb := range deferredDiagnosticsCallbacks {
			cb()
		}
		/* TODO(ExpressionStatement): deferredDiagnosticsCallbacks = []; */
	}
	checkSourceFileWithEagerDiagnostics := func(sourceFile SourceFile, nodesToCheck []Node) {
		ensurePendingDiagnosticWorkComplete()
		oldAddLazyDiagnostics := addLazyDiagnostic
		/* TODO(ExpressionStatement): addLazyDiagnostic = cb => cb(); */
		checkSourceFile(sourceFile, nodesToCheck)
		/* TODO(ExpressionStatement): addLazyDiagnostic = oldAddLazyDiagnostics; */
	}
	getDiagnosticsWorker := func(sourceFile SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) []Diagnostic {
		if sourceFile {
			ensurePendingDiagnosticWorkComplete()
			previousGlobalDiagnostics := /* TODO(PropertyAccessExpression): diagnostics.getGlobalDiagnostics */ TODO()
			previousGlobalDiagnosticsSize := /* TODO(PropertyAccessExpression): previousGlobalDiagnostics.length */ TODO
			checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck)
			semanticDiagnostics := /* TODO(PropertyAccessExpression): diagnostics.getDiagnostics */ TODO( /* TODO(PropertyAccessExpression): sourceFile.fileName */ TODO)
			if nodesToCheck {
				return semanticDiagnostics
			}
			currentGlobalDiagnostics := /* TODO(PropertyAccessExpression): diagnostics.getGlobalDiagnostics */ TODO()
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): currentGlobalDiagnostics !== previousGlobalDiagnostics */ TODO {
				deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
				return concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
			} else if previousGlobalDiagnosticsSize == 0 && /* TODO(PropertyAccessExpression): currentGlobalDiagnostics.length */ TODO > 0 {
				return concatenate(currentGlobalDiagnostics, semanticDiagnostics)
			}
			return semanticDiagnostics
		}
		forEach( /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO() /* TODO(ArrowFunction): file => checkSourceFileWithEagerDiagnostics(file) */, TODO)
		return /* TODO(PropertyAccessExpression): diagnostics.getDiagnostics */ TODO()
	}
	getGlobalDiagnostics := func() []Diagnostic {
		ensurePendingDiagnosticWorkComplete()
		return /* TODO(PropertyAccessExpression): diagnostics.getGlobalDiagnostics */ TODO()
	}
	getSymbolsInScope := func(location Node, meaning SymbolFlags) []Symbol {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): location.flags & NodeFlags.InWithStatement */ TODO {
			return /* TODO(ArrayLiteralExpression): [] */ TODO
		}
		symbols := createSymbolTable()
		isStaticSymbol := /* TODO(FalseKeyword): false */ TODO
		populateSymbols()
		/* TODO(PropertyAccessExpression): symbols.delete */ TODO( /* TODO(PropertyAccessExpression): InternalSymbolName.This */ TODO)
		return symbolsToArray(symbols)
		populateSymbols := func() {
			/* TODO(WhileStatement): while (location) {                 if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                     copySymbols(location.locals, meaning);                 }                  switch (location.kind) {                     case SyntaxKind.SourceFile:                         if (!isExternalModule(location as SourceFile)) break;                         // falls through                     case SyntaxKind.ModuleDeclaration:                         copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location as ModuleDeclaration | SourceFile).exports!, meaning & SymbolFlags.ModuleMember);                         break;                     case SyntaxKind.EnumDeclaration:                         copySymbols(getSymbolOfDeclaration(location as EnumDeclaration).exports!, meaning & SymbolFlags.EnumMember);                         break;                     case SyntaxKind.ClassExpression:                         const className = (location as ClassExpression).name;                         if (className) {                             copySymbol((location as ClassExpression).symbol, meaning);                         }                      // this fall-through is necessary because we would like to handle                     // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.                     // falls through                     case SyntaxKind.ClassDeclaration:                     case SyntaxKind.InterfaceDeclaration:                         // If we didn't come from static member of class or interface,                         // add the type parameters into the symbol table                         // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.                         // Note: that the memberFlags come from previous iteration.                         if (!isStaticSymbol) {                             copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location as ClassDeclaration | InterfaceDeclaration)), meaning & SymbolFlags.Type);                         }                         break;                     case SyntaxKind.FunctionExpression:                         const funcName = (location as FunctionExpression).name;                         if (funcName) {                             copySymbol((location as FunctionExpression).symbol, meaning);                         }                         break;                 }                  if (introducesArgumentsExoticObject(location)) {                     copySymbol(argumentsSymbol, meaning);                 }                  isStaticSymbol = isStatic(location);                 location = location.parent;             } */
			copySymbols(globals, meaning)
		}
		copySymbol := func(symbol Symbol, meaning SymbolFlags) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCombinedLocalAndExportSymbolFlags(symbol) & meaning */ TODO {
				id := /* TODO(PropertyAccessExpression): symbol.escapedName */ TODO
				if ! /* TODO(PropertyAccessExpression): symbols.has */ TODO(id) {
					/* TODO(PropertyAccessExpression): symbols.set */ TODO(id, symbol)
				}
			}
		}
		copySymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				/* TODO(PropertyAccessExpression): source.forEach */ TODO( /* TODO(ArrowFunction): symbol => {                     copySymbol(symbol, meaning);                 } */ TODO)
			}
		}
		copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				/* TODO(PropertyAccessExpression): source.forEach */ TODO( /* TODO(ArrowFunction): symbol => {                     // Similar condition as in `resolveNameHelper`                     if (!getDeclarationOfKind(symbol, SyntaxKind.ExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKind.NamespaceExport) && symbol.escapedName !== InternalSymbolName.Default) {                         copySymbol(symbol, meaning);                     }                 } */ TODO)
			}
		}
	}
	isTypeDeclarationName := func(name Node) bool {
		return /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO && isTypeDeclaration( /* TODO(PropertyAccessExpression): name.parent */ TODO) && getNameOfDeclaration( /* TODO(PropertyAccessExpression): name.parent */ TODO) == name
	}
	isTypeReferenceIdentifier := func(node EntityName) bool {
		/* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.QualifiedName) {             node = node.parent as QualifiedName;         } */
		return /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeReference */ TODO
	}
	isInNameOfExpressionWithTypeArguments := func(node Node) bool {
		/* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.PropertyAccessExpression) {             node = node.parent;         } */
		return /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExpressionWithTypeArguments */ TODO
	}
	forEachEnclosingClass := func(node Node, callback func(node ClassLikeDeclaration) *T) *T {
		var result *T
		containingClass := getContainingClass(node)
		/* TODO(WhileStatement): while (containingClass) {             if (result = callback(containingClass)) break;             containingClass = getContainingClass(containingClass);         } */
		return result
	}
	isNodeUsedDuringClassInitialization := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !!findAncestor(node /* TODO(ArrowFunction): element => {             if (isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element)) {                 return true;             }             else if (isClassLike(element) || isFunctionLikeDeclaration(element)) {                 return "quit";             }              return false;         } */, TODO)
	}
	isNodeWithinClass := func(node Node, classDeclaration ClassLikeDeclaration) /* TODO(undefined): boolean */ TODO {
		return !!forEachEnclosingClass(node /* TODO(ArrowFunction): n => n === classDeclaration */, TODO)
	}
	getLeftSideOfImportEqualsOrExportAssignment := func(nodeOnRightSide EntityName) /* TODO(UnionType): ImportEqualsDeclaration | ExportAssignment | undefined */ any {
		/* TODO(WhileStatement): while (nodeOnRightSide.parent.kind === SyntaxKind.QualifiedName) {             nodeOnRightSide = nodeOnRightSide.parent as QualifiedName;         } */
		if /* TODO(PropertyAccessExpression): nodeOnRightSide.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */ TODO {
			return /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ImportEqualsDeclaration).moduleReference === nodeOnRightSide ? nodeOnRightSide.parent as ImportEqualsDeclaration : undefined */ TODO
		}
		if /* TODO(PropertyAccessExpression): nodeOnRightSide.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO {
			return /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ExportAssignment).expression === nodeOnRightSide as Node ? nodeOnRightSide.parent as ExportAssignment : undefined */ TODO
		}
		return nil
	}
	isInRightSideOfImportOrExportAssignment := func(node EntityName) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined */ TODO
	}
	getSpecialPropertyAssignmentSymbolFromEntityName := func(entityName /* TODO(UnionType): EntityName | PropertyAccessExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		specialPropertyAssignmentKind := getAssignmentDeclarationKind( /* TODO(PropertyAccessExpression): entityName.parent.parent */ TODO /* as */ /* TODO(TypeReference): BinaryExpression */)
		/* TODO(SwitchStatement): switch (specialPropertyAssignmentKind) {             case AssignmentDeclarationKind.ExportsProperty:             case AssignmentDeclarationKind.PrototypeProperty:                 return getSymbolOfNode(entityName.parent);             case AssignmentDeclarationKind.Property:                 if (isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) === entityName) {                     return undefined;                 }                 // falls through             case AssignmentDeclarationKind.ThisProperty:             case AssignmentDeclarationKind.ModuleExports:                 return getSymbolOfDeclaration(entityName.parent.parent as BinaryExpression);         } */
	}
	isImportTypeQualifierPart := func(node EntityName) *ImportTypeNode {
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		/* TODO(WhileStatement): while (isQualifiedName(parent)) {             node = parent;             parent = parent.parent;         } */
		if parent && /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportType */ TODO && /* TODO(PropertyAccessExpression): (parent as ImportTypeNode).qualifier */ TODO == node {
			return parent /* as */ /* TODO(TypeReference): ImportTypeNode */
		}
		return nil
	}
	isThisPropertyAndThisTyped := func(node PropertyAccessExpression) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): node.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ThisKeyword */ TODO {
			container := getThisContainer(node /* TODO(FalseKeyword): false */, TODO /* TODO(FalseKeyword): false */, TODO)
			if isFunctionLike(container) {
				containingLiteral := getContainingObjectLiteral(container)
				if containingLiteral {
					contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
					type_ := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
					return type_ && !isTypeAny(type_)
				}
			}
		}
	}
	getSymbolOfNameOrPropertyAccessExpression := func(name /* TODO(UnionType): EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) *Symbol {
		if isDeclarationName(name) {
			return getSymbolOfNode( /* TODO(PropertyAccessExpression): name.parent */ TODO)
		}
		if isInJSFile(name) && /* TODO(PropertyAccessExpression): name.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO && /* TODO(PropertyAccessExpression): name.parent */ TODO == /* TODO(PropertyAccessExpression): (name.parent.parent as BinaryExpression).left */ TODO {
			if !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped( /* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(TypeReference): PropertyAccessExpression */) {
				specialPropertyAssignmentSymbol := getSpecialPropertyAssignmentSymbolFromEntityName(name)
				if specialPropertyAssignmentSymbol {
					return specialPropertyAssignmentSymbol
				}
			}
		}
		if /* TODO(PropertyAccessExpression): name.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO && isEntityNameExpression(name) {
			success := resolveEntityName(name /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */, TODO /* TODO(TrueKeyword): true */, TODO)
			if success && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): success !== unknownSymbol */ TODO {
				return success
			}
		} else if isEntityName(name) && isInRightSideOfImportOrExportAssignment(name) {
			importEqualsDeclaration := getAncestor(name /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */, TODO)
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): importEqualsDeclaration !== undefined */ TODO)
			return getSymbolOfPartOfRightHandSideOfImportEquals(name /* TODO(TrueKeyword): true */, TODO)
		}
		if isEntityName(name) {
			possibleImportNode := isImportTypeQualifierPart(name)
			if possibleImportNode {
				getTypeFromTypeNode(possibleImportNode)
				sym := /* TODO(PropertyAccessExpression): getNodeLinks(name).resolvedSymbol */ TODO
				return /* TODO(ConditionalExpression): sym === unknownSymbol ? undefined : sym */ TODO
			}
		}
		/* TODO(WhileStatement): while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {             name = name.parent as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName;         } */
		if isInNameOfExpressionWithTypeArguments(name) {
			meaning := /* TODO(PropertyAccessExpression): SymbolFlags.None */ TODO
			if /* TODO(PropertyAccessExpression): name.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExpressionWithTypeArguments */ TODO {
				/* TODO(ExpressionStatement): meaning = isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value; */
				if isExpressionWithTypeArgumentsInClassExtendsClause( /* TODO(PropertyAccessExpression): name.parent */ TODO) {
					/* TODO(ExpressionStatement): meaning |= SymbolFlags.Value; */
				}
			} else {
				/* TODO(ExpressionStatement): meaning = SymbolFlags.Namespace; */
			}
			/* TODO(ExpressionStatement): meaning |= SymbolFlags.Alias; */
			entityNameSymbol := /* TODO(ConditionalExpression): isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors* / true) : undefined */ TODO
			if entityNameSymbol {
				return entityNameSymbol
			}
		}
		if /* TODO(PropertyAccessExpression): name.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocParameterTag */ TODO {
			return getParameterSymbolFromJSDoc( /* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(TypeReference): JSDocParameterTag */)
		}
		if /* TODO(PropertyAccessExpression): name.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeParameter */ TODO && /* TODO(PropertyAccessExpression): name.parent.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JSDocTemplateTag */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(!isInJSFile(name))
			typeParameter := getTypeParameterFromJsDoc( /* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(IntersectionType): TypeParameterDeclaration & { parent: JSDocTemplateTag; } */)
			return typeParameter && /* TODO(PropertyAccessExpression): typeParameter.symbol */ TODO
		}
		if isExpressionNode(name) {
			if nodeIsMissing(name) {
				return nil
			}
			isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
			meaning := /* TODO(ConditionalExpression): isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value */ TODO
			if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
				if isJSXTagName(name) && isJsxIntrinsicTagName(name) {
					symbol := getIntrinsicTagSymbol( /* TODO(PropertyAccessExpression): name.parent */ TODO /* as */ /* TODO(TypeReference): JsxOpeningLikeElement */)
					return /* TODO(ConditionalExpression): symbol === unknownSymbol ? undefined : symbol */ TODO
				}
				result := resolveEntityName(name, meaning /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, getHostSignatureFromJSDoc(name))
				if !result && isJSDoc {
					container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
					if container {
						return resolveJSDocMemberName(name /* TODO(TrueKeyword): true */, TODO, getSymbolOfDeclaration(container))
					}
				}
				if result && isJSDoc {
					container := getJSDocHost(name)
					if container && isEnumMember(container) && container == /* TODO(PropertyAccessExpression): result.valueDeclaration */ TODO {
						return resolveEntityName(name, meaning /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, getSourceFileOfNode(container)) || result
					}
				}
				return result
			} else if isPrivateIdentifier(name) {
				return getSymbolForPrivateIdentifierExpression(name)
			} else if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO || /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.QualifiedName */ TODO {
				links := getNodeLinks(name)
				if /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO {
					return /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
				}
				if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAccessExpression */ TODO {
					checkPropertyAccessExpression(name /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO)
					if ! /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO {
						/* TODO(ExpressionStatement): links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name)); */
					}
				} else {
					checkQualifiedName(name /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO)
				}
				if ! /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO && isJSDoc && isQualifiedName(name) {
					return resolveJSDocMemberName(name)
				}
				return /* TODO(PropertyAccessExpression): links.resolvedSymbol */ TODO
			} else if isJSDocMemberName(name) {
				return resolveJSDocMemberName(name)
			}
		} else if isTypeReferenceIdentifier(name /* as */ /* TODO(TypeReference): EntityName */) {
			meaning := /* TODO(ConditionalExpression): name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO
			symbol := resolveEntityName(name /* as */ /* TODO(TypeReference): EntityName */, meaning /* TODO(FalseKeyword): false */, TODO /* TODO(TrueKeyword): true */, TODO)
			return /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name as EntityName) */ TODO
		}
		if /* TODO(PropertyAccessExpression): name.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypePredicate */ TODO {
			return resolveEntityName(name /* as */ /* TODO(TypeReference): Identifier */ /* TODO(PropertyAccessExpression): SymbolFlags.FunctionScopedVariable */, TODO)
		}
		return nil
	}
	getApplicableIndexSymbol := func(type_ Type, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		infos := getApplicableIndexInfos(type_, keyType)
		if /* TODO(PropertyAccessExpression): infos.length */ TODO && /* TODO(PropertyAccessExpression): (type as ObjectType).members */ TODO {
			symbol := getIndexSymbolFromSymbolTable( /* TODO(PropertyAccessExpression): resolveStructuredTypeMembers(type as ObjectType).members */ TODO)
			if infos == getIndexInfosOfType(type_) {
				return symbol
			} else if symbol {
				symbolLinks := getSymbolLinks(symbol)
				declarationList := mapDefined(infos /* TODO(ArrowFunction): i => i.declaration */, TODO)
				nodeListId := /* TODO(PropertyAccessExpression): map(declarationList, getNodeId).join */ TODO(",")
				if ! /* TODO(PropertyAccessExpression): symbolLinks.filteredIndexSymbolCache */ TODO {
					/* TODO(ExpressionStatement): symbolLinks.filteredIndexSymbolCache = new Map(); */
				}
				if /* TODO(PropertyAccessExpression): symbolLinks.filteredIndexSymbolCache.has */ TODO(nodeListId) {
					return /* TODO(NonNullExpression): symbolLinks.filteredIndexSymbolCache.get(nodeListId)! */ TODO
				} else {
					copy := createSymbol( /* TODO(PropertyAccessExpression): SymbolFlags.Signature */ TODO /* TODO(PropertyAccessExpression): InternalSymbolName.Index */, TODO)
					/* TODO(ExpressionStatement): copy.declarations = mapDefined(infos, i => i.declaration); */
					/* TODO(ExpressionStatement): copy.parent = type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent); */
					/* TODO(PropertyAccessExpression): symbolLinks.filteredIndexSymbolCache.set */
					TODO(nodeListId, copy)
					return copy
				}
			}
		}
	}
	resolveJSDocMemberName := func(name /* TODO(UnionType): EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) *Symbol {
		if isEntityName(name) {
			meaning := /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value */ TODO
			symbol := resolveEntityName(name, meaning, ignoreErrors /* TODO(TrueKeyword): true */, TODO, getHostSignatureFromJSDoc(name))
			if !symbol && isIdentifier(name) && container {
				/* TODO(ExpressionStatement): symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning)); */
			}
			if symbol {
				return symbol
			}
		}
		left := /* TODO(ConditionalExpression): isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container) */ TODO
		right := /* TODO(ConditionalExpression): isIdentifier(name) ? name.escapedText : name.right.escapedText */ TODO
		if left {
			proto := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): left.flags & SymbolFlags.Value */ TODO && getPropertyOfType(getTypeOfSymbol(left), "prototype" /* as */ /* TODO(TypeReference): __String */)
			t := /* TODO(ConditionalExpression): proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left) */ TODO
			return getPropertyOfType(t, right)
		}
	}
	getSymbolAtLocation := func(node Node, ignoreErrors bool) *Symbol {
		if isSourceFile(node) {
			return /* TODO(ConditionalExpression): isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined */ TODO
		}
		TODO_IDENTIFIER := node
		grandParent := /* TODO(PropertyAccessExpression): parent.parent */ TODO
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
			return nil
		}
		if isDeclarationNameOrImportPropertyName(node) {
			parentSymbol := getSymbolOfDeclaration(parent /* as */ /* TODO(TypeReference): Declaration */)
			return /* TODO(ConditionalExpression): isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node                 ? getImmediateAliasedSymbol(parentSymbol)                 : parentSymbol */ TODO
		} else if isLiteralComputedPropertyDeclarationName(node) {
			return getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): parent.parent */ TODO /* as */ /* TODO(TypeReference): Declaration */)
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			if isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) {
				return getSymbolOfNameOrPropertyAccessExpression(node /* as */ /* TODO(TypeReference): Identifier */)
			} else if /* TODO(PropertyAccessExpression): parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BindingElement */ TODO && /* TODO(PropertyAccessExpression): grandParent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectBindingPattern */ TODO && node == /* TODO(PropertyAccessExpression): (parent as BindingElement).propertyName */ TODO {
				typeOfPattern := getTypeOfNode(grandParent)
				propertyDeclaration := getPropertyOfType(typeOfPattern /* TODO(PropertyAccessExpression): (node as Identifier).escapedText */, TODO)
				if propertyDeclaration {
					return propertyDeclaration
				}
			} else if isMetaProperty(parent) && /* TODO(PropertyAccessExpression): parent.name */ TODO == node {
				if /* TODO(PropertyAccessExpression): parent.keywordToken */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NewKeyword */ TODO && idText(node /* as */ /* TODO(TypeReference): Identifier */) == "target" {
					return /* TODO(PropertyAccessExpression): checkNewTargetMetaProperty(parent).symbol */ TODO
				}
				if /* TODO(PropertyAccessExpression): parent.keywordToken */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportKeyword */ TODO && idText(node /* as */ /* TODO(TypeReference): Identifier */) == "meta" {
					return /* TODO(PropertyAccessExpression): getGlobalImportMetaExpressionType().members!.get */ TODO("meta" /* as */ /* TODO(TypeReference): __String */)
				}
				return nil
			}
		}
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.PrivateIdentifier:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.QualifiedName:                 if (!isThisInTypeQuery(node)) {                     return getSymbolOfNameOrPropertyAccessExpression(node as EntityName | PrivateIdentifier | PropertyAccessExpression);                 }                 // falls through              case SyntaxKind.ThisKeyword:                 const container = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);                 if (isFunctionLike(container)) {                     const sig = getSignatureFromDeclaration(container);                     if (sig.thisParameter) {                         return sig.thisParameter;                     }                 }                 if (isInExpressionContext(node)) {                     return checkExpression(node as Expression).symbol;                 }                 // falls through              case SyntaxKind.ThisType:                 return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode).symbol;              case SyntaxKind.SuperKeyword:                 return checkExpression(node as Expression).symbol;              case SyntaxKind.ConstructorKeyword:                 // constructor keyword for an overload, should take us to the definition if it exist                 const constructorDeclaration = node.parent;                 if (constructorDeclaration && constructorDeclaration.kind === SyntaxKind.Constructor) {                     return (constructorDeclaration.parent as ClassDeclaration).symbol;                 }                 return undefined;              case SyntaxKind.StringLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:                 // 1). import x = require("./mo/*gotToDefinitionHere* /d")                 // 2). External module name in an import declaration                 // 3). Dynamic import call or require in javascript                 // 4). type A = import("./f/*gotToDefinitionHere* /oo")                 if (                     (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||                     ((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) && (node.parent as ImportDeclaration).moduleSpecifier === node) ||                     (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier === node) ||                     ((isInJSFile(node) && isRequireCall(node.parent, /*requireStringLiteralLikeArgument* / false)) || isImportCall(node.parent)) ||                     (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)                 ) {                     return resolveExternalModuleName(node, node as LiteralExpression, ignoreErrors);                 }                 if (isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) {                     return getSymbolOfDeclaration(parent);                 }                 // falls through              case SyntaxKind.NumericLiteral:                 // index access                 const objectType = isElementAccessExpression(parent)                     ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined                     : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent)                     ? getTypeFromTypeNode(grandParent.objectType)                     : undefined;                 return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node as StringLiteral | NumericLiteral).text));              case SyntaxKind.DefaultKeyword:             case SyntaxKind.FunctionKeyword:             case SyntaxKind.EqualsGreaterThanToken:             case SyntaxKind.ClassKeyword:                 return getSymbolOfNode(node.parent);             case SyntaxKind.ImportType:                 return isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;              case SyntaxKind.ExportKeyword:                 return isExportAssignment(node.parent) ? Debug.checkDefined(node.parent.symbol) : undefined;              case SyntaxKind.ImportKeyword:             case SyntaxKind.NewKeyword:                 return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined;             case SyntaxKind.InstanceOfKeyword:                 if (isBinaryExpression(node.parent)) {                     const type = getTypeOfExpression(node.parent.right);                     const hasInstanceMethodType = getSymbolHasInstanceMethodOfObjectType(type);                     return hasInstanceMethodType?.symbol ?? type.symbol;                 }                 return undefined;             case SyntaxKind.MetaProperty:                 return checkExpression(node as Expression).symbol;             case SyntaxKind.JsxNamespacedName:                 if (isJSXTagName(node) && isJsxIntrinsicTagName(node)) {                     const symbol = getIntrinsicTagSymbol(node.parent as JsxOpeningLikeElement);                     return symbol === unknownSymbol ? undefined : symbol;                 }                 // falls through              default:                 return undefined;         } */
	}
	getIndexInfosAtLocation := func(node Node) /* TODO(TypeOperator): readonly IndexInfo[] */ any {
		if isIdentifier(node) && isPropertyAccessExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(PropertyAccessExpression): node.parent.name */ TODO == node {
			keyType := getLiteralTypeFromPropertyName(node)
			objectType := getTypeOfExpression( /* TODO(PropertyAccessExpression): node.parent.expression */ TODO)
			objectTypes := /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Union ? (objectType as UnionType).types : [objectType] */ TODO
			return flatMap(objectTypes /* TODO(ArrowFunction): t => filter(getIndexInfosOfType(t), info => isApplicableIndexType(keyType, info.keyType)) */, TODO)
		}
		return nil
	}
	getShorthandAssignmentValueSymbol := func(location Node) *Symbol {
		if location && /* TODO(PropertyAccessExpression): location.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO {
			return resolveEntityName( /* TODO(PropertyAccessExpression): (location as ShorthandPropertyAssignment).name */ TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Alias */, TODO)
		}
		return nil
	}
	getExportSpecifierLocalTargetSymbol := func(node /* TODO(UnionType): ExportSpecifier | Identifier */ any) *Symbol {
		if isExportSpecifier(node) {
			name := /* TODO(PropertyAccessExpression): node.propertyName */ TODO || /* TODO(PropertyAccessExpression): node.name */ TODO
			return /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?                 getExternalModuleMember(node.parent.parent, node) :                 name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }                 resolveEntityName(name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias) */ TODO
		} else {
			return resolveEntityName(node /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias */, TODO)
		}
	}
	getTypeOfNode := func(node Node) Type {
		if isSourceFile(node) && !isExternalModule(node) {
			return errorType
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.InWithStatement */ TODO {
			return errorType
		}
		classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
		classType := classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration( /* TODO(PropertyAccessExpression): classDecl.class */ TODO))
		if isPartOfTypeNode(node) {
			typeFromTypeNode := getTypeFromTypeNode(node /* as */ /* TODO(TypeReference): TypeNode */)
			return /* TODO(ConditionalExpression): classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode */ TODO
		}
		if isExpressionNode(node) {
			return getRegularTypeOfExpression(node /* as */ /* TODO(TypeReference): Expression */)
		}
		if classType && ! /* TODO(PropertyAccessExpression): classDecl.isImplements */ TODO {
			baseType := firstOrUndefined(getBaseTypes(classType))
			return /* TODO(ConditionalExpression): baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType */ TODO
		}
		if isTypeDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return getDeclaredTypeOfSymbol(symbol)
		}
		if isTypeDeclarationName(node) {
			symbol := getSymbolAtLocation(node)
			return /* TODO(ConditionalExpression): symbol ? getDeclaredTypeOfSymbol(symbol) : errorType */ TODO
		}
		if isBindingElement(node) {
			return getTypeForVariableLikeDeclaration(node /* TODO(TrueKeyword): true */, TODO /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO) || errorType
		}
		if isDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return /* TODO(ConditionalExpression): symbol ? getTypeOfSymbol(symbol) : errorType */ TODO
		}
		if isDeclarationNameOrImportPropertyName(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				return getTypeOfSymbol(symbol)
			}
			return errorType
		}
		if isBindingPattern(node) {
			return getTypeForVariableLikeDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(TrueKeyword): true */, TODO /* TODO(PropertyAccessExpression): CheckMode.Normal */, TODO) || errorType
		}
		if isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				declaredType := getDeclaredTypeOfSymbol(symbol)
				return /* TODO(ConditionalExpression): !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol) */ TODO
			}
		}
		if isMetaProperty( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(PropertyAccessExpression): node.parent.keywordToken */ TODO == /* TODO(PropertyAccessExpression): node.kind */ TODO {
			return checkMetaPropertyKeyword( /* TODO(PropertyAccessExpression): node.parent */ TODO)
		}
		if isImportAttributes(node) {
			return getGlobalImportAttributesType( /* TODO(FalseKeyword): false */ TODO)
		}
		return errorType
	}
	getTypeOfAssignmentPattern := func(expr AssignmentPattern) *Type {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO || /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ArrayLiteralExpression */ TODO)
		if /* TODO(PropertyAccessExpression): expr.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForOfStatement */ TODO {
			iteratedType := checkRightHandSideOfForOf( /* TODO(PropertyAccessExpression): expr.parent */ TODO /* as */ /* TODO(TypeReference): ForOfStatement */)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if /* TODO(PropertyAccessExpression): expr.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO {
			iteratedType := getTypeOfExpression( /* TODO(PropertyAccessExpression): (expr.parent as BinaryExpression).right */ TODO)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if /* TODO(PropertyAccessExpression): expr.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertyAssignment */ TODO {
			node := cast( /* TODO(PropertyAccessExpression): expr.parent.parent */ TODO, isObjectLiteralExpression)
			typeOfParentObjectLiteral := getTypeOfAssignmentPattern(node) || errorType
			propertyIndex := indexOfNode( /* TODO(PropertyAccessExpression): node.properties */ TODO /* TODO(PropertyAccessExpression): expr.parent */, TODO)
			return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
		}
		node := cast( /* TODO(PropertyAccessExpression): expr.parent */ TODO, isArrayLiteralExpression)
		typeOfArrayLiteral := getTypeOfAssignmentPattern(node) || errorType
		elementType := checkIteratedTypeOrElementType( /* TODO(PropertyAccessExpression): IterationUse.Destructuring */ TODO, typeOfArrayLiteral, undefinedType /* TODO(PropertyAccessExpression): expr.parent */, TODO) || errorType
		return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral /* TODO(PropertyAccessExpression): node.elements.indexOf */, TODO(expr), elementType)
	}
	getPropertySymbolOfDestructuringAssignment := func(location Identifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		typeOfObjectLiteral := getTypeOfAssignmentPattern(cast( /* TODO(PropertyAccessExpression): location.parent.parent */ TODO, isAssignmentPattern))
		return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral /* TODO(PropertyAccessExpression): location.escapedText */, TODO)
	}
	getRegularTypeOfExpression := func(expr Expression) Type {
		if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
			/* TODO(ExpressionStatement): expr = expr.parent as Expression; */
		}
		return getRegularTypeOfLiteralType(getTypeOfExpression(expr))
	}
	getParentTypeOfClassElement := func(node ClassElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		classSymbol := /* TODO(NonNullExpression): getSymbolOfNode(node.parent)! */ TODO
		return /* TODO(ConditionalExpression): isStatic(node)             ? getTypeOfSymbol(classSymbol)             : getDeclaredTypeOfSymbol(classSymbol) */ TODO
	}
	getClassElementPropertyKeyType := func(element ClassElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		name := /* TODO(NonNullExpression): element.name! */ TODO
		/* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.Identifier:                 return getStringLiteralType(idText(name));             case SyntaxKind.NumericLiteral:             case SyntaxKind.StringLiteral:                 return getStringLiteralType(name.text);             case SyntaxKind.ComputedPropertyName:                 const nameType = checkComputedPropertyName(name);                 return isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType;             default:                 return Debug.fail("Unsupported property name.");         } */
	}
	getAugmentedPropertiesOfType := func(type_ Type) []Symbol {
		/* TODO(ExpressionStatement): type = getApparentType(type); */
		propsByName := createSymbolTable(getPropertiesOfType(type_))
		functionType := /* TODO(ConditionalExpression): getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType :             getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType :             undefined */ TODO
		if functionType {
			forEach(getPropertiesOfType(functionType) /* TODO(ArrowFunction): p => {                 if (!propsByName.has(p.escapedName)) {                     propsByName.set(p.escapedName, p);                 }             } */, TODO)
		}
		return getNamedMembers(propsByName)
	}
	typeHasCallOrConstructSignatures := func(type_ Type) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSignaturesOfType(type, SignatureKind.Call).length !== 0 */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSignaturesOfType(type, SignatureKind.Construct).length !== 0 */ TODO
	}
	getRootSymbols := func(symbol Symbol) []Symbol {
		roots := getImmediateRootSymbols(symbol)
		return /* TODO(ConditionalExpression): roots ? flatMap(roots, getRootSymbols) : [symbol] */ TODO
	}
	getImmediateRootSymbols := func(symbol Symbol) /* TODO(TypeOperator): readonly Symbol[] */ any {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCheckFlags(symbol) & CheckFlags.Synthetic */ TODO {
			return mapDefined( /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).containingType!.types */ TODO /* TODO(ArrowFunction): type => getPropertyOfType(type, symbol.escapedName) */, TODO)
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.Transient */ TODO {
			TODO_IDENTIFIER := symbol /* as */ /* TODO(TypeReference): TransientSymbol */
			return /* TODO(ConditionalExpression): leftSpread ? [leftSpread, rightSpread!]                 : syntheticOrigin ? [syntheticOrigin]                 : singleElementArray(tryGetTarget(symbol)) */ TODO
		}
		return nil
	}
	tryGetTarget := func(symbol Symbol) *Symbol {
		var target *Symbol
		var next *Symbol = symbol
		/* TODO(WhileStatement): while (next = getSymbolLinks(next).target) {             target = next;         } */
		return target
	}
	isArgumentsLocalBinding := func(nodeIn Identifier) bool {
		if isGeneratedIdentifier(nodeIn) {
			/* TODO(FalseKeyword): false */
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if !node {
			/* TODO(FalseKeyword): false */
		}
		parent := /* TODO(PropertyAccessExpression): node.parent */ TODO
		if !parent {
			/* TODO(FalseKeyword): false */
		}
		isPropertyName := /* TODO(ParenthesizedExpression): (isPropertyAccessExpression(parent)             || isPropertyAssignment(parent)) */ TODO && /* TODO(PropertyAccessExpression): parent.name */ TODO == node
		return !isPropertyName && getReferencedValueSymbol(node) == argumentsSymbol
	}
	isNameOfModuleOrEnumDeclaration := func(node Identifier) /* TODO(undefined): boolean */ TODO {
		return isModuleOrEnumDeclaration( /* TODO(PropertyAccessExpression): node.parent */ TODO) && node == /* TODO(PropertyAccessExpression): node.parent.name */ TODO
	}
	getReferencedExportContainer := func(nodeIn Identifier, prefixLocals bool) /* TODO(UnionType): SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node))
			if symbol {
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.ExportValue */ TODO {
					exportSymbol := getMergedSymbol( /* TODO(NonNullExpression): symbol.exportSymbol! */ TODO)
					if !prefixLocals && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): exportSymbol.flags & SymbolFlags.ExportHasLocal */ TODO && ! /* TODO(ParenthesizedExpression): (exportSymbol.flags & SymbolFlags.Variable) */ TODO {
						return nil
					}
					/* TODO(ExpressionStatement): symbol = exportSymbol; */
				}
				parentSymbol := getParentOfSymbol(symbol)
				if parentSymbol {
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): parentSymbol.flags & SymbolFlags.ValueModule */ TODO && /* TODO(PropertyAccessExpression): parentSymbol.valueDeclaration?.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO {
						symbolFile := /* TODO(PropertyAccessExpression): parentSymbol.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): SourceFile */
						referenceFile := getSourceFileOfNode(node)
						symbolIsUmdExport := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbolFile !== referenceFile */ TODO
						return /* TODO(ConditionalExpression): symbolIsUmdExport ? undefined : symbolFile */ TODO
					}
					return findAncestor( /* TODO(PropertyAccessExpression): node.parent */ TODO /* TODO(ArrowFunction): (n): n is ModuleDeclaration | EnumDeclaration => isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) === parentSymbol */, TODO)
				}
			}
		}
	}
	getReferencedImportDeclaration := func(nodeIn Identifier) Declaration {
		specifier := getIdentifierGeneratedImportReference(nodeIn)
		if specifier {
			return specifier
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueOrAliasSymbol(node)
			if isNonLocalAlias(symbol /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO) && !getTypeOnlyAliasDeclaration(symbol /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO) {
				return getDeclarationOfAliasSymbol(symbol)
			}
		}
		return nil
	}
	isSymbolOfDestructuredElementOfCatchBinding := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		return /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && isBindingElement( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) && /* TODO(PropertyAccessExpression): walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CatchClause */ TODO
	}
	isSymbolOfDeclarationWithCollidingName := func(symbol Symbol) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): symbol.flags & SymbolFlags.BlockScoped */ TODO && /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO && !isSourceFile( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO) {
			links := getSymbolLinks(symbol)
			if /* TODO(PropertyAccessExpression): links.isDeclarationWithCollidingName */ TODO == nil {
				container := getEnclosingBlockScopeContainer( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
				if isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol) {
					if resolveName( /* TODO(PropertyAccessExpression): container.parent */ TODO /* TODO(PropertyAccessExpression): symbol.escapedName */, TODO /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO, nil /* TODO(FalseKeyword): false */, TODO) {
						/* TODO(ExpressionStatement): links.isDeclarationWithCollidingName = true; */
					} else if hasNodeCheckFlag( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): NodeCheckFlags.CapturedBlockScopedBinding */, TODO) {
						isDeclaredInLoop := hasNodeCheckFlag( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* TODO(PropertyAccessExpression): NodeCheckFlags.BlockScopedBindingInLoop */, TODO)
						inLoopInitializer := isIterationStatement(container /* TODO(FalseKeyword): false */, TODO)
						inLoopBodyBlock := /* TODO(PropertyAccessExpression): container.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Block */ TODO && isIterationStatement( /* TODO(PropertyAccessExpression): container.parent */ TODO /* TODO(FalseKeyword): false */, TODO)
						/* TODO(ExpressionStatement): links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock)); */
					} else {
						/* TODO(ExpressionStatement): links.isDeclarationWithCollidingName = false; */
					}
				}
			}
			return /* TODO(NonNullExpression): links.isDeclarationWithCollidingName! */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getReferencedDeclarationWithCollidingName := func(nodeIn Identifier) Declaration {
		if !isGeneratedIdentifier(nodeIn) {
			node := getParseTreeNode(nodeIn, isIdentifier)
			if node {
				symbol := getReferencedValueSymbol(node)
				if symbol && isSymbolOfDeclarationWithCollidingName(symbol) {
					return /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO
				}
			}
		}
		return nil
	}
	isDeclarationWithCollidingName := func(nodeIn Declaration) bool {
		node := getParseTreeNode(nodeIn, isDeclaration)
		if node {
			symbol := getSymbolOfDeclaration(node)
			if symbol {
				return isSymbolOfDeclarationWithCollidingName(symbol)
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isValueAliasDeclaration := func(node Node) bool {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(canCollectSymbolAliasAccessabilityData)
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:                 return isAliasResolvedToValue(getSymbolOfDeclaration(node as ImportEqualsDeclaration));             case SyntaxKind.ImportClause:             case SyntaxKind.NamespaceImport:             case SyntaxKind.ImportSpecifier:             case SyntaxKind.ExportSpecifier:                 const symbol = getSymbolOfDeclaration(node as ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier);                 return !!symbol && isAliasResolvedToValue(symbol, /*excludeTypeOnlyValues* / true);             case SyntaxKind.ExportDeclaration:                 const exportClause = (node as ExportDeclaration).exportClause;                 return !!exportClause && (                     isNamespaceExport(exportClause) ||                     some(exportClause.elements, isValueAliasDeclaration)                 );             case SyntaxKind.ExportAssignment:                 return (node as ExportAssignment).expression && (node as ExportAssignment).expression.kind === SyntaxKind.Identifier ?                     isAliasResolvedToValue(getSymbolOfDeclaration(node as ExportAssignment), /*excludeTypeOnlyValues* / true) :                     true;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	isTopLevelValueImportEqualsWithEntityName := func(nodeIn ImportEqualsDeclaration) bool {
		node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
		if node == nil || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile */ TODO || !isInternalModuleImportEqualsDeclaration(node) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		isValue := isAliasResolvedToValue(getSymbolOfDeclaration(node))
		return isValue && /* TODO(PropertyAccessExpression): node.moduleReference */ TODO && !nodeIsMissing( /* TODO(PropertyAccessExpression): node.moduleReference */ TODO)
	}
	isAliasResolvedToValue := func(symbol *Symbol, excludeTypeOnlyValues bool) bool {
		if !symbol {
			return /* TODO(FalseKeyword): false */ TODO
		}
		container := getSourceFileOfNode( /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO)
		fileSymbol := container && getSymbolOfDeclaration(container)
		/* TODO(ExpressionStatement): void resolveExternalModuleSymbol(fileSymbol); */
		target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
		if target == unknownSymbol {
			return !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol)
		}
		return !! /* TODO(ParenthesizedExpression): (getSymbolFlags(symbol, excludeTypeOnlyValues, /*excludeLocalMeanings* / true) & SymbolFlags.Value) */ TODO && /* TODO(ParenthesizedExpression): (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) */ TODO
	}
	isConstEnumOrConstEnumOnlyModule := func(s Symbol) bool {
		return isConstEnumSymbol(s) || !! /* TODO(PropertyAccessExpression): s.constEnumOnlyModule */ TODO
	}
	isReferencedAliasDeclaration := func(node Node, checkChildren bool) bool {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(canCollectSymbolAliasAccessabilityData)
		if isAliasSymbolDeclaration(node) {
			symbol := getSymbolOfDeclaration(node /* as */ /* TODO(TypeReference): Declaration */)
			links := symbol && getSymbolLinks(symbol)
			if /* TODO(PropertyAccessExpression): links?.referenced */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
			target := /* TODO(PropertyAccessExpression): getSymbolLinks(symbol).aliasTarget */ TODO
			if target && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getEffectiveModifierFlags(node) & ModifierFlags.Export */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getSymbolFlags(target) & SymbolFlags.Value */ TODO && /* TODO(ParenthesizedExpression): (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) */ TODO {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		if checkChildren {
			return !!forEachChild(node /* TODO(ArrowFunction): node => isReferencedAliasDeclaration(node, checkChildren) */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	isImplementationOfOverload := func(node SignatureDeclaration) /* TODO(undefined): boolean */ TODO {
		if nodeIsPresent( /* TODO(PropertyAccessExpression): (node as FunctionLikeDeclaration).body */ TODO) {
			if isGetAccessor(node) || isSetAccessor(node) {
				/* TODO(FalseKeyword): false */
			}
			symbol := getSymbolOfDeclaration(node)
			signaturesOfSymbol := getSignaturesOfSymbol(symbol)
			return /* TODO(PropertyAccessExpression): signaturesOfSymbol.length */ TODO > 1 || /* TODO(ParenthesizedExpression): (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node) */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	declaredParameterTypeContainsUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO(undefined): boolean */ TODO {
		typeNode := getNonlocalEffectiveTypeAnnotationNode(parameter)
		if !typeNode {
			/* TODO(FalseKeyword): false */
		}
		type_ := getTypeFromTypeNode(typeNode)
		return containsUndefinedType(type_)
	}
	requiresAddingImplicitUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ParenthesizedExpression): (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) */ TODO && !declaredParameterTypeContainsUndefined(parameter)
	}
	isRequiredInitializedParameter := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
		if !strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || ! /* TODO(PropertyAccessExpression): parameter.initializer */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if hasSyntacticModifier(parameter /* TODO(PropertyAccessExpression): ModifierFlags.ParameterPropertyModifier */, TODO) {
			return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration)
		}
		return /* TODO(TrueKeyword): true */ TODO
	}
	isOptionalUninitializedParameterProperty := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO(undefined): boolean */ TODO {
		return strictNullChecks && isOptionalParameter(parameter) && /* TODO(ParenthesizedExpression): (isJSDocParameterTag(parameter) || !parameter.initializer) */ TODO && hasSyntacticModifier(parameter /* TODO(PropertyAccessExpression): ModifierFlags.ParameterPropertyModifier */, TODO)
	}
	isExpandoFunctionDeclaration := func(node Declaration) bool {
		declaration := getParseTreeNode(node /* TODO(ArrowFunction): (n): n is FunctionDeclaration | VariableDeclaration => isFunctionDeclaration(n) || isVariableDeclaration(n) */, TODO)
		if !declaration {
			return /* TODO(FalseKeyword): false */ TODO
		}
		var symbol *Symbol
		if isVariableDeclaration(declaration) {
			if /* TODO(PropertyAccessExpression): declaration.type */ TODO || /* TODO(ParenthesizedExpression): (!isInJSFile(declaration) && !isVarConstLike(declaration)) */ TODO {
				return /* TODO(FalseKeyword): false */ TODO
			}
			initializer := getDeclaredExpandoInitializer(declaration)
			if !initializer || !canHaveSymbol(initializer) {
				return /* TODO(FalseKeyword): false */ TODO
			}
			/* TODO(ExpressionStatement): symbol = getSymbolOfDeclaration(initializer); */
		} else {
			/* TODO(ExpressionStatement): symbol = getSymbolOfDeclaration(declaration); */
		}
		if !symbol || ! /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.Function | SymbolFlags.Variable) */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return !!forEachEntry(getExportsOfSymbol(symbol) /* TODO(ArrowFunction): p => p.flags & SymbolFlags.Value && isExpandoPropertyDeclaration(p.valueDeclaration) */, TODO)
	}
	getPropertiesOfContainerFunction := func(node Declaration) []Symbol {
		declaration := getParseTreeNode(node, isFunctionDeclaration)
		if !declaration {
			return emptyArray
		}
		symbol := getSymbolOfDeclaration(declaration)
		return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray
	}
	getNodeCheckFlags := func(node Node) NodeCheckFlags {
		nodeId := /* TODO(PropertyAccessExpression): node.id */ TODO || 0
		if nodeId < 0 || nodeId >= /* TODO(PropertyAccessExpression): nodeLinks.length */ TODO {
			/* TODO(NumericLiteral): 0 */
		}
		return /* TODO(PropertyAccessExpression): nodeLinks[nodeId]?.flags */ TODO || 0
	}
	hasNodeCheckFlag := func(node Node, flag LazyNodeCheckFlags) /* TODO(undefined): boolean */ TODO {
		calculateNodeCheckFlagWorker(node, flag)
		return !! /* TODO(ParenthesizedExpression): (getNodeCheckFlags(node) & flag) */ TODO
	}
	calculateNodeCheckFlagWorker := func(node Node, flag LazyNodeCheckFlags) {
		if ! /* TODO(PropertyAccessExpression): compilerOptions.noCheck */ TODO && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions) {
			return
		}
		links := getNodeLinks(node)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
			return
		}
		/* TODO(SwitchStatement): switch (flag) {             case NodeCheckFlags.SuperInstance:             case NodeCheckFlags.SuperStatic:                 return checkSingleSuperExpression(node);             case NodeCheckFlags.MethodWithSuperPropertyAccessInAsync:             case NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync:             case NodeCheckFlags.ContainsSuperPropertyInStaticInitializer:                 return checkChildSuperExpressions(node);             case NodeCheckFlags.CaptureArguments:             case NodeCheckFlags.ContainsCapturedBlockScopeBinding:             case NodeCheckFlags.NeedsLoopOutParameter:             case NodeCheckFlags.ContainsConstructorReference:                 return checkChildIdentifiers(node);             case NodeCheckFlags.ConstructorReference:                 return checkSingleIdentifier(node);             case NodeCheckFlags.LoopWithCapturedBlockScopedBinding:             case NodeCheckFlags.BlockScopedBindingInLoop:             case NodeCheckFlags.CapturedBlockScopedBinding:                 return checkContainingBlockScopeBindingUses(node);             default:                 return Debug.assertNever(flag, `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}`);         } */
		forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(UnionType): T | "skip" | undefined */ any) *T {
			rootResult := cb(root /* TODO(PropertyAccessExpression): root.parent */, TODO)
			if rootResult == "skip" {
				/* TODO(Identifier): undefined */
			}
			if rootResult {
				/* TODO(Identifier): rootResult */
			}
			return forEachChildRecursively(root, cb)
		}
		checkSuperExpressions := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
				/* TODO(StringLiteral): "skip" */
			}
			/* TODO(ExpressionStatement): links.calculatedFlags |= NodeCheckFlags.MethodWithSuperPropertyAccessInAsync | NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync | NodeCheckFlags.ContainsSuperPropertyInStaticInitializer; */
			checkSingleSuperExpression(node)
			return nil
		}
		checkChildSuperExpressions := func(node Node) {
			forEachNodeRecursively(node, checkSuperExpressions)
		}
		checkSingleSuperExpression := func(node Node) {
			nodeLinks := getNodeLinks(node)
			/* TODO(ExpressionStatement): nodeLinks.calculatedFlags |= NodeCheckFlags.SuperInstance | NodeCheckFlags.SuperStatic; */
			if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SuperKeyword */ TODO {
				checkSuperExpression(node)
			}
		}
		checkIdentifiers := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
				/* TODO(StringLiteral): "skip" */
			}
			/* TODO(ExpressionStatement): links.calculatedFlags |= NodeCheckFlags.CaptureArguments | NodeCheckFlags.ContainsCapturedBlockScopeBinding | NodeCheckFlags.NeedsLoopOutParameter | NodeCheckFlags.ContainsConstructorReference; */
			checkSingleIdentifier(node)
			return nil
		}
		checkChildIdentifiers := func(node Node) {
			forEachNodeRecursively(node, checkIdentifiers)
		}
		isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) /* TODO(undefined): boolean */ TODO {
			return isExpressionNode(node) || isShorthandPropertyAssignment( /* TODO(PropertyAccessExpression): node.parent */ TODO) && /* TODO(ParenthesizedExpression): (node.parent.objectAssignmentInitializer ?? node.parent.name) */ TODO == node
		}
		checkSingleIdentifier := func(node Node) {
			nodeLinks := getNodeLinks(node)
			/* TODO(ExpressionStatement): nodeLinks.calculatedFlags |= NodeCheckFlags.ConstructorReference; */
			if isIdentifier(node) {
				/* TODO(ExpressionStatement): nodeLinks.calculatedFlags |= NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding; */
				if isExpressionNodeOrShorthandPropertyAssignmentName(node) && ! /* TODO(ParenthesizedExpression): (isPropertyAccessExpression(node.parent) && node.parent.name === node) */ TODO {
					s := getResolvedSymbol(node)
					if s && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): s !== unknownSymbol */ TODO {
						checkIdentifierCalculateNodeCheckFlags(node, s)
					}
				}
			}
		}
		checkBlockScopeBindings := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): links.calculatedFlags & flag */ TODO {
				/* TODO(StringLiteral): "skip" */
			}
			/* TODO(ExpressionStatement): links.calculatedFlags |= NodeCheckFlags.LoopWithCapturedBlockScopedBinding | NodeCheckFlags.BlockScopedBindingInLoop | NodeCheckFlags.CapturedBlockScopedBinding; */
			checkSingleBlockScopeBinding(node)
			return nil
		}
		checkContainingBlockScopeBindingUses := func(node Node) {
			scope := getEnclosingBlockScopeContainer( /* TODO(ConditionalExpression): isDeclarationName(node) ? node.parent : node */ TODO)
			forEachNodeRecursively(scope, checkBlockScopeBindings)
		}
		checkSingleBlockScopeBinding := func(node Node) {
			checkSingleIdentifier(node)
			if isComputedPropertyName(node) {
				checkComputedPropertyName(node)
			}
			if isPrivateIdentifier(node) && isClassElement( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
				setNodeLinksForPrivateIdentifierScope( /* TODO(PropertyAccessExpression): node.parent */ TODO /* as */ /* TODO(UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */)
			}
		}
	}
	getEnumMemberValue := func(node EnumMember) EvaluatorResult {
		computeEnumMemberValues( /* TODO(PropertyAccessExpression): node.parent */ TODO)
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
	}
	canHaveConstantValue := func(node Node) /* TODO(TypePredicate): node is EnumMember | AccessExpression */ TODO {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.EnumMember:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 return true;         } */
		return /* TODO(FalseKeyword): false */ TODO
	}
	getConstantValue := func(node /* TODO(UnionType): EnumMember | AccessExpression */ any) /* TODO(UnionType): string | number | undefined */ any {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.EnumMember */ TODO {
			return /* TODO(PropertyAccessExpression): getEnumMemberValue(node).value */ TODO
		}
		if ! /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO {
			/* TODO(ExpressionStatement): void checkExpressionCached(node); */
		}
		symbol := /* TODO(PropertyAccessExpression): getNodeLinks(node).resolvedSymbol */ TODO || /* TODO(ParenthesizedExpression): (isEntityNameExpression(node) ? resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors* / true) : undefined) */ TODO
		if symbol && /* TODO(ParenthesizedExpression): (symbol.flags & SymbolFlags.EnumMember) */ TODO {
			member := /* TODO(PropertyAccessExpression): symbol.valueDeclaration */ TODO /* as */ /* TODO(TypeReference): EnumMember */
			if isEnumConst( /* TODO(PropertyAccessExpression): member.parent */ TODO) {
				return /* TODO(PropertyAccessExpression): getEnumMemberValue(member).value */ TODO
			}
		}
		return nil
	}
	isFunctionType := func(type_ Type) bool {
		return !! /* TODO(ParenthesizedExpression): (type.flags & TypeFlags.Object) */ TODO && /* TODO(PropertyAccessExpression): getSignaturesOfType(type, SignatureKind.Call).length */ TODO > 0
	}
	getTypeReferenceSerializationKind := func(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
		typeName := getParseTreeNode(typeNameIn, isEntityName)
		if !typeName {
			/* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Unknown */
		}
		if location {
			/* TODO(ExpressionStatement): location = getParseTreeNode(location); */
			if !location {
				/* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Unknown */
			}
		}
		isTypeOnly := /* TODO(FalseKeyword): false */ TODO
		if isQualifiedName(typeName) {
			rootValueSymbol := resolveEntityName(getFirstIdentifier(typeName) /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, location)
			/* TODO(ExpressionStatement): isTypeOnly = !!rootValueSymbol?.declarations?.every(isTypeOnlyImportOrExportDeclaration); */
		}
		valueSymbol := resolveEntityName(typeName /* TODO(PropertyAccessExpression): SymbolFlags.Value */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, location)
		resolvedValueSymbol := /* TODO(ConditionalExpression): valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(valueSymbol) : valueSymbol */ TODO
		/* TODO(ExpressionStatement): isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value)); */
		typeSymbol := resolveEntityName(typeName /* TODO(PropertyAccessExpression): SymbolFlags.Type */, TODO /* TODO(TrueKeyword): true */, TODO /* TODO(TrueKeyword): true */, TODO, location)
		resolvedTypeSymbol := /* TODO(ConditionalExpression): typeSymbol && typeSymbol.flags & SymbolFlags.Alias ? resolveAlias(typeSymbol) : typeSymbol */ TODO
		if !valueSymbol {
			/* TODO(ExpressionStatement): isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type)); */
		}
		if resolvedValueSymbol && resolvedValueSymbol == resolvedTypeSymbol {
			globalPromiseSymbol := getGlobalPromiseConstructorSymbol( /* TODO(FalseKeyword): false */ TODO)
			if globalPromiseSymbol && resolvedValueSymbol == globalPromiseSymbol {
				return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Promise */ TODO
			}
			constructorType := getTypeOfSymbol(resolvedValueSymbol)
			if constructorType && isConstructorType(constructorType) {
				return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.TypeWithCallSignature : TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue */ TODO
			}
		}
		if !resolvedTypeSymbol {
			return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
		}
		type_ := getDeclaredTypeOfSymbol(resolvedTypeSymbol)
		if isErrorType(type_) {
			return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
		} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): type.flags & TypeFlags.AnyOrUnknown */ TODO {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ObjectType */ TODO
		} else if isTypeAssignableToKind(type_ /* TODO(BarToken): | */ /* TODO(BinaryExpression): TypeFlags.Void | TypeFlags.Nullable | TypeFlags.Never */, TODO) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.VoidNullableOrNeverType */ TODO
		} else if isTypeAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.BooleanLike */, TODO) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.BooleanType */ TODO
		} else if isTypeAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.NumberLike */, TODO) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.NumberLikeType */ TODO
		} else if isTypeAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.BigIntLike */, TODO) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.BigIntLikeType */ TODO
		} else if isTypeAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.StringLike */, TODO) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.StringLikeType */ TODO
		} else if isTupleType(type_) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ArrayLikeType */ TODO
		} else if isTypeAssignableToKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.ESSymbolLike */, TODO) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ESSymbolType */ TODO
		} else if isFunctionType(type_) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.TypeWithCallSignature */ TODO
		} else if isArrayType(type_) {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ArrayLikeType */ TODO
		} else {
			return /* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.ObjectType */ TODO
		}
	}
	createTypeOfDeclaration := func(declarationIn /* TODO(UnionType): AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
		if !declaration {
			return /* TODO(PropertyAccessExpression): factory.createToken */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* as */ /* TODO(TypeReference): KeywordTypeNode */
		}
		symbol := getSymbolOfDeclaration(declaration)
		type_ := /* TODO(ConditionalExpression): symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature))             ? getWidenedLiteralType(getTypeOfSymbol(symbol))             : errorType */ TODO
		return /* TODO(PropertyAccessExpression): nodeBuilder.serializeTypeForDeclaration */ TODO(declaration, type_, symbol, enclosingDeclaration /* TODO(BarToken): | */ /* TODO(BinaryExpression): flags | NodeBuilderFlags.MultilineObjectLiterals */, TODO, internalFlags, tracker)
	}
	type DeclarationWithPotentialInnerNodeReuse /* TODO(UnionType): | SignatureDeclaration         | JSDocSignature         | AccessorDeclaration         | VariableLikeDeclaration         | PropertyAccessExpression         | ExportAssignment */ any
	isDeclarationWithPossibleInnerTypeNodeReuse := func(declaration Declaration) /* TODO(TypePredicate): declaration is DeclarationWithPotentialInnerNodeReuse */ TODO {
		return isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration)
	}
	getAllAccessorDeclarationsForDeclaration := func(accessor AccessorDeclaration) AllAccessorDeclarations {
		/* TODO(ExpressionStatement): accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)!; */
		otherKind := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor */ TODO
		otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind)
		firstAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor */ TODO
		secondAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor */ TODO
		setAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor as SetAccessorDeclaration */ TODO
		getAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor as GetAccessorDeclaration */ TODO
		return /* TODO(ObjectLiteralExpression): {             firstAccessor,             secondAccessor,             setAccessor,             getAccessor,         } */ TODO
	}
	getPossibleTypeNodeReuseExpression := func(declaration DeclarationWithPotentialInnerNodeReuse) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		return /* TODO(ConditionalExpression): isFunctionLike(declaration) && !isSetAccessor(declaration)             ? getSingleReturnExpression(declaration)             : isExportAssignment(declaration)             ? declaration.expression             : !!(declaration as HasInitializer).initializer             ? (declaration as HasInitializer & typeof declaration).initializer             : isParameter(declaration) && isSetAccessor(declaration.parent)             ? getSingleReturnExpression(getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)             : undefined */ TODO
	}
	getSingleReturnExpression := func(declaration *SignatureDeclaration) *Expression {
		var candidateExpr *Expression
		if declaration && !nodeIsMissing( /* TODO(PropertyAccessExpression): (declaration as FunctionLikeDeclaration).body */ TODO) {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getFunctionFlags(declaration) & FunctionFlags.AsyncGenerator */ TODO {
				/* TODO(Identifier): undefined */
			}
			body := /* TODO(PropertyAccessExpression): (declaration as FunctionLikeDeclaration).body */ TODO
			if body && isBlock(body) {
				forEachReturnStatement(body /* TODO(ArrowFunction): s => {                     if (!candidateExpr) {                         candidateExpr = s.expression;                     }                     else {                         candidateExpr = undefined;                         return true;                     }                 } */, TODO)
			} else {
				/* TODO(ExpressionStatement): candidateExpr = body; */
			}
		}
		return candidateExpr
	}
	createReturnTypeOfSignatureDeclaration := func(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
		if !signatureDeclaration {
			return /* TODO(PropertyAccessExpression): factory.createToken */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* as */ /* TODO(TypeReference): KeywordTypeNode */
		}
		return /* TODO(PropertyAccessExpression): nodeBuilder.serializeReturnTypeForSignature */ TODO(getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration /* TODO(BarToken): | */ /* TODO(BinaryExpression): flags | NodeBuilderFlags.MultilineObjectLiterals */, TODO, internalFlags, tracker)
	}
	createTypeOfExpression := func(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		expr := getParseTreeNode(exprIn, isExpression)
		if !expr {
			return /* TODO(PropertyAccessExpression): factory.createToken */ TODO( /* TODO(PropertyAccessExpression): SyntaxKind.AnyKeyword */ TODO) /* as */ /* TODO(TypeReference): KeywordTypeNode */
		}
		type_ := getWidenedType(getRegularTypeOfExpression(expr))
		return /* TODO(PropertyAccessExpression): nodeBuilder.expressionOrTypeToTypeNode */ TODO(expr, type_, nil, enclosingDeclaration /* TODO(BarToken): | */ /* TODO(BinaryExpression): flags | NodeBuilderFlags.MultilineObjectLiterals */, TODO, internalFlags, tracker)
	}
	hasGlobalName := func(name string) bool {
		return /* TODO(PropertyAccessExpression): globals.has */ TODO(escapeLeadingUnderscores(name))
	}
	getReferencedValueSymbol := func(reference Identifier, startInDeclarationContainer bool) *Symbol {
		resolvedSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(reference).resolvedSymbol */ TODO
		if resolvedSymbol {
			return resolvedSymbol
		}
		var location Node = reference
		if startInDeclarationContainer {
			parent := /* TODO(PropertyAccessExpression): reference.parent */ TODO
			if isDeclaration(parent) && reference == /* TODO(PropertyAccessExpression): parent.name */ TODO {
				/* TODO(ExpressionStatement): location = getDeclarationContainer(parent); */
			}
		}
		return resolveName(location /* TODO(PropertyAccessExpression): reference.escapedText */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias */, TODO, nil /* TODO(TrueKeyword): true */, TODO)
	}
	getReferencedValueOrAliasSymbol := func(reference Identifier) *Symbol {
		resolvedSymbol := /* TODO(PropertyAccessExpression): getNodeLinks(reference).resolvedSymbol */ TODO
		if resolvedSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): resolvedSymbol !== unknownSymbol */ TODO {
			return resolvedSymbol
		}
		return resolveName(reference /* TODO(PropertyAccessExpression): reference.escapedText */, TODO /* TODO(BarToken): | */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.ExportValue | SymbolFlags.Alias */, TODO, nil /* TODO(TrueKeyword): true */, TODO, nil)
	}
	getReferencedValueDeclaration := func(referenceIn Identifier) Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return /* TODO(PropertyAccessExpression): getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration */ TODO
				}
			}
		}
		return nil
	}
	getReferencedValueDeclarations := func(referenceIn Identifier) /* TODO(ArrayType): Declaration[] */ any {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return filter( /* TODO(PropertyAccessExpression): getExportSymbolOfValueSymbolIfExported(symbol).declarations */ TODO /* TODO(ArrowFunction): declaration => {                         switch (declaration.kind) {                             case SyntaxKind.VariableDeclaration:                             case SyntaxKind.Parameter:                             case SyntaxKind.BindingElement:                             case SyntaxKind.PropertyDeclaration:                             case SyntaxKind.PropertyAssignment:                             case SyntaxKind.ShorthandPropertyAssignment:                             case SyntaxKind.EnumMember:                             case SyntaxKind.ObjectLiteralExpression:                             case SyntaxKind.FunctionDeclaration:                             case SyntaxKind.FunctionExpression:                             case SyntaxKind.ArrowFunction:                             case SyntaxKind.ClassDeclaration:                             case SyntaxKind.ClassExpression:                             case SyntaxKind.EnumDeclaration:                             case SyntaxKind.MethodDeclaration:                             case SyntaxKind.GetAccessor:                             case SyntaxKind.SetAccessor:                             case SyntaxKind.ModuleDeclaration:                                 return true;                         }                         return false;                     } */, TODO)
				}
			}
		}
		return nil
	}
	isLiteralConstDeclaration := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
		if isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node) {
			return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)))
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	literalTypeToNode := func(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
		enumResult := /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, /*flags* / undefined, /*internalFlags* / undefined, tracker)             : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse() */ TODO
		if enumResult {
			/* TODO(Identifier): enumResult */
		}
		literalValue := /* TODO(PropertyAccessExpression): (type as LiteralType).value */ TODO
		return /* TODO(ConditionalExpression): typeof literalValue === "object" ? factory.createBigIntLiteral(literalValue) :             typeof literalValue === "string" ? factory.createStringLiteral(literalValue) :             literalValue < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-literalValue)) :             factory.createNumericLiteral(literalValue) */ TODO
	}
	createLiteralConstValue := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
		type_ := getTypeOfSymbol(getSymbolOfDeclaration(node))
		return literalTypeToNode(type_ /* as */ /* TODO(TypeReference): FreshableType */, node, tracker)
	}
	getJsxFactoryEntity := func(location Node) *EntityName {
		return /* TODO(ConditionalExpression): location ? (getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity */ TODO
	}
	getJsxFragmentFactoryEntity := func(location Node) *EntityName {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO {
					return /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO
				}
				jsxFragPragmas := /* TODO(PropertyAccessExpression): file.pragmas.get */ TODO("jsxfrag")
				jsxFragPragma := /* TODO(ConditionalExpression): isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas */ TODO
				if jsxFragPragma {
					/* TODO(ExpressionStatement): file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion); */
					return /* TODO(PropertyAccessExpression): file.localJsxFragmentFactory */ TODO
				}
			}
		}
		if /* TODO(PropertyAccessExpression): compilerOptions.jsxFragmentFactory */ TODO {
			return parseIsolatedEntityName( /* TODO(PropertyAccessExpression): compilerOptions.jsxFragmentFactory */ TODO, languageVersion)
		}
	}
	getNonlocalEffectiveTypeAnnotationNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		direct := getEffectiveTypeAnnotationNode(node)
		if direct {
			return direct
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO && /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO {
			other := /* TODO(PropertyAccessExpression): getAllAccessorDeclarationsForDeclaration(node.parent as SetAccessorDeclaration).getAccessor */ TODO
			if other {
				return getEffectiveReturnTypeNode(other)
			}
		}
		return nil
	}
	getNonlocalEffectiveReturnTypeAnnotationNode := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		direct := getEffectiveReturnTypeNode(node)
		if direct {
			return direct
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.GetAccessor */ TODO {
			other := /* TODO(PropertyAccessExpression): getAllAccessorDeclarationsForDeclaration(node).setAccessor */ TODO
			if other {
				param := getSetAccessorValueParameter(other)
				if param {
					return getEffectiveTypeAnnotationNode(param)
				}
			}
		}
		return nil
	}
	createResolver := func() EmitResolver {
		return /* TODO(ObjectLiteralExpression): {             getReferencedExportContainer,             getReferencedImportDeclaration,             getReferencedDeclarationWithCollidingName,             isDeclarationWithCollidingName,             isValueAliasDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated like values.                 return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true;             },             hasGlobalName,             isReferencedAliasDeclaration: (nodeIn, checkChildren?) => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated as referenced.                 return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true;             },             hasNodeCheckFlag: (nodeIn, flag) => {                 const node = getParseTreeNode(nodeIn);                 if (!node) return false;                 return hasNodeCheckFlag(node, flag);             },             isTopLevelValueImportEqualsWithEntityName,             isDeclarationVisible,             isImplementationOfOverload,             requiresAddingImplicitUndefined,             isExpandoFunctionDeclaration,             getPropertiesOfContainerFunction,             createTypeOfDeclaration,             createReturnTypeOfSignatureDeclaration,             createTypeOfExpression,             createLiteralConstValue,             isSymbolAccessible,             isEntityNameVisible,             getConstantValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, canHaveConstantValue);                 return node ? getConstantValue(node) : undefined;             },             getEnumMemberValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, isEnumMember);                 return node ? getEnumMemberValue(node) : undefined;             },             collectLinkedAliases,             markLinkedReferences: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 return node && markLinkedReferences(node, ReferenceHint.Unspecified);             },             getReferencedValueDeclaration,             getReferencedValueDeclarations,             getTypeReferenceSerializationKind,             isOptionalParameter,             isArgumentsLocalBinding,             getExternalModuleFileFromDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);                 return node && getExternalModuleFileFromDeclaration(node);             },             isLiteralConstDeclaration,             isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {                 const node = getParseTreeNode(nodeIn, isDeclaration);                 const symbol = node && getSymbolOfDeclaration(node);                 return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);             },             getJsxFactoryEntity,             getJsxFragmentFactoryEntity,             isBindingCapturedByNode: (node, decl) => {                 const parseNode = getParseTreeNode(node);                 const parseDecl = getParseTreeNode(decl);                 return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);             },             getDeclarationStatementsForSourceFile: (node, flags, internalFlags, tracker) => {                 const n = getParseTreeNode(node) as SourceFile;                 Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile");                 const sym = getSymbolOfDeclaration(node);                 if (!sym) {                     return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker);                 }                 resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup                 return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker);             },             isImportRequiredByAugmentation,             isDefinitelyReferenceToGlobalSymbolObject,         } */ TODO
		isImportRequiredByAugmentation := func(node ImportDeclaration) /* TODO(undefined): boolean */ TODO {
			file := getSourceFileOfNode(node)
			if ! /* TODO(PropertyAccessExpression): file.symbol */ TODO {
				/* TODO(FalseKeyword): false */
			}
			importTarget := getExternalModuleFileFromDeclaration(node)
			if !importTarget {
				/* TODO(FalseKeyword): false */
			}
			if importTarget == file {
				/* TODO(FalseKeyword): false */
			}
			exports := getExportsOfModule( /* TODO(PropertyAccessExpression): file.symbol */ TODO)
			for _, s := range arrayFrom( /* TODO(PropertyAccessExpression): exports.values */ TODO()) {
				if /* TODO(PropertyAccessExpression): s.mergeId */ TODO {
					merged := getMergedSymbol(s)
					if /* TODO(PropertyAccessExpression): merged.declarations */ TODO {
						for _, d := range /* TODO(PropertyAccessExpression): merged.declarations */ TODO {
							declFile := getSourceFileOfNode(d)
							if declFile == importTarget {
								return /* TODO(TrueKeyword): true */ TODO
							}
						}
					}
				}
			}
			return /* TODO(FalseKeyword): false */ TODO
		}
	}
	getExternalModuleFileFromDeclaration := func(declaration /* TODO(UnionType): AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
		specifier := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration) */ TODO
		moduleSymbol := resolveExternalModuleNameWorker( /* TODO(NonNullExpression): specifier! */ TODO /* TODO(NonNullExpression): specifier! */, TODO, nil)
		if !moduleSymbol {
			return nil
		}
		return getDeclarationOfKind(moduleSymbol /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */, TODO)
	}
	initializeTypeChecker := func() {
		for _, file := range /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO() {
			bindSourceFile(file, compilerOptions)
		}
		/* TODO(ExpressionStatement): amalgamatedDuplicates = new Map(); */
		var augmentations /* TODO(ArrayType): (readonly (StringLiteral | Identifier)[])[] */ any
		for _, file := range /* TODO(PropertyAccessExpression): host.getSourceFiles */ TODO() {
			if /* TODO(PropertyAccessExpression): file.redirectInfo */ TODO {
				/* TODO(ContinueStatement): continue; */
			}
			if !isExternalOrCommonJsModule(file) {
				fileGlobalThisSymbol := /* TODO(PropertyAccessExpression): file.locals!.get */ TODO("globalThis" /* as */ /* TODO(TypeReference): __String */)
				if /* TODO(PropertyAccessExpression): fileGlobalThisSymbol?.declarations */ TODO {
					for _, declaration := range /* TODO(PropertyAccessExpression): fileGlobalThisSymbol.declarations */ TODO {
						/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNode(declaration /* TODO(PropertyAccessExpression): Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0 */, TODO, "globalThis"))
					}
				}
				mergeSymbolTable(globals /* TODO(NonNullExpression): file.locals! */, TODO)
			}
			if /* TODO(PropertyAccessExpression): file.jsGlobalAugmentations */ TODO {
				mergeSymbolTable(globals /* TODO(PropertyAccessExpression): file.jsGlobalAugmentations */, TODO)
			}
			if /* TODO(PropertyAccessExpression): file.patternAmbientModules */ TODO && /* TODO(PropertyAccessExpression): file.patternAmbientModules.length */ TODO {
				/* TODO(ExpressionStatement): patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules); */
			}
			if /* TODO(PropertyAccessExpression): file.moduleAugmentations.length */ TODO {
				/* TODO(PropertyAccessExpression): (augmentations || (augmentations = [])).push */ TODO( /* TODO(PropertyAccessExpression): file.moduleAugmentations */ TODO)
			}
			if /* TODO(PropertyAccessExpression): file.symbol */ TODO && /* TODO(PropertyAccessExpression): file.symbol.globalExports */ TODO {
				source := /* TODO(PropertyAccessExpression): file.symbol.globalExports */ TODO
				/* TODO(PropertyAccessExpression): source.forEach */ TODO( /* TODO(ArrowFunction): (sourceSymbol, id) => {                     if (!globals.has(id)) {                         globals.set(id, sourceSymbol);                     }                 } */ TODO)
			}
		}
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if !isGlobalScopeAugmentation( /* TODO(PropertyAccessExpression): augmentation.parent */ TODO /* as */ /* TODO(TypeReference): ModuleDeclaration */) {
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		addUndefinedToGlobalsOrErrorOnRedeclaration()
		/* TODO(ExpressionStatement): getSymbolLinks(undefinedSymbol).type = undefinedWideningType; */
		/* TODO(ExpressionStatement): getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): getSymbolLinks(unknownSymbol).type = errorType; */
		/* TODO(ExpressionStatement): getSymbolLinks(globalThisSymbol).type = createObjectType(ObjectFlags.Anonymous, globalThisSymbol); */
		/* TODO(ExpressionStatement): globalArrayType = getGlobalType("Array" as __String, /*arity* / 1, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): globalObjectType = getGlobalType("Object" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): globalFunctionType = getGlobalType("Function" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction" as __String, /*arity* / 0, /*reportErrors* / true) || globalFunctionType; */
		/* TODO(ExpressionStatement): globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction" as __String, /*arity* / 0, /*reportErrors* / true) || globalFunctionType; */
		/* TODO(ExpressionStatement): globalStringType = getGlobalType("String" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): globalNumberType = getGlobalType("Number" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): globalBooleanType = getGlobalType("Boolean" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): globalRegExpType = getGlobalType("RegExp" as __String, /*arity* / 0, /*reportErrors* / true); */
		/* TODO(ExpressionStatement): anyArrayType = createArrayType(anyType); */
		/* TODO(ExpressionStatement): autoArrayType = createArrayType(autoType); */
		if autoArrayType == emptyObjectType {
			/* TODO(ExpressionStatement): autoArrayType = createAnonymousType(/*symbol* / undefined, emptySymbols, emptyArray, emptyArray, emptyArray); */
		}
		/* TODO(ExpressionStatement): globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray" as __String, /*arity* / 1) as GenericType || globalArrayType; */
		/* TODO(ExpressionStatement): anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType; */
		/* TODO(ExpressionStatement): globalThisType = getGlobalTypeOrUndefined("ThisType" as __String, /*arity* / 1) as GenericType; */
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if isGlobalScopeAugmentation( /* TODO(PropertyAccessExpression): augmentation.parent */ TODO /* as */ /* TODO(TypeReference): ModuleDeclaration */) {
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		/* TODO(PropertyAccessExpression): amalgamatedDuplicates.forEach */ TODO( /* TODO(ArrowFunction): ({ firstFile, secondFile, conflictingSymbols }) => {             // If not many things conflict, issue individual errors             if (conflictingSymbols.size < 8) {                 conflictingSymbols.forEach(({ isBlockScoped, firstFileLocations, secondFileLocations }, symbolName) => {                     const message = isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;                     for (const node of firstFileLocations) {                         addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);                     }                     for (const node of secondFileLocations) {                         addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);                     }                 });             }             else {                 // Otherwise issue top-level error since the files appear very identical in terms of what they contain                 const list = arrayFrom(conflictingSymbols.keys()).join(", ");                 diagnostics.add(addRelatedInfo(                     createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),                     createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file),                 ));                 diagnostics.add(addRelatedInfo(                     createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list),                     createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file),                 ));             }         } */ TODO)
		/* TODO(ExpressionStatement): amalgamatedDuplicates = undefined; */
	}
	checkExternalEmitHelpers := func(location Node, helpers ExternalEmitHelpers) {
		if /* TODO(PropertyAccessExpression): compilerOptions.importHelpers */ TODO {
			sourceFile := getSourceFileOfNode(location)
			if isEffectiveExternalModule(sourceFile, compilerOptions) && ! /* TODO(ParenthesizedExpression): (location.flags & NodeFlags.Ambient) */ TODO {
				helpersModule := resolveHelpersModule(sourceFile, location)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): helpersModule !== unknownSymbol */ TODO {
					links := getSymbolLinks(helpersModule)
					/* TODO(ExpressionStatement): links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers; */
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (links.requestedExternalEmitHelpers & helpers) !== helpers */ TODO {
						uncheckedHelpers := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): helpers & ~links.requestedExternalEmitHelpers */ TODO
						/* TODO(ForStatement): for (let helper = ExternalEmitHelpers.FirstEmitHelper; helper <= ExternalEmitHelpers.LastEmitHelper; helper <<= 1) {                             if (uncheckedHelpers & helper) {                                 for (const name of getHelperNames(helper)) {                                     const symbol = resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlags.Value));                                     if (!symbol) {                                         error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldGet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 3)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldSet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 4)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.SpreadArray) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 2)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3);                                         }                                     }                                 }                             }                         } */
					}
					/* TODO(ExpressionStatement): links.requestedExternalEmitHelpers |= helpers; */
				}
			}
		}
	}
	getHelperNames := func(helper ExternalEmitHelpers) /* TODO(undefined): string[] */ TODO {
		/* TODO(SwitchStatement): switch (helper) {             case ExternalEmitHelpers.Extends:                 return ["__extends"];             case ExternalEmitHelpers.Assign:                 return ["__assign"];             case ExternalEmitHelpers.Rest:                 return ["__rest"];             case ExternalEmitHelpers.Decorate:                 return legacyDecorators ? ["__decorate"] : ["__esDecorate", "__runInitializers"];             case ExternalEmitHelpers.Metadata:                 return ["__metadata"];             case ExternalEmitHelpers.Param:                 return ["__param"];             case ExternalEmitHelpers.Awaiter:                 return ["__awaiter"];             case ExternalEmitHelpers.Generator:                 return ["__generator"];             case ExternalEmitHelpers.Values:                 return ["__values"];             case ExternalEmitHelpers.Read:                 return ["__read"];             case ExternalEmitHelpers.SpreadArray:                 return ["__spreadArray"];             case ExternalEmitHelpers.Await:                 return ["__await"];             case ExternalEmitHelpers.AsyncGenerator:                 return ["__asyncGenerator"];             case ExternalEmitHelpers.AsyncDelegator:                 return ["__asyncDelegator"];             case ExternalEmitHelpers.AsyncValues:                 return ["__asyncValues"];             case ExternalEmitHelpers.ExportStar:                 return ["__exportStar"];             case ExternalEmitHelpers.ImportStar:                 return ["__importStar"];             case ExternalEmitHelpers.ImportDefault:                 return ["__importDefault"];             case ExternalEmitHelpers.MakeTemplateObject:                 return ["__makeTemplateObject"];             case ExternalEmitHelpers.ClassPrivateFieldGet:                 return ["__classPrivateFieldGet"];             case ExternalEmitHelpers.ClassPrivateFieldSet:                 return ["__classPrivateFieldSet"];             case ExternalEmitHelpers.ClassPrivateFieldIn:                 return ["__classPrivateFieldIn"];             case ExternalEmitHelpers.SetFunctionName:                 return ["__setFunctionName"];             case ExternalEmitHelpers.PropKey:                 return ["__propKey"];             case ExternalEmitHelpers.AddDisposableResourceAndDisposeResources:                 return ["__addDisposableResource", "__disposeResources"];             default:                 return Debug.fail("Unrecognized helper");         } */
	}
	resolveHelpersModule := func(file SourceFile, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		links := getNodeLinks(file)
		if ! /* TODO(PropertyAccessExpression): links.externalHelpersModule */ TODO {
			/* TODO(ExpressionStatement): links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol; */
		}
		return /* TODO(PropertyAccessExpression): links.externalHelpersModule */ TODO
	}
	checkGrammarModifiers := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
		quickResult := reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): quickResult !== undefined */ TODO {
			return quickResult
		}
		if isParameter(node) && parameterIsThisKeyword(node) {
			return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters */, TODO)
		}
		blockScopeKind := /* TODO(ConditionalExpression): isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None */ TODO
		var lastStatic Node
		var lastDeclare Node
		var lastAsync Node
		var lastOverride Node
		var firstDecorator *Decorator
		flags := /* TODO(PropertyAccessExpression): ModifierFlags.None */ TODO
		sawExportBeforeDecorators := /* TODO(FalseKeyword): false */ TODO
		hasLeadingDecorators := /* TODO(FalseKeyword): false */ TODO
		for _, modifier := range /* TODO(NonNullExpression): (node as HasModifiers).modifiers! */ TODO {
			if isDecorator(modifier) {
				if !nodeCanBeDecorated(legacyDecorators, node /* TODO(PropertyAccessExpression): node.parent */, TODO /* TODO(PropertyAccessExpression): node.parent.parent */, TODO) {
					if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO && !nodeIsPresent( /* TODO(PropertyAccessExpression): node.body */ TODO) {
						return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload */, TODO)
					} else {
						return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.Decorators_are_not_valid_here */, TODO)
					}
				} else if legacyDecorators && /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.GetAccessor || node.kind === SyntaxKind.SetAccessor) */ TODO {
					accessors := getAllAccessorDeclarationsForDeclaration(node /* as */ /* TODO(TypeReference): AccessorDeclaration */)
					if hasDecorators( /* TODO(PropertyAccessExpression): accessors.firstAccessor */ TODO) && node == /* TODO(PropertyAccessExpression): accessors.secondAccessor */ TODO {
						return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name */, TODO)
					}
				}
				if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ~(ModifierFlags.ExportDefault | ModifierFlags.Decorator) */ TODO {
					return grammarErrorOnNode(modifier /* TODO(PropertyAccessExpression): Diagnostics.Decorators_are_not_valid_here */, TODO)
				}
				if hasLeadingDecorators && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Modifier */ TODO {
					/* TODO(PropertyAccessExpression): Debug.assertIsDefined */ TODO(firstDecorator)
					sourceFile := getSourceFileOfNode(modifier)
					if !hasParseDiagnostics(sourceFile) {
						addRelatedInfo(error(modifier /* TODO(PropertyAccessExpression): Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export */, TODO), createDiagnosticForNode(firstDecorator /* TODO(PropertyAccessExpression): Diagnostics.Decorator_used_before_export_here */, TODO))
						return /* TODO(TrueKeyword): true */ TODO
					}
					return /* TODO(FalseKeyword): false */ TODO
				}
				/* TODO(ExpressionStatement): flags |= ModifierFlags.Decorator; */
				if ! /* TODO(ParenthesizedExpression): (flags & ModifierFlags.Modifier) */ TODO {
					/* TODO(ExpressionStatement): hasLeadingDecorators = true; */
				} else if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Export */ TODO {
					/* TODO(ExpressionStatement): sawExportBeforeDecorators = true; */
				}
				/* TODO(ExpressionStatement): firstDecorator ??= modifier; */
			} else {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.ReadonlyKeyword */ TODO {
					if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PropertySignature */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodSignature */ TODO {
						return grammarErrorOnNode(modifier /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_type_member */, TODO, tokenToString( /* TODO(PropertyAccessExpression): modifier.kind */ TODO))
					}
					if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.IndexSignature */ TODO && /* TODO(ParenthesizedExpression): (modifier.kind !== SyntaxKind.StaticKeyword || !isClassLike(node.parent)) */ TODO {
						return grammarErrorOnNode(modifier /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_an_index_signature */, TODO, tokenToString( /* TODO(PropertyAccessExpression): modifier.kind */ TODO))
					}
				}
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.InKeyword */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.OutKeyword */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.ConstKeyword */ TODO {
					if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeParameter */ TODO {
						return grammarErrorOnNode(modifier /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_type_parameter */, TODO, tokenToString( /* TODO(PropertyAccessExpression): modifier.kind */ TODO))
					}
				}
				/* TODO(SwitchStatement): switch (modifier.kind) {                     case SyntaxKind.ConstKeyword: {                         if (node.kind !== SyntaxKind.EnumDeclaration && node.kind !== SyntaxKind.TypeParameter) {                             return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKind.ConstKeyword));                         }                         const parent = (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent;                         if (                             node.kind === SyntaxKind.TypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) ||                                 isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent))                         ) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind));                         }                         break;                     }                     case SyntaxKind.OverrideKeyword:                         // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.                         if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");                         }                         flags |= ModifierFlags.Override;                         lastOverride = modifier;                         break;                      case SyntaxKind.PublicKeyword:                     case SyntaxKind.ProtectedKeyword:                     case SyntaxKind.PrivateKeyword:                         const text = visibilityToString(modifierToFlag(modifier.kind));                          if (flags & ModifierFlags.AccessibilityModifier) {                             return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen);                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override");                         }                         else if (flags & ModifierFlags.Static) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async");                         }                         else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);                         }                         else if (flags & ModifierFlags.Abstract) {                             if (modifier.kind === SyntaxKind.PrivateKeyword) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");                             }                             else {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");                             }                         }                         else if (isPrivateIdentifierClassElementDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);                         }                         flags |= modifierToFlag(modifier.kind);                         break;                      case SyntaxKind.StaticKeyword:                         if (flags & ModifierFlags.Static) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor");                         }                         else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");                         }                         else if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");                         }                         flags |= ModifierFlags.Static;                         lastStatic = modifier;                         break;                      case SyntaxKind.AccessorKeyword:                         if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare");                         }                         else if (node.kind !== SyntaxKind.PropertyDeclaration) {                             return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration);                         }                          flags |= ModifierFlags.Accessor;                         break;                      case SyntaxKind.ReadonlyKeyword:                         if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly");                         }                         else if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature && node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.Parameter) {                             // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.                             return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor");                         }                         flags |= ModifierFlags.Readonly;                         break;                      case SyntaxKind.ExportKeyword:                         if (                             compilerOptions.verbatimModuleSyntax &&                             !(node.flags & NodeFlags.Ambient) &&                             node.kind !== SyntaxKind.TypeAliasDeclaration &&                             node.kind !== SyntaxKind.InterfaceDeclaration &&                             // ModuleDeclaration needs to be checked that it is uninstantiated later                             node.kind !== SyntaxKind.ModuleDeclaration &&                             node.parent.kind === SyntaxKind.SourceFile &&                             host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS                         ) {                             return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);                         }                         if (flags & ModifierFlags.Export) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");                         }                         else if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");                         }                         else if (isClassLike(node.parent)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export");                         }                         flags |= ModifierFlags.Export;                         break;                     case SyntaxKind.DefaultKeyword:                         const container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;                         if (container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(container)) {                             return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default");                         }                         else if (!(flags & ModifierFlags.Export)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");                         }                         else if (sawExportBeforeDecorators) {                             return grammarErrorOnNode(firstDecorator!, Diagnostics.Decorators_are_not_valid_here);                         }                          flags |= ModifierFlags.Default;                         break;                     case SyntaxKind.DeclareKeyword:                         if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");                         }                         else if (isClassLike(node.parent) && !isPropertyDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare");                         }                         else if ((node.parent.flags & NodeFlags.Ambient) && node.parent.kind === SyntaxKind.ModuleBlock) {                             return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);                         }                         else if (isPrivateIdentifierClassElementDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor");                         }                         flags |= ModifierFlags.Ambient;                         lastDeclare = modifier;                         break;                      case SyntaxKind.AbstractKeyword:                         if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract");                         }                         if (                             node.kind !== SyntaxKind.ClassDeclaration &&                             node.kind !== SyntaxKind.ConstructorType                         ) {                             if (                                 node.kind !== SyntaxKind.MethodDeclaration &&                                 node.kind !== SyntaxKind.PropertyDeclaration &&                                 node.kind !== SyntaxKind.GetAccessor &&                                 node.kind !== SyntaxKind.SetAccessor                             ) {                                 return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);                             }                             if (!(node.parent.kind === SyntaxKind.ClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlags.Abstract))) {                                 const message = node.kind === SyntaxKind.PropertyDeclaration                                     ? Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class                                     : Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class;                                 return grammarErrorOnNode(modifier, message);                             }                             if (flags & ModifierFlags.Static) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");                             }                             if (flags & ModifierFlags.Private) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");                             }                             if (flags & ModifierFlags.Async && lastAsync) {                                 return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");                             }                             if (flags & ModifierFlags.Override) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");                             }                             if (flags & ModifierFlags.Accessor) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor");                             }                         }                         if (isNamedDeclaration(node) && node.name.kind === SyntaxKind.PrivateIdentifier) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");                         }                          flags |= ModifierFlags.Abstract;                         break;                      case SyntaxKind.AsyncKeyword:                         if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async");                         }                         else if (flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");                         }                         if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");                         }                         flags |= ModifierFlags.Async;                         lastAsync = modifier;                         break;                      case SyntaxKind.InKeyword:                     case SyntaxKind.OutKeyword: {                         const inOutFlag = modifier.kind === SyntaxKind.InKeyword ? ModifierFlags.In : ModifierFlags.Out;                         const inOutText = modifier.kind === SyntaxKind.InKeyword ? "in" : "out";                         const parent = isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent)?.tags, isJSDocTypedefTag)) || node.parent;                         if (node.kind !== SyntaxKind.TypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent))) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);                         }                         if (flags & inOutFlag) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText);                         }                         if (inOutFlag & ModifierFlags.In && flags & ModifierFlags.Out) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");                         }                         flags |= inOutFlag;                         break;                     }                 } */
			}
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Constructor */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Static */ TODO {
				return grammarErrorOnNode( /* TODO(NonNullExpression): lastStatic! */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration */, TODO, "static")
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Override */ TODO {
				return grammarErrorOnNode( /* TODO(NonNullExpression): lastOverride! */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration */, TODO, "override")
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Async */ TODO {
				return grammarErrorOnNode( /* TODO(NonNullExpression): lastAsync! */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration */, TODO, "async")
			}
			return /* TODO(FalseKeyword): false */ TODO
		} else if /* TODO(ParenthesizedExpression): (node.kind === SyntaxKind.ImportDeclaration || node.kind === SyntaxKind.ImportEqualsDeclaration) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Ambient */ TODO {
			return grammarErrorOnNode( /* TODO(NonNullExpression): lastDeclare! */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration */, TODO, "declare")
		} else if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO && /* TODO(ParenthesizedExpression): (flags & ModifierFlags.ParameterPropertyModifier) */ TODO && isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern */, TODO)
		} else if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Parameter */ TODO && /* TODO(ParenthesizedExpression): (flags & ModifierFlags.ParameterPropertyModifier) */ TODO && /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter */, TODO)
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): flags & ModifierFlags.Async */ TODO {
			return checkGrammarAsyncModifier(node /* TODO(NonNullExpression): lastAsync! */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	reportObviousModifierErrors := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) /* TODO(BooleanKeyword): boolean */ any {
		if ! /* TODO(PropertyAccessExpression): node.modifiers */ TODO {
			/* TODO(FalseKeyword): false */
		}
		modifier := findFirstIllegalModifier(node)
		return modifier && grammarErrorOnFirstToken(modifier /* TODO(PropertyAccessExpression): Diagnostics.Modifiers_cannot_appear_here */, TODO)
	}
	findFirstModifierExcept := func(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
		modifier := find( /* TODO(PropertyAccessExpression): node.modifiers */ TODO, isModifier)
		return /* TODO(ConditionalExpression): modifier && modifier.kind !== allowedModifier ? modifier : undefined */ TODO
	}
	findFirstIllegalModifier := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) *Modifier {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:             case SyntaxKind.Constructor:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:             case SyntaxKind.IndexSignature:             case SyntaxKind.ModuleDeclaration:             case SyntaxKind.ImportDeclaration:             case SyntaxKind.ImportEqualsDeclaration:             case SyntaxKind.ExportDeclaration:             case SyntaxKind.ExportAssignment:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.Parameter:             case SyntaxKind.TypeParameter:                 return undefined;             case SyntaxKind.ClassStaticBlockDeclaration:             case SyntaxKind.PropertyAssignment:             case SyntaxKind.ShorthandPropertyAssignment:             case SyntaxKind.NamespaceExportDeclaration:             case SyntaxKind.MissingDeclaration:                 return find(node.modifiers, isModifier);             default:                 if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                     return undefined;                 }                 switch (node.kind) {                     case SyntaxKind.FunctionDeclaration:                         return findFirstModifierExcept(node, SyntaxKind.AsyncKeyword);                     case SyntaxKind.ClassDeclaration:                     case SyntaxKind.ConstructorType:                         return findFirstModifierExcept(node, SyntaxKind.AbstractKeyword);                     case SyntaxKind.ClassExpression:                     case SyntaxKind.InterfaceDeclaration:                     case SyntaxKind.TypeAliasDeclaration:                         return find(node.modifiers, isModifier);                     case SyntaxKind.VariableStatement:                         return node.declarationList.flags & NodeFlags.Using ?                             findFirstModifierExcept(node, SyntaxKind.AwaitKeyword) :                             find(node.modifiers, isModifier);                     case SyntaxKind.EnumDeclaration:                         return findFirstModifierExcept(node, SyntaxKind.ConstKeyword);                     default:                         Debug.assertNever(node);                 }         } */
	}
	reportObviousDecoratorErrors := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) /* TODO(undefined): boolean | undefined */ TODO {
		decorator := findFirstIllegalDecorator(node)
		return decorator && grammarErrorOnFirstToken(decorator /* TODO(PropertyAccessExpression): Diagnostics.Decorators_are_not_valid_here */, TODO)
	}
	findFirstIllegalDecorator := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
		return /* TODO(ConditionalExpression): canHaveIllegalDecorators(node) ? find(node.modifiers, isDecorator) : undefined */ TODO
	}
	checkGrammarAsyncModifier := func(node Node, asyncModifier Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.MethodDeclaration:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return false;         } */
		return grammarErrorOnNode(asyncModifier /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_be_used_here */, TODO, "async")
	}
	checkGrammarForDisallowedTrailingComma := func(list *NodeArray[Node], diag /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO /* = */ /* TODO(PropertyAccessExpression): Diagnostics.Trailing_comma_not_allowed */) bool {
		if list && /* TODO(PropertyAccessExpression): list.hasTrailingComma */ TODO {
			return grammarErrorAtPos( /* TODO(ElementAccessExpression): list[0] */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): list.end - ",".length */, TODO /* TODO(PropertyAccessExpression): ",".length */, TODO, diag)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarTypeParameterList := func(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
		if typeParameters && /* TODO(PropertyAccessExpression): typeParameters.length */ TODO == 0 {
			start := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): typeParameters.pos - "<".length */ TODO
			end := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): skipTrivia(file.text, typeParameters.end) + ">".length */ TODO
			return grammarErrorAtPos(file, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_parameter_list_cannot_be_empty */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarParameterList := func(parameters NodeArray[ParameterDeclaration]) /* TODO(undefined): boolean | undefined */ TODO {
		seenOptionalParameter := /* TODO(FalseKeyword): false */ TODO
		parameterCount := /* TODO(PropertyAccessExpression): parameters.length */ TODO
		/* TODO(ForStatement): for (let i = 0; i < parameterCount; i++) {             const parameter = parameters[i];             if (parameter.dotDotDotToken) {                 if (i !== (parameterCount - 1)) {                     return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);                 }                 if (!(parameter.flags & NodeFlags.Ambient)) { // Allow `...foo,` in ambient declarations; see GH#23070                     checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);                 }                  if (parameter.questionToken) {                     return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);                 }                  if (parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);                 }             }             else if (hasEffectiveQuestionToken(parameter)) {                 seenOptionalParameter = true;                 if (parameter.questionToken && parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);                 }             }             else if (seenOptionalParameter && !parameter.initializer) {                 return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);             }         } */
	}
	getNonSimpleParameters := func(parameters []ParameterDeclaration) []ParameterDeclaration {
		return filter(parameters /* TODO(ArrowFunction): parameter => !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter) */, TODO)
	}
	checkGrammarForUseStrictSimpleParameterList := func(node FunctionLikeDeclaration) bool {
		if languageVersion >= /* TODO(PropertyAccessExpression): ScriptTarget.ES2016 */ TODO {
			useStrictDirective := /* TODO(PropertyAccessExpression): node.body */ TODO && isBlock( /* TODO(PropertyAccessExpression): node.body */ TODO) && findUseStrictPrologue( /* TODO(PropertyAccessExpression): node.body.statements */ TODO)
			if useStrictDirective {
				nonSimpleParameters := getNonSimpleParameters( /* TODO(PropertyAccessExpression): node.parameters */ TODO)
				if length(nonSimpleParameters) {
					forEach(nonSimpleParameters /* TODO(ArrowFunction): parameter => {                         addRelatedInfo(                             error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive),                             createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here),                         );                     } */, TODO)
					diagnostics := /* TODO(PropertyAccessExpression): nonSimpleParameters.map */ TODO( /* TODO(ArrowFunction): (parameter, index) => (                         index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here)                     ) */ TODO) /* as */ /* TODO(TupleType): [DiagnosticWithLocation, ...DiagnosticWithLocation[]] */
					addRelatedInfo(error(useStrictDirective /* TODO(PropertyAccessExpression): Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list */, TODO) /* TODO(SpreadElement): ...diagnostics */, TODO)
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarFunctionLikeDeclaration := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarModifiers(node) || checkGrammarTypeParameterList( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO, file) || checkGrammarParameterList( /* TODO(PropertyAccessExpression): node.parameters */ TODO) || checkGrammarArrowFunction(node, file) || /* TODO(ParenthesizedExpression): (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node)) */ TODO
	}
	checkGrammarClassLikeDeclaration := func(node ClassLikeDeclaration) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList( /* TODO(PropertyAccessExpression): node.typeParameters */ TODO, file)
	}
	checkGrammarArrowFunction := func(node Node, file SourceFile) bool {
		if !isArrowFunction(node) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(PropertyAccessExpression): node.typeParameters */ TODO && ! /* TODO(ParenthesizedExpression): (length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint) */ TODO {
			if file && fileExtensionIsOneOf( /* TODO(PropertyAccessExpression): file.fileName */ TODO /* TODO(ArrayLiteralExpression): [Extension.Mts, Extension.Cts] */, TODO) {
				grammarErrorOnNode( /* TODO(ElementAccessExpression): node.typeParameters[0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint */, TODO)
			}
		}
		TODO_IDENTIFIER := node
		startLine := /* TODO(PropertyAccessExpression): getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line */ TODO
		endLine := /* TODO(PropertyAccessExpression): getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line */ TODO
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): startLine !== endLine */ TODO && grammarErrorOnNode(equalsGreaterThanToken /* TODO(PropertyAccessExpression): Diagnostics.Line_terminator_not_permitted_before_arrow */, TODO)
	}
	checkGrammarIndexSignatureParameters := func(node SignatureDeclaration) bool {
		parameter := /* TODO(ElementAccessExpression): node.parameters[0] */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parameters.length !== 1 */ TODO {
			if parameter {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_must_have_exactly_one_parameter */, TODO)
			} else {
				return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_must_have_exactly_one_parameter */, TODO)
			}
		}
		checkGrammarForDisallowedTrailingComma( /* TODO(PropertyAccessExpression): node.parameters */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_cannot_have_a_trailing_comma */, TODO)
		if /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_cannot_have_a_rest_parameter */, TODO)
		}
		if hasEffectiveModifiers(parameter) {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier */, TODO)
		}
		if /* TODO(PropertyAccessExpression): parameter.questionToken */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.questionToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark */, TODO)
		}
		if /* TODO(PropertyAccessExpression): parameter.initializer */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_cannot_have_an_initializer */, TODO)
		}
		if ! /* TODO(PropertyAccessExpression): parameter.type */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_must_have_a_type_annotation */, TODO)
		}
		type_ := getTypeFromTypeNode( /* TODO(PropertyAccessExpression): parameter.type */ TODO)
		if someType(type_ /* TODO(ArrowFunction): t => !!(t.flags & TypeFlags.StringOrNumberLiteralOrUnique) */, TODO) || isGenericType(type_) {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead */, TODO)
		}
		if !everyType(type_, isValidIndexKeyType) {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type */, TODO)
		}
		if ! /* TODO(PropertyAccessExpression): node.type */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.An_index_signature_must_have_a_type_annotation */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarIndexSignature := func(node IndexSignatureDeclaration) /* TODO(undefined): boolean */ TODO {
		return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node)
	}
	checkGrammarForAtLeastOneTypeArgument := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		if typeArguments && /* TODO(PropertyAccessExpression): typeArguments.length */ TODO == 0 {
			sourceFile := getSourceFileOfNode(node)
			start := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): typeArguments.pos - "<".length */ TODO
			end := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): skipTrivia(sourceFile.text, typeArguments.end) + ">".length */ TODO
			return grammarErrorAtPos(sourceFile, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_argument_list_cannot_be_empty */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarTypeArguments := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments)
	}
	checkGrammarTaggedTemplateChain := func(node TaggedTemplateExpression) bool {
		if /* TODO(PropertyAccessExpression): node.questionDotToken */ TODO || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.OptionalChain */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.template */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarHeritageClause := func(node HeritageClause) bool {
		types := /* TODO(PropertyAccessExpression): node.types */ TODO
		if checkGrammarForDisallowedTrailingComma(types) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if types && /* TODO(PropertyAccessExpression): types.length */ TODO == 0 {
			listType := tokenToString( /* TODO(PropertyAccessExpression): node.token */ TODO)
			return grammarErrorAtPos(node /* TODO(PropertyAccessExpression): types.pos */, TODO, 0 /* TODO(PropertyAccessExpression): Diagnostics._0_list_cannot_be_empty */, TODO, listType)
		}
		return some(types, checkGrammarExpressionWithTypeArguments)
	}
	checkGrammarExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO(undefined): boolean */ TODO {
		if isExpressionWithTypeArguments(node) && isImportKeyword( /* TODO(PropertyAccessExpression): node.expression */ TODO) && /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments */, TODO)
		}
		return checkGrammarTypeArguments(node /* TODO(PropertyAccessExpression): node.typeArguments */, TODO)
	}
	checkGrammarClassDeclarationHeritageClauses := func(node ClassLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		seenExtendsClause := /* TODO(FalseKeyword): false */ TODO
		seenImplementsClause := /* TODO(FalseKeyword): false */ TODO
		if !checkGrammarModifiers(node) && /* TODO(PropertyAccessExpression): node.heritageClauses */ TODO {
			for _, heritageClause := range /* TODO(PropertyAccessExpression): node.heritageClauses */ TODO {
				if /* TODO(PropertyAccessExpression): heritageClause.token */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExtendsKeyword */ TODO {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause /* TODO(PropertyAccessExpression): Diagnostics.extends_clause_already_seen */, TODO)
					}
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause /* TODO(PropertyAccessExpression): Diagnostics.extends_clause_must_precede_implements_clause */, TODO)
					}
					if /* TODO(PropertyAccessExpression): heritageClause.types.length */ TODO > 1 {
						return grammarErrorOnFirstToken( /* TODO(ElementAccessExpression): heritageClause.types[1] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Classes_can_only_extend_a_single_class */, TODO)
					}
					/* TODO(ExpressionStatement): seenExtendsClause = true; */
				} else {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): heritageClause.token */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImplementsKeyword */ TODO)
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause /* TODO(PropertyAccessExpression): Diagnostics.implements_clause_already_seen */, TODO)
					}
					/* TODO(ExpressionStatement): seenImplementsClause = true; */
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
	}
	checkGrammarInterfaceDeclaration := func(node InterfaceDeclaration) /* TODO(undefined): boolean */ TODO {
		seenExtendsClause := /* TODO(FalseKeyword): false */ TODO
		if /* TODO(PropertyAccessExpression): node.heritageClauses */ TODO {
			for _, heritageClause := range /* TODO(PropertyAccessExpression): node.heritageClauses */ TODO {
				if /* TODO(PropertyAccessExpression): heritageClause.token */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExtendsKeyword */ TODO {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause /* TODO(PropertyAccessExpression): Diagnostics.extends_clause_already_seen */, TODO)
					}
					/* TODO(ExpressionStatement): seenExtendsClause = true; */
				} else {
					/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): heritageClause.token */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImplementsKeyword */ TODO)
					return grammarErrorOnFirstToken(heritageClause /* TODO(PropertyAccessExpression): Diagnostics.Interface_declaration_cannot_have_implements_clause */, TODO)
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarComputedPropertyName := func(node Node) bool {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ComputedPropertyName */ TODO {
			return /* TODO(FalseKeyword): false */ TODO
		}
		computedPropertyName := node /* as */ /* TODO(TypeReference): ComputedPropertyName */
		if /* TODO(PropertyAccessExpression): computedPropertyName.expression.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BinaryExpression */ TODO && /* TODO(PropertyAccessExpression): (computedPropertyName.expression as BinaryExpression).operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.CommaToken */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): computedPropertyName.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarForGenerator := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.FunctionExpression */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO)
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Generators_are_not_allowed_in_an_ambient_context */, TODO)
			}
			if ! /* TODO(PropertyAccessExpression): node.body */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.asteriskToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator */, TODO)
			}
		}
	}
	checkGrammarForInvalidQuestionMark := func(questionToken *QuestionToken, message DiagnosticMessage) bool {
		return !!questionToken && grammarErrorOnNode(questionToken, message)
	}
	checkGrammarForInvalidExclamationToken := func(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
		return !!exclamationToken && grammarErrorOnNode(exclamationToken, message)
	}
	checkGrammarObjectLiteralExpression := func(node ObjectLiteralExpression, inDestructuring bool) /* TODO(undefined): boolean | undefined */ TODO {
		seen := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		for _, prop := range /* TODO(PropertyAccessExpression): node.properties */ TODO {
			if /* TODO(PropertyAccessExpression): prop.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SpreadAssignment */ TODO {
				if inDestructuring {
					expression := skipParentheses( /* TODO(PropertyAccessExpression): prop.expression */ TODO)
					if isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression) {
						return grammarErrorOnNode( /* TODO(PropertyAccessExpression): prop.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_contain_a_binding_pattern */, TODO)
					}
				}
				/* TODO(ContinueStatement): continue; */
			}
			name := /* TODO(PropertyAccessExpression): prop.name */ TODO
			if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ComputedPropertyName */ TODO {
				checkGrammarComputedPropertyName(name)
			}
			if /* TODO(PropertyAccessExpression): prop.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ShorthandPropertyAssignment */ TODO && !inDestructuring && /* TODO(PropertyAccessExpression): prop.objectAssignmentInitializer */ TODO {
				grammarErrorOnNode( /* TODO(NonNullExpression): prop.equalsToken! */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern */, TODO)
			}
			if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PrivateIdentifier */ TODO {
				grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies */, TODO)
			}
			if canHaveModifiers(prop) && /* TODO(PropertyAccessExpression): prop.modifiers */ TODO {
				for _, mod := range /* TODO(PropertyAccessExpression): prop.modifiers */ TODO {
					if isModifier(mod) && /* TODO(ParenthesizedExpression): (mod.kind !== SyntaxKind.AsyncKeyword || prop.kind !== SyntaxKind.MethodDeclaration) */ TODO {
						grammarErrorOnNode(mod /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_be_used_here */, TODO, getTextOfNode(mod))
					}
				}
			} else if canHaveIllegalModifiers(prop) && /* TODO(PropertyAccessExpression): prop.modifiers */ TODO {
				for _, mod := range /* TODO(PropertyAccessExpression): prop.modifiers */ TODO {
					if isModifier(mod) {
						grammarErrorOnNode(mod /* TODO(PropertyAccessExpression): Diagnostics._0_modifier_cannot_be_used_here */, TODO, getTextOfNode(mod))
					}
				}
			}
			var currentKind DeclarationMeaning
			/* TODO(SwitchStatement): switch (prop.kind) {                 case SyntaxKind.ShorthandPropertyAssignment:                 case SyntaxKind.PropertyAssignment:                     // Grammar checking for computedPropertyName and shorthandPropertyAssignment                     checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);                     checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional);                     if (name.kind === SyntaxKind.NumericLiteral) {                         checkGrammarNumericLiteral(name);                     }                     if (name.kind === SyntaxKind.BigIntLiteral) {                         addErrorOrSuggestion(/*isError* / true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name));                     }                     currentKind = DeclarationMeaning.PropertyAssignment;                     break;                 case SyntaxKind.MethodDeclaration:                     currentKind = DeclarationMeaning.Method;                     break;                 case SyntaxKind.GetAccessor:                     currentKind = DeclarationMeaning.GetAccessor;                     break;                 case SyntaxKind.SetAccessor:                     currentKind = DeclarationMeaning.SetAccessor;                     break;                 default:                     Debug.assertNever(prop, "Unexpected syntax kind:" + (prop as Node).kind);             } */
			if !inDestructuring {
				effectiveName := getEffectivePropertyNameForPropertyNameNode(name)
				if effectiveName == nil {
					/* TODO(ContinueStatement): continue; */
				}
				existingKind := /* TODO(PropertyAccessExpression): seen.get */ TODO(effectiveName)
				if !existingKind {
					/* TODO(PropertyAccessExpression): seen.set */ TODO(effectiveName, currentKind)
				} else {
					if /* TODO(ParenthesizedExpression): (currentKind & DeclarationMeaning.Method) */ TODO && /* TODO(ParenthesizedExpression): (existingKind & DeclarationMeaning.Method) */ TODO {
						grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.Duplicate_identifier_0 */, TODO, getTextOfNode(name))
					} else if /* TODO(ParenthesizedExpression): (currentKind & DeclarationMeaning.PropertyAssignment) */ TODO && /* TODO(ParenthesizedExpression): (existingKind & DeclarationMeaning.PropertyAssignment) */ TODO {
						grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name */, TODO, getTextOfNode(name))
					} else if /* TODO(ParenthesizedExpression): (currentKind & DeclarationMeaning.GetOrSetAccessor) */ TODO && /* TODO(ParenthesizedExpression): (existingKind & DeclarationMeaning.GetOrSetAccessor) */ TODO {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existingKind !== DeclarationMeaning.GetOrSetAccessor */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): currentKind !== existingKind */ TODO {
							/* TODO(PropertyAccessExpression): seen.set */ TODO(effectiveName /* TODO(BarToken): | */ /* TODO(BinaryExpression): currentKind | existingKind */, TODO)
						} else {
							return grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name */, TODO)
						}
					} else {
						return grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name */, TODO)
					}
				}
			}
		}
	}
	checkGrammarJsxElement := func(node JsxOpeningLikeElement) /* TODO(undefined): boolean | undefined */ TODO {
		checkGrammarJsxName( /* TODO(PropertyAccessExpression): node.tagName */ TODO)
		checkGrammarTypeArguments(node /* TODO(PropertyAccessExpression): node.typeArguments */, TODO)
		seen := /* TODO(NewExpression): new Map<__String, boolean>() */ TODO
		for _, attr := range /* TODO(PropertyAccessExpression): node.attributes.properties */ TODO {
			if /* TODO(PropertyAccessExpression): attr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JsxSpreadAttribute */ TODO {
				/* TODO(ContinueStatement): continue; */
			}
			TODO_IDENTIFIER := attr
			escapedText := getEscapedTextOfJsxAttributeName(name)
			if ! /* TODO(PropertyAccessExpression): seen.get */ TODO(escapedText) {
				/* TODO(PropertyAccessExpression): seen.set */ TODO(escapedText /* TODO(TrueKeyword): true */, TODO)
			} else {
				return grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name */, TODO)
			}
			if initializer && /* TODO(PropertyAccessExpression): initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.JsxExpression */ TODO && ! /* TODO(PropertyAccessExpression): initializer.expression */ TODO {
				return grammarErrorOnNode(initializer /* TODO(PropertyAccessExpression): Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression */, TODO)
			}
		}
	}
	checkGrammarJsxName := func(node JsxTagNameExpression) /* TODO(undefined): boolean | undefined */ TODO {
		if isPropertyAccessExpression(node) && isJsxNamespacedName( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names */, TODO)
		}
		if isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName( /* TODO(PropertyAccessExpression): node.namespace.escapedText */ TODO) {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.React_components_cannot_include_JSX_namespace_names */, TODO)
		}
	}
	checkGrammarJsxExpression := func(node JsxExpression) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): node.expression */ TODO && isCommaSequence( /* TODO(PropertyAccessExpression): node.expression */ TODO) {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.expression */ TODO /* TODO(PropertyAccessExpression): Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array */, TODO)
		}
	}
	checkGrammarForInOrForOfStatement := func(forInOrOfStatement ForInOrOfStatement) bool {
		if checkGrammarStatementInAmbientContext(forInOrOfStatement) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(PropertyAccessExpression): forInOrOfStatement.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ForOfStatement */ TODO && /* TODO(PropertyAccessExpression): forInOrOfStatement.awaitModifier */ TODO {
			if ! /* TODO(ParenthesizedExpression): (forInOrOfStatement.flags & NodeFlags.AwaitContext) */ TODO {
				sourceFile := getSourceFileOfNode(forInOrOfStatement)
				if isInTopLevelContext(forInOrOfStatement) {
					if !hasParseDiagnostics(sourceFile) {
						if !isEffectiveExternalModule(sourceFile, compilerOptions) {
							/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNode( /* TODO(PropertyAccessExpression): forInOrOfStatement.awaitModifier */ TODO /* TODO(PropertyAccessExpression): Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module */, TODO))
						}
						/* TODO(SwitchStatement): switch (moduleKind) {                             case ModuleKind.Node16:                             case ModuleKind.NodeNext:                                 if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {                                     diagnostics.add(                                         createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),                                     );                                     break;                                 }                                 // fallthrough                             case ModuleKind.ES2022:                             case ModuleKind.ESNext:                             case ModuleKind.Preserve:                             case ModuleKind.System:                                 if (languageVersion >= ScriptTarget.ES2017) {                                     break;                                 }                                 // fallthrough                             default:                                 diagnostics.add(                                     createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher),                                 );                                 break;                         } */
					}
				} else {
					if !hasParseDiagnostics(sourceFile) {
						diagnostic := createDiagnosticForNode( /* TODO(PropertyAccessExpression): forInOrOfStatement.awaitModifier */ TODO /* TODO(PropertyAccessExpression): Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */, TODO)
						func_ := getContainingFunction(forInOrOfStatement)
						if func_ && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.kind !== SyntaxKind.Constructor */ TODO {
							/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(ParenthesizedExpression): (getFunctionFlags(func) & FunctionFlags.Async) */ TODO == 0, "Enclosing function should never be an async function.")
							relatedInfo := createDiagnosticForNode(func_ /* TODO(PropertyAccessExpression): Diagnostics.Did_you_mean_to_mark_this_function_as_async */, TODO)
							addRelatedInfo(diagnostic, relatedInfo)
						}
						/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(diagnostic)
						return /* TODO(TrueKeyword): true */ TODO
					}
				}
			}
		}
		if isForOfStatement(forInOrOfStatement) && ! /* TODO(ParenthesizedExpression): (forInOrOfStatement.flags & NodeFlags.AwaitContext) */ TODO && isIdentifier( /* TODO(PropertyAccessExpression): forInOrOfStatement.initializer */ TODO) && /* TODO(PropertyAccessExpression): forInOrOfStatement.initializer.escapedText */ TODO == "async" {
			grammarErrorOnNode( /* TODO(PropertyAccessExpression): forInOrOfStatement.initializer */ TODO /* TODO(PropertyAccessExpression): Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async */, TODO)
			return /* TODO(FalseKeyword): false */ TODO
		}
		if /* TODO(PropertyAccessExpression): forInOrOfStatement.initializer.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableDeclarationList */ TODO {
			variableList := /* TODO(PropertyAccessExpression): forInOrOfStatement.initializer */ TODO /* as */ /* TODO(TypeReference): VariableDeclarationList */
			if !checkGrammarVariableDeclarationList(variableList) {
				declarations := /* TODO(PropertyAccessExpression): variableList.declarations */ TODO
				if ! /* TODO(PropertyAccessExpression): declarations.length */ TODO {
					return /* TODO(FalseKeyword): false */ TODO
				}
				if /* TODO(PropertyAccessExpression): declarations.length */ TODO > 1 {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement                         : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement */ TODO
					return grammarErrorOnFirstToken( /* TODO(ElementAccessExpression): variableList.declarations[1] */ TODO, diagnostic)
				}
				firstDeclaration := /* TODO(ElementAccessExpression): declarations[0] */ TODO
				if /* TODO(PropertyAccessExpression): firstDeclaration.initializer */ TODO {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer                         : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer */ TODO
					return grammarErrorOnNode( /* TODO(PropertyAccessExpression): firstDeclaration.name */ TODO, diagnostic)
				}
				if /* TODO(PropertyAccessExpression): firstDeclaration.type */ TODO {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation                         : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation */ TODO
					return grammarErrorOnNode(firstDeclaration, diagnostic)
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarAccessor := func(accessor AccessorDeclaration) bool {
		if ! /* TODO(ParenthesizedExpression): (accessor.flags & NodeFlags.Ambient) */ TODO && /* TODO(ParenthesizedExpression): (accessor.parent.kind !== SyntaxKind.TypeLiteral) */ TODO && /* TODO(ParenthesizedExpression): (accessor.parent.kind !== SyntaxKind.InterfaceDeclaration) */ TODO {
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO && isPrivateIdentifier( /* TODO(PropertyAccessExpression): accessor.name */ TODO) {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): accessor.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher */, TODO)
			}
			if /* TODO(PropertyAccessExpression): accessor.body */ TODO == nil && !hasSyntacticModifier(accessor /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) {
				return grammarErrorAtPos(accessor /* TODO(MinusToken): - */ /* TODO(BinaryExpression): accessor.end - 1 */, TODO /* TODO(PropertyAccessExpression): ";".length */, TODO /* TODO(PropertyAccessExpression): Diagnostics._0_expected */, TODO, "{")
			}
		}
		if /* TODO(PropertyAccessExpression): accessor.body */ TODO {
			if hasSyntacticModifier(accessor /* TODO(PropertyAccessExpression): ModifierFlags.Abstract */, TODO) {
				return grammarErrorOnNode(accessor /* TODO(PropertyAccessExpression): Diagnostics.An_abstract_accessor_cannot_have_an_implementation */, TODO)
			}
			if /* TODO(PropertyAccessExpression): accessor.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeLiteral */ TODO || /* TODO(PropertyAccessExpression): accessor.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): accessor.body */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts */, TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): accessor.typeParameters */ TODO {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): accessor.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_accessor_cannot_have_type_parameters */, TODO)
		}
		if !doesAccessorHaveCorrectParameterCount(accessor) {
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): accessor.name */ TODO /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ?                     Diagnostics.A_get_accessor_cannot_have_parameters :                     Diagnostics.A_set_accessor_must_have_exactly_one_parameter */, TODO)
		}
		if /* TODO(PropertyAccessExpression): accessor.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SetAccessor */ TODO {
			if /* TODO(PropertyAccessExpression): accessor.type */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): accessor.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation */, TODO)
			}
			parameter := /* TODO(PropertyAccessExpression): Debug.checkDefined */ TODO(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
			if /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.dotDotDotToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_cannot_have_rest_parameter */, TODO)
			}
			if /* TODO(PropertyAccessExpression): parameter.questionToken */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): parameter.questionToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_cannot_have_an_optional_parameter */, TODO)
			}
			if /* TODO(PropertyAccessExpression): parameter.initializer */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): accessor.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer */, TODO)
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	doesAccessorHaveCorrectParameterCount := func(accessor AccessorDeclaration) /* TODO(undefined): boolean | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
		return getAccessorThisParameter(accessor) || /* TODO(PropertyAccessExpression): accessor.parameters.length */ TODO == /* TODO(ParenthesizedExpression): (accessor.kind === SyntaxKind.GetAccessor ? 0 : 1) */ TODO
	}
	getAccessorThisParameter := func(accessor AccessorDeclaration) *ParameterDeclaration {
		if /* TODO(PropertyAccessExpression): accessor.parameters.length */ TODO == /* TODO(ParenthesizedExpression): (accessor.kind === SyntaxKind.GetAccessor ? 1 : 2) */ TODO {
			return getThisParameter(accessor)
		}
	}
	checkGrammarTypeOperatorNode := func(node TypeOperatorNode) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): node.operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.UniqueKeyword */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.SymbolKeyword */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.type */ TODO /* TODO(PropertyAccessExpression): Diagnostics._0_expected */, TODO, tokenToString( /* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO))
			}
			parent := walkUpParenthesizedTypes( /* TODO(PropertyAccessExpression): node.parent */ TODO)
			if isInJSFile(parent) && isJSDocTypeExpression(parent) {
				host := getJSDocHost(parent)
				if host {
					/* TODO(ExpressionStatement): parent = getSingleVariableOfVariableStatement(host) || host; */
				}
			}
			/* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.VariableDeclaration:                     const decl = parent as VariableDeclaration;                     if (decl.name.kind !== SyntaxKind.Identifier) {                         return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);                     }                     if (!isVariableDeclarationInVariableStatement(decl)) {                         return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);                     }                     if (!(decl.parent.flags & NodeFlags.Const)) {                         return grammarErrorOnNode((parent as VariableDeclaration).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);                     }                     break;                  case SyntaxKind.PropertyDeclaration:                     if (                         !isStatic(parent) ||                         !hasEffectiveReadonlyModifier(parent)                     ) {                         return grammarErrorOnNode((parent as PropertyDeclaration).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);                     }                     break;                  case SyntaxKind.PropertySignature:                     if (!hasSyntacticModifier(parent, ModifierFlags.Readonly)) {                         return grammarErrorOnNode((parent as PropertySignature).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);                     }                     break;                  default:                     return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here);             } */
		} else if /* TODO(PropertyAccessExpression): node.operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ReadonlyKeyword */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.ArrayType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.TupleType */ TODO {
				return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types */, TODO, tokenToString( /* TODO(PropertyAccessExpression): SyntaxKind.SymbolKeyword */ TODO))
			}
		}
	}
	checkGrammarForInvalidDynamicName := func(node DeclarationName, message DiagnosticMessage) /* TODO(undefined): boolean | undefined */ TODO {
		if isNonBindableDynamicName(node) {
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarMethod := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
		if checkGrammarFunctionLikeDeclaration(node) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO {
			if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ObjectLiteralExpression */ TODO {
				if /* TODO(PropertyAccessExpression): node.modifiers */ TODO && ! /* TODO(ParenthesizedExpression): (node.modifiers.length === 1 && first(node.modifiers).kind === SyntaxKind.AsyncKeyword) */ TODO {
					return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.Modifiers_cannot_appear_here */, TODO)
				} else if checkGrammarForInvalidQuestionMark( /* TODO(PropertyAccessExpression): node.questionToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_object_member_cannot_be_declared_optional */, TODO) {
					return /* TODO(TrueKeyword): true */ TODO
				} else if checkGrammarForInvalidExclamationToken( /* TODO(PropertyAccessExpression): node.exclamationToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */, TODO) {
					return /* TODO(TrueKeyword): true */ TODO
				} else if /* TODO(PropertyAccessExpression): node.body */ TODO == nil {
					return grammarErrorAtPos(node /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.end - 1 */, TODO /* TODO(PropertyAccessExpression): ";".length */, TODO /* TODO(PropertyAccessExpression): Diagnostics._0_expected */, TODO, "{")
				}
			}
			if checkGrammarForGenerator(node) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		}
		if isClassLike( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO && isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher */, TODO)
			}
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
				return checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */, TODO)
			} else if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MethodDeclaration */ TODO && ! /* TODO(PropertyAccessExpression): node.body */ TODO {
				return checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */, TODO)
			}
		} else if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO {
			return checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */, TODO)
		} else if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeLiteral */ TODO {
			return checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */, TODO)
		}
	}
	checkGrammarBreakOrContinueStatement := func(node BreakOrContinueStatement) bool {
		var current Node = node
		/* TODO(WhileStatement): while (current) {             if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {                 return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);             }              switch (current.kind) {                 case SyntaxKind.LabeledStatement:                     if (node.label && (current as LabeledStatement).label.escapedText === node.label.escapedText) {                         // found matching label - verify that label usage is correct                         // continue can only target labels that are on iteration statements                         const isMisplacedContinueLabel = node.kind === SyntaxKind.ContinueStatement                             && !isIterationStatement((current as LabeledStatement).statement, /*lookInLabeledStatements* / true);                          if (isMisplacedContinueLabel) {                             return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);                         }                          return false;                     }                     break;                 case SyntaxKind.SwitchStatement:                     if (node.kind === SyntaxKind.BreakStatement && !node.label) {                         // unlabeled break within switch statement - ok                         return false;                     }                     break;                 default:                     if (isIterationStatement(current, /*lookInLabeledStatements* / false) && !node.label) {                         // unlabeled break or continue within iteration statement - ok                         return false;                     }                     break;             }              current = current.parent;         } */
		if /* TODO(PropertyAccessExpression): node.label */ TODO {
			message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement                 : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		} else {
			message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement                 : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarBindingElement := func(node BindingElement) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO {
			elements := /* TODO(PropertyAccessExpression): node.parent.elements */ TODO
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node !== last(elements) */ TODO {
				return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern */, TODO)
			}
			checkGrammarForDisallowedTrailingComma(elements /* TODO(PropertyAccessExpression): Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma */, TODO)
			if /* TODO(PropertyAccessExpression): node.propertyName */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_have_a_property_name */, TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): node.dotDotDotToken */ TODO && /* TODO(PropertyAccessExpression): node.initializer */ TODO {
			return grammarErrorAtPos(node /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.initializer.pos - 1 */, TODO, 1 /* TODO(PropertyAccessExpression): Diagnostics.A_rest_element_cannot_have_an_initializer */, TODO)
		}
	}
	isStringOrNumberLiteralExpression := func(expr Expression) /* TODO(undefined): boolean */ TODO {
		return isStringOrNumericLiteralLike(expr) || /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PrefixUnaryExpression */ TODO && /* TODO(PropertyAccessExpression): (expr as PrefixUnaryExpression).operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MinusToken */ TODO && /* TODO(PropertyAccessExpression): (expr as PrefixUnaryExpression).operand.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NumericLiteral */ TODO
	}
	isBigIntLiteralExpression := func(expr Expression) /* TODO(undefined): boolean */ TODO {
		return /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BigIntLiteral */ TODO || /* TODO(PropertyAccessExpression): expr.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.PrefixUnaryExpression */ TODO && /* TODO(PropertyAccessExpression): (expr as PrefixUnaryExpression).operator */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.MinusToken */ TODO && /* TODO(PropertyAccessExpression): (expr as PrefixUnaryExpression).operand.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.BigIntLiteral */ TODO
	}
	isSimpleLiteralEnumReference := func(expr Expression) /* TODO(undefined): boolean | undefined */ TODO {
		if /* TODO(ParenthesizedExpression): (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) */ TODO && isEntityNameExpression( /* TODO(PropertyAccessExpression): expr.expression */ TODO) {
			return !! /* TODO(ParenthesizedExpression): (checkExpressionCached(expr).flags & TypeFlags.EnumLike) */ TODO
		}
	}
	checkAmbientInitializer := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
		initializer := /* TODO(PropertyAccessExpression): node.initializer */ TODO
		if initializer {
			isInvalidInitializer := ! /* TODO(ParenthesizedExpression): (                 isStringOrNumberLiteralExpression(initializer) ||                 isSimpleLiteralEnumReference(initializer) ||                 initializer.kind === SyntaxKind.TrueKeyword || initializer.kind === SyntaxKind.FalseKeyword ||                 isBigIntLiteralExpression(initializer)             ) */ TODO
			isConstOrReadonly := isDeclarationReadonly(node) || isVariableDeclaration(node) && /* TODO(ParenthesizedExpression): (isVarConstLike(node)) */ TODO
			if isConstOrReadonly && ! /* TODO(PropertyAccessExpression): node.type */ TODO {
				if isInvalidInitializer {
					return grammarErrorOnNode(initializer /* TODO(PropertyAccessExpression): Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference */, TODO)
				}
			} else {
				return grammarErrorOnNode(initializer /* TODO(PropertyAccessExpression): Diagnostics.Initializers_are_not_allowed_in_ambient_contexts */, TODO)
			}
		}
	}
	checkGrammarVariableDeclaration := func(node VariableDeclaration) /* TODO(undefined): boolean */ TODO {
		nodeFlags := getCombinedNodeFlagsCached(node)
		blockScopeKind := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nodeFlags & NodeFlags.BlockScoped */ TODO
		if isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) {
			/* TODO(SwitchStatement): switch (blockScopeKind) {                 case NodeFlags.AwaitUsing:                     return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using");                 case NodeFlags.Using:                     return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using");             } */
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForOfStatement */ TODO {
			if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): nodeFlags & NodeFlags.Ambient */ TODO {
				checkAmbientInitializer(node)
			} else if ! /* TODO(PropertyAccessExpression): node.initializer */ TODO {
				if isBindingPattern( /* TODO(PropertyAccessExpression): node.name */ TODO) && !isBindingPattern( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
					return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.A_destructuring_declaration_must_have_an_initializer */, TODO)
				}
				/* TODO(SwitchStatement): switch (blockScopeKind) {                     case NodeFlags.AwaitUsing:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using");                     case NodeFlags.Using:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using");                     case NodeFlags.Const:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const");                 } */
			}
		}
		if /* TODO(PropertyAccessExpression): node.exclamationToken */ TODO && /* TODO(ParenthesizedExpression): (node.parent.parent.kind !== SyntaxKind.VariableStatement || !node.type || node.initializer || nodeFlags & NodeFlags.Ambient) */ TODO {
			message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.exclamationToken */ TODO, message)
		}
		if /* TODO(PropertyAccessExpression): host.getEmitModuleFormatOfFile */ TODO(getSourceFileOfNode(node)) < /* TODO(PropertyAccessExpression): ModuleKind.System */ TODO && ! /* TODO(ParenthesizedExpression): (node.parent.parent.flags & NodeFlags.Ambient) */ TODO && hasSyntacticModifier( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO /* TODO(PropertyAccessExpression): ModifierFlags.Export */, TODO) {
			checkESModuleMarker( /* TODO(PropertyAccessExpression): node.name */ TODO)
		}
		return !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations( /* TODO(PropertyAccessExpression): node.name */ TODO)
	}
	checkESModuleMarker := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
		if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			if idText(name) == "__esModule" {
				return grammarErrorOnNodeSkippedOn("noEmit", name /* TODO(PropertyAccessExpression): Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules */, TODO)
			}
		} else {
			elements := /* TODO(PropertyAccessExpression): name.elements */ TODO
			for _, element := range elements {
				if !isOmittedExpression(element) {
					return checkESModuleMarker( /* TODO(PropertyAccessExpression): element.name */ TODO)
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarNameInLetOrConstDeclarations := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
		if /* TODO(PropertyAccessExpression): name.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Identifier */ TODO {
			if /* TODO(PropertyAccessExpression): name.escapedText */ TODO == "let" {
				return grammarErrorOnNode(name /* TODO(PropertyAccessExpression): Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations */, TODO)
			}
		} else {
			elements := /* TODO(PropertyAccessExpression): name.elements */ TODO
			for _, element := range elements {
				if !isOmittedExpression(element) {
					checkGrammarNameInLetOrConstDeclarations( /* TODO(PropertyAccessExpression): element.name */ TODO)
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarVariableDeclarationList := func(declarationList VariableDeclarationList) bool {
		declarations := /* TODO(PropertyAccessExpression): declarationList.declarations */ TODO
		if checkGrammarForDisallowedTrailingComma( /* TODO(PropertyAccessExpression): declarationList.declarations */ TODO) {
			return /* TODO(TrueKeyword): true */ TODO
		}
		if ! /* TODO(PropertyAccessExpression): declarationList.declarations.length */ TODO {
			return grammarErrorAtPos(declarationList /* TODO(PropertyAccessExpression): declarations.pos */, TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): declarations.end - declarations.pos */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Variable_declaration_list_cannot_be_empty */, TODO)
		}
		blockScopeFlags := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): declarationList.flags & NodeFlags.BlockScoped */ TODO
		if /* TODO(ParenthesizedExpression): (blockScopeFlags === NodeFlags.Using || blockScopeFlags === NodeFlags.AwaitUsing) */ TODO && isForInStatement( /* TODO(PropertyAccessExpression): declarationList.parent */ TODO) {
			return grammarErrorOnNode(declarationList /* TODO(ConditionalExpression): blockScopeFlags === NodeFlags.Using ?                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration :                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration */, TODO)
		}
		if blockScopeFlags == /* TODO(PropertyAccessExpression): NodeFlags.AwaitUsing */ TODO {
			return checkAwaitGrammar(declarationList)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	allowLetAndConstDeclarations := func(parent Node) bool {
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.IfStatement:             case SyntaxKind.DoStatement:             case SyntaxKind.WhileStatement:             case SyntaxKind.WithStatement:             case SyntaxKind.ForStatement:             case SyntaxKind.ForInStatement:             case SyntaxKind.ForOfStatement:                 return false;             case SyntaxKind.LabeledStatement:                 return allowLetAndConstDeclarations(parent.parent);         } */
		return /* TODO(TrueKeyword): true */ TODO
	}
	checkGrammarForDisallowedBlockScopedVariableStatement := func(node VariableStatement) /* TODO(undefined): boolean | undefined */ TODO {
		if !allowLetAndConstDeclarations( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			blockScopeKind := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCombinedNodeFlagsCached(node.declarationList) & NodeFlags.BlockScoped */ TODO
			if blockScopeKind {
				keyword := /* TODO(ConditionalExpression): blockScopeKind === NodeFlags.Let ? "let" :                     blockScopeKind === NodeFlags.Const ? "const" :                     blockScopeKind === NodeFlags.Using ? "using" :                     blockScopeKind === NodeFlags.AwaitUsing ? "await using" :                     Debug.fail("Unknown BlockScope flag") */ TODO
				return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics._0_declarations_can_only_be_declared_inside_a_block */, TODO, keyword)
			}
		}
	}
	checkGrammarMetaProperty := func(node MetaProperty) /* TODO(undefined): boolean | undefined */ TODO {
		escapedText := /* TODO(PropertyAccessExpression): node.name.escapedText */ TODO
		/* TODO(SwitchStatement): switch (node.keywordToken) {             case SyntaxKind.NewKeyword:                 if (escapedText !== "target") {                     return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target");                 }                 break;             case SyntaxKind.ImportKeyword:                 if (escapedText !== "meta") {                     return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta");                 }                 break;         } */
	}
	hasParseDiagnostics := func(sourceFile SourceFile) bool {
		return /* TODO(PropertyAccessExpression): sourceFile.parseDiagnostics.length */ TODO > 0
	}
	grammarErrorOnFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile /* TODO(PropertyAccessExpression): node.pos */, TODO)
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createFileDiagnostic(sourceFile /* TODO(PropertyAccessExpression): span.start */, TODO /* TODO(PropertyAccessExpression): span.length */, TODO, message /* TODO(SpreadElement): ...args */, TODO))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	grammarErrorAtPos := func(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(nodeForSourceFile)
		if !hasParseDiagnostics(sourceFile) {
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createFileDiagnostic(sourceFile, start, length, message /* TODO(SpreadElement): ...args */, TODO))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	grammarErrorOnNodeSkippedOn := func(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			errorSkippedOn(key, node, message /* TODO(SpreadElement): ...args */, TODO)
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	grammarErrorOnNode := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createDiagnosticForNode(node, message /* TODO(SpreadElement): ...args */, TODO))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarConstructorTypeParameters := func(node ConstructorDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		jsdocTypeParameters := /* TODO(ConditionalExpression): isInJSFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined */ TODO
		range_ := /* TODO(PropertyAccessExpression): node.typeParameters */ TODO || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters)
		if range_ {
			pos := /* TODO(ConditionalExpression): range.pos === range.end ? range.pos : skipTrivia(getSourceFileOfNode(node).text, range.pos) */ TODO
			return grammarErrorAtPos(node, pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): range.end - pos */, TODO /* TODO(PropertyAccessExpression): Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration */, TODO)
		}
	}
	checkGrammarConstructorTypeAnnotation := func(node ConstructorDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		type_ := /* TODO(PropertyAccessExpression): node.type */ TODO || getEffectiveReturnTypeNode(node)
		if type_ {
			return grammarErrorOnNode(type_ /* TODO(PropertyAccessExpression): Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration */, TODO)
		}
	}
	checkGrammarProperty := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
		if isComputedPropertyName( /* TODO(PropertyAccessExpression): node.name */ TODO) && isBinaryExpression( /* TODO(PropertyAccessExpression): node.name.expression */ TODO) && /* TODO(PropertyAccessExpression): node.name.expression.operatorToken.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InKeyword */ TODO {
			return grammarErrorOnNode( /* TODO(ElementAccessExpression): node.parent.members[0] */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_mapped_type_may_not_declare_properties_or_methods */, TODO)
		}
		if isClassLike( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			if isStringLiteral( /* TODO(PropertyAccessExpression): node.name */ TODO) && /* TODO(PropertyAccessExpression): node.name.text */ TODO == "constructor" {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Classes_may_not_have_a_field_named_constructor */, TODO)
			}
			if checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type */, TODO) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO && isPrivateIdentifier( /* TODO(PropertyAccessExpression): node.name */ TODO) {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher */, TODO)
			}
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2015 */ TODO && isAutoAccessorPropertyDeclaration(node) {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher */, TODO)
			}
			if isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark( /* TODO(PropertyAccessExpression): node.questionToken */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_accessor_property_cannot_be_declared_optional */, TODO) {
				return /* TODO(TrueKeyword): true */ TODO
			}
		} else if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO {
			if checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */, TODO) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			/* TODO(PropertyAccessExpression): Debug.assertNode */ TODO(node, isPropertySignature)
			if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.initializer */ TODO /* TODO(PropertyAccessExpression): Diagnostics.An_interface_property_cannot_have_an_initializer */, TODO)
			}
		} else if isTypeLiteralNode( /* TODO(PropertyAccessExpression): node.parent */ TODO) {
			if checkGrammarForInvalidDynamicName( /* TODO(PropertyAccessExpression): node.name */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type */, TODO) {
				return /* TODO(TrueKeyword): true */ TODO
			}
			/* TODO(PropertyAccessExpression): Debug.assertNode */ TODO(node, isPropertySignature)
			if /* TODO(PropertyAccessExpression): node.initializer */ TODO {
				return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.initializer */ TODO /* TODO(PropertyAccessExpression): Diagnostics.A_type_literal_property_cannot_have_an_initializer */, TODO)
			}
		}
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
			checkAmbientInitializer(node)
		}
		if isPropertyDeclaration(node) && /* TODO(PropertyAccessExpression): node.exclamationToken */ TODO && /* TODO(ParenthesizedExpression): (!isClassLike(node.parent) || !node.type || node.initializer ||                 node.flags & NodeFlags.Ambient || isStatic(node) || hasAbstractModifier(node)) */ TODO {
			message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode( /* TODO(PropertyAccessExpression): node.exclamationToken */ TODO, message)
		}
	}
	checkGrammarTopLevelElementForRequiredDeclareModifier := func(node Node) bool {
		if /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.InterfaceDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.TypeAliasDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ImportEqualsDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportDeclaration */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ExportAssignment */ TODO || /* TODO(PropertyAccessExpression): node.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamespaceExportDeclaration */ TODO || hasSyntacticModifier(node /* TODO(BarToken): | */ /* TODO(BinaryExpression): ModifierFlags.Ambient | ModifierFlags.Export | ModifierFlags.Default */, TODO) {
			return /* TODO(FalseKeyword): false */ TODO
		}
		return grammarErrorOnFirstToken(node /* TODO(PropertyAccessExpression): Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier */, TODO)
	}
	checkGrammarTopLevelElementsForRequiredDeclareModifier := func(file SourceFile) bool {
		for _, decl := range /* TODO(PropertyAccessExpression): file.statements */ TODO {
			if isDeclaration(decl) || /* TODO(PropertyAccessExpression): decl.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.VariableStatement */ TODO {
				if checkGrammarTopLevelElementForRequiredDeclareModifier(decl) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarSourceFile := func(node SourceFile) bool {
		return !! /* TODO(ParenthesizedExpression): (node.flags & NodeFlags.Ambient) */ TODO && checkGrammarTopLevelElementsForRequiredDeclareModifier(node)
	}
	checkGrammarStatementInAmbientContext := func(node Node) bool {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.flags & NodeFlags.Ambient */ TODO {
			links := getNodeLinks(node)
			if ! /* TODO(PropertyAccessExpression): links.hasReportedStatementInAmbientContext */ TODO && /* TODO(ParenthesizedExpression): (isFunctionLike(node.parent) || isAccessor(node.parent)) */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts) */ TODO
			}
			if /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.Block */ TODO || /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.ModuleBlock */ TODO || /* TODO(PropertyAccessExpression): node.parent.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.SourceFile */ TODO {
				links := getNodeLinks( /* TODO(PropertyAccessExpression): node.parent */ TODO)
				if ! /* TODO(PropertyAccessExpression): links.hasReportedStatementInAmbientContext */ TODO {
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts) */ TODO
				}
			} else {
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarNumericLiteral := func(node NumericLiteral) {
		isFractional := /* TODO(PropertyAccessExpression): getTextOfNode(node).includes */ TODO(".")
		isScientific := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): node.numericLiteralFlags & TokenFlags.Scientific */ TODO
		if isFractional || isScientific {
			return
		}
		value := + /* TODO(PropertyAccessExpression): node.text */ TODO
		if value <= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): 2 ** 53 - 1 */ TODO {
			return
		}
		addErrorOrSuggestion( /* TODO(FalseKeyword): false */ TODO, createDiagnosticForNode(node /* TODO(PropertyAccessExpression): Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers */, TODO))
	}
	checkGrammarBigIntLiteral := func(node BigIntLiteral) bool {
		literalType := isLiteralTypeNode( /* TODO(PropertyAccessExpression): node.parent */ TODO) || isPrefixUnaryExpression( /* TODO(PropertyAccessExpression): node.parent */ TODO) && isLiteralTypeNode( /* TODO(PropertyAccessExpression): node.parent.parent */ TODO)
		if !literalType {
			if languageVersion < /* TODO(PropertyAccessExpression): ScriptTarget.ES2020 */ TODO {
				if grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020 */, TODO) {
					return /* TODO(TrueKeyword): true */ TODO
				}
			}
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	grammarErrorAfterFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile /* TODO(PropertyAccessExpression): node.pos */, TODO)
			/* TODO(PropertyAccessExpression): diagnostics.add */ TODO(createFileDiagnostic(sourceFile, textSpanEnd(span), 0, message /* TODO(SpreadElement): ...args */, TODO))
			return /* TODO(TrueKeyword): true */ TODO
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	getAmbientModules := func() []Symbol {
		if !ambientModulesCache {
			/* TODO(ExpressionStatement): ambientModulesCache = []; */
			/* TODO(PropertyAccessExpression): globals.forEach */
			TODO( /* TODO(ArrowFunction): (global, sym) => {                 // No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.                 if (ambientModuleSymbolRegex.test(sym as string)) {                     ambientModulesCache!.push(global);                 }             } */ TODO)
		}
		return ambientModulesCache
	}
	checkGrammarImportClause := func(node ImportClause) bool {
		if /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO && /* TODO(PropertyAccessExpression): node.name */ TODO && /* TODO(PropertyAccessExpression): node.namedBindings */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.isTypeOnly */ TODO && /* TODO(PropertyAccessExpression): node.namedBindings?.kind */ TODO == /* TODO(PropertyAccessExpression): SyntaxKind.NamedImports */ TODO {
			return checkGrammarNamedImportsOrExports( /* TODO(PropertyAccessExpression): node.namedBindings */ TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	checkGrammarNamedImportsOrExports := func(namedBindings NamedImportsOrExports) bool {
		return !!forEach( /* TODO(PropertyAccessExpression): namedBindings.elements */ TODO /* TODO(ArrowFunction): specifier => {             if (specifier.isTypeOnly) {                 return grammarErrorOnFirstToken(                     specifier,                     specifier.kind === SyntaxKind.ImportSpecifier                         ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement                         : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement,                 );             }         } */, TODO)
	}
	checkGrammarImportCallExpression := func(node ImportCall) bool {
		if /* TODO(PropertyAccessExpression): compilerOptions.verbatimModuleSyntax */ TODO && moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.CommonJS */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled */, TODO)
		}
		if moduleKind == /* TODO(PropertyAccessExpression): ModuleKind.ES2015 */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext */, TODO)
		}
		if /* TODO(PropertyAccessExpression): node.typeArguments */ TODO {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments */, TODO)
		}
		nodeArguments := /* TODO(PropertyAccessExpression): node.arguments */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.NodeNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Node16 */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Preserve */ TODO {
			checkGrammarForDisallowedTrailingComma(nodeArguments)
			if /* TODO(PropertyAccessExpression): nodeArguments.length */ TODO > 1 {
				importAttributesArgument := /* TODO(ElementAccessExpression): nodeArguments[1] */ TODO
				return grammarErrorOnNode(importAttributesArgument /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve */, TODO)
			}
		}
		if /* TODO(PropertyAccessExpression): nodeArguments.length */ TODO == 0 || /* TODO(PropertyAccessExpression): nodeArguments.length */ TODO > 2 {
			return grammarErrorOnNode(node /* TODO(PropertyAccessExpression): Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments */, TODO)
		}
		spreadElement := find(nodeArguments, isSpreadElement)
		if spreadElement {
			return grammarErrorOnNode(spreadElement /* TODO(PropertyAccessExpression): Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element */, TODO)
		}
		return /* TODO(FalseKeyword): false */ TODO
	}
	findMatchingTypeReferenceOrTypeAliasReference := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		sourceObjectFlags := getObjectFlags(source)
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): sourceObjectFlags & (ObjectFlags.Reference | ObjectFlags.Anonymous) */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): unionTarget.flags & TypeFlags.Union */ TODO {
			return find( /* TODO(PropertyAccessExpression): unionTarget.types */ TODO /* TODO(ArrowFunction): target => {                 if (target.flags & TypeFlags.Object) {                     const overlapObjFlags = sourceObjectFlags & getObjectFlags(target);                     if (overlapObjFlags & ObjectFlags.Reference) {                         return (source as TypeReference).target === (target as TypeReference).target;                     }                     if (overlapObjFlags & ObjectFlags.Anonymous) {                         return !!(source as AnonymousType).aliasSymbol && (source as AnonymousType).aliasSymbol === (target as AnonymousType).aliasSymbol;                     }                 }                 return false;             } */, TODO)
		}
	}
	findBestTypeForObjectLiteral := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getObjectFlags(source) & ObjectFlags.ObjectLiteral */ TODO && someType(unionTarget, isArrayLikeType) {
			return find( /* TODO(PropertyAccessExpression): unionTarget.types */ TODO /* TODO(ArrowFunction): t => !isArrayLikeType(t) */, TODO)
		}
	}
	findBestTypeForInvokable := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signatureKind := /* TODO(PropertyAccessExpression): SignatureKind.Call */ TODO
		hasSignatures := /* TODO(PropertyAccessExpression): getSignaturesOfType(source, signatureKind).length */ TODO > 0 || /* TODO(ParenthesizedExpression): (signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0) */ TODO
		if hasSignatures {
			return find( /* TODO(PropertyAccessExpression): unionTarget.types */ TODO /* TODO(ArrowFunction): t => getSignaturesOfType(t, signatureKind).length > 0 */, TODO)
		}
	}
	findMostOverlappyType := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var bestMatch *Type
		if ! /* TODO(ParenthesizedExpression): (source.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive)) */ TODO {
			matchingCount := 0
			for _, target := range /* TODO(PropertyAccessExpression): unionTarget.types */ TODO {
				if ! /* TODO(ParenthesizedExpression): (target.flags & (TypeFlags.Primitive | TypeFlags.InstantiablePrimitive)) */ TODO {
					overlap := getIntersectionType( /* TODO(ArrayLiteralExpression): [getIndexType(source), getIndexType(target)] */ TODO)
					if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): overlap.flags & TypeFlags.Index */ TODO {
						return target
					} else if isUnitType(overlap) || /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): overlap.flags & TypeFlags.Union */ TODO {
						len := /* TODO(ConditionalExpression): overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1 */ TODO
						if len >= matchingCount {
							/* TODO(ExpressionStatement): bestMatch = target; */
							/* TODO(ExpressionStatement): matchingCount = len; */
						}
					}
				}
			}
		}
		return bestMatch
	}
	filterPrimitivesIfContainsNonPrimitive := func(type_ UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if maybeTypeOfKind(type_ /* TODO(PropertyAccessExpression): TypeFlags.NonPrimitive */, TODO) {
			result := filterType(type_ /* TODO(ArrowFunction): t => !(t.flags & TypeFlags.Primitive) */, TODO)
			if ! /* TODO(ParenthesizedExpression): (result.flags & TypeFlags.Never) */ TODO {
				return result
			}
		}
		return type_
	}
	findMatchingDiscriminantType := func(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): target.flags & TypeFlags.Union */ TODO && /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): source.flags & (TypeFlags.Intersection | TypeFlags.Object) */ TODO {
			match := getMatchingUnionConstituentForType(target /* as */ /* TODO(TypeReference): UnionType */, source)
			if match {
				return match
			}
			sourceProperties := getPropertiesOfType(source)
			if sourceProperties {
				sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
				if sourcePropertiesFiltered {
					discriminated := discriminateTypeByDiscriminableItems(target /* as */ /* TODO(TypeReference): UnionType */, map_(sourcePropertiesFiltered /* TODO(ArrowFunction): p => ([() => getTypeOfSymbol(p), p.escapedName] as [() => Type, __String]) */, TODO), isRelatedTo)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): discriminated !== target */ TODO {
						return discriminated
					}
				}
			}
		}
		return nil
	}
	getEffectivePropertyNameForPropertyNameNode := func(node PropertyName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		name := getPropertyNameForPropertyNameNode(node)
		return /* TODO(ConditionalExpression): name ? name :             isComputedPropertyName(node) ? tryGetNameFromType(getTypeOfExpression(node.expression)) : undefined */ TODO
	}
	getCombinedModifierFlagsCached := func(node Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ TODO {
		if lastGetCombinedModifierFlagsNode == node {
			return lastGetCombinedModifierFlagsResult
		}
		/* TODO(ExpressionStatement): lastGetCombinedModifierFlagsNode = node; */
		/* TODO(ExpressionStatement): lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node); */
		return lastGetCombinedModifierFlagsResult
	}
	getCombinedNodeFlagsCached := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").NodeFlags */ TODO {
		if lastGetCombinedNodeFlagsNode == node {
			return lastGetCombinedNodeFlagsResult
		}
		/* TODO(ExpressionStatement): lastGetCombinedNodeFlagsNode = node; */
		/* TODO(ExpressionStatement): lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node); */
		return lastGetCombinedNodeFlagsResult
	}
	isVarConstLike := func(node /* TODO(UnionType): VariableDeclaration | VariableDeclarationList */ any) /* TODO(undefined): boolean */ TODO {
		blockScopeKind := /* TODO(AmpersandToken): & */ /* TODO(BinaryExpression): getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped */ TODO
		return blockScopeKind == /* TODO(PropertyAccessExpression): NodeFlags.Const */ TODO || blockScopeKind == /* TODO(PropertyAccessExpression): NodeFlags.Using */ TODO || blockScopeKind == /* TODO(PropertyAccessExpression): NodeFlags.AwaitUsing */ TODO
	}
	getJSXRuntimeImportSpecifier := func(file *SourceFile, specifierText string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike | undefined */ TODO {
		jsxImportIndex := /* TODO(ConditionalExpression): compilerOptions.importHelpers ? 1 : 0 */ TODO
		specifier := /* TODO(ElementAccessExpression): file?.imports[jsxImportIndex] */ TODO
		if specifier {
			/* TODO(PropertyAccessExpression): Debug.assert */ TODO(nodeIsSynthesized(specifier) && /* TODO(PropertyAccessExpression): specifier.text */ TODO == specifierText /* TODO(TemplateExpression): `Expected sourceFile.imports[${jsxImportIndex}] to be the synthesized JSX runtime import` */, TODO)
		}
		return specifier
	}
	getImportHelpersImportSpecifier := func(file SourceFile) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike */ TODO {
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO( /* TODO(PropertyAccessExpression): compilerOptions.importHelpers */ TODO, "Expected importHelpers to be enabled")
		specifier := /* TODO(ElementAccessExpression): file.imports[0] */ TODO
		/* TODO(PropertyAccessExpression): Debug.assert */ TODO(specifier && nodeIsSynthesized(specifier) && /* TODO(PropertyAccessExpression): specifier.text */ TODO == "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`)
		return specifier
	}
}
func isNotAccessor(declaration Declaration) bool {
	return !isAccessor(declaration)
}
func isNotOverload(declaration Declaration) bool {
	return /* TODO(ParenthesizedExpression): (declaration.kind !== SyntaxKind.FunctionDeclaration && declaration.kind !== SyntaxKind.MethodDeclaration) */ TODO || !! /* TODO(PropertyAccessExpression): (declaration as FunctionDeclaration).body */ TODO
}
func isDeclarationNameOrImportPropertyName(name Node) bool {
	/* TODO(SwitchStatement): switch (name.parent.kind) {         case SyntaxKind.ImportSpecifier:         case SyntaxKind.ExportSpecifier:             return isIdentifier(name) || name.kind === SyntaxKind.StringLiteral;         default:             return isDeclarationName(name);     } */
}

/* TODO(ModuleDeclaration): namespace JsxNames {     export const JSX = "JSX" as __String;     export const IntrinsicElements = "IntrinsicElements" as __String;     export const ElementClass = "ElementClass" as __String;     export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support     export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String;     export const Element = "Element" as __String;     export const ElementType = "ElementType" as __String;     export const IntrinsicAttributes = "IntrinsicAttributes" as __String;     export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String;     export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String; } */
func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO(undefined): "yieldType" | "returnType" | "nextType" */ TODO {
	/* TODO(SwitchStatement): switch (typeKind) {         case IterationTypeKind.Yield:             return "yieldType";         case IterationTypeKind.Return:             return "returnType";         case IterationTypeKind.Next:             return "nextType";     } */
}
func signatureHasRestParameter(s Signature) /* TODO(undefined): boolean */ TODO {
	return !! /* TODO(ParenthesizedExpression): (s.flags & SignatureFlags.HasRestParameter) */ TODO
}
func signatureHasLiteralTypes(s Signature) /* TODO(undefined): boolean */ TODO {
	return !! /* TODO(ParenthesizedExpression): (s.flags & SignatureFlags.HasLiteralTypes) */ TODO
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
	return /* TODO(ObjectLiteralExpression): {         getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "",         getCurrentDirectory: () => host.getCurrentDirectory(),         getSymlinkCache: maybeBind(host, host.getSymlinkCache),         getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(),         useCaseSensitiveFileNames: maybeBind(host, host.useCaseSensitiveFileNames),         redirectTargetsMap: host.redirectTargetsMap,         getProjectReferenceRedirect: fileName => host.getProjectReferenceRedirect(fileName),         isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName),         fileExists: fileName => host.fileExists(fileName),         getFileIncludeReasons: () => host.getFileIncludeReasons(),         readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined,         getDefaultResolutionModeForFile: file => host.getDefaultResolutionModeForFile(file),         getModeForResolutionAtIndex: (file, index) => host.getModeForResolutionAtIndex(file, index),     } */ TODO
}

type NodeBuilderContext struct {
	enclosingDeclaration Node
	enclosingFile        *SourceFile
	flags                NodeBuilderFlags
	internalFlags        InternalNodeBuilderFlags
	tracker              SymbolTrackerImpl
	encounteredError     bool
	reportedDiagnostic   bool
	trackedSymbols/* TODO(ArrayType): TrackedSymbol[] */ any
	visitedTypes *Set[number]
	symbolDepth  *Map[string, number]
	inferTypeParameters/* TODO(ArrayType): TypeParameter[] */ any
	approximateLength                     number
	truncating                            bool
	mustCreateTypeParameterSymbolList     bool
	typeParameterSymbolList               *Set[number]
	mustCreateTypeParametersNamesLookups  bool
	typeParameterNames                    *Map[TypeId, Identifier]
	typeParameterNamesByText              *Set[string]
	typeParameterNamesByTextNextNameCount *Map[string, number]
	usedSymbolNames                       *Set[string]
	remappedSymbolNames                   *Map[SymbolId, string]
	remappedSymbolReferences              *Map[SymbolId, Symbol]
	reverseMappedStack/* TODO(ArrayType): ReverseMappedSymbol[] */ any
	bundled bool
	mapper  *TypeMapper
}
type SymbolTrackerImpl struct {
	/* TODO(ClassDeclaration): class SymbolTrackerImpl implements SymbolTracker {     moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;     context: NodeBuilderContext;      readonly inner: SymbolTracker | undefined = undefined;     readonly canTrackSymbol: boolean;     disableTrackSymbol = false;      constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {         while (tracker instanceof SymbolTrackerImpl) {             tracker = tracker.inner;         }          this.inner = tracker;         this.moduleResolverHost = moduleResolverHost;         this.context = context;         this.canTrackSymbol = !!this.inner?.trackSymbol;     }      trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {         if (this.inner?.trackSymbol && !this.disableTrackSymbol) {             if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {                 this.onDiagnosticReported();                 return true;             }             // Skip recording type parameters as they dont contribute to late painted statements             if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);         }         return false;     }      reportInaccessibleThisError(): void {         if (this.inner?.reportInaccessibleThisError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleThisError();         }     }      reportPrivateInBaseOfClassExpression(propertyName: string): void {         if (this.inner?.reportPrivateInBaseOfClassExpression) {             this.onDiagnosticReported();             this.inner.reportPrivateInBaseOfClassExpression(propertyName);         }     }      reportInaccessibleUniqueSymbolError(): void {         if (this.inner?.reportInaccessibleUniqueSymbolError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleUniqueSymbolError();         }     }      reportCyclicStructureError(): void {         if (this.inner?.reportCyclicStructureError) {             this.onDiagnosticReported();             this.inner.reportCyclicStructureError();         }     }      reportLikelyUnsafeImportRequiredError(specifier: string): void {         if (this.inner?.reportLikelyUnsafeImportRequiredError) {             this.onDiagnosticReported();             this.inner.reportLikelyUnsafeImportRequiredError(specifier);         }     }      reportTruncationError(): void {         if (this.inner?.reportTruncationError) {             this.onDiagnosticReported();             this.inner.reportTruncationError();         }     }      reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {         if (this.inner?.reportNonlocalAugmentation) {             this.onDiagnosticReported();             this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);         }     }      reportNonSerializableProperty(propertyName: string): void {         if (this.inner?.reportNonSerializableProperty) {             this.onDiagnosticReported();             this.inner.reportNonSerializableProperty(propertyName);         }     }      private onDiagnosticReported() {         this.context.reportedDiagnostic = true;     }      reportInferenceFallback(node: Node): void {         if (this.inner?.reportInferenceFallback) {             this.inner.reportInferenceFallback(node);         }     } } */
}