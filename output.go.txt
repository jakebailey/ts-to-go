// Code generated by ts-to-go at dc535a7be8f40fde10110b0fc29a106499327118. DO NOT EDIT.

package output

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)"

type ReferenceHint int32

const (
	ReferenceHintUnspecified ReferenceHint = iota
	ReferenceHintIdentifier
	ReferenceHintProperty
	ReferenceHintExportAssignment
	ReferenceHintJsx
	ReferenceHintAsyncFunction
	ReferenceHintExportImportEquals
	ReferenceHintExportSpecifier
	ReferenceHintDecorator
)

var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1

type IterationUse int32

const (
	IterationUseAllowsSyncIterablesFlag  IterationUse = 1 << 0
	IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
	IterationUseAllowsStringInputFlag    IterationUse = 1 << 2
	IterationUseForOfFlag                IterationUse = 1 << 3
	IterationUseYieldStarFlag            IterationUse = 1 << 4
	IterationUseSpreadFlag               IterationUse = 1 << 5
	IterationUseDestructuringFlag        IterationUse = 1 << 6
	IterationUsePossiblyOutOfBounds      IterationUse = 1 << 7
	IterationUseElement                  IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseSpread                   IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
	IterationUseDestructuring            IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
	IterationUseForOf                    IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseForAwaitOf               IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseYieldStar                IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseAsyncYieldStar           IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseGeneratorReturnType      IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)

type IterationTypeKind int32

const (
	IterationTypeKindYield IterationTypeKind = iota
	IterationTypeKindReturn
	IterationTypeKindNext
)

type IterationTypesResolver struct {
	iterableCacheKey/* TODO(TypeNode UnionType): "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	iteratorCacheKey/* TODO(TypeNode UnionType): "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
	iteratorSymbolName/* TODO(TypeNode UnionType): "asyncIterator" | "iterator" */ any
	getGlobalIteratorType         func(reportErrors bool) GenericType
	getGlobalIterableType         func(reportErrors bool) GenericType
	getGlobalIterableIteratorType func(reportErrors bool) GenericType
	getGlobalIteratorObjectType   func(reportErrors bool) GenericType
	getGlobalGeneratorType        func(reportErrors bool) GenericType
	getGlobalBuiltinIteratorTypes func() []GenericType
	resolveIterationType          func(type_ Type, errorNode Node) *Type
	mustHaveANextMethodDiagnostic DiagnosticMessage
	mustBeAMethodDiagnostic       DiagnosticMessage
	mustHaveAValueDiagnostic      DiagnosticMessage
}
type WideningKind int32

const (
	WideningKindNormal WideningKind = iota
	WideningKindFunctionReturn
	WideningKindGeneratorNext
	WideningKindGeneratorYield
)

type TypeFacts int32

const (
	TypeFactsNone                      TypeFacts = 0
	TypeFactsTypeofEQString            TypeFacts = 1 << 0
	TypeFactsTypeofEQNumber            TypeFacts = 1 << 1
	TypeFactsTypeofEQBigInt            TypeFacts = 1 << 2
	TypeFactsTypeofEQBoolean           TypeFacts = 1 << 3
	TypeFactsTypeofEQSymbol            TypeFacts = 1 << 4
	TypeFactsTypeofEQObject            TypeFacts = 1 << 5
	TypeFactsTypeofEQFunction          TypeFacts = 1 << 6
	TypeFactsTypeofEQHostObject        TypeFacts = 1 << 7
	TypeFactsTypeofNEString            TypeFacts = 1 << 8
	TypeFactsTypeofNENumber            TypeFacts = 1 << 9
	TypeFactsTypeofNEBigInt            TypeFacts = 1 << 10
	TypeFactsTypeofNEBoolean           TypeFacts = 1 << 11
	TypeFactsTypeofNESymbol            TypeFacts = 1 << 12
	TypeFactsTypeofNEObject            TypeFacts = 1 << 13
	TypeFactsTypeofNEFunction          TypeFacts = 1 << 14
	TypeFactsTypeofNEHostObject        TypeFacts = 1 << 15
	TypeFactsEQUndefined               TypeFacts = 1 << 16
	TypeFactsEQNull                    TypeFacts = 1 << 17
	TypeFactsEQUndefinedOrNull         TypeFacts = 1 << 18
	TypeFactsNEUndefined               TypeFacts = 1 << 19
	TypeFactsNENull                    TypeFacts = 1 << 20
	TypeFactsNEUndefinedOrNull         TypeFacts = 1 << 21
	TypeFactsTruthy                    TypeFacts = 1 << 22
	TypeFactsFalsy                     TypeFacts = 1 << 23
	TypeFactsIsUndefined               TypeFacts = 1 << 24
	TypeFactsIsNull                    TypeFacts = 1 << 25
	TypeFactsIsUndefinedOrNull         TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
	TypeFactsAll                       TypeFacts = (1 << 27) - 1
	TypeFactsBaseStringStrictFacts     TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseStringFacts           TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsStringStrictFacts         TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsStringFacts               TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsEmptyStringStrictFacts    TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
	TypeFactsEmptyStringFacts          TypeFacts = TypeFactsBaseTypeFactsStringFacts
	TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
	TypeFactsNonEmptyStringFacts       TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsBaseNumberStrictFacts     TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsNumberStrictFacts         TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsNumberFacts               TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsZeroNumberStrictFacts     TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
	TypeFactsZeroNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberFacts
	TypeFactsNonZeroNumberStrictFacts  TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroNumberFacts        TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsBaseBigIntStrictFacts     TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBigIntStrictFacts         TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBigIntFacts               TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsZeroBigIntStrictFacts     TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
	TypeFactsZeroBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
	TypeFactsNonZeroBigIntStrictFacts  TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroBigIntFacts        TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsBaseBooleanStrictFacts    TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBooleanFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBooleanStrictFacts        TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBooleanFacts              TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsFalseStrictFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
	TypeFactsFalseFacts                TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
	TypeFactsTrueStrictFacts           TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
	TypeFactsTrueFacts                 TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsSymbolStrictFacts         TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsSymbolFacts               TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsObjectStrictFacts         TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsObjectFacts               TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsFunctionStrictFacts       TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsFunctionFacts             TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsVoidFacts                 TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
	TypeFactsUndefinedFacts            TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
	TypeFactsNullFacts                 TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
	TypeFactsEmptyObjectStrictFacts    TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
	TypeFactsEmptyObjectFacts          TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsUnknownFacts              TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsAllTypeofNE               TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
	TypeFactsOrFactsMask               TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
	TypeFactsAndFactsMask              TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)

var typeofNEFacts ReadonlyMap[string, TypeFacts] = /* TODO(Node NewExpression): new Map(Object.entries({ string: TypeFacts.TypeofNEString, number: TypeFacts.TypeofNENumber, bigint: TypeFacts.TypeofNEBigInt, boolean: TypeFacts.TypeofNEBoolean, symbol: TypeFacts.TypeofNESymbol, undefined: TypeFacts.NEUndefined, object: TypeFacts.TypeofNEObject, function: TypeFacts.TypeofNEFunction,
})) */TODO

type TypeSystemEntity /* TODO(TypeNode UnionType): Node | Symbol | Type | Signature */ any
type TypeSystemPropertyName int32

const (
	TypeSystemPropertyNameType TypeSystemPropertyName = iota
	TypeSystemPropertyNameResolvedBaseConstructorType
	TypeSystemPropertyNameDeclaredType
	TypeSystemPropertyNameResolvedReturnType
	TypeSystemPropertyNameImmediateBaseConstraint
	TypeSystemPropertyNameResolvedTypeArguments
	TypeSystemPropertyNameResolvedBaseTypes
	TypeSystemPropertyNameWriteType
	TypeSystemPropertyNameParameterInitializerContainsUndefined
)

type CheckMode int32

const (
	CheckModeNormal               CheckMode = 0
	CheckModeContextual           CheckMode = 1 << 0
	CheckModeInferential          CheckMode = 1 << 1
	CheckModeSkipContextSensitive CheckMode = 1 << 2
	CheckModeSkipGenericFunctions CheckMode = 1 << 3
	CheckModeIsForSignatureHelp   CheckMode = 1 << 4
	CheckModeRestBindingElement   CheckMode = 1 << 5
	CheckModeTypeOnly             CheckMode = 1 << 6
)

type SignatureCheckMode int32

const (
	SignatureCheckModeNone               SignatureCheckMode = 0
	SignatureCheckModeBivariantCallback  SignatureCheckMode = 1 << 0
	SignatureCheckModeStrictCallback     SignatureCheckMode = 1 << 1
	SignatureCheckModeIgnoreReturnTypes  SignatureCheckMode = 1 << 2
	SignatureCheckModeStrictArity        SignatureCheckMode = 1 << 3
	SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
	SignatureCheckModeCallback           SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)

type IntersectionState int32

const (
	IntersectionStateNone   IntersectionState = 0
	IntersectionStateSource IntersectionState = 1 << 0
	IntersectionStateTarget IntersectionState = 1 << 1
)

type RecursionFlags int32

const (
	RecursionFlagsNone   RecursionFlags = 0
	RecursionFlagsSource RecursionFlags = 1 << 0
	RecursionFlagsTarget RecursionFlags = 1 << 1
	RecursionFlagsBoth   RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)

type MappedTypeModifiers int32

const (
	MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
	MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
	MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
	MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)

type MappedTypeNameTypeKind int32

const (
	MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
	MappedTypeNameTypeKindFiltering
	MappedTypeNameTypeKindRemapping
)

type ExpandingFlags int32

const (
	ExpandingFlagsNone   ExpandingFlags = 0
	ExpandingFlagsSource ExpandingFlags = 1
	ExpandingFlagsTarget ExpandingFlags = 1 << 1
	ExpandingFlagsBoth   ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)

type MembersOrExportsResolutionKind string

const (
	MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
	MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)

type UnusedKind int32

const (
	UnusedKindLocal UnusedKind = iota
	UnusedKindParameter
)

type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation)

var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)

type DeclarationMeaning int32

const (
	DeclarationMeaningGetAccessor                DeclarationMeaning = 1
	DeclarationMeaningSetAccessor                DeclarationMeaning = 2
	DeclarationMeaningPropertyAssignment         DeclarationMeaning = 4
	DeclarationMeaningMethod                     DeclarationMeaning = 8
	DeclarationMeaningPrivateStatic              DeclarationMeaning = 16
	DeclarationMeaningGetOrSetAccessor           DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
	DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)

type DeclarationSpaces int32

const (
	DeclarationSpacesNone            DeclarationSpaces = 0
	DeclarationSpacesExportValue     DeclarationSpaces = 1 << 0
	DeclarationSpacesExportType      DeclarationSpaces = 1 << 1
	DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)

type MinArgumentCountFlags int32

const (
	MinArgumentCountFlagsNone                    MinArgumentCountFlags = 0
	MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
	MinArgumentCountFlagsVoidIsNonOptional       MinArgumentCountFlags = 1 << 1
)

type IntrinsicTypeKind int32

const (
	IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
	IntrinsicTypeKindLowercase
	IntrinsicTypeKindCapitalize
	IntrinsicTypeKindUncapitalize
	IntrinsicTypeKindNoInfer
)

var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = /* TODO(Node NewExpression): new Map(Object.entries({ Uppercase: IntrinsicTypeKind.Uppercase, Lowercase: IntrinsicTypeKind.Lowercase, Capitalize: IntrinsicTypeKind.Capitalize, Uncapitalize: IntrinsicTypeKind.Uncapitalize, NoInfer: IntrinsicTypeKind.NoInfer,
})) */TODO
var SymbolLinks = /* TODO(Node ClassExpression): class implements SymbolLinks { declare _symbolLinksBrand: any;
} */TODO

func NodeLinks(this NodeLinks) {
	this.flags = NodeCheckFlagsNone
}
func getNodeId(node Node) number {
	if !node.id {
		node.id = nextNodeId
		nextNodeId++
	}
	return node.id
}
func getSymbolId(symbol Symbol) SymbolId {
	if !symbol.id {
		symbol.id = nextSymbolId
		nextSymbolId++
	}
	return symbol.id
}
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) /* TODO inferred type boolean */ any {
	moduleState := getModuleInstanceState(node)
	return moduleState == ModuleInstanceStateInstantiated || (preserveConstEnums && moduleState == ModuleInstanceStateConstEnumOnly)
}
func createTypeChecker(host TypeCheckerHost) TypeChecker {
	var deferredDiagnosticsCallbacks []func() = [] /* TODO inferred type never */ any{}
	addLazyDiagnostic := func(arg func()) {
		deferredDiagnosticsCallbacks.push(arg)
	}
	var cancellationToken *CancellationToken
	var scanner *Scanner
	Symbol := objectAllocator.getSymbolConstructor()
	Type := objectAllocator.getTypeConstructor()
	Signature := objectAllocator.getSignatureConstructor()
	typeCount := 0
	symbolCount := 0
	totalInstantiationCount := 0
	instantiationCount := 0
	instantiationDepth := 0
	inlineLevel := 0
	var currentNode Node
	var varianceTypeParameter *TypeParameter
	isInferencePartiallyBlocked := false
	emptySymbols := createSymbolTable()
	arrayVariances := [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ any{VarianceFlagsCovariant}
	compilerOptions := host.getCompilerOptions()
	languageVersion := getEmitScriptTarget(compilerOptions)
	moduleKind := getEmitModuleKind(compilerOptions)
	legacyDecorators := !!compilerOptions.experimentalDecorators
	useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
	emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
	allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
	strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
	strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
	strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
	strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
	strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
	noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
	noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
	useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
	exactOptionalPropertyTypes := compilerOptions.exactOptionalPropertyTypes
	noUncheckedSideEffectImports := !!compilerOptions.noUncheckedSideEffectImports
	checkBinaryExpression := createCheckBinaryExpression()
	emitResolver := createResolver()
	nodeBuilder := createNodeBuilder()
	syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions /* TODO(Node ObjectLiteralExpression): { isEntityNameVisible, isExpandoFunctionDeclaration, getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration, requiresAddingImplicitUndefined, isUndefinedIdentifierExpression(node: Identifier) { Debug.assert(isExpressionNode(node)); return getSymbolAtLocation(node) === undefinedSymbol; }, isDefinitelyReferenceToGlobalSymbolObject, } */, TODO)
	evaluate := createEvaluator( /* TODO(Node ObjectLiteralExpression): { evaluateElementAccessExpression, evaluateEntityNameExpression, } */ TODO)
	globals := createSymbolTable()
	undefinedSymbol := createSymbol(SymbolFlagsProperty, "undefined")
	undefinedSymbol.declarations = [] /* TODO inferred type never */ any{}
	globalThisSymbol := createSymbol(SymbolFlagsModule, "globalThis", CheckFlagsReadonly)
	globalThisSymbol.exports = globals
	globalThisSymbol.declarations = [] /* TODO inferred type never */ any{}
	globals.set(globalThisSymbol.escapedName, globalThisSymbol)
	argumentsSymbol := createSymbol(SymbolFlagsProperty, "arguments")
	requireSymbol := createSymbol(SymbolFlagsProperty, "require")
	isolatedModulesLikeFlagName := /* TODO(Node ConditionalExpression): compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules" */ TODO
	canCollectSymbolAliasAccessabilityData := !compilerOptions.verbatimModuleSyntax
	var apparentArgumentCount *number
	var lastGetCombinedNodeFlagsNode Node
	lastGetCombinedNodeFlagsResult := NodeFlagsNone
	var lastGetCombinedModifierFlagsNode Declaration
	lastGetCombinedModifierFlagsResult := ModifierFlagsNone
	resolveName := createNameResolver( /* TODO(Node ObjectLiteralExpression): { compilerOptions, requireSymbol, argumentsSymbol, globals, getSymbolOfDeclaration, error, getRequiresScopeChangeCache, setRequiresScopeChangeCache, lookup: getSymbol, onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer, onFailedToResolveSymbol, onSuccessfullyResolvedSymbol, } */ TODO)
	resolveNameForSymbolSuggestion := createNameResolver( /* TODO(Node ObjectLiteralExpression): { compilerOptions, requireSymbol, argumentsSymbol, globals, getSymbolOfDeclaration, error, getRequiresScopeChangeCache, setRequiresScopeChangeCache, lookup: getSuggestionForSymbolNameLookup, } */ TODO)
	var checker TypeChecker = /* TODO(Node ObjectLiteralExpression): { getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0), getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0), getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount), getTypeCount: () => typeCount, getInstantiationCount: () => totalInstantiationCount, getRelationCacheSizes: () => ({ assignable: assignableRelation.size, identity: identityRelation.size, subtype: subtypeRelation.size, strictSubtype: strictSubtypeRelation.size, }), isUndefinedSymbol: symbol => symbol === undefinedSymbol, isArgumentsSymbol: symbol => symbol === argumentsSymbol, isUnknownSymbol: symbol => symbol === unknownSymbol, getMergedSymbol, symbolIsValue, getDiagnostics, getGlobalDiagnostics, getRecursionIdentity, getUnmatchedProperties, getTypeOfSymbolAtLocation: (symbol, locationIn) => { const location = getParseTreeNode(locationIn); return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType; }, getTypeOfSymbol, getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => { const parameter = getParseTreeNode(parameterIn, isParameter); if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node."); Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent)); return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName)); }, getDeclaredTypeOfSymbol, getPropertiesOfType, getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)), getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => { const node = getParseTreeNode(location); if (!node) { return undefined; } const propName = escapeLeadingUnderscores(name); const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node); return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined; }, getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)), getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType), getIndexInfosOfType, getIndexInfosOfIndexSymbol, getSignaturesOfType, getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType), getIndexType: type => getIndexType(type), getBaseTypes, getBaseTypeOfLiteralType, getWidenedType, getWidenedLiteralType, getTypeFromTypeNode: nodeIn => { const node = getParseTreeNode(nodeIn, isTypeNode); return node ? getTypeFromTypeNode(node) : errorType; }, getParameterType: getTypeAtPosition, getParameterIdentifierInfoAtPosition, getPromisedTypeOfPromise, getAwaitedType: type => getAwaitedType(type), getReturnTypeOfSignature, isNullableType, getNullableType, getNonNullableType, getNonOptionalType: removeOptionalTypeMarker, getTypeArguments, typeToTypeNode: nodeBuilder.typeToTypeNode, typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode, indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration, signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration, symbolToEntityName: nodeBuilder.symbolToEntityName, symbolToExpression: nodeBuilder.symbolToExpression, symbolToNode: nodeBuilder.symbolToNode, symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations, symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration, typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration, getSymbolsInScope: (locationIn, meaning) => { const location = getParseTreeNode(locationIn); return location ? getSymbolsInScope(location, meaning) : []; }, getSymbolAtLocation: nodeIn => { const node = getParseTreeNode(nodeIn); // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors return node ? getSymbolAtLocation(node, /*ignoreErrors* / true) : undefined; }, getIndexInfosAtLocation: nodeIn => { const node = getParseTreeNode(nodeIn); return node ? getIndexInfosAtLocation(node) : undefined; }, getShorthandAssignmentValueSymbol: nodeIn => { const node = getParseTreeNode(nodeIn); return node ? getShorthandAssignmentValueSymbol(node) : undefined; }, getExportSpecifierLocalTargetSymbol: nodeIn => { const node = getParseTreeNode(nodeIn, isExportSpecifier); return node ? getExportSpecifierLocalTargetSymbol(node) : undefined; }, getExportSymbolOfSymbol(symbol) { return getMergedSymbol(symbol.exportSymbol || symbol); }, getTypeAtLocation: nodeIn => { const node = getParseTreeNode(nodeIn); return node ? getTypeOfNode(node) : errorType; }, getTypeOfAssignmentPattern: nodeIn => { const node = getParseTreeNode(nodeIn, isAssignmentPattern); return node && getTypeOfAssignmentPattern(node) || errorType; }, getPropertySymbolOfDestructuringAssignment: locationIn => { const location = getParseTreeNode(locationIn, isIdentifier); return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined; }, signatureToString: (signature, enclosingDeclaration, flags, kind) => { return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind); }, typeToString: (type, enclosingDeclaration, flags) => { return typeToString(type, getParseTreeNode(enclosingDeclaration), flags); }, symbolToString: (symbol, enclosingDeclaration, meaning, flags) => { return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags); }, typePredicateToString: (predicate, enclosingDeclaration, flags) => { return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags); }, writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => { return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer); }, writeType: (type, enclosingDeclaration, flags, writer) => { return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer); }, writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => { return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer); }, writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => { return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer); }, getAugmentedPropertiesOfType, getRootSymbols, getSymbolOfExpando, getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => { const node = getParseTreeNode(nodeIn, isExpression); if (!node) { return undefined; } if (contextFlags! & ContextFlags.Completions) { return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags)); } return getContextualType(node, contextFlags); }, getContextualTypeForObjectLiteralElement: nodeIn => { const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike); return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags* / undefined) : undefined; }, getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => { const node = getParseTreeNode(nodeIn, isCallLikeExpression); return node && getContextualTypeForArgumentAtIndex(node, argIndex); }, getContextualTypeForJsxAttribute: nodeIn => { const node = getParseTreeNode(nodeIn, isJsxAttributeLike); return node && getContextualTypeForJsxAttribute(node, /*contextFlags* / undefined); }, isContextSensitive, getTypeOfPropertyOfContextualType, getFullyQualifiedName, getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal), getCandidateSignaturesForStringLiteralCompletions, getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)), getExpandedParameters, hasEffectiveRestParameter, containsArgumentsReference, getConstantValue: nodeIn => { const node = getParseTreeNode(nodeIn, canHaveConstantValue); return node ? getConstantValue(node) : undefined; }, isValidPropertyAccess: (nodeIn, propertyName) => { const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode); return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName)); }, isValidPropertyAccessForCompletions: (nodeIn, type, property) => { const node = getParseTreeNode(nodeIn, isPropertyAccessExpression); return !!node && isValidPropertyAccessForCompletions(node, type, property); }, getSignatureFromDeclaration: declarationIn => { const declaration = getParseTreeNode(declarationIn, isFunctionLike); return declaration ? getSignatureFromDeclaration(declaration) : undefined; }, isImplementationOfOverload: nodeIn => { const node = getParseTreeNode(nodeIn, isFunctionLike); return node ? isImplementationOfOverload(node) : undefined; }, getImmediateAliasedSymbol, getAliasedSymbol: resolveAlias, getEmitResolver, requiresAddingImplicitUndefined, getExportsOfModule: getExportsOfModuleAsArray, getExportsAndPropertiesOfModule, forEachExportAndPropertyOfModule, getSymbolWalker: createGetSymbolWalker( getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, getFirstIdentifier, getTypeArguments, ), getAmbientModules, getJsxIntrinsicTagNamesAt, isOptionalParameter: nodeIn => { const node = getParseTreeNode(nodeIn, isParameter); return node ? isOptionalParameter(node) : false; }, tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol), tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol), tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations* / true), getApparentType, getUnionType, isTypeAssignableTo, createAnonymousType, createSignature, createSymbol, createIndexInfo, getAnyType: () => anyType, getStringType: () => stringType, getStringLiteralType, getNumberType: () => numberType, getNumberLiteralType, getBigIntType: () => bigintType, getBigIntLiteralType, createPromiseType, createArrayType, getElementTypeOfArrayType, getBooleanType: () => booleanType, getFalseType: (fresh?) => fresh ? falseType : regularFalseType, getTrueType: (fresh?) => fresh ? trueType : regularTrueType, getVoidType: () => voidType, getUndefinedType: () => undefinedType, getNullType: () => nullType, getESSymbolType: () => esSymbolType, getNeverType: () => neverType, getOptionalType: () => optionalType, getPromiseType: () => getGlobalPromiseType(/*reportErrors* / false), getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors* / false), getAnyAsyncIterableType: () => { const type = getGlobalAsyncIterableType(/*reportErrors* / false); if (type === emptyGenericType) return undefined; return createTypeReference(type, [anyType, anyType, anyType]); }, isSymbolAccessible, isArrayType, isTupleType, isArrayLikeType, isEmptyAnonymousObjectType, isTypeInvalidDueToUnionDiscriminant, getExactOptionalProperties, getAllPossiblePropertiesOfTypes, getSuggestedSymbolForNonexistentProperty, getSuggestedSymbolForNonexistentJSXAttribute, getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning), getSuggestedSymbolForNonexistentModule, getSuggestedSymbolForNonexistentClassMember, getBaseConstraintOfType, getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined, resolveName(name, location, meaning, excludeGlobals) { return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage* / undefined, /*isUse* / false, excludeGlobals); }, getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)), getJsxFragmentFactory: n => { const jsxFragmentFactory = getJsxFragmentFactoryEntity(n); return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText); }, getAccessibleSymbolChain, getTypePredicateOfSignature, resolveExternalModuleName: moduleSpecifierIn => { const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression); return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors* / true); }, resolveExternalModuleSymbol, tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => { const node = getParseTreeNode(nodeIn); return node && tryGetThisTypeAt(node, includeGlobalThis, container); }, getTypeArgumentConstraint: nodeIn => { const node = getParseTreeNode(nodeIn, isTypeNode); return node && getTypeArgumentConstraint(node); }, getSuggestionDiagnostics: (fileIn, ct) => { const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file."); if (skipTypeChecking(file, compilerOptions, host)) { return emptyArray; } let diagnostics: DiagnosticWithLocation[] | undefined; try { // Record the cancellation token so it can be checked later on during checkSourceElement. // Do this in a finally block so we can ensure that it gets reset back to nothing after // this call is done. cancellationToken = ct; // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused checkSourceFileWithEagerDiagnostics(file); Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked)); diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName)); checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => { if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) { (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion }); } }); return diagnostics || emptyArray; } finally { cancellationToken = undefined; } }, runWithCancellationToken: (token, callback) => { try { cancellationToken = token; return callback(checker); } finally { cancellationToken = undefined; } }, getLocalTypeParametersOfClassOrInterfaceOrTypeAlias, isDeclarationVisible, isPropertyAccessible, getTypeOnlyAliasDeclaration, getMemberOverrideModifierStatus, isTypeParameterPossiblyReferenced, typeHasCallOrConstructSignatures, getSymbolFlags, } */ TODO
	getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ any {
		candidatesSet := make(map[Signature]struct{})
		var candidates []Signature = [] /* TODO inferred type never */ any{}
		runWithInferenceBlockedFromSourceNode(editingArgument, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
			return getResolvedSignatureWorker(call, candidates, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		candidates.length = 0
		runWithoutResolvedSignatureCaching(editingArgument, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
			return getResolvedSignatureWorker(call, candidates, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		return arrayFrom(candidatesSet)
	}
	runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
		node = findAncestor(node, isCallLikeOrFunctionLikeExpression)
		if node {
			cachedResolvedSignatures := [] /* TODO inferred type never */ any{}
			cachedTypes := [] /* TODO inferred type never */ any{}
			for node {
				nodeLinks := getNodeLinks(node)
				cachedResolvedSignatures.push([]TODO{nodeLinks, nodeLinks.resolvedSignature})
				nodeLinks.resolvedSignature = nil
				if isFunctionExpressionOrArrowFunction(node) {
					symbolLinks := getSymbolLinks(getSymbolOfDeclaration(node))
					type_ := symbolLinks.type_
					cachedTypes.push([]TODO{symbolLinks, type_})
					symbolLinks.type_ = nil
				}
				node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression)
			}
			result := fn()
			for _, TODO_IDENTIFIER := range cachedResolvedSignatures {
				nodeLinks.resolvedSignature = resolvedSignature
			}
			for _, TODO_IDENTIFIER := range cachedTypes {
				symbolLinks.type_ = type_
			}
			return result
		}
		return fn()
	}
	runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
		containingCall := findAncestor(node, isCallLikeExpression)
		if containingCall {
			toMarkSkip := node
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall {
				getNodeLinks(toMarkSkip).skipDirectInference = true
				toMarkSkip = toMarkSkip.parent
			}
		}
		isInferencePartiallyBlocked = true
		result := runWithoutResolvedSignatureCaching(node, fn)
		isInferencePartiallyBlocked = false
		if containingCall {
			toMarkSkip := node
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall {
				getNodeLinks(toMarkSkip).skipDirectInference = nil
				toMarkSkip = toMarkSkip.parent
			}
		}
		return result
	}
	getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number, checkMode CheckMode) *Signature {
		node := getParseTreeNode(nodeIn, isCallLikeExpression)
		apparentArgumentCount = argumentCount
		res := /* TODO(Node ConditionalExpression): !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode) */ TODO
		apparentArgumentCount = nil
		return res
	}
	tupleTypes := make(map[string]GenericType)
	unionTypes := make(map[string]UnionType)
	unionOfUnionTypes := make(map[string]Type)
	intersectionTypes := make(map[string]Type)
	stringLiteralTypes := make(map[string]StringLiteralType)
	numberLiteralTypes := make(map[number]NumberLiteralType)
	bigIntLiteralTypes := make(map[string]BigIntLiteralType)
	enumLiteralTypes := make(map[string]LiteralType)
	indexedAccessTypes := make(map[string]IndexedAccessType)
	templateLiteralTypes := make(map[string]TemplateLiteralType)
	stringMappingTypes := make(map[string]StringMappingType)
	substitutionTypes := make(map[string]SubstitutionType)
	subtypeReductionCache := make(map[string][]Type)
	decoratorContextOverrideTypeCache := make(map[string]Type)
	cachedTypes := make(map[string]Type)
	var evolvingArrayTypes []EvolvingArrayType = [] /* TODO inferred type never */ any{}
	var undefinedProperties SymbolTable = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
	markerTypes := make(map[number]struct{})
	unknownSymbol := createSymbol(SymbolFlagsProperty, "unknown")
	resolvingSymbol := createSymbol(0, InternalSymbolNameResolving)
	unresolvedSymbols := make(map[string]TransientSymbol)
	errorTypes := make(map[string]Type)
	seenIntrinsicNames := make(map[string]struct{})
	anyType := createIntrinsicType(TypeFlagsAny, "any")
	autoType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsNonInferrableType, "auto")
	wildcardType := createIntrinsicType(TypeFlagsAny, "any", nil, "wildcard")
	blockedStringType := createIntrinsicType(TypeFlagsAny, "any", nil, "blocked string")
	errorType := createIntrinsicType(TypeFlagsAny, "error")
	unresolvedType := createIntrinsicType(TypeFlagsAny, "unresolved")
	nonInferrableAnyType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsContainsWideningType, "non-inferrable")
	intrinsicMarkerType := createIntrinsicType(TypeFlagsAny, "intrinsic")
	unknownType := createIntrinsicType(TypeFlagsUnknown, "unknown")
	undefinedType := createIntrinsicType(TypeFlagsUndefined, "undefined")
	undefinedWideningType := /* TODO(Node ConditionalExpression): strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening") */ TODO
	missingType := createIntrinsicType(TypeFlagsUndefined, "undefined", nil, "missing")
	undefinedOrMissingType := /* TODO(Node ConditionalExpression): exactOptionalPropertyTypes ? missingType : undefinedType */ TODO
	optionalType := createIntrinsicType(TypeFlagsUndefined, "undefined", nil, "optional")
	nullType := createIntrinsicType(TypeFlagsNull, "null")
	nullWideningType := /* TODO(Node ConditionalExpression): strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening") */ TODO
	stringType := createIntrinsicType(TypeFlagsString, "string")
	numberType := createIntrinsicType(TypeFlagsNumber, "number")
	bigintType := createIntrinsicType(TypeFlagsBigInt, "bigint")
	falseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false", nil, "fresh")
	regularFalseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false")
	trueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true", nil, "fresh")
	regularTrueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true")
	trueType.regularType = regularTrueType
	trueType.freshType = trueType
	regularTrueType.regularType = regularTrueType
	regularTrueType.freshType = trueType
	falseType.regularType = regularFalseType
	falseType.freshType = falseType
	regularFalseType.regularType = regularFalseType
	regularFalseType.freshType = falseType
	booleanType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FreshableIntrinsicType */ any{regularFalseType, regularTrueType})
	esSymbolType := createIntrinsicType(TypeFlagsESSymbol, "symbol")
	voidType := createIntrinsicType(TypeFlagsVoid, "void")
	neverType := createIntrinsicType(TypeFlagsNever, "never")
	silentNeverType := createIntrinsicType(TypeFlagsNever, "never", ObjectFlagsNonInferrableType, "silent")
	implicitNeverType := createIntrinsicType(TypeFlagsNever, "never", nil, "implicit")
	unreachableNeverType := createIntrinsicType(TypeFlagsNever, "never", nil, "unreachable")
	nonPrimitiveType := createIntrinsicType(TypeFlagsNonPrimitive, "object")
	stringOrNumberType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{stringType, numberType})
	stringNumberSymbolType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{stringType, numberType, esSymbolType})
	numberOrBigIntType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{numberType, bigintType})
	templateConstraintType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{stringType, numberType, booleanType, bigintType, nullType, undefinedType})
	numericStringType := getTemplateLiteralType([] /* TODO inferred type string */ any{"", ""}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{numberType})
	var restrictiveMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.TypeParameter ? getRestrictiveTypeParameter(t as TypeParameter) : t */ TODO
	}, func() /* TODO inferred type string */ any {
		return "(restrictive mapper)"
	})
	var permissiveMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.TypeParameter ? wildcardType : t */ TODO
	}, func() /* TODO inferred type string */ any {
		return "(permissive mapper)"
	})
	uniqueLiteralType := createIntrinsicType(TypeFlagsNever, "never", nil, "unique literal")
	var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.TypeParameter ? uniqueLiteralType : t */ TODO
	}, func() /* TODO inferred type string */ any {
		return "(unique literal mapper)"
	})
	var outofbandVarianceMarkerHandler *func(onlyUnreliable bool)
	reportUnreliableMapper := makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(true)
		}
		return t
	}, func() /* TODO inferred type string */ any {
		return "(unmeasurable reporter)"
	})
	reportUnmeasurableMapper := makeFunctionTypeMapper(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(false)
		}
		return t
	}, func() /* TODO inferred type string */ any {
		return "(unreliable reporter)"
	})
	emptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType.objectFlags |= ObjectFlagsJsxAttributes
	emptyTypeLiteralSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	emptyTypeLiteralSymbol.members = createSymbolTable()
	emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownEmptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownUnionType := /* TODO(Node ConditionalExpression): strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType */ TODO
	emptyGenericType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyGenericType.instantiations = make(map[string]TypeReference)
	anyFunctionType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	anyFunctionType.objectFlags |= ObjectFlagsNonInferrableType
	noConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	circularConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	resolvingDefaultType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	markerSuperType := createTypeParameter()
	markerSubType := createTypeParameter()
	markerSubType.constraint = markerSuperType
	markerOtherType := createTypeParameter()
	markerSuperTypeForCheck := createTypeParameter()
	markerSubTypeForCheck := createTypeParameter()
	markerSubTypeForCheck.constraint = markerSuperTypeForCheck
	noTypePredicate := createTypePredicate(TypePredicateKindIdentifier, "<<unresolved>>", 0, anyType)
	anySignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0, SignatureFlagsNone)
	unknownSignature := createSignature(nil, nil, nil, emptyArray, errorType, nil, 0, SignatureFlagsNone)
	resolvingSignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0, SignatureFlagsNone)
	silentNeverSignature := createSignature(nil, nil, nil, emptyArray, silentNeverType, nil, 0, SignatureFlagsNone)
	enumNumberIndexInfo := createIndexInfo(numberType, stringType, true)
	iterationTypesCache := make(map[string]IterationTypes)
	var noIterationTypes IterationTypes = /* TODO(Node ObjectLiteralExpression): { get yieldType(): Type { return Debug.fail("Not supported"); }, get returnType(): Type { return Debug.fail("Not supported"); }, get nextType(): Type { return Debug.fail("Not supported"); }, } */ TODO
	anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
	var asyncIterationTypesResolver IterationTypesResolver = /* TODO(Node ObjectLiteralExpression): { iterableCacheKey: "iterationTypesOfAsyncIterable", iteratorCacheKey: "iterationTypesOfAsyncIterator", iteratorSymbolName: "asyncIterator", getGlobalIteratorType: getGlobalAsyncIteratorType, getGlobalIterableType: getGlobalAsyncIterableType, getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType, getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType, getGlobalGeneratorType: getGlobalAsyncGeneratorType, getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes, resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member), mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method, mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method, mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property, } */ TODO
	var syncIterationTypesResolver IterationTypesResolver = /* TODO(Node ObjectLiteralExpression): { iterableCacheKey: "iterationTypesOfIterable", iteratorCacheKey: "iterationTypesOfIterator", iteratorSymbolName: "iterator", getGlobalIteratorType, getGlobalIterableType, getGlobalIterableIteratorType, getGlobalIteratorObjectType, getGlobalGeneratorType, getGlobalBuiltinIteratorTypes, resolveIterationType: (type, _errorNode) => type, mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method, mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method, mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property, } */ TODO
	type DuplicateInfoForSymbol struct {
		firstFileLocations  []Declaration
		secondFileLocations []Declaration
		isBlockScoped       bool
	}
	type DuplicateInfoForFiles struct {
		firstFile          SourceFile
		secondFile         SourceFile
		conflictingSymbols Map[string, DuplicateInfoForSymbol]
	}
	var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
	reverseMappedCache := make(map[string]*Type)
	reverseHomomorphicMappedCache := make(map[string]*Type)
	var ambientModulesCache *[]Symbol
	var patternAmbientModules []PatternAmbientModule
	var patternAmbientModuleAugmentations *Map[string, Symbol]
	var globalObjectType ObjectType
	var globalFunctionType ObjectType
	var globalCallableFunctionType ObjectType
	var globalNewableFunctionType ObjectType
	var globalArrayType GenericType
	var globalReadonlyArrayType GenericType
	var globalStringType ObjectType
	var globalNumberType ObjectType
	var globalBooleanType ObjectType
	var globalRegExpType ObjectType
	var globalThisType GenericType
	var anyArrayType Type
	var autoArrayType Type
	var anyReadonlyArrayType Type
	var deferredGlobalNonNullableTypeAlias Symbol
	var deferredGlobalESSymbolConstructorSymbol *Symbol
	var deferredGlobalESSymbolConstructorTypeSymbol *Symbol
	var deferredGlobalESSymbolType *ObjectType
	var deferredGlobalTypedPropertyDescriptorType GenericType
	var deferredGlobalPromiseType *GenericType
	var deferredGlobalPromiseLikeType *GenericType
	var deferredGlobalPromiseConstructorSymbol *Symbol
	var deferredGlobalPromiseConstructorLikeType *ObjectType
	var deferredGlobalIterableType *GenericType
	var deferredGlobalIteratorType *GenericType
	var deferredGlobalIterableIteratorType *GenericType
	var deferredGlobalIteratorObjectType *GenericType
	var deferredGlobalGeneratorType *GenericType
	var deferredGlobalIteratorYieldResultType *GenericType
	var deferredGlobalIteratorReturnResultType *GenericType
	var deferredGlobalAsyncIterableType *GenericType
	var deferredGlobalAsyncIteratorType *GenericType
	var deferredGlobalAsyncIterableIteratorType *GenericType
	var deferredGlobalBuiltinIteratorTypes *[]GenericType
	var deferredGlobalBuiltinAsyncIteratorTypes *[]GenericType
	var deferredGlobalAsyncIteratorObjectType *GenericType
	var deferredGlobalAsyncGeneratorType *GenericType
	var deferredGlobalTemplateStringsArrayType *ObjectType
	var deferredGlobalImportMetaType ObjectType
	var deferredGlobalImportMetaExpressionType ObjectType
	var deferredGlobalImportCallOptionsType *ObjectType
	var deferredGlobalImportAttributesType *ObjectType
	var deferredGlobalDisposableType *ObjectType
	var deferredGlobalAsyncDisposableType *ObjectType
	var deferredGlobalExtractSymbol *Symbol
	var deferredGlobalOmitSymbol *Symbol
	var deferredGlobalAwaitedSymbol *Symbol
	var deferredGlobalBigIntType *ObjectType
	var deferredGlobalNaNSymbol *Symbol
	var deferredGlobalRecordSymbol *Symbol
	var deferredGlobalClassDecoratorContextType *GenericType
	var deferredGlobalClassMethodDecoratorContextType *GenericType
	var deferredGlobalClassGetterDecoratorContextType *GenericType
	var deferredGlobalClassSetterDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorTargetType *GenericType
	var deferredGlobalClassAccessorDecoratorResultType *GenericType
	var deferredGlobalClassFieldDecoratorContextType *GenericType
	allPotentiallyUnusedIdentifiers := make(map[Path][]PotentiallyUnusedIdentifier)
	flowLoopStart := 0
	flowLoopCount := 0
	sharedFlowCount := 0
	flowAnalysisDisabled := false
	flowInvocationCount := 0
	var lastFlowNode *FlowNode
	var lastFlowNodeReachable bool
	var flowTypeCache *[]Type
	var contextualTypeNodes []Node = [] /* TODO inferred type never */ any{}
	var contextualTypes []*Type = [] /* TODO inferred type never */ any{}
	var contextualIsCache []bool = [] /* TODO inferred type never */ any{}
	contextualTypeCount := 0
	var contextualBindingPatterns []BindingPattern = [] /* TODO inferred type never */ any{}
	var inferenceContextNodes []Node = [] /* TODO inferred type never */ any{}
	var inferenceContexts []*InferenceContext = [] /* TODO inferred type never */ any{}
	inferenceContextCount := 0
	emptyStringType := getStringLiteralType("")
	zeroType := getNumberLiteralType(0)
	zeroBigIntType := getBigIntLiteralType( /* TODO(Node ObjectLiteralExpression): { negative: false, base10Value: "0" } */ TODO)
	var resolutionTargets []TypeSystemEntity = [] /* TODO inferred type never */ any{}
	var resolutionResults []bool = [] /* TODO inferred type never */ any{}
	var resolutionPropertyNames []TypeSystemPropertyName = [] /* TODO inferred type never */ any{}
	resolutionStart := 0
	inVarianceComputation := false
	suggestionCount := 0
	maximumSuggestionCount := 10
	var mergedSymbols []Symbol = [] /* TODO inferred type never */ any{}
	var symbolLinks []SymbolLinks = [] /* TODO inferred type never */ any{}
	var nodeLinks []NodeLinks = [] /* TODO inferred type never */ any{}
	var flowLoopCaches []Map[string, Type] = [] /* TODO inferred type never */ any{}
	var flowLoopNodes []FlowNode = [] /* TODO inferred type never */ any{}
	var flowLoopKeys []string = [] /* TODO inferred type never */ any{}
	var flowLoopTypes [][]Type = [] /* TODO inferred type never */ any{}
	var sharedFlowNodes []FlowNode = [] /* TODO inferred type never */ any{}
	var sharedFlowTypes []FlowType = [] /* TODO inferred type never */ any{}
	var flowNodeReachable []*bool = [] /* TODO inferred type never */ any{}
	var flowNodePostSuper []*bool = [] /* TODO inferred type never */ any{}
	var potentialThisCollisions []Node = [] /* TODO inferred type never */ any{}
	var potentialNewTargetCollisions []Node = [] /* TODO inferred type never */ any{}
	var potentialWeakMapSetCollisions []Node = [] /* TODO inferred type never */ any{}
	var potentialReflectCollisions []Node = [] /* TODO inferred type never */ any{}
	var potentialUnusedRenamedBindingElementsInTypes []BindingElement = [] /* TODO inferred type never */ any{}
	var awaitedTypeStack []number = [] /* TODO inferred type never */ any{}
	var reverseMappedSourceStack []Type = [] /* TODO inferred type never */ any{}
	var reverseMappedTargetStack []Type = [] /* TODO inferred type never */ any{}
	reverseExpandingFlags := ExpandingFlagsNone
	diagnostics := createDiagnosticCollection()
	suggestionDiagnostics := createDiagnosticCollection()
	typeofType := createTypeofType()
	var _jsxNamespace __String
	var _jsxFactoryEntity *EntityName
	subtypeRelation := make(map[string]RelationComparisonResult)
	strictSubtypeRelation := make(map[string]RelationComparisonResult)
	assignableRelation := make(map[string]RelationComparisonResult)
	comparableRelation := make(map[string]RelationComparisonResult)
	identityRelation := make(map[string]RelationComparisonResult)
	enumRelation := make(map[string]RelationComparisonResult)
	var suggestedExtensions [] /* TODO(TypeNode TupleType): [string, string] */ any = [] /* TODO inferred type [string, string] */ any{[]TODO{".mts", ".mjs"}, []TODO{".ts", ".js"}, []TODO{".cts", ".cjs"}, []TODO{".mjs", ".mjs"}, []TODO{".js", ".js"}, []TODO{".cjs", ".cjs"}, []TODO{".tsx" /* TODO(Node ConditionalExpression): compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js" */, TODO}, []TODO{".jsx", ".jsx"}, []TODO{".json", ".json"}}
	initializeTypeChecker()
	return checker
	isDefinitelyReferenceToGlobalSymbolObject := func(node Node) bool {
		if !isPropertyAccessExpression(node) {
			return false
		}
		if !isIdentifier(node.name) {
			return false
		}
		if !isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression) {
			return false
		}
		if isIdentifier(node.expression) {
			return idText(node.expression) == "Symbol" && getResolvedSymbol(node.expression) == (getGlobalSymbol("Symbol", SymbolFlagsValue|SymbolFlagsExportValue, nil) || unknownSymbol)
		}
		if !isIdentifier(node.expression.expression) {
			return false
		}
		return idText(node.expression.name) == "Symbol" && idText(node.expression.expression) == "globalThis" && getResolvedSymbol(node.expression.expression) == globalThisSymbol
	}
	getCachedType := func(key *string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		// converted from conditional expression
		switch {
		case key:
			return cachedTypes.get(key)
		default:
			return nil
		}
	}
	setCachedType := func(key *string, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if key {
			cachedTypes.set(key, type_)
		}
		return type_
	}
	getJsxNamespace := func(location Node) __String {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if isJsxOpeningFragment(location) {
					if file.localJsxFragmentNamespace {
						return file.localJsxFragmentNamespace
					}
					jsxFragmentPragma := file.pragmas.get("jsxfrag")
					if jsxFragmentPragma {
						chosenPragma := /* TODO(Node ConditionalExpression): isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma */ TODO
						file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
						visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName)
						if file.localJsxFragmentFactory {
							file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText
							return file.localJsxFragmentNamespace
						}
					}
					entity := getJsxFragmentFactoryEntity(location)
					if entity {
						file.localJsxFragmentFactory = entity
						file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText
						return file.localJsxFragmentNamespace
					}
				} else {
					localJsxNamespace := getLocalJsxNamespace(file)
					if localJsxNamespace {
						file.localJsxNamespace = localJsxNamespace
						return file.localJsxNamespace
					}
				}
			}
		}
		if !_jsxNamespace {
			_jsxNamespace = "React"
			if compilerOptions.jsxFactory {
				_jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion)
				visitNode(_jsxFactoryEntity, markAsSynthetic)
				if _jsxFactoryEntity {
					_jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText
				}
			} else if compilerOptions.reactNamespace {
				_jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace)
			}
		}
		if !_jsxFactoryEntity {
			_jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement")
		}
		return _jsxNamespace
	}
	getLocalJsxNamespace := func(file SourceFile) *__String {
		if file.localJsxNamespace {
			return file.localJsxNamespace
		}
		jsxPragma := file.pragmas.get("jsx")
		if jsxPragma {
			chosenPragma := /* TODO(Node ConditionalExpression): isArray(jsxPragma) ? jsxPragma[0] : jsxPragma */ TODO
			file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
			visitNode(file.localJsxFactory, markAsSynthetic, isEntityName)
			if file.localJsxFactory {
				file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText
				return file.localJsxNamespace
			}
		}
	}
	markAsSynthetic := func(node T) VisitResult[T] {
		setTextRangePosEnd(node, -1, -1)
		return visitEachChildWorker(node, markAsSynthetic, nil)
	}
	getEmitResolver := func(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitResolver */ any {
		if !skipDiagnostics {
			getDiagnostics(sourceFile, cancellationToken)
		}
		return emitResolver
	}
	lookupOrIssueError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := /* TODO(Node ConditionalExpression): location ? createDiagnosticForNode(location, message, ...args) : createCompilerDiagnostic(message, ...args) */ TODO
		existing := diagnostics.lookup(diagnostic)
		if existing {
			return existing
		} else {
			diagnostics.add(diagnostic)
			return diagnostic
		}
	}
	errorSkippedOn := func(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message, args...)
		diagnostic.skippedOn = key
		return diagnostic
	}
	createError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		// converted from conditional expression
		switch {
		case location:
			return createDiagnosticForNode(location, message, args...)
		default:
			return createCompilerDiagnostic(message, args...)
		}
	}
	error := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := createError(location, message, args...)
		diagnostics.add(diagnostic)
		return diagnostic
	}
	addErrorOrSuggestion := func(isError bool, diagnostic Diagnostic) {
		if isError {
			diagnostics.add(diagnostic)
		} else {
			suggestionDiagnostics.add( /* TODO(Node ObjectLiteralExpression): { ...diagnostic, category: DiagnosticCategory.Suggestion } */ TODO)
		}
	}
	errorOrSuggestion := func(isError bool, location Node, message /* TODO(TypeNode UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		if location.pos < 0 || location.end < 0 {
			if !isError {
				return
			}
			file := getSourceFileOfNode(location)
			addErrorOrSuggestion(isError /* TODO(Node ConditionalExpression): "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message) */, TODO)
			return
		}
		addErrorOrSuggestion(isError /* TODO(Node ConditionalExpression): "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message) */, TODO)
	}
	errorAndMaybeSuggestAwait := func(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message, args...)
		if maybeMissingAwait {
			related := createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await)
			addRelatedInfo(diagnostic, related)
		}
		return diagnostic
	}
	addDeprecatedSuggestionWorker := func(declarations /* TODO(TypeNode UnionType): Node | Node[] */ any, diagnostic DiagnosticWithLocation) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
		deprecatedTag := /* TODO(Node ConditionalExpression): Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations) */ TODO
		if deprecatedTag {
			addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here))
		}
		suggestionDiagnostics.add(diagnostic)
		return diagnostic
	}
	isDeprecatedSymbol := func(symbol Symbol) /* TODO inferred type boolean | 0 */ any {
		parentSymbol := getParentOfSymbol(symbol)
		if parentSymbol && length(symbol.declarations) > 1 {
			// converted from conditional expression
			switch {
			case parentSymbol.flags & SymbolFlagsInterface:
				return some(symbol.declarations, isDeprecatedDeclaration)
			default:
				return every(symbol.declarations, isDeprecatedDeclaration)
			}
		}
		return !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration) || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration)
	}
	isDeprecatedDeclaration := func(declaration Declaration) /* TODO inferred type boolean */ any {
		return !!(getCombinedNodeFlagsCached(declaration) & NodeFlagsDeprecated)
	}
	addDeprecatedSuggestion := func(location Node, declarations []Node, deprecatedEntity string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
		diagnostic := createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity)
		return addDeprecatedSuggestionWorker(declarations, diagnostic)
	}
	addDeprecatedSuggestionWithSignature := func(location Node, declaration Node, deprecatedEntity *string, signatureString string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
		diagnostic := /* TODO(Node ConditionalExpression): deprecatedEntity ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity) : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString) */ TODO
		return addDeprecatedSuggestionWorker(declaration, diagnostic)
	}
	createSymbol := func(flags SymbolFlags, name __String, checkFlags CheckFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
		symbolCount++
		symbol := /* TODO(Node NewExpression): new Symbol(flags | SymbolFlags.Transient, name) */ TODO
		symbol.links = /* TODO(Node NewExpression): new SymbolLinks() */ TODO
		symbol.links.checkFlags = checkFlags || CheckFlagsNone
		return symbol
	}
	createParameter := func(name __String, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
		symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name)
		symbol.links.type_ = type_
		return symbol
	}
	createProperty := func(name __String, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
		symbol := createSymbol(SymbolFlagsProperty, name)
		symbol.links.type_ = type_
		return symbol
	}
	getExcludedSymbolFlags := func(flags SymbolFlags) SymbolFlags {
		var result SymbolFlags = 0
		if flags & SymbolFlagsBlockScopedVariable {
			result |= SymbolFlagsBlockScopedVariableExcludes
		}
		if flags & SymbolFlagsFunctionScopedVariable {
			result |= SymbolFlagsFunctionScopedVariableExcludes
		}
		if flags & SymbolFlagsProperty {
			result |= SymbolFlagsPropertyExcludes
		}
		if flags & SymbolFlagsEnumMember {
			result |= SymbolFlagsEnumMemberExcludes
		}
		if flags & SymbolFlagsFunction {
			result |= SymbolFlagsFunctionExcludes
		}
		if flags & SymbolFlagsClass {
			result |= SymbolFlagsClassExcludes
		}
		if flags & SymbolFlagsInterface {
			result |= SymbolFlagsInterfaceExcludes
		}
		if flags & SymbolFlagsRegularEnum {
			result |= SymbolFlagsRegularEnumExcludes
		}
		if flags & SymbolFlagsConstEnum {
			result |= SymbolFlagsConstEnumExcludes
		}
		if flags & SymbolFlagsValueModule {
			result |= SymbolFlagsValueModuleExcludes
		}
		if flags & SymbolFlagsMethod {
			result |= SymbolFlagsMethodExcludes
		}
		if flags & SymbolFlagsGetAccessor {
			result |= SymbolFlagsGetAccessorExcludes
		}
		if flags & SymbolFlagsSetAccessor {
			result |= SymbolFlagsSetAccessorExcludes
		}
		if flags & SymbolFlagsTypeParameter {
			result |= SymbolFlagsTypeParameterExcludes
		}
		if flags & SymbolFlagsTypeAlias {
			result |= SymbolFlagsTypeAliasExcludes
		}
		if flags & SymbolFlagsAlias {
			result |= SymbolFlagsAliasExcludes
		}
		return result
	}
	recordMergedSymbol := func(target Symbol, source Symbol) {
		if !source.mergeId {
			source.mergeId = nextMergeId
			nextMergeId++
		}
		mergedSymbols[source.mergeId] = target
	}
	cloneSymbol := func(symbol Symbol) TransientSymbol {
		result := createSymbol(symbol.flags, symbol.escapedName)
		result.declarations = /* TODO(Node ConditionalExpression): symbol.declarations ? symbol.declarations.slice() : [] */ TODO
		result.parent = symbol.parent
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if symbol.constEnumOnlyModule {
			result.constEnumOnlyModule = true
		}
		if symbol.members {
			result.members = /* TODO(Node NewExpression): new Map(symbol.members) */ TODO
		}
		if symbol.exports {
			result.exports = /* TODO(Node NewExpression): new Map(symbol.exports) */ TODO
		}
		recordMergedSymbol(result, symbol)
		return result
	}
	mergeSymbol := func(target Symbol, source Symbol, unidirectional /* TODO inferred type boolean */ any /*  = false */) Symbol {
		if !(target.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|target.flags)&SymbolFlagsAssignment {
			if source == target {
				return target
			}
			if !(target.flags & SymbolFlagsTransient) {
				resolvedTarget := resolveSymbol(target)
				if resolvedTarget == unknownSymbol {
					return source
				}
				if !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|resolvedTarget.flags)&SymbolFlagsAssignment {
					target = cloneSymbol(resolvedTarget)
				} else {
					reportMergeSymbolError(target, source)
					return source
				}
			}
			if source.flags&SymbolFlagsValueModule && target.flags&SymbolFlagsValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule {
				target.constEnumOnlyModule = false
			}
			target.flags |= source.flags
			if source.valueDeclaration {
				setValueDeclaration(target, source.valueDeclaration)
			}
			addRange(target.declarations, source.declarations)
			if source.members {
				if !target.members {
					target.members = createSymbolTable()
				}
				mergeSymbolTable(target.members, source.members, unidirectional)
			}
			if source.exports {
				if !target.exports {
					target.exports = createSymbolTable()
				}
				mergeSymbolTable(target.exports, source.exports, unidirectional, target)
			}
			if !unidirectional {
				recordMergedSymbol(target, source)
			}
		} else if target.flags & SymbolFlagsNamespaceModule {
			if target != globalThisSymbol {
				error(source.declarations && getNameOfDeclaration(source.declarations[0]), Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target))
			}
		} else {
			reportMergeSymbolError(target, source)
		}
		return target
		reportMergeSymbolError := func(target Symbol, source Symbol) {
			isEitherEnum := !!(target.flags&SymbolFlagsEnum || source.flags&SymbolFlagsEnum)
			isEitherBlockScoped := !!(target.flags&SymbolFlagsBlockScopedVariable || source.flags&SymbolFlagsBlockScopedVariable)
			message := /* TODO(Node ConditionalExpression): isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0 */ TODO
			sourceSymbolFile := source.declarations && getSourceFileOfNode(source.declarations[0])
			targetSymbolFile := target.declarations && getSourceFileOfNode(target.declarations[0])
			isSourcePlainJs := isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs)
			isTargetPlainJs := isPlainJsFile(targetSymbolFile, compilerOptions.checkJs)
			symbolName := symbolToString(source)
			if sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile != targetSymbolFile {
				firstFile := /* TODO(Node ConditionalExpression): comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile */ TODO
				secondFile := /* TODO(Node ConditionalExpression): firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile */ TODO
				filesDuplicates := getOrUpdate(amalgamatedDuplicates /* TODO(Node TemplateExpression): `${firstFile.path}|${secondFile.path}` */, TODO, func() DuplicateInfoForFiles {
					return ( /* TODO(Node ObjectLiteralExpression): { firstFile, secondFile, conflictingSymbols: new Map() } */ TODO)
				})
				conflictingSymbolInfo := getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, func() DuplicateInfoForSymbol {
					return ( /* TODO(Node ObjectLiteralExpression): { isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] } */ TODO)
				})
				if !isSourcePlainJs {
					addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source)
				}
				if !isTargetPlainJs {
					addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target)
				}
			} else {
				if !isSourcePlainJs {
					addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target)
				}
				if !isTargetPlainJs {
					addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source)
				}
			}
		}
		addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
			if symbol.declarations {
				for _, decl := range symbol.declarations {
					pushIfUnique(locs, decl)
				}
			}
		}
	}
	addDuplicateDeclarationErrorsForSymbols := func(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
		forEach(target.declarations, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
			addDuplicateDeclarationError(node, message, symbolName, source.declarations)
		})
	}
	addDuplicateDeclarationError := func(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes *[]Declaration) {
		errorNode := ( /* TODO(Node ConditionalExpression): getExpandoInitializer(node, /*isPrototypeAssignment* / false) ? getNameOfExpando(node) : getNameOfDeclaration(node) */ TODO) || node
		err := lookupOrIssueError(errorNode, message, symbolName)
		for _, relatedNode := range relatedNodes || emptyArray {
			adjustedNode := ( /* TODO(Node ConditionalExpression): getExpandoInitializer(relatedNode, /*isPrototypeAssignment* / false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode) */ TODO) || relatedNode
			if adjustedNode == errorNode {
				continue
			}
			err.relatedInformation = err.relatedInformation || [] /* TODO inferred type never */ any{}
			leadingMessage := createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName)
			followOnMessage := createDiagnosticForNode(adjustedNode, Diagnostics.and_here)
			if length(err.relatedInformation) >= 5 || some(err.relatedInformation, func(r /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ any) /* TODO inferred type boolean */ any {
				return compareDiagnostics(r, followOnMessage) == ComparisonEqualTo || compareDiagnostics(r, leadingMessage) == ComparisonEqualTo
			}) {
				continue
			}
			addRelatedInfo(err /* TODO(Node ConditionalExpression): !length(err.relatedInformation) ? leadingMessage : followOnMessage */, TODO)
		}
	}
	combineSymbolTables := func(first *SymbolTable, second *SymbolTable) *SymbolTable {
		if !first. /*?*/ size {
			return second
		}
		if !second. /*?*/ size {
			return first
		}
		combined := createSymbolTable()
		mergeSymbolTable(combined, first)
		mergeSymbolTable(combined, second)
		return combined
	}
	mergeSymbolTable := func(target SymbolTable, source SymbolTable, unidirectional /* TODO inferred type boolean */ any /*  = false */, mergedParent Symbol) {
		source.forEach(func(sourceSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
			targetSymbol := target.get(id)
			merged := /* TODO(Node ConditionalExpression): targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol) */ TODO
			if mergedParent && targetSymbol {
				merged.parent = mergedParent
			}
			target.set(id, merged)
		})
	}
	mergeModuleAugmentation := func(moduleName /* TODO(TypeNode UnionType): StringLiteral | Identifier */ any) {
		moduleAugmentation := moduleName.parent
		if moduleAugmentation.symbol.declarations[0] != moduleAugmentation {
			Debug.assert(moduleAugmentation.symbol.declarations.length > 1)
			return
		}
		if isGlobalScopeAugmentation(moduleAugmentation) {
			mergeSymbolTable(globals, moduleAugmentation.symbol.exports)
		} else {
			moduleNotFoundError := /* TODO(Node ConditionalExpression): !(moduleName.parent.parent.flags & NodeFlags.Ambient) ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found : undefined */ TODO
			mainModule := resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, false, true)
			if !mainModule {
				return
			}
			mainModule = resolveExternalModuleSymbol(mainModule)
			if mainModule.flags & SymbolFlagsNamespace {
				if some(patternAmbientModules, func(module /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PatternAmbientModule */ any) /* TODO inferred type boolean */ any {
					return mainModule == module.symbol
				}) {
					merged := mergeSymbol(moduleAugmentation.symbol, mainModule, true)
					if !patternAmbientModuleAugmentations {
						patternAmbientModuleAugmentations = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
					}
					patternAmbientModuleAugmentations.set((moduleName).text, merged)
				} else {
					if mainModule.exports. /*?*/ get(InternalSymbolNameExportStar) && moduleAugmentation.symbol.exports. /*?*/ size {
						resolvedExports := getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKindresolvedExports)
						for _, TODO_IDENTIFIER := range arrayFrom(moduleAugmentation.symbol.exports.entries()) {
							if resolvedExports.has(key) && !mainModule.exports.has(key) {
								mergeSymbol(resolvedExports.get(key), value)
							}
						}
					}
					mergeSymbol(mainModule, moduleAugmentation.symbol)
				}
			} else {
				error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName).text)
			}
		}
	}
	addUndefinedToGlobalsOrErrorOnRedeclaration := func() {
		name := undefinedSymbol.escapedName
		targetSymbol := globals.get(name)
		if targetSymbol {
			forEach(targetSymbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
				if !isTypeDeclaration(declaration) {
					diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)))
				}
			})
		} else {
			globals.set(name, undefinedSymbol)
		}
	}
	getSymbolLinks := func(symbol Symbol) SymbolLinks {
		if symbol.flags & SymbolFlagsTransient {
			return (symbol).links
		}
		id := getSymbolId(symbol)
		return /* TODO(Node BinaryExpression): symbolLinks[id] ??= new SymbolLinks() */ TODO
	}
	getNodeLinks := func(node Node) NodeLinks {
		nodeId := getNodeId(node)
		return nodeLinks[nodeId] || ( /* TODO(Node BinaryExpression): nodeLinks[nodeId] = new (NodeLinks as any)() */ TODO)
	}
	getSymbol := func(symbols SymbolTable, name __String, meaning SymbolFlags) *Symbol {
		if meaning {
			symbol := getMergedSymbol(symbols.get(name))
			if symbol {
				if symbol.flags & meaning {
					return symbol
				}
				if symbol.flags & SymbolFlagsAlias {
					targetFlags := getSymbolFlags(symbol)
					if targetFlags & meaning {
						return symbol
					}
				}
			}
		}
	}
	getSymbolsOfParameterPropertyDeclaration := func(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TypeNode TupleType): [Symbol, Symbol] */ any {
		constructorDeclaration := parameter.parent
		classDeclaration := parameter.parent.parent
		parameterSymbol := getSymbol(constructorDeclaration.locals, parameterName, SymbolFlagsValue)
		propertySymbol := getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlagsValue)
		if parameterSymbol && propertySymbol {
			return []TODO{parameterSymbol, propertySymbol}
		}
		return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration")
	}
	isBlockScopedNameDeclaredBeforeUse := func(declaration Declaration, usage Node) bool {
		declarationFile := getSourceFileOfNode(declaration)
		useFile := getSourceFileOfNode(usage)
		declContainer := getEnclosingBlockScopeContainer(declaration)
		if declarationFile != useFile {
			if (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) || (!compilerOptions.outFile) || isInTypeQuery(usage) || declaration.flags&NodeFlagsAmbient {
				return true
			}
			if isUsedInFunctionOrInstanceProperty(usage, declaration) {
				return true
			}
			sourceFiles := host.getSourceFiles()
			return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile)
		}
		if !!(usage.flags & NodeFlagsJSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage) {
			return true
		}
		if declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) {
			if declaration.kind == SyntaxKindBindingElement {
				errorBindingElement := getAncestor(usage, SyntaxKindBindingElement)
				if errorBindingElement {
					return findAncestor(errorBindingElement, isBindingElement) != findAncestor(declaration, isBindingElement) || declaration.pos < errorBindingElement.pos
				}
				return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKindVariableDeclaration), usage)
			} else if declaration.kind == SyntaxKindVariableDeclaration {
				return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage)
			} else if isClassLike(declaration) {
				container := findAncestor(usage, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
					return /* TODO(Node ConditionalExpression): n === declaration ? "quit" : isComputedPropertyName(n) ? n.parent.parent === declaration : !legacyDecorators && isDecorator(n) && (n.parent === declaration || isMethodDeclaration(n.parent) && n.parent.parent === declaration || isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration || isPropertyDeclaration(n.parent) && n.parent.parent === declaration || isParameter(n.parent) && n.parent.parent.parent === declaration) */ TODO
				})
				if !container {
					return true
				}
				if !legacyDecorators && isDecorator(container) {
					return !!findAncestor(usage, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
						return /* TODO(Node ConditionalExpression): n === container ? "quit" : isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n) */ TODO
					})
				}
				return false
			} else if isPropertyDeclaration(declaration) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false)
			} else if isParameterPropertyDeclaration(declaration, declaration.parent) {
				return !(emitStandardClassFields && getContainingClass(declaration) == getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(usage, declaration))
			}
			return true
		}
		if usage.parent.kind == SyntaxKindExportSpecifier || (usage.parent.kind == SyntaxKindExportAssignment && (usage.parent).isExportEquals) {
			return true
		}
		if usage.kind == SyntaxKindExportAssignment && (usage).isExportEquals {
			return true
		}
		if isUsedInFunctionOrInstanceProperty(usage, declaration) {
			if emitStandardClassFields && getContainingClass(declaration) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true)
			} else {
				return true
			}
		}
		return false
		isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
			switch declaration.parent.parent.kind {
			case SyntaxKindVariableStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForOfStatement:
				if isSameScopeDescendentOf(usage, declaration, declContainer) {
					return true
				}
				break
			}
			grandparent := declaration.parent.parent
			return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer)
		}
		isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
			return !!findAncestor(usage, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
				if current == declContainer {
					return "quit"
				}
				if isFunctionLike(current) {
					return true
				}
				if isClassStaticBlockDeclaration(current) {
					return declaration.pos < usage.pos
				}
				propertyDeclaration := tryCast(current.parent, isPropertyDeclaration)
				if propertyDeclaration {
					initializerOfProperty := propertyDeclaration.initializer == current
					if initializerOfProperty {
						if isStatic(current.parent) {
							if declaration.kind == SyntaxKindMethodDeclaration {
								return true
							}
							if isPropertyDeclaration(declaration) && getContainingClass(usage) == getContainingClass(declaration) {
								propName := declaration.name
								if isIdentifier(propName) || isPrivateIdentifier(propName) {
									type_ := getTypeOfSymbol(getSymbolOfDeclaration(declaration))
									staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
									if isPropertyInitializedInStaticBlocks(propName, type_, staticBlocks, declaration.parent.pos, current.pos) {
										return true
									}
								}
							}
						} else {
							isDeclarationInstanceProperty := declaration.kind == SyntaxKindPropertyDeclaration && !isStatic(declaration)
							if !isDeclarationInstanceProperty || getContainingClass(usage) != getContainingClass(declaration) {
								return true
							}
						}
					}
				}
				return false
			})
		}
		isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(TypeNode UnionType): PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) /* TODO inferred type boolean */ any {
			if usage.end > declaration.end {
				return false
			}
			ancestorChangingReferenceScope := findAncestor(usage, func(node Node) /* TODO inferred type boolean | "quit" */ any {
				if node == declaration {
					return "quit"
				}
				switch node.kind {
				case SyntaxKindArrowFunction:
					return true
				case SyntaxKindPropertyDeclaration:
					// converted from conditional expression
					switch {
					case stopAtAnyPropertyDeclaration && (isPropertyDeclaration(declaration) && node.parent == declaration.parent || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent == declaration.parent.parent):
						return "quit"
					default:
						return true
					}
				case SyntaxKindBlock:
					switch node.parent.kind {
					case SyntaxKindGetAccessor:
						fallthrough // TODO: merge cases
					case SyntaxKindMethodDeclaration:
						fallthrough // TODO: merge cases
					case SyntaxKindSetAccessor:
						return true
					default:
						return false
					}
					fallthrough
				default:
					return false
				}
			})
			return ancestorChangingReferenceScope == nil
		}
	}
	getRequiresScopeChangeCache := func(node FunctionLikeDeclaration) /* TODO inferred type boolean | undefined */ any {
		return getNodeLinks(node).declarationRequiresScopeChange
	}
	setRequiresScopeChangeCache := func(node FunctionLikeDeclaration, value bool) {
		getNodeLinks(node).declarationRequiresScopeChange = value
	}
	checkAndReportErrorForInvalidInitializer := func(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result *Symbol) /* TODO inferred type boolean */ any {
		if !emitStandardClassFields {
			if errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name) {
				return true
			}
			error(errorLocation /* TODO(Node ConditionalExpression): errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos) ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor */, TODO, declarationNameToString(propertyWithInvalidInitializer.name), diagnosticName(name))
			return true
		}
		return false
	}
	onFailedToResolveSymbol := func(errorLocation Node, nameArg /* TODO(TypeNode UnionType): __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
		name := /* TODO(Node ConditionalExpression): isString(nameArg) ? nameArg : (nameArg as Identifier).escapedText */ TODO
		addLazyDiagnostic(func() {
			if !errorLocation || errorLocation.parent.kind != SyntaxKindJSDocLink && !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) && !checkAndReportErrorForExtendingInterface(errorLocation) && !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) && !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) && !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
				var suggestion *Symbol
				var suggestedLib *string
				if nameArg {
					suggestedLib = getSuggestedLibForNonExistentName(nameArg)
					if suggestedLib {
						error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib)
					}
				}
				if !suggestedLib && suggestionCount < maximumSuggestionCount {
					suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning)
					isGlobalScopeAugmentationDeclaration := suggestion. /*?*/ valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration)
					if isGlobalScopeAugmentationDeclaration {
						suggestion = nil
					}
					if suggestion {
						suggestionName := symbolToString(suggestion)
						isUncheckedJS := isUncheckedJSSuggestion(errorLocation, suggestion, false)
						message := /* TODO(Node ConditionalExpression): meaning === SymbolFlags.Namespace || nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ? Diagnostics.Cannot_find_namespace_0_Did_you_mean_1 : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1 : Diagnostics.Cannot_find_name_0_Did_you_mean_1 */ TODO
						diagnostic := createError(errorLocation, message, diagnosticName(nameArg), suggestionName)
						diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg))
						addErrorOrSuggestion(!isUncheckedJS, diagnostic)
						if suggestion.valueDeclaration {
							addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
						}
					}
				}
				if !suggestion && !suggestedLib && nameArg {
					error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg))
				}
				suggestionCount++
			}
		})
	}
	onSuccessfullyResolvedSymbol := func(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(TypeNode UnionType): ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
		addLazyDiagnostic(func() {
			name := result.escapedName
			isInExternalModule := lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation)
			if errorLocation && (meaning&SymbolFlagsBlockScopedVariable || ((meaning&SymbolFlagsClass || meaning&SymbolFlagsEnum) && (meaning&SymbolFlagsValue) == SymbolFlagsValue)) {
				exportOrLocalSymbol := getExportSymbolOfValueSymbolIfExported(result)
				if exportOrLocalSymbol.flags&SymbolFlagsBlockScopedVariable || exportOrLocalSymbol.flags&SymbolFlagsClass || exportOrLocalSymbol.flags&SymbolFlagsEnum {
					checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation)
				}
			}
			if isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue && !(errorLocation.flags & NodeFlagsJSDoc) {
				merged := getMergedSymbol(result)
				if length(merged.declarations) && every(merged.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports
				}) {
					errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name))
				}
			}
			if associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				candidate := getMergedSymbol(getLateBoundSymbol(result))
				root := getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName)
				if candidate == getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName) {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name))
				} else if candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) == candidate {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation))
				}
			}
			if errorLocation && meaning&SymbolFlagsValue && result.flags&SymbolFlagsAlias && !(result.flags & SymbolFlagsValue) && !isValidTypeOnlyAliasUseSite(errorLocation) {
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(result, SymbolFlagsValue)
				if typeOnlyDeclaration {
					message := /* TODO(Node ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type */ TODO
					unescapedName := unescapeLeadingUnderscores(name)
					addTypeOnlyDeclarationRelatedInfo(error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName)
				}
			}
			if compilerOptions.isolatedModules && result && isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				isGlobal := getSymbol(globals, name, meaning) == result
				nonValueSymbol := isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlagsValue)
				if nonValueSymbol {
					importDecl := nonValueSymbol.declarations. /*?*/ find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
						return d.kind == SyntaxKindImportSpecifier || d.kind == SyntaxKindImportClause || d.kind == SyntaxKindNamespaceImport || d.kind == SyntaxKindImportEqualsDeclaration
					})
					if importDecl && !isTypeOnlyImportDeclaration(importDecl) {
						error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name))
					}
				}
			}
		})
	}
	addTypeOnlyDeclarationRelatedInfo := func(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ any {
		if !typeOnlyDeclaration {
			return diagnostic
		}
		return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration /* TODO(Node ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport ? Diagnostics._0_was_exported_here : Diagnostics._0_was_imported_here */, TODO, unescapedName))
	}
	diagnosticName := func(nameArg /* TODO(TypeNode UnionType): __String | Identifier | PrivateIdentifier */ any) /* TODO inferred type string */ any {
		// converted from conditional expression
		switch {
		case isString(nameArg):
			return unescapeLeadingUnderscores(nameArg)
		default:
			return declarationNameToString(nameArg)
		}
	}
	checkAndReportErrorForMissingPrefix := func(errorLocation Node, name __String, nameArg /* TODO(TypeNode UnionType): __String | Identifier */ any) bool {
		if !isIdentifier(errorLocation) || errorLocation.escapedText != name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) {
			return false
		}
		container := getThisContainer(errorLocation, false, false)
		var location Node = container
		for location {
			if isClassLike(location.parent) {
				classSymbol := getSymbolOfDeclaration(location.parent)
				if !classSymbol {
					break
				}
				constructorType := getTypeOfSymbol(classSymbol)
				if getPropertyOfType(constructorType, name) {
					error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol))
					return true
				}
				if location == container && !isStatic(location) {
					instanceType := (getDeclaredTypeOfSymbol(classSymbol)).thisType
					if getPropertyOfType(instanceType, name) {
						error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg))
						return true
					}
				}
			}
			location = location.parent
		}
		return false
	}
	checkAndReportErrorForExtendingInterface := func(errorLocation Node) bool {
		expression := getEntityNameForExtendingInterface(errorLocation)
		if expression && resolveEntityName(expression, SymbolFlagsInterface, true) {
			error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression))
			return true
		}
		return false
	}
	getEntityNameForExtendingInterface := func(node Node) *EntityNameExpression {
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			// converted from conditional expression
			switch {
			case node.parent:
				return getEntityNameForExtendingInterface(node.parent)
			default:
				return nil
			}
		case SyntaxKindExpressionWithTypeArguments:
			if isEntityNameExpression((node).expression) {
				return (node).expression
			}
			fallthrough
		default:
			return nil
		}
	}
	checkAndReportErrorForUsingTypeAsNamespace := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		namespaceMeaning := SymbolFlagsNamespace | ( /* TODO(Node ConditionalExpression): isInJSFile(errorLocation) ? SymbolFlags.Value : 0 */ TODO)
		if meaning == namespaceMeaning {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~namespaceMeaning, nil, false))
			parent := errorLocation.parent
			if symbol {
				if isQualifiedName(parent) {
					Debug.assert(parent.left == errorLocation, "Should only be resolving left side of qualified name as a namespace")
					propName := parent.right.escapedText
					propType := getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName)
					if propType {
						error(parent, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName))
						return true
					}
				}
				error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkAndReportErrorForUsingValueAsType := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsType & ~SymbolFlagsNamespace) {
			symbol := resolveSymbol(resolveName(errorLocation, name, ~SymbolFlagsType&SymbolFlagsValue, nil, false))
			if symbol && !(symbol.flags & SymbolFlagsNamespace) {
				error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	isPrimitiveTypeName := func(name __String) /* TODO inferred type boolean */ any {
		return name == "any" || name == "string" || name == "number" || name == "boolean" || name == "never" || name == "unknown"
	}
	checkAndReportErrorForExportingPrimitiveType := func(errorLocation Node, name __String) bool {
		if isPrimitiveTypeName(name) && errorLocation.parent.kind == SyntaxKindExportSpecifier {
			error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name)
			return true
		}
		return false
	}
	checkAndReportErrorForUsingTypeAsValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & SymbolFlagsValue {
			if isPrimitiveTypeName(name) {
				grandparent := errorLocation.parent.parent
				if grandparent && grandparent.parent && isHeritageClause(grandparent) {
					heritageKind := grandparent.token
					containerKind := grandparent.parent.kind
					if containerKind == SyntaxKindInterfaceDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindImplementsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name))
					}
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name))
				}
				return true
			}
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~SymbolFlagsValue, nil, false))
			allFlags := symbol && getSymbolFlags(symbol)
			if symbol && allFlags != nil && !(allFlags & SymbolFlagsValue) {
				rawName := unescapeLeadingUnderscores(name)
				if isES2015OrLaterConstructorName(name) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName)
				} else if maybeMappedType(errorLocation, symbol) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName /* TODO(Node ConditionalExpression): rawName === "K" ? "P" : "K" */, TODO)
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName)
				}
				return true
			}
		}
		return false
	}
	maybeMappedType := func(node Node, symbol Symbol) /* TODO inferred type boolean */ any {
		container := findAncestor(node.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(n) || "quit" */ TODO
		})
		if container && container.members.length == 1 {
			type_ := getDeclaredTypeOfSymbol(symbol)
			return !!(type_.flags & TypeFlagsUnion) && allTypesAssignableToKind(type_, TypeFlagsStringOrNumberLiteral, true)
		}
		return false
	}
	isES2015OrLaterConstructorName := func(n __String) /* TODO inferred type boolean */ any {
		switch n {
		case "Promise":
			fallthrough // TODO: merge cases
		case "Symbol":
			fallthrough // TODO: merge cases
		case "Map":
			fallthrough // TODO: merge cases
		case "WeakMap":
			fallthrough // TODO: merge cases
		case "Set":
			fallthrough // TODO: merge cases
		case "WeakSet":
			return true
		}
		return false
	}
	checkAndReportErrorForUsingNamespaceAsTypeOrValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsValue & ~SymbolFlagsType) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsNamespaceModule, nil, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_value, unescapeLeadingUnderscores(name))
				return true
			}
		} else if meaning & (SymbolFlagsType & ~SymbolFlagsValue) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsModule, nil, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkResolvedBlockScopedVariable := func(result Symbol, errorLocation Node) {
		Debug.assert(!!(result.flags&SymbolFlagsBlockScopedVariable || result.flags&SymbolFlagsClass || result.flags&SymbolFlagsEnum))
		if result.flags&(SymbolFlagsFunction|SymbolFlagsFunctionScopedVariable|SymbolFlagsAssignment) && result.flags&SymbolFlagsClass {
			return
		}
		declaration := result.declarations. /*?*/ find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
			return isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind == SyntaxKindEnumDeclaration)
		})
		if declaration == nil {
			return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration")
		}
		if !(declaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) {
			var diagnosticMessage TODO
			declarationName := declarationNameToString(getNameOfDeclaration(declaration))
			if result.flags & SymbolFlagsBlockScopedVariable {
				diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsClass {
				diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsRegularEnum {
				diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
			} else {
				Debug.assert(!!(result.flags & SymbolFlagsConstEnum))
				if getIsolatedModules(compilerOptions) {
					diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
				}
			}
			if diagnosticMessage {
				addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName))
			}
		}
	}
	isSameScopeDescendentOf := func(initial Node, parent Node, stopAt Node) bool {
		return !!parent && !!findAncestor(initial, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return n == parent || ( /* TODO(Node ConditionalExpression): n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false */ TODO)
		})
	}
	getAnyImportSyntax := func(node Node) *AnyImportOrJsDocImport {
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			return node
		case SyntaxKindImportClause:
			return (node).parent
		case SyntaxKindNamespaceImport:
			return (node).parent.parent
		case SyntaxKindImportSpecifier:
			return (node).parent.parent.parent
		default:
			return nil
		}
	}
	getDeclarationOfAliasSymbol := func(symbol Symbol) Declaration {
		return symbol.declarations && findLast(symbol.declarations, isAliasSymbolDeclaration)
	}
	isAliasSymbolDeclaration := func(node Node) bool {
		return node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindNamespaceExportDeclaration || node.kind == SyntaxKindImportClause && !!(node).name || node.kind == SyntaxKindNamespaceImport || node.kind == SyntaxKindNamespaceExport || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindExportSpecifier || node.kind == SyntaxKindExportAssignment && exportAssignmentIsAlias(node) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindModuleExports && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken && isAliasableOrJsExpression(node.parent.right) || node.kind == SyntaxKindShorthandPropertyAssignment || node.kind == SyntaxKindPropertyAssignment && isAliasableOrJsExpression((node).initializer) || node.kind == SyntaxKindVariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || node.kind == SyntaxKindBindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent)
	}
	isAliasableOrJsExpression := func(e Expression) /* TODO inferred type boolean */ any {
		return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e)
	}
	getTargetOfImportEqualsDeclaration := func(node /* TODO(TypeNode UnionType): ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) *Symbol {
		commonJSPropertyAccess := getCommonJSPropertyAccess(node)
		if commonJSPropertyAccess {
			name := (getLeftmostAccessExpression(commonJSPropertyAccess.expression)).arguments[0]
			// converted from conditional expression
			switch {
			case isIdentifier(commonJSPropertyAccess.name):
				return resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))
			default:
				return nil
			}
		}
		if isVariableDeclaration(node) || node.moduleReference.kind == SyntaxKindExternalModuleReference {
			immediate := resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node))
			resolved := resolveExternalModuleSymbol(immediate)
			markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
			return resolved
		}
		resolved := getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias)
		checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved)
		return resolved
	}
	checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol := func(node ImportEqualsDeclaration, resolved *Symbol) {
		if markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false) && !node.isTypeOnly {
			typeOnlyDeclaration := getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))
			isExport := typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration
			message := /* TODO(Node ConditionalExpression): isExport ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type */ TODO
			relatedMessage := /* TODO(Node ConditionalExpression): isExport ? Diagnostics._0_was_exported_here : Diagnostics._0_was_imported_here */ TODO
			name := /* TODO(Node ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? "*" : moduleExportNameTextUnescaped(typeOnlyDeclaration.name) */ TODO
			addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name))
		}
	}
	resolveExportByName := func(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		exportValue := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
		exportSymbol := /* TODO(Node ConditionalExpression): exportValue ? getPropertyOfType(getTypeOfSymbol(exportValue), name, /*skipObjectFunctionPropertyAugment* / true) : moduleSymbol.exports!.get(name) */ TODO
		resolved := resolveSymbol(exportSymbol, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false)
		return resolved
	}
	isSyntacticDefault := func(node Node) /* TODO inferred type boolean */ any {
		return ((isExportAssignment(node) && !node.isExportEquals) || hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) || isNamespaceExport(node))
	}
	getEmitSyntaxForModuleSpecifierExpression := func(usage Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolutionMode */ any {
		// converted from conditional expression
		switch {
		case isStringLiteralLike(usage):
			return host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage)
		default:
			return nil
		}
	}
	isESMFormatImportImportingCommonjsFormatFile := func(usageMode ResolutionMode, targetMode ResolutionMode) /* TODO inferred type boolean */ any {
		return usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS
	}
	isOnlyImportableAsDefault := func(usage Expression) /* TODO inferred type boolean */ any {
		if ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
			usageMode := getEmitSyntaxForModuleSpecifierExpression(usage)
			return usageMode == ModuleKindESNext && endsWith((usage).text, ExtensionJson)
		}
		return false
	}
	canHaveSyntheticDefault := func(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) /* TODO inferred type boolean */ any {
		usageMode := file && getEmitSyntaxForModuleSpecifierExpression(usage)
		if file && usageMode != nil {
			targetMode := host.getImpliedNodeFormatForEmit(file)
			if usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS && ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
				return true
			}
			if usageMode == ModuleKindESNext && targetMode == ModuleKindESNext {
				return false
			}
		}
		if !allowSyntheticDefaultImports {
			return false
		}
		if !file || file.isDeclarationFile {
			defaultExportSymbol := resolveExportByName(moduleSymbol, InternalSymbolNameDefault, nil, true)
			if defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault) {
				return false
			}
			if resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias) {
				return false
			}
			return true
		}
		if !isSourceFileJS(file) {
			return hasExportAssignmentSymbol(moduleSymbol)
		}
		return /* TODO(Node TypeOfExpression): typeof file.externalModuleIndicator */ TODO != "object" && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias)
	}
	getTargetOfImportClause := func(node ImportClause, dontResolveAlias bool) *Symbol {
		moduleSymbol := resolveExternalModuleName(node, node.parent.moduleSpecifier)
		if moduleSymbol {
			return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
		}
	}
	getTargetofModuleDefault := func(moduleSymbol Symbol, node /* TODO(TypeNode UnionType): ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		var exportDefaultSymbol *Symbol
		if isShorthandAmbientModuleSymbol(moduleSymbol) {
			exportDefaultSymbol = moduleSymbol
		} else {
			exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolNameDefault, node, dontResolveAlias)
		}
		file := moduleSymbol.declarations. /*?*/ find(isSourceFile)
		specifier := getModuleSpecifierForImportOrExport(node)
		if !specifier {
			return exportDefaultSymbol
		}
		hasDefaultOnly := isOnlyImportableAsDefault(specifier)
		hasSyntheticDefault := canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
		if !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly {
			if hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports {
				compilerOptionName := /* TODO(Node ConditionalExpression): moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop" */ TODO
				exportEqualsSymbol := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
				exportAssignment := exportEqualsSymbol.valueDeclaration
				err := error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName)
				if exportAssignment {
					addRelatedInfo(err, createDiagnosticForNode(exportAssignment, Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName))
				}
			} else if isImportClause(node) {
				reportNonDefaultExport(moduleSymbol, node)
			} else {
				errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name)
			}
		} else if hasSyntheticDefault || hasDefaultOnly {
			resolved := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false)
			return resolved
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, nil, false)
		return exportDefaultSymbol
	}
	getModuleSpecifierForImportOrExport := func(node /* TODO(TypeNode UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) *Expression {
		switch node.kind {
		case SyntaxKindImportClause:
			return node.parent.moduleSpecifier
		case SyntaxKindImportEqualsDeclaration:
			// converted from conditional expression
			switch {
			case isExternalModuleReference(node.moduleReference):
				return node.moduleReference.expression
			default:
				return nil
			}
		case SyntaxKindNamespaceImport:
			return node.parent.parent.moduleSpecifier
		case SyntaxKindImportSpecifier:
			return node.parent.parent.parent.moduleSpecifier
		case SyntaxKindExportSpecifier:
			return node.parent.parent.moduleSpecifier
		default:
			return Debug.assertNever(node)
		}
	}
	reportNonDefaultExport := func(moduleSymbol Symbol, node ImportClause) {
		if moduleSymbol.exports. /*?*/ has(node.symbol.escapedName) {
			error(node.name, Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol))
		} else {
			diagnostic := error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol))
			exportStar := moduleSymbol.exports. /*?*/ get(InternalSymbolNameExportStar)
			if exportStar {
				defaultExport := exportStar.declarations. /*?*/ find(func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return !!(isExportDeclaration(decl) && decl.moduleSpecifier && resolveExternalModuleName(decl, decl.moduleSpecifier). /*?*/ exports. /*?*/ has(InternalSymbolNameDefault))
				})
				if defaultExport {
					addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default))
				}
			}
		}
	}
	getTargetOfNamespaceImport := func(node NamespaceImport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := node.parent.parent.moduleSpecifier
		immediate := resolveExternalModuleName(node, moduleSpecifier)
		resolved := resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
		return resolved
	}
	getTargetOfNamespaceExport := func(node NamespaceExport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := node.parent.moduleSpecifier
		immediate := moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier)
		resolved := moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
		return resolved
	}
	combineValueAndTypeSymbols := func(valueSymbol Symbol, typeSymbol Symbol) Symbol {
		if valueSymbol == unknownSymbol && typeSymbol == unknownSymbol {
			return unknownSymbol
		}
		if valueSymbol.flags & (SymbolFlagsType | SymbolFlagsNamespace) {
			return valueSymbol
		}
		result := createSymbol(valueSymbol.flags|typeSymbol.flags, valueSymbol.escapedName)
		Debug.assert(valueSymbol.declarations || typeSymbol.declarations)
		result.declarations = deduplicate(concatenate(valueSymbol.declarations, typeSymbol.declarations), equateValues)
		result.parent = valueSymbol.parent || typeSymbol.parent
		if valueSymbol.valueDeclaration {
			result.valueDeclaration = valueSymbol.valueDeclaration
		}
		if typeSymbol.members {
			result.members = /* TODO(Node NewExpression): new Map(typeSymbol.members) */ TODO
		}
		if valueSymbol.exports {
			result.exports = /* TODO(Node NewExpression): new Map(valueSymbol.exports) */ TODO
		}
		return result
	}
	getExportOfModule := func(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) *Symbol {
		if symbol.flags & SymbolFlagsModule {
			exportSymbol := getExportsOfSymbol(symbol).get(nameText)
			resolved := resolveSymbol(exportSymbol, dontResolveAlias)
			exportStarDeclaration := getSymbolLinks(symbol).typeOnlyExportStarMap. /*?*/ get(nameText)
			markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false, exportStarDeclaration, nameText)
			return resolved
		}
	}
	getPropertyOfVariable := func(symbol Symbol, name __String) *Symbol {
		if symbol.flags & SymbolFlagsVariable {
			typeAnnotation := (symbol.valueDeclaration).type_
			if typeAnnotation {
				return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name))
			}
		}
	}
	getExternalModuleMember := func(node /* TODO(TypeNode UnionType): ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(TypeNode UnionType): ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias /* TODO inferred type boolean */ any /*  = false */) *Symbol {
		moduleSpecifier := getExternalModuleRequireArgument(node) || (node).moduleSpecifier
		moduleSymbol := resolveExternalModuleName(node, moduleSpecifier)
		name := !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name
		if !isIdentifier(name) && name.kind != SyntaxKindStringLiteral {
			return nil
		}
		nameText := moduleExportNameTextEscaped(name)
		suppressInteropError := nameText == InternalSymbolNameDefault && allowSyntheticDefaultImports
		targetSymbol := resolveESModuleSymbol(moduleSymbol, moduleSpecifier, false, suppressInteropError)
		if targetSymbol {
			if nameText || name.kind == SyntaxKindStringLiteral {
				if isShorthandAmbientModuleSymbol(moduleSymbol) {
					return moduleSymbol
				}
				var symbolFromVariable *Symbol
				if moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolNameExportEquals) {
					symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText, true)
				} else {
					symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText)
				}
				symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias)
				symbolFromModule := getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
				if symbolFromModule == nil && nameText == InternalSymbolNameDefault {
					file := moduleSymbol.declarations. /*?*/ find(isSourceFile)
					if isOnlyImportableAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) {
						symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
					}
				}
				symbol := /* TODO(Node ConditionalExpression): symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ? combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) : symbolFromModule || symbolFromVariable */ TODO
				if !symbol {
					errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name)
				}
				return symbol
			}
		}
	}
	errorNoModuleMemberSymbol := func(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
		moduleName := getFullyQualifiedName(moduleSymbol, node)
		declarationName := declarationNameToString(name)
		suggestion := /* TODO(Node ConditionalExpression): isIdentifier(name) ? getSuggestedSymbolForNonexistentModule(name, targetSymbol) : undefined */ TODO
		if suggestion != nil {
			suggestionName := symbolToString(suggestion)
			diagnostic := error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName)
			if suggestion.valueDeclaration {
				addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
			}
		} else {
			if moduleSymbol.exports. /*?*/ has(InternalSymbolNameDefault) {
				error(name, Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName)
			} else {
				reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName)
			}
		}
	}
	reportNonExportedMember := func(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
		localSymbol := tryCast(moduleSymbol.valueDeclaration, canHaveLocals). /*?*/ locals. /*?*/ get(moduleExportNameTextEscaped(name))
		exports := moduleSymbol.exports
		if localSymbol {
			exportedEqualsSymbol := exports. /*?*/ get(InternalSymbolNameExportEquals)
			if exportedEqualsSymbol {
				/* TODO(Node ConditionalExpression): getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) : error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName) */ TODO
			} else {
				exportedSymbol := /* TODO(Node ConditionalExpression): exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined */ TODO
				diagnostic := /* TODO(Node ConditionalExpression): exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) : error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName) */ TODO
				if localSymbol.declarations {
					addRelatedInfo(diagnostic, map_(localSymbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any, index /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
						return createDiagnosticForNode(decl /* TODO(Node ConditionalExpression): index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here */, TODO, declarationName)
					})...)
				}
			}
		} else {
			error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName)
		}
	}
	reportInvalidImportEqualsExportMember := func(node Node, name ModuleExportName, declarationName string, moduleName string) {
		if moduleKind >= ModuleKindES2015 {
			message := /* TODO(Node ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import : Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
			error(name, message, declarationName)
		} else {
			if isInJSFile(node) {
				message := /* TODO(Node ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import : Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName)
			} else {
				message := /* TODO(Node ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import : Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName, declarationName, moduleName)
			}
		}
	}
	getTargetOfImportSpecifier := func(node /* TODO(TypeNode UnionType): ImportSpecifier | BindingElement */ any, dontResolveAlias bool) *Symbol {
		if isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
			}
		}
		root := /* TODO(Node ConditionalExpression): isBindingElement(node) ? getRootDeclaration(node) as VariableDeclaration : node.parent.parent.parent */ TODO
		commonJSPropertyAccess := getCommonJSPropertyAccess(root)
		resolved := getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias)
		name := node.propertyName || node.name
		if commonJSPropertyAccess && resolved && isIdentifier(name) {
			return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias)
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getCommonJSPropertyAccess := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAccessExpression | undefined */ any {
		if isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer) {
			return node.initializer
		}
	}
	getTargetOfNamespaceExportDeclaration := func(node NamespaceExportDeclaration, dontResolveAlias bool) *Symbol {
		if canHaveSymbol(node.parent) {
			resolved := resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
			return resolved
		}
	}
	getTargetOfExportSpecifier := func(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		name := node.propertyName || node.name
		if moduleExportNameIsDefault(name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias)
			}
		}
		resolved := /* TODO(Node ConditionalExpression): node.parent.parent.moduleSpecifier ? getExternalModuleMember(node.parent.parent, node, dontResolveAlias) : name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" } resolveEntityName(name, meaning, /*ignoreErrors* / false, dontResolveAlias) */ TODO
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getTargetOfExportAssignment := func(node /* TODO(TypeNode UnionType): ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) *Symbol {
		expression := /* TODO(Node ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
		resolved := getTargetOfAliasLikeExpression(expression, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getTargetOfAliasLikeExpression := func(expression Expression, dontResolveAlias bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		if isClassExpression(expression) {
			return checkExpressionCached(expression).symbol
		}
		if !isEntityName(expression) && !isEntityNameExpression(expression) {
			return nil
		}
		aliasLike := resolveEntityName(expression, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, true, dontResolveAlias)
		if aliasLike {
			return aliasLike
		}
		checkExpressionCached(expression)
		return getNodeLinks(expression).resolvedSymbol
	}
	getTargetOfAccessExpression := func(node AccessExpression, dontRecursivelyResolve bool) *Symbol {
		if !(isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken) {
			return nil
		}
		return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve)
	}
	getTargetOfAliasDeclaration := func(node Declaration, dontRecursivelyResolve /* TODO inferred type boolean */ any /*  = false */) *Symbol {
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindVariableDeclaration:
			return getTargetOfImportEqualsDeclaration(node, dontRecursivelyResolve)
		case SyntaxKindImportClause:
			return getTargetOfImportClause(node, dontRecursivelyResolve)
		case SyntaxKindNamespaceImport:
			return getTargetOfNamespaceImport(node, dontRecursivelyResolve)
		case SyntaxKindNamespaceExport:
			return getTargetOfNamespaceExport(node, dontRecursivelyResolve)
		case SyntaxKindImportSpecifier:
			fallthrough // TODO: merge cases
		case SyntaxKindBindingElement:
			return getTargetOfImportSpecifier(node, dontRecursivelyResolve)
		case SyntaxKindExportSpecifier:
			return getTargetOfExportSpecifier(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, dontRecursivelyResolve)
		case SyntaxKindExportAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindBinaryExpression:
			return getTargetOfExportAssignment(node, dontRecursivelyResolve)
		case SyntaxKindNamespaceExportDeclaration:
			return getTargetOfNamespaceExportDeclaration(node, dontRecursivelyResolve)
		case SyntaxKindShorthandPropertyAssignment:
			return resolveEntityName((node).name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, true, dontRecursivelyResolve)
		case SyntaxKindPropertyAssignment:
			return getTargetOfAliasLikeExpression((node).initializer, dontRecursivelyResolve)
		case SyntaxKindElementAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			return getTargetOfAccessExpression(node, dontRecursivelyResolve)
		default:
			return Debug.fail()
		}
	}
	isNonLocalAlias := func(symbol *Symbol, excludes /* TODO inferred type number */ any /*  = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TypeNode TypePredicate): symbol is Symbol */ any {
		if !symbol {
			return false
		}
		return (symbol.flags&(SymbolFlagsAlias|excludes)) == SymbolFlagsAlias || !!(symbol.flags&SymbolFlagsAlias && symbol.flags&SymbolFlagsAssignment)
	}
	/* OVERLOAD: function resolveSymbol(symbol: Symbol, dontResolveAlias?: boolean): Symbol; */
	/* OVERLOAD: function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined; */
	resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol {
		// converted from conditional expression
		switch {
		case !dontResolveAlias && isNonLocalAlias(symbol):
			return resolveAlias(symbol)
		default:
			return symbol
		}
	}
	resolveAlias := func(symbol Symbol) Symbol {
		Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.aliasTarget {
			links.aliasTarget = resolvingSymbol
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			target := getTargetOfAliasDeclaration(node)
			if links.aliasTarget == resolvingSymbol {
				links.aliasTarget = target || unknownSymbol
			} else {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		} else if links.aliasTarget == resolvingSymbol {
			links.aliasTarget = unknownSymbol
		}
		return links.aliasTarget
	}
	tryResolveAlias := func(symbol Symbol) *Symbol {
		links := getSymbolLinks(symbol)
		if links.aliasTarget != resolvingSymbol {
			return resolveAlias(symbol)
		}
		return nil
	}
	getSymbolFlags := func(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
		typeOnlyDeclaration := excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol)
		typeOnlyDeclarationIsExportStar := typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration)
		typeOnlyResolution := typeOnlyDeclaration && ( /* TODO(Node ConditionalExpression): typeOnlyDeclarationIsExportStar ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors* / true) : resolveAlias(typeOnlyDeclaration.symbol) */ TODO)
		typeOnlyExportStarTargets := /* TODO(Node ConditionalExpression): typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined */ TODO
		flags := /* TODO(Node ConditionalExpression): excludeLocalMeanings ? SymbolFlags.None : symbol.flags */ TODO
		var seenSymbols TODO
		for symbol.flags & SymbolFlagsAlias {
			target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
			if !typeOnlyDeclarationIsExportStar && target == typeOnlyResolution || typeOnlyExportStarTargets. /*?*/ get(target.escapedName) == target {
				break
			}
			if target == unknownSymbol {
				return SymbolFlagsAll
			}
			if target == symbol || seenSymbols. /*?*/ has(target) {
				break
			}
			if target.flags & SymbolFlagsAlias {
				if seenSymbols {
					seenSymbols.add(target)
				} else {
					seenSymbols = /* TODO(Node NewExpression): new Set([symbol, target]) */ TODO
				}
			}
			flags |= target.flags
			symbol = target
		}
		return flags
	}
	markSymbolOfAliasDeclarationIfTypeOnly := func(aliasDeclaration Declaration, immediateTarget *Symbol, finalTarget *Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(TypeNode IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ any, exportStarName __String) bool {
		if !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) {
			return false
		}
		sourceSymbol := getSymbolOfDeclaration(aliasDeclaration)
		if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = aliasDeclaration
			return true
		}
		if exportStarDeclaration {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = exportStarDeclaration
			if sourceSymbol.escapedName != exportStarName {
				links.typeOnlyExportStarName = exportStarName
			}
			return true
		}
		links := getSymbolLinks(sourceSymbol)
		return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty)
	}
	markSymbolOfAliasDeclarationIfTypeOnlyWorker := func(aliasDeclarationLinks SymbolLinks, target *Symbol, overwriteEmpty bool) bool {
		if target && (aliasDeclarationLinks.typeOnlyDeclaration == nil || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration == false) {
			exportSymbol := /* TODO(Node BinaryExpression): target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
			typeOnly := exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration)
			aliasDeclarationLinks.typeOnlyDeclaration = /* TODO(Node BinaryExpression): typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false */ TODO
		}
		return !!aliasDeclarationLinks.typeOnlyDeclaration
	}
	getTypeOnlyAliasDeclaration := func(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
		if !(symbol.flags & SymbolFlagsAlias) {
			return nil
		}
		links := getSymbolLinks(symbol)
		if links.typeOnlyDeclaration == nil {
			links.typeOnlyDeclaration = false
			resolved := resolveSymbol(symbol)
			markSymbolOfAliasDeclarationIfTypeOnly(symbol.declarations[0], getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved, true)
		}
		if include == nil {
			return links.typeOnlyDeclaration || nil
		}
		if links.typeOnlyDeclaration {
			resolved := /* TODO(Node ConditionalExpression): links.typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent!).get(links.typeOnlyExportStarName || symbol.escapedName))! : resolveAlias(links.typeOnlyDeclaration.symbol) */ TODO
			// converted from conditional expression
			switch {
			case getSymbolFlags(resolved) & include:
				return links.typeOnlyDeclaration
			default:
				return nil
			}
		}
		return nil
	}
	getSymbolOfPartOfRightHandSideOfImportEquals := func(entityName EntityName, dontResolveAlias bool) *Symbol {
		if entityName.kind == SyntaxKindIdentifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName) {
			entityName = entityName.parent
		}
		if entityName.kind == SyntaxKindIdentifier || entityName.parent.kind == SyntaxKindQualifiedName {
			return resolveEntityName(entityName, SymbolFlagsNamespace, false, dontResolveAlias)
		} else {
			Debug.assert(entityName.parent.kind == SyntaxKindImportEqualsDeclaration)
			return resolveEntityName(entityName, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, false, dontResolveAlias)
		}
	}
	getFullyQualifiedName := func(symbol Symbol, containingLocation Node) string {
		// converted from conditional expression
		switch {
		case symbol.parent:
			return getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol)
		default:
			return symbolToString(symbol, containingLocation, nil, SymbolFormatFlagsDoNotIncludeSymbolChain|SymbolFormatFlagsAllowAnyNodeKind)
		}
	}
	getContainingQualifiedNameNode := func(node QualifiedName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").QualifiedName */ any {
		for isQualifiedName(node.parent) {
			node = node.parent
		}
		return node
	}
	tryGetQualifiedNameAsValue := func(node QualifiedName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		var left /* TODO(TypeNode UnionType): Identifier | QualifiedName */ any = getFirstIdentifier(node)
		symbol := resolveName(left, left, SymbolFlagsValue, nil, true)
		if !symbol {
			return nil
		}
		for isQualifiedName(left.parent) {
			type_ := getTypeOfSymbol(symbol)
			symbol = getPropertyOfType(type_, left.parent.right.escapedText)
			if !symbol {
				return nil
			}
			left = left.parent
		}
		return symbol
	}
	resolveEntityName := func(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) *Symbol {
		if nodeIsMissing(name) {
			return nil
		}
		namespaceMeaning := SymbolFlagsNamespace | ( /* TODO(Node ConditionalExpression): isInJSFile(name) ? meaning & SymbolFlags.Value : 0 */ TODO)
		var symbol *Symbol
		if name.kind == SyntaxKindIdentifier {
			message := /* TODO(Node ConditionalExpression): meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name)) */ TODO
			symbolFromJSPrototype := /* TODO(Node ConditionalExpression): isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined */ TODO
			symbol = getMergedSymbol(resolveName(location || name, name, meaning /* TODO(Node ConditionalExpression): ignoreErrors || symbolFromJSPrototype ? undefined : message */, TODO, true, false))
			if !symbol {
				return getMergedSymbol(symbolFromJSPrototype)
			}
		} else if name.kind == SyntaxKindQualifiedName || name.kind == SyntaxKindPropertyAccessExpression {
			left := /* TODO(Node ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.left : name.expression */ TODO
			right := /* TODO(Node ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right : name.name */ TODO
			namespace := resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location)
			if !namespace || nodeIsMissing(right) {
				return nil
			} else if namespace == unknownSymbol {
				return namespace
			}
			if namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && getEmitModuleResolutionKind(compilerOptions) != ModuleResolutionKindBundler && isVariableDeclaration(namespace.valueDeclaration) && namespace.valueDeclaration.initializer && isCommonJsRequire(namespace.valueDeclaration.initializer) {
				moduleName := (namespace.valueDeclaration.initializer).arguments[0]
				moduleSym := resolveExternalModuleName(moduleName, moduleName)
				if moduleSym {
					resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
					if resolvedModuleSymbol {
						namespace = resolvedModuleSymbol
					}
				}
			}
			symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning))
			if !symbol && (namespace.flags & SymbolFlagsAlias) {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning))
			}
			if !symbol {
				if !ignoreErrors {
					namespaceName := getFullyQualifiedName(namespace)
					declarationName := declarationNameToString(right)
					suggestionForNonexistentModule := getSuggestedSymbolForNonexistentModule(right, namespace)
					if suggestionForNonexistentModule {
						error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule))
						return nil
					}
					containingQualifiedName := isQualifiedName(name) && getContainingQualifiedNameNode(name)
					canSuggestTypeof := globalObjectType && (meaning & SymbolFlagsType) && containingQualifiedName && !isTypeOfExpression(containingQualifiedName.parent) && tryGetQualifiedNameAsValue(containingQualifiedName)
					if canSuggestTypeof {
						error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName))
						return nil
					}
					if meaning&SymbolFlagsNamespace && isQualifiedName(name.parent) {
						exportedTypeSymbol := getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, SymbolFlagsType))
						if exportedTypeSymbol {
							error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText))
							return nil
						}
					}
					error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName)
				}
				return nil
			}
		} else {
			Debug.assertNever(name, "Unknown entity name kind.")
		}
		if !nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags&SymbolFlagsAlias || name.parent.kind == SyntaxKindExportAssignment) {
			markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, nil, true)
		}
		// converted from conditional expression
		switch {
		case (symbol.flags & meaning) || dontResolveAlias:
			return symbol
		default:
			return resolveAlias(symbol)
		}
	}
	resolveEntityNameFromAssignmentDeclaration := func(name Identifier, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		if isJSDocTypeReference(name.parent) {
			secondaryLocation := getAssignmentDeclarationLocation(name.parent)
			if secondaryLocation {
				return resolveName(secondaryLocation, name, meaning, nil, true)
			}
		}
	}
	getAssignmentDeclarationLocation := func(node TypeReferenceNode) Node {
		typeAlias := findAncestor(node, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) ? "quit" : isJSDocTypeAlias(node) */ TODO
		})
		if typeAlias {
			return
		}
		host := getJSDocHost(node)
		if host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression) {
			symbol := getSymbolOfDeclaration(host.expression.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent) {
			symbol := getSymbolOfDeclaration(host.parent.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) && isBinaryExpression(host.parent.parent) && getAssignmentDeclarationKind(host.parent.parent) == AssignmentDeclarationKindPrototype {
			symbol := getSymbolOfDeclaration(host.parent.parent.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		sig := getEffectiveJSDocHost(node)
		if sig && isFunctionLike(sig) {
			symbol := getSymbolOfDeclaration(sig)
			return symbol && symbol.valueDeclaration
		}
	}
	getDeclarationOfJSPrototypeContainer := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ any {
		decl := symbol.parent.valueDeclaration
		if !decl {
			return nil
		}
		initializer := /* TODO(Node ConditionalExpression): isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) : hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) : undefined */ TODO
		return initializer || decl
	}
	getExpandoSymbol := func(symbol Symbol) *Symbol {
		decl := symbol.valueDeclaration
		if !decl || !isInJSFile(decl) || symbol.flags&SymbolFlagsTypeAlias || getExpandoInitializer(decl, false) {
			return nil
		}
		init := /* TODO(Node ConditionalExpression): isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl) */ TODO
		if init {
			initSymbol := getSymbolOfNode(init)
			if initSymbol {
				return mergeJSSymbols(initSymbol, symbol)
			}
		}
	}
	resolveExternalModuleName := func(location Node, moduleReferenceExpression Expression, ignoreErrors bool) *Symbol {
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		errorMessage := /* TODO(Node ConditionalExpression): isClassic ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		return resolveExternalModuleNameWorker(location, moduleReferenceExpression /* TODO(Node ConditionalExpression): ignoreErrors ? undefined : errorMessage */, TODO, ignoreErrors)
	}
	resolveExternalModuleNameWorker := func(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors /* TODO inferred type boolean */ any /*  = false */, isForAugmentation /* TODO inferred type boolean */ any /*  = false */) *Symbol {
		// converted from conditional expression
		switch {
		case isStringLiteralLike(moduleReferenceExpression):
			return resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError /* TODO(Node ConditionalExpression): !ignoreErrors ? moduleReferenceExpression : undefined */, TODO, isForAugmentation)
		default:
			return nil
		}
	}
	resolveExternalModule := func(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation /* TODO inferred type boolean */ any /*  = false */) *Symbol {
		if errorNode && startsWith(moduleReference, "@types/") {
			diag := Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1
			withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
			error(errorNode, diag, withoutAtTypePrefix, moduleReference)
		}
		ambientModule := tryFindAmbientModule(moduleReference, true)
		if ambientModule {
			return ambientModule
		}
		currentSourceFile := getSourceFileOfNode(location)
		contextSpecifier := /* TODO(Node ConditionalExpression): isStringLiteralLike(location) ? location : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name || (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal || (isInJSFile(location) && isJSDocImportTag(location) ? location.moduleSpecifier : undefined) || (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument* / true) ? location.initializer.arguments[0] : undefined) || findAncestor(location, isImportCall)?.arguments[0] || findAncestor(location, isImportDeclaration)?.moduleSpecifier || findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression || findAncestor(location, isExportDeclaration)?.moduleSpecifier */ TODO
		mode := /* TODO(Node ConditionalExpression): contextSpecifier && isStringLiteralLike(contextSpecifier) ? host.getModeForUsageLocation(currentSourceFile, contextSpecifier) : host.getDefaultResolutionModeForFile(currentSourceFile) */ TODO
		moduleResolutionKind := getEmitModuleResolutionKind(compilerOptions)
		resolvedModule := host.getResolvedModule(currentSourceFile, moduleReference, mode). /*?*/ resolvedModule
		resolutionDiagnostic := errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile)
		sourceFile := resolvedModule && (!resolutionDiagnostic || resolutionDiagnostic == Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) && host.getSourceFile(resolvedModule.resolvedFileName)
		if sourceFile {
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			}
			if resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference) {
				importOrExport := findAncestor(location, isImportDeclaration). /*?*/ importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall) {
					error(errorNode, Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead, getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))))
				}
			} else if resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName) {
				importOrExport := findAncestor(location, isImportDeclaration). /*?*/ importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && !(importOrExport. /*?*/ isTypeOnly || findAncestor(location, isImportTypeNode)) {
					tsExtension := Debug.checkDefined(tryExtractTSExtension(moduleReference))
					error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension)
				}
			}
			if sourceFile.symbol {
				if errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension) {
					errorOnImplicitAnyModule(false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
				}
				if errorNode && (moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext) {
					isSyncImport := (currentSourceFile.impliedNodeFormat == ModuleKindCommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration)
					overrideHost := findAncestor(location, func(l /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
						return isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l)
					})
					if isSyncImport && sourceFile.impliedNodeFormat == ModuleKindESNext && !hasResolutionModeOverride(overrideHost) {
						if findAncestor(location, isImportEqualsDeclaration) {
							error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference)
						} else {
							var diagnosticDetails TODO
							ext := tryGetExtensionFromPath(currentSourceFile.fileName)
							if ext == ExtensionTs || ext == ExtensionJs || ext == ExtensionTsx || ext == ExtensionJsx {
								diagnosticDetails = createModeMismatchDetails(currentSourceFile)
							}
							message := /* TODO(Node ConditionalExpression): overrideHost?.kind === SyntaxKind.ImportDeclaration && overrideHost.importClause?.isTypeOnly ? Diagnostics.Type_only_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute : overrideHost?.kind === SyntaxKind.ImportType ? Diagnostics.Type_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute : Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead */ TODO
							diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails, message, moduleReference)))
						}
					}
				}
				return getMergedSymbol(sourceFile.symbol)
			}
			if errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) {
				error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName)
			}
			return nil
		}
		if patternAmbientModules {
			pattern := findBestPatternMatch(patternAmbientModules, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PatternAmbientModule */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/core").Pattern */ any {
				return _.pattern
			}, moduleReference)
			if pattern {
				augmentation := patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference)
				if augmentation {
					return getMergedSymbol(augmentation)
				}
				return getMergedSymbol(pattern.symbol)
			}
		}
		if !errorNode {
			return nil
		}
		if resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic == nil || resolutionDiagnostic == Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type {
			if isForAugmentation {
				diag := Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented
				error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName)
			} else {
				errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
			}
			return nil
		}
		if moduleNotFoundError {
			if resolvedModule {
				redirect := host.getProjectReferenceRedirect(resolvedModule.resolvedFileName)
				if redirect {
					error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName)
					return nil
				}
			}
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			} else {
				isExtensionlessRelativePathImport := pathIsRelative(moduleReference) && !hasExtension(moduleReference)
				resolutionIsNode16OrNext := moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext
				if !getResolveJsonModule(compilerOptions) && fileExtensionIs(moduleReference, ExtensionJson) && moduleResolutionKind != ModuleResolutionKindClassic && hasJsonModuleEmitEnabled(compilerOptions) {
					error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference)
				} else if mode == ModuleKindESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport {
					absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path))
					suggestedExt := suggestedExtensions.find(func(TODO_IDENTIFIER /* TODO inferred type [string, string] */ any) /* TODO inferred type boolean */ any {
						return host.fileExists(absoluteRef + actualExt)
					})[1]
					if suggestedExt {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference+suggestedExt)
					} else {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path)
					}
				} else {
					if host.getResolvedModule(currentSourceFile, moduleReference, mode). /*?*/ alternateResult {
						errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
						errorOrSuggestion(true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference))
					} else {
						error(errorNode, moduleNotFoundError, moduleReference)
					}
				}
			}
		}
		return nil
		getSuggestedImportSource := func(tsExtension string) /* TODO inferred type string */ any {
			importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
			if emitModuleKindIsNonNodeESM(moduleKind) || mode == ModuleKindESNext {
				preferTs := isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions)
				ext := /* TODO(Node ConditionalExpression): tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" : tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" : preferTs ? ".ts" : ".js" */ TODO
				return importSourceWithoutExtension + ext
			}
			return importSourceWithoutExtension
		}
	}
	errorOnImplicitAnyModule := func(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
		if isSideEffectImport(errorNode) {
			return
		}
		var errorInfo *DiagnosticMessageChain
		if !isExternalModuleNameRelative(moduleReference) && packageId {
			errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name)
		}
		errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName))
	}
	/* OVERLOAD: function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol; */
	/* OVERLOAD: function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined; */
	resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol {
		if moduleSymbol. /*?*/ exports {
			exportEquals := resolveSymbol(moduleSymbol.exports.get(InternalSymbolNameExportEquals), dontResolveAlias)
			exported := getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol))
			return getMergedSymbol(exported) || moduleSymbol
		}
		return nil
	}
	getCommonJsExportEquals := func(exported *Symbol, moduleSymbol Symbol) *Symbol {
		if !exported || exported == unknownSymbol || exported == moduleSymbol || moduleSymbol.exports.size == 1 || exported.flags&SymbolFlagsAlias {
			return exported
		}
		links := getSymbolLinks(exported)
		if links.cjsExportMerged {
			return links.cjsExportMerged
		}
		merged := /* TODO(Node ConditionalExpression): exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(exported) */ TODO
		merged.flags = merged.flags | SymbolFlagsValueModule
		if merged.exports == nil {
			merged.exports = createSymbolTable()
		}
		moduleSymbol.exports.forEach(func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
			if name == InternalSymbolNameExportEquals {
				return
			}
			merged.exports.set(name /* TODO(Node ConditionalExpression): merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s */, TODO)
		})
		if merged == exported {
			getSymbolLinks(merged).resolvedExports = nil
			getSymbolLinks(merged).resolvedMembers = nil
		}
		getSymbolLinks(merged).cjsExportMerged = merged
		links.cjsExportMerged = merged
		return links.cjsExportMerged
	}
	resolveESModuleSymbol := func(moduleSymbol *Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) *Symbol {
		symbol := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)
		if !dontResolveAlias && symbol {
			if !suppressInteropError && !(symbol.flags & (SymbolFlagsModule | SymbolFlagsVariable)) && !getDeclarationOfKind(symbol, SyntaxKindSourceFile) {
				compilerOptionName := /* TODO(Node ConditionalExpression): moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop" */ TODO
				error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName)
				return symbol
			}
			referenceParent := referencingLocation.parent
			if (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) || isImportCall(referenceParent) {
				reference := /* TODO(Node ConditionalExpression): isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier */ TODO
				type_ := getTypeOfSymbol(symbol)
				defaultOnlyType := getTypeWithSyntheticDefaultOnly(type_, symbol, moduleSymbol, reference)
				if defaultOnlyType {
					return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
				}
				targetFile := moduleSymbol. /*?*/ declarations. /*?*/ find(isSourceFile)
				isEsmCjsRef := targetFile && isESMFormatImportImportingCommonjsFormatFile(getEmitSyntaxForModuleSpecifierExpression(reference), host.getImpliedNodeFormatForEmit(targetFile))
				if getESModuleInterop(compilerOptions) || isEsmCjsRef {
					sigs := getSignaturesOfStructuredType(type_, SignatureKindCall)
					if !sigs || !sigs.length {
						sigs = getSignaturesOfStructuredType(type_, SignatureKindConstruct)
					}
					if (sigs && sigs.length) || getPropertyOfType(type_, InternalSymbolNameDefault, true) || isEsmCjsRef {
						moduleType := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.StructuredType ? getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!, reference) : createDefaultPropertyWrapperForModule(symbol, symbol.parent) */ TODO
						return cloneTypeAsModuleType(symbol, moduleType, referenceParent)
					}
				}
			}
		}
		return symbol
	}
	cloneTypeAsModuleType := func(symbol Symbol, moduleType Type, referenceParent /* TODO(TypeNode UnionType): ImportDeclaration | ImportCall */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
		result := createSymbol(symbol.flags, symbol.escapedName)
		result.declarations = /* TODO(Node ConditionalExpression): symbol.declarations ? symbol.declarations.slice() : [] */ TODO
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.originatingImport = referenceParent
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if symbol.constEnumOnlyModule {
			result.constEnumOnlyModule = true
		}
		if symbol.members {
			result.members = /* TODO(Node NewExpression): new Map(symbol.members) */ TODO
		}
		if symbol.exports {
			result.exports = /* TODO(Node NewExpression): new Map(symbol.exports) */ TODO
		}
		resolvedModuleType := resolveStructuredTypeMembers(moduleType)
		result.links.type_ = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos)
		return result
	}
	hasExportAssignmentSymbol := func(moduleSymbol Symbol) bool {
		return moduleSymbol.exports.get(InternalSymbolNameExportEquals) != nil
	}
	getExportsOfModuleAsArray := func(moduleSymbol Symbol) []Symbol {
		return symbolsToArray(getExportsOfModule(moduleSymbol))
	}
	getExportsAndPropertiesOfModule := func(moduleSymbol Symbol) []Symbol {
		exports := getExportsOfModuleAsArray(moduleSymbol)
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals != moduleSymbol {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				addRange(exports, getPropertiesOfType(type_))
			}
		}
		return exports
	}
	forEachExportAndPropertyOfModule := func(moduleSymbol Symbol, cb func(symbol Symbol, key __String)) {
		exports := getExportsOfModule(moduleSymbol)
		exports.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, key /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
			if !isReservedMemberName(key) {
				cb(symbol, key)
			}
		})
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals != moduleSymbol {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				forEachPropertyOfType(type_, func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, escapedName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
					cb(symbol, escapedName)
				})
			}
		}
	}
	tryGetMemberInModuleExports := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbolTable := getExportsOfModule(moduleSymbol)
		if symbolTable {
			return symbolTable.get(memberName)
		}
	}
	tryGetMemberInModuleExportsAndProperties := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbol := tryGetMemberInModuleExports(memberName, moduleSymbol)
		if symbol {
			return symbol
		}
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals == moduleSymbol {
			return nil
		}
		type_ := getTypeOfSymbol(exportEquals)
		// converted from conditional expression
		switch {
		case shouldTreatPropertiesOfExternalModuleAsExports(type_):
			return getPropertyOfType(type_, memberName)
		default:
			return nil
		}
	}
	shouldTreatPropertiesOfExternalModuleAsExports := func(resolvedExternalModuleType Type) /* TODO inferred type boolean */ any {
		return !(resolvedExternalModuleType.flags&TypeFlagsPrimitive || getObjectFlags(resolvedExternalModuleType)&ObjectFlagsClass || isArrayType(resolvedExternalModuleType) || isTupleType(resolvedExternalModuleType))
	}
	getExportsOfSymbol := func(symbol Symbol) SymbolTable {
		// converted from conditional expression
		switch {
		case symbol.flags & SymbolFlagsLateBindingContainer:
			return getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKindresolvedExports)
		case symbol.flags & SymbolFlagsModule:
			return getExportsOfModule(symbol)
		default:
			return symbol.exports || emptySymbols
		}
	}
	getExportsOfModule := func(moduleSymbol Symbol) SymbolTable {
		links := getSymbolLinks(moduleSymbol)
		if !links.resolvedExports {
			TODO_IDENTIFIER := getExportsOfModuleWorker(moduleSymbol)
			links.resolvedExports = exports
			links.typeOnlyExportStarMap = typeOnlyExportStarMap
		}
		return links.resolvedExports
	}
	type ExportCollisionTracker struct {
		specifierText        string
		exportsWithDuplicate []ExportDeclaration
	}
	type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]
	extendExportSymbols := func(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
		if !source {
			return
		}
		source.forEach(func(sourceSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
			if id == InternalSymbolNameDefault {
				return
			}
			targetSymbol := target.get(id)
			if !targetSymbol {
				target.set(id, sourceSymbol)
				if lookupTable && exportNode {
					lookupTable.set(id /* TODO(Node ObjectLiteralExpression): { specifierText: getTextOfNode(exportNode.moduleSpecifier!), } */, TODO)
				}
			} else if lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) != resolveSymbol(sourceSymbol) {
				collisionTracker := lookupTable.get(id)
				if !collisionTracker.exportsWithDuplicate {
					collisionTracker.exportsWithDuplicate = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ any{exportNode}
				} else {
					collisionTracker.exportsWithDuplicate.push(exportNode)
				}
			}
		})
	}
	getExportsOfModuleWorker := func(moduleSymbol Symbol) /* TODO inferred type { exports: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable; typeOnlyExportStarMap: Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> | undefined; } */ any {
		var visitedSymbols []Symbol = [] /* TODO inferred type never */ any{}
		var typeOnlyExportStarMap *Map[__String /* TODO(TypeNode IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, any]
		nonTypeOnlyNames := make(map[__String]struct{})
		moduleSymbol = resolveExternalModuleSymbol(moduleSymbol)
		exports := visit(moduleSymbol) || emptySymbols
		if typeOnlyExportStarMap {
			nonTypeOnlyNames.forEach(func(name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) /* TODO inferred type boolean */ any {
				return typeOnlyExportStarMap.delete(name)
			})
		}
		return /* TODO(Node ObjectLiteralExpression): { exports, typeOnlyExportStarMap, } */ TODO
		visit := func(symbol *Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
			if !isTypeOnly && symbol. /*?*/ exports {
				symbol.exports.forEach(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) /* TODO inferred type Set<import("/home/jabaile/work/TypeScript/src/compiler/types").__String> */ any {
					return nonTypeOnlyNames.add(name)
				})
			}
			if !(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) {
				return
			}
			symbols := /* TODO(Node NewExpression): new Map(symbol.exports) */ TODO
			exportStars := symbol.exports.get(InternalSymbolNameExportStar)
			if exportStars {
				nestedSymbols := createSymbolTable()
				var lookupTable ExportCollisionTrackerTable = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
				if exportStars.declarations {
					for _, node := range exportStars.declarations {
						resolvedModule := resolveExternalModuleName(node, (node).moduleSpecifier)
						exportedSymbols := visit(resolvedModule, node, isTypeOnly || (node).isTypeOnly)
						extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node)
					}
				}
				lookupTable.forEach(func(TODO_IDENTIFIER /* TODO inferred type ExportCollisionTracker */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
					if id == "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id) {
						return
					}
					for _, node := range exportsWithDuplicate {
						diagnostics.add(createDiagnosticForNode(node, Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable.get(id).specifierText, unescapeLeadingUnderscores(id)))
					}
				})
				extendExportSymbols(symbols, nestedSymbols)
			}
			if exportStar. /*?*/ isTypeOnly {
				/* TODO(Node BinaryExpression): typeOnlyExportStarMap ??= new Map() */ TODO
				symbols.forEach(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, escapedName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) /* TODO inferred type Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> */ any {
					return typeOnlyExportStarMap.set(escapedName, exportStar)
				})
			}
			return symbols
		}
	}
	/* OVERLOAD: function getMergedSymbol(symbol: Symbol): Symbol; */
	/* OVERLOAD: function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined; */
	getMergedSymbol := func(symbol *Symbol) *Symbol {
		var merged Symbol
		// converted from conditional expression
		switch {
		case symbol && symbol.mergeId && ( /* TODO(Node BinaryExpression): merged = mergedSymbols[symbol.mergeId] */ TODO):
			return merged
		default:
			return symbol
		}
	}
	getSymbolOfDeclaration := func(node Declaration) Symbol {
		return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol))
	}
	getSymbolOfNode := func(node Node) *Symbol {
		// converted from conditional expression
		switch {
		case canHaveSymbol(node):
			return getSymbolOfDeclaration(node)
		default:
			return nil
		}
	}
	getParentOfSymbol := func(symbol Symbol) *Symbol {
		return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent))
	}
	getFunctionExpressionParentSymbolOrSymbol := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		// converted from conditional expression
		switch {
		case symbol.valueDeclaration. /*?*/ kind == SyntaxKindArrowFunction || symbol.valueDeclaration. /*?*/ kind == SyntaxKindFunctionExpression:
			return getSymbolOfNode(symbol.valueDeclaration.parent) || symbol
		default:
			return symbol
		}
	}
	getAlternativeContainingModules := func(symbol Symbol, enclosingDeclaration Node) []Symbol {
		containingFile := getSourceFileOfNode(enclosingDeclaration)
		id := getNodeId(containingFile)
		links := getSymbolLinks(symbol)
		var results *[]Symbol
		if links.extendedContainersByFile && ( /* TODO(Node BinaryExpression): results = links.extendedContainersByFile.get(id) */ TODO) {
			return results
		}
		if containingFile && containingFile.imports {
			for _, importRef := range containingFile.imports {
				if nodeIsSynthesized(importRef) {
					continue
				}
				resolvedModule := resolveExternalModuleName(enclosingDeclaration, importRef, true)
				if !resolvedModule {
					continue
				}
				ref := getAliasForSymbolInContainer(resolvedModule, symbol)
				if !ref {
					continue
				}
				results = append(results, resolvedModule)
			}
			if length(results) {
				(links.extendedContainersByFile || ( /* TODO(Node BinaryExpression): links.extendedContainersByFile = new Map() */ TODO)).set(id, results)
				return results
			}
		}
		if links.extendedContainers {
			return links.extendedContainers
		}
		otherFiles := host.getSourceFiles()
		for _, file := range otherFiles {
			if !isExternalModule(file) {
				continue
			}
			sym := getSymbolOfDeclaration(file)
			ref := getAliasForSymbolInContainer(sym, symbol)
			if !ref {
				continue
			}
			results = append(results, sym)
		}
		links.extendedContainers = results || emptyArray
		return links.extendedContainers
	}
	getContainersOfSymbol := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) *[]Symbol {
		container := getParentOfSymbol(symbol)
		if container && !(symbol.flags & SymbolFlagsTypeParameter) {
			return getWithAlternativeContainers(container)
		}
		candidates := mapDefined(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			if !isAmbientModule(d) && d.parent {
				if hasNonGlobalAugmentationExternalModuleSymbol(d.parent) {
					return getSymbolOfDeclaration(d.parent)
				}
				if isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) == symbol {
					return getSymbolOfDeclaration(d.parent.parent)
				}
			}
			if isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind == SyntaxKindEqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression) {
				if isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression) {
					return getSymbolOfDeclaration(getSourceFileOfNode(d))
				}
				checkExpressionCached(d.parent.left.expression)
				return getNodeLinks(d.parent.left.expression).resolvedSymbol
			}
		})
		if !length(candidates) {
			return nil
		}
		containers := mapDefined(candidates, func(candidate /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			return /* TODO(Node ConditionalExpression): getAliasForSymbolInContainer(candidate, symbol) ? candidate : undefined */ TODO
		})
		var bestContainers []Symbol = [] /* TODO inferred type never */ any{}
		var alternativeContainers []Symbol = [] /* TODO inferred type never */ any{}
		for _, container := range containers {
			TODO_IDENTIFIER := getWithAlternativeContainers(container)
			bestContainers = append(bestContainers, bestMatch)
			alternativeContainers = addRange(alternativeContainers, rest)
		}
		return concatenate(bestContainers, alternativeContainers)
		getWithAlternativeContainers := func(container Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
			additionalContainers := mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer)
			reexportContainers := enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration)
			objectLiteralContainer := getVariableDeclarationOfObjectLiteral(container, meaning)
			if enclosingDeclaration && container.flags&getQualifiedLeftMeaning(meaning) && getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlagsNamespace, false) {
				return append(concatenate(concatenate([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{container}, additionalContainers), reexportContainers), objectLiteralContainer)
			}
			firstVariableMatch := /* TODO(Node ConditionalExpression): !(container.flags & getQualifiedLeftMeaning(meaning)) && container.flags & SymbolFlags.Type && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object && meaning === SymbolFlags.Value ? forEachSymbolTableInScope(enclosingDeclaration, t => { return forEachEntry(t, s => { if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) { return s; } }); }) : undefined */ TODO
			res := /* TODO(Node ConditionalExpression): firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container] */ TODO
			res = append(res, objectLiteralContainer)
			res = addRange(res, reexportContainers)
			return res
		}
		fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container)
		}
	}
	getVariableDeclarationOfObjectLiteral := func(symbol Symbol, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		var firstDecl /* TODO(TypeNode UnionType): Node | false */ any = !!length(symbol.declarations) && first(symbol.declarations)
		if meaning&SymbolFlagsValue && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent) {
			if isObjectLiteralExpression(firstDecl) && firstDecl == firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl == firstDecl.parent.type_ {
				return getSymbolOfDeclaration(firstDecl.parent)
			}
		}
	}
	getFileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration, container Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		fileSymbol := getExternalModuleContainer(d)
		exported := fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolNameExportEquals)
		// converted from conditional expression
		switch {
		case exported && getSymbolIfSameReference(exported, container):
			return fileSymbol
		default:
			return nil
		}
	}
	getAliasForSymbolInContainer := func(container Symbol, symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		if container == getParentOfSymbol(symbol) {
			return symbol
		}
		exportEquals := container.exports && container.exports.get(InternalSymbolNameExportEquals)
		if exportEquals && getSymbolIfSameReference(exportEquals, symbol) {
			return container
		}
		exports := getExportsOfSymbol(container)
		quick := exports.get(symbol.escapedName)
		if quick && getSymbolIfSameReference(quick, symbol) {
			return quick
		}
		return forEachEntry(exports, func(exported /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			if getSymbolIfSameReference(exported, symbol) {
				return exported
			}
		})
	}
	getSymbolIfSameReference := func(s1 Symbol, s2 Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		if getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) == getMergedSymbol(resolveSymbol(getMergedSymbol(s2))) {
			return s1
		}
	}
	/* OVERLOAD: function getExportSymbolOfValueSymbolIfExported(symbol: Symbol): Symbol; */
	/* OVERLOAD: function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined; */
	getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol {
		return getMergedSymbol(symbol && (symbol.flags&SymbolFlagsExportValue) != 0 && symbol.exportSymbol || symbol)
	}
	symbolIsValue := func(symbol Symbol, includeTypeOnlyMembers bool) bool {
		return !!(symbol.flags&SymbolFlagsValue || symbol.flags&SymbolFlagsAlias && getSymbolFlags(symbol, !includeTypeOnlyMembers)&SymbolFlagsValue)
	}
	createType := func(flags TypeFlags) Type {
		result := /* TODO(Node NewExpression): new Type(checker, flags) */ TODO
		typeCount++
		result.id = typeCount
		tracing. /*?*/ recordType(result)
		return result
	}
	createTypeWithSymbol := func(flags TypeFlags, symbol Symbol) Type {
		result := createType(flags)
		result.symbol = symbol
		return result
	}
	createOriginType := func(flags TypeFlags) Type {
		return /* TODO(Node NewExpression): new Type(checker, flags) */ TODO
	}
	createIntrinsicType := func(kind TypeFlags, intrinsicName string, objectFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectFlags */ any /*  = ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
		checkIntrinsicName(intrinsicName, debugIntrinsicName)
		type_ := createType(kind)
		type_.intrinsicName = intrinsicName
		type_.debugIntrinsicName = debugIntrinsicName
		type_.objectFlags = objectFlags | ObjectFlagsCouldContainTypeVariablesComputed | ObjectFlagsIsGenericTypeComputed | ObjectFlagsIsUnknownLikeUnionComputed | ObjectFlagsIsNeverIntersectionComputed
		return type_
	}
	checkIntrinsicName := func(name string, debug *string) {
		key := /* TODO(Node TemplateExpression): `${name},${debug ?? ""}` */ TODO
		if seenIntrinsicNames.has(key) {
			Debug.fail( /* TODO(Node TemplateExpression): `Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.` */ TODO)
		}
		seenIntrinsicNames.add(key)
	}
	createObjectType := func(objectFlags ObjectFlags, symbol Symbol) ObjectType {
		type_ := createTypeWithSymbol(TypeFlagsObject, symbol)
		type_.objectFlags = objectFlags
		type_.members = nil
		type_.properties = nil
		type_.callSignatures = nil
		type_.constructSignatures = nil
		type_.indexInfos = nil
		return type_
	}
	createTypeofType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getUnionType(arrayFrom(typeofNEFacts.keys(), getStringLiteralType))
	}
	createTypeParameter := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
		return createTypeWithSymbol(TypeFlagsTypeParameter, symbol)
	}
	isReservedMemberName := func(name __String) /* TODO inferred type boolean */ any {
		return (name).charCodeAt(0) == CharacterCodes_ && (name).charCodeAt(1) == CharacterCodes_ && (name).charCodeAt(2) != CharacterCodes_ && (name).charCodeAt(2) != CharacterCodesat && (name).charCodeAt(2) != CharacterCodeshash
	}
	getNamedMembers := func(members SymbolTable) []Symbol {
		var result *[]Symbol
		members.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
			if isNamedMember(symbol, id) {
				(result || ( /* TODO(Node BinaryExpression): result = [] */ TODO)).push(symbol)
			}
		})
		return result || emptyArray
	}
	isNamedMember := func(member Symbol, escapedName __String) /* TODO inferred type boolean */ any {
		return !isReservedMemberName(escapedName) && symbolIsValue(member)
	}
	getNamedOrIndexSignatureMembers := func(members SymbolTable) []Symbol {
		result := getNamedMembers(members)
		index := getIndexSymbolFromSymbolTable(members)
		// converted from conditional expression
		switch {
		case index:
			return concatenate(result, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{index})
		default:
			return result
		}
	}
	setStructuredTypeMembers := func(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		resolved := type_
		resolved.members = members
		resolved.properties = emptyArray
		resolved.callSignatures = callSignatures
		resolved.constructSignatures = constructSignatures
		resolved.indexInfos = indexInfos
		if members != emptySymbols {
			resolved.properties = getNamedMembers(members)
		}
		return resolved
	}
	createAnonymousType := func(symbol *Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		return setStructuredTypeMembers(createObjectType(ObjectFlagsAnonymous, symbol), members, callSignatures, constructSignatures, indexInfos)
	}
	getResolvedTypeWithoutAbstractConstructSignatures := func(type_ ResolvedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		if type_.constructSignatures.length == 0 {
			return type_
		}
		if type_.objectTypeWithoutAbstractConstructSignatures {
			return type_.objectTypeWithoutAbstractConstructSignatures
		}
		constructSignatures := filter(type_.constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
			return !(signature.flags & SignatureFlagsAbstract)
		})
		if type_.constructSignatures == constructSignatures {
			return type_
		}
		typeCopy := createAnonymousType(type_.symbol, type_.members, type_.callSignatures /* TODO(Node ConditionalExpression): some(constructSignatures) ? constructSignatures : emptyArray */, TODO, type_.indexInfos)
		type_.objectTypeWithoutAbstractConstructSignatures = typeCopy
		typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy
		return typeCopy
	}
	forEachSymbolTableInScope := func(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
		var result T
		for location := enclosingDeclaration; location; location = location.parent {
			if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
				if /* TODO(Node BinaryExpression): result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location) */ TODO {
					return result
				}
			}
			switch location.kind {
			case SyntaxKindSourceFile:
				if !isExternalOrCommonJsModule(location) {
					break
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				sym := getSymbolOfDeclaration(location)
				if /* TODO(Node BinaryExpression): result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location) */ TODO {
					return result
				}
				break
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				var table *Map[__String, Symbol]
				(getSymbolOfDeclaration(location).members || emptySymbols).forEach(func(memberSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, key /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
					if memberSymbol.flags & (SymbolFlagsType & ~SymbolFlagsAssignment) {
						(table || ( /* TODO(Node BinaryExpression): table = createSymbolTable() */ TODO)).set(key, memberSymbol)
					}
				})
				if table && ( /* TODO(Node BinaryExpression): result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location) */ TODO) {
					return result
				}
				break
			}
		}
		return callback(globals, nil, true)
	}
	getQualifiedLeftMeaning := func(rightMeaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Value | import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Namespace */ any {
		// converted from conditional expression
		switch {
		case rightMeaning == SymbolFlagsValue:
			return SymbolFlagsValue
		default:
			return SymbolFlagsNamespace
		}
	}
	getAccessibleSymbolChain := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap /* TODO inferred type Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable[]> */ any /*  = new Map<SymbolId, SymbolTable[]>() */) *[]Symbol {
		if !(symbol && !isPropertyOrMethodDeclarationSymbol(symbol)) {
			return nil
		}
		links := getSymbolLinks(symbol)
		cache := ( /* TODO(Node BinaryExpression): links.accessibleChainCache ||= new Map() */ TODO)
		firstRelevantLocation := forEachSymbolTableInScope(enclosingDeclaration, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ any, __ /* TODO inferred type boolean | undefined */ any, ___ /* TODO inferred type boolean | undefined */ any, node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ any {
			return node
		})
		key := /* TODO(Node TemplateExpression): `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}` */ TODO
		if cache.has(key) {
			return cache.get(key)
		}
		id := getSymbolId(symbol)
		visitedSymbolTables := visitedSymbolTablesMap.get(id)
		if !visitedSymbolTables {
			visitedSymbolTablesMap.set(id /* TODO(Node BinaryExpression): visitedSymbolTables = [] */, TODO)
		}
		result := forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
		cache.set(key, result)
		return result
		getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) *[]Symbol {
			if !pushIfUnique(visitedSymbolTables, symbols) {
				return nil
			}
			result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
			visitedSymbolTables.pop()
			return result
		}
		canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) /* TODO inferred type boolean */ any {
			return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) || !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
		}
		isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) /* TODO inferred type boolean */ any {
			return (symbol == (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) == getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) && (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning))
		}
		trySymbolTable := func(symbols SymbolTable, ignoreQualification *bool, isLocalNameLookup *bool) *[]Symbol {
			if isAccessible(symbols.get(symbol.escapedName), nil, ignoreQualification) {
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbol}
			}
			result := forEachEntry(symbols, func(symbolFromSymbolTable /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ any {
				if symbolFromSymbolTable.flags&SymbolFlagsAlias && symbolFromSymbolTable.escapedName != InternalSymbolNameExportEquals && symbolFromSymbolTable.escapedName != InternalSymbolNameDefault && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration))) && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration)) && ( /* TODO(Node ConditionalExpression): isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true */ TODO) && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)) {
					resolvedImportedSymbol := resolveAlias(symbolFromSymbolTable)
					candidate := getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)
					if candidate {
						return candidate
					}
				}
				if symbolFromSymbolTable.escapedName == symbol.escapedName && symbolFromSymbolTable.exportSymbol {
					if isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), nil, ignoreQualification) {
						return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbol}
					}
				}
			})
			return result || ( /* TODO(Node ConditionalExpression): symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined */ TODO)
		}
		getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification *bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ any {
			if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbolFromSymbolTable}
			}
			candidateTable := getExportsOfSymbol(resolvedImportedSymbol)
			accessibleSymbolsFromExports := candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true)
			if accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning)) {
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbolFromSymbolTable}.concat(accessibleSymbolsFromExports)
			}
		}
	}
	needsQualification := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO inferred type boolean */ any {
		qualify := false
		forEachSymbolTableInScope(enclosingDeclaration, func(symbolTable /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ any) /* TODO inferred type boolean */ any {
			symbolFromSymbolTable := getMergedSymbol(symbolTable.get(symbol.escapedName))
			if !symbolFromSymbolTable {
				return false
			}
			if symbolFromSymbolTable == symbol {
				return true
			}
			shouldResolveAlias := symbolFromSymbolTable.flags&SymbolFlagsAlias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)
			symbolFromSymbolTable = /* TODO(Node ConditionalExpression): shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable */ TODO
			flags := /* TODO(Node ConditionalExpression): shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags */ TODO
			if flags & meaning {
				qualify = true
				return true
			}
			return false
		})
		return qualify
	}
	isPropertyOrMethodDeclarationSymbol := func(symbol Symbol) /* TODO inferred type boolean */ any {
		if symbol.declarations && symbol.declarations.length {
			for _, declaration := range symbol.declarations {
				switch declaration.kind {
				case SyntaxKindPropertyDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindMethodDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindGetAccessor:
					fallthrough // TODO: merge cases
				case SyntaxKindSetAccessor:
					continue
					fallthrough
				default:
					return false
				}
			}
			return true
		}
		return false
	}
	isTypeSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsType, false, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isValueSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsValue, false, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isSymbolAccessibleByFlags := func(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, false, false)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isAnySymbolAccessible := func(symbols *[]Symbol, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
		if !length(symbols) {
			return
		}
		var hadAccessibleChain *Symbol
		earlyModuleBail := false
		for _, symbol := range symbols {
			accessibleSymbolChain := getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false)
			if accessibleSymbolChain {
				hadAccessibleChain = symbol
				hasAccessibleDeclarations := hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible)
				if hasAccessibleDeclarations {
					return hasAccessibleDeclarations
				}
			}
			if allowModules {
				if some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					if shouldComputeAliasesToMakeVisible {
						earlyModuleBail = true
						continue
					}
					return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, } */ TODO
				}
			}
			containers := getContainersOfSymbol(symbol, enclosingDeclaration, meaning)
			parentResult := isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol /* TODO(Node ConditionalExpression): initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning */, TODO, shouldComputeAliasesToMakeVisible, allowModules)
			if parentResult {
				return parentResult
			}
		}
		if earlyModuleBail {
			return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, } */ TODO
		}
		if hadAccessibleChain {
			return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.NotAccessible, errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning), errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined, } */ TODO
		}
	}
	isSymbolAccessible := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
		return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, true)
	}
	isSymbolAccessibleWorker := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
		if symbol && enclosingDeclaration {
			result := isAnySymbolAccessible([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbol}, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
			if result {
				return result
			}
			symbolExternalModule := forEach(symbol.declarations, getExternalModuleContainer)
			if symbolExternalModule {
				enclosingExternalModule := getExternalModuleContainer(enclosingDeclaration)
				if symbolExternalModule != enclosingExternalModule {
					return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.CannotBeNamed, errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning), errorModuleName: symbolToString(symbolExternalModule), errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined, } */ TODO
				}
			}
			return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.NotAccessible, errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning), } */ TODO
		}
		return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
	}
	getExternalModuleContainer := func(declaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		node := findAncestor(declaration, hasExternalModuleSymbol)
		return node && getSymbolOfDeclaration(node)
	}
	hasExternalModuleSymbol := func(declaration Node) /* TODO inferred type boolean */ any {
		return isAmbientModule(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration))
	}
	hasNonGlobalAugmentationExternalModuleSymbol := func(declaration Node) /* TODO inferred type boolean */ any {
		return isModuleWithStringLiteralName(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration))
	}
	hasVisibleDeclarations := func(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
		var aliasesToMakeVisible *[]LateVisibilityPaintedStatement
		if !every(filter(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
			return d.kind != SyntaxKindIdentifier
		}), getIsDeclarationVisible) {
			return nil
		}
		return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible } */ TODO
		getIsDeclarationVisible := func(declaration Declaration) /* TODO inferred type boolean */ any {
			if !isDeclarationVisible(declaration) {
				anyImportSyntax := getAnyImportSyntax(declaration)
				if anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, ModifierFlagsExport) && isDeclarationVisible(anyImportSyntax.parent) {
					return addVisibleAlias(declaration, anyImportSyntax)
				} else if isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) && !hasSyntacticModifier(declaration.parent.parent, ModifierFlagsExport) && isDeclarationVisible(declaration.parent.parent.parent) {
					return addVisibleAlias(declaration, declaration.parent.parent)
				} else if isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, ModifierFlagsExport) && isDeclarationVisible(declaration.parent) {
					return addVisibleAlias(declaration, declaration)
				} else if isBindingElement(declaration) {
					if symbol.flags&SymbolFlagsAlias && isInJSFile(declaration) && declaration.parent. /*?*/ parent && isVariableDeclaration(declaration.parent.parent) && declaration.parent.parent.parent. /*?*/ parent && isVariableStatement(declaration.parent.parent.parent.parent) && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlagsExport) && declaration.parent.parent.parent.parent.parent && isDeclarationVisible(declaration.parent.parent.parent.parent.parent) {
						return addVisibleAlias(declaration, declaration.parent.parent.parent.parent)
					} else if symbol.flags & SymbolFlagsBlockScopedVariable {
						variableStatement := findAncestor(declaration, isVariableStatement)
						if hasSyntacticModifier(variableStatement, ModifierFlagsExport) {
							return true
						}
						if !isDeclarationVisible(variableStatement.parent) {
							return false
						}
						return addVisibleAlias(declaration, variableStatement)
					}
				}
				return false
			}
			return true
		}
		addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) /* TODO inferred type boolean */ any {
			if shouldComputeAliasToMakeVisible {
				getNodeLinks(declaration).isVisible = true
				aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement)
			}
			return true
		}
	}
	getMeaningOfEntityNameReference := func(entityName EntityNameOrEntityNameExpression) SymbolFlags {
		var meaning SymbolFlags
		if entityName.parent.kind == SyntaxKindTypeQuery || entityName.parent.kind == SyntaxKindExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) || entityName.parent.kind == SyntaxKindComputedPropertyName || entityName.parent.kind == SyntaxKindTypePredicate && (entityName.parent).parameterName == entityName {
			meaning = SymbolFlagsValue | SymbolFlagsExportValue
		} else if entityName.kind == SyntaxKindQualifiedName || entityName.kind == SyntaxKindPropertyAccessExpression || entityName.parent.kind == SyntaxKindImportEqualsDeclaration || (entityName.parent.kind == SyntaxKindQualifiedName && (entityName.parent).left == entityName) || (entityName.parent.kind == SyntaxKindPropertyAccessExpression && (entityName.parent).expression == entityName) || (entityName.parent.kind == SyntaxKindElementAccessExpression && (entityName.parent).expression == entityName) {
			meaning = SymbolFlagsNamespace
		} else {
			meaning = SymbolFlagsType
		}
		return meaning
	}
	isEntityNameVisible := func(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible /* TODO inferred type boolean */ any /*  = true */) SymbolVisibilityResult {
		meaning := getMeaningOfEntityNameReference(entityName)
		firstIdentifier := getFirstIdentifier(entityName)
		symbol := resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, nil, false)
		if symbol && symbol.flags&SymbolFlagsTypeParameter && meaning&SymbolFlagsType {
			return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, false, false)), firstIdentifier, meaning, false).accessibility == SymbolAccessibilityAccessible {
			return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol {
			return /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.NotResolved, errorSymbolName: getTextOfNode(firstIdentifier), errorNode: firstIdentifier, } */ TODO
		}
		return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || /* TODO(Node ObjectLiteralExpression): { accessibility: SymbolAccessibility.NotAccessible, errorSymbolName: getTextOfNode(firstIdentifier), errorNode: firstIdentifier, } */ TODO
	}
	symbolToString := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /*  = SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
		nodeFlags := NodeBuilderFlagsIgnoreErrors
		internalNodeFlags := InternalNodeBuilderFlagsNone
		if flags & SymbolFormatFlagsUseOnlyExternalAliasing {
			nodeFlags |= NodeBuilderFlagsUseOnlyExternalAliasing
		}
		if flags & SymbolFormatFlagsWriteTypeParametersOrArguments {
			nodeFlags |= NodeBuilderFlagsWriteTypeParametersInQualifiedName
		}
		if flags & SymbolFormatFlagsUseAliasDefinedOutsideCurrentScope {
			nodeFlags |= NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope
		}
		if flags & SymbolFormatFlagsDoNotIncludeSymbolChain {
			internalNodeFlags |= InternalNodeBuilderFlagsDoNotIncludeSymbolChain
		}
		if flags & SymbolFormatFlagsWriteComputedProps {
			internalNodeFlags |= InternalNodeBuilderFlagsWriteComputedProps
		}
		builder := /* TODO(Node ConditionalExpression): flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName */ TODO
		// converted from conditional expression
		switch {
		case writer:
			return symbolToStringWorker(writer).getText()
		default:
			return usingSingleLineStringWriter(symbolToStringWorker)
		}
		symbolToStringWorker := func(writer EmitTextWriter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ any {
			entity := builder(symbol, meaning, enclosingDeclaration, nodeFlags, internalNodeFlags)
			printer := /* TODO(Node ConditionalExpression): enclosingDeclaration?.kind === SyntaxKind.SourceFile ? createPrinterWithRemoveCommentsNeverAsciiEscape() : createPrinterWithRemoveComments() */ TODO
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, entity, sourceFile, writer)
			return writer
		}
	}
	signatureToString := func(signature Signature, enclosingDeclaration Node, flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ any /*  = TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
		// converted from conditional expression
		switch {
		case writer:
			return signatureToStringWorker(writer).getText()
		default:
			return usingSingleLineStringWriter(signatureToStringWorker)
		}
		signatureToStringWorker := func(writer EmitTextWriter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ any {
			var sigOutput SyntaxKind
			if flags & TypeFormatFlagsWriteArrowStyleSignature {
				sigOutput = /* TODO(Node ConditionalExpression): kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType */ TODO
			} else {
				sigOutput = /* TODO(Node ConditionalExpression): kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature */ TODO
			}
			sig := nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|NodeBuilderFlagsWriteTypeParametersInQualifiedName)
			printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, sig, sourceFile, getTrailingSemicolonDeferringWriter(writer))
			return writer
		}
	}
	typeToString := func(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /*  = createTextWriter("") */) string {
		noTruncation := compilerOptions.noErrorTruncation || flags&TypeFormatFlagsNoTruncation
		typeNode := nodeBuilder.typeToTypeNode(type_, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|( /* TODO(Node ConditionalExpression): noTruncation ? NodeBuilderFlags.NoTruncation : NodeBuilderFlags.None */ TODO), nil)
		if typeNode == nil {
			return Debug.fail("should always get typenode")
		}
		printer := /* TODO(Node ConditionalExpression): type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults() */ TODO
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, typeNode, sourceFile, writer)
		result := writer.getText()
		maxLength := /* TODO(Node ConditionalExpression): noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2 */ TODO
		if maxLength && result && result.length >= maxLength {
			return result.substr(0, maxLength-"...".length) + "..."
		}
		return result
	}
	getTypeNamesForErrorDisplay := func(left Type, right Type) /* TODO(TypeNode TupleType): [string, string] */ any {
		leftStr := /* TODO(Node ConditionalExpression): symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left) */ TODO
		rightStr := /* TODO(Node ConditionalExpression): symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right) */ TODO
		if leftStr == rightStr {
			leftStr = getTypeNameForErrorDisplay(left)
			rightStr = getTypeNameForErrorDisplay(right)
		}
		return []TODO{leftStr, rightStr}
	}
	getTypeNameForErrorDisplay := func(type_ Type) /* TODO inferred type string */ any {
		return typeToString(type_, nil, TypeFormatFlagsUseFullyQualifiedType)
	}
	symbolValueDeclarationIsContextSensitive := func(symbol Symbol) bool {
		return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration)
	}
	toNodeBuilderFlags := func(flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ any /*  = TypeFormatFlags.None */) NodeBuilderFlags {
		return flags & TypeFormatFlagsNodeBuilderFlagsMask
	}
	isClassInstanceSide := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!type_.symbol && !!(type_.symbol.flags & SymbolFlagsClass) && (type_ == getDeclaredTypeOfClassOrInterface(type_.symbol) || (!!(type_.flags & TypeFlagsObject) && !!(getObjectFlags(type_) & ObjectFlagsIsClassInstanceClone)))
	}
	getTypeFromTypeNodeWithoutContext := func(node TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getTypeFromTypeNode(node)
	}
	createNodeBuilder := func() /* TODO inferred type { typeToTypeNode: (type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeValue | undefined, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, addUndefined?: boolean | undefined, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeTypeForDeclaration: (declaration: import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeReturnTypeForSignature: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, kind: import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.Constructor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.GetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.SetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.CallSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.IndexSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructorType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.JSDocFunctionType, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | undefined; symbolToEntityName: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").EntityName | undefined; symbolToExpression: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; symbolToTypeParameterDeclarations: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] | undefined; symbolToNode: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined; } */ any {
		return /* TODO(Node ObjectLiteralExpression): { typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeToTypeNodeHelper(type, context)), typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typePredicateToTypePredicateNodeHelper(typePredicate, context)), expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => expressionOrTypeToTypeNode(context, expr, type, addUndefined)), serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeTypeForDeclaration(context, declaration, type, symbol)), serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeReturnTypeForSignature(context, signature)), indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, /*typeNode* / undefined)), signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)), symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToName(symbol, context, meaning, /*expectsIdentifier* / false)), symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToExpression(symbol, context, meaning)), symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)), symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToParameterDeclaration(symbol, context)), typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParameterToDeclaration(parameter, context)), symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolTableToDeclarationStatements(symbolTable, context)), symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToNode(symbol, context, meaning)), } */ TODO
		/* OVERLOAD: function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: false): Type; */
		/* OVERLOAD: function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes: true): Type | undefined; */
		getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) *Type {
			type_ := getTypeFromTypeNodeWithoutContext(node)
			if !context.mapper {
				return type_
			}
			mappedType := instantiateType(type_, context.mapper)
			// converted from conditional expression
			switch {
			case noMappedTypes && mappedType != type_:
				return nil
			default:
				return mappedType
			}
		}
		setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
			if !nodeIsSynthesized(range_) || !(range_.flags & NodeFlagsSynthesized) || !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(getOriginalNode(range_)) {
				range_ = factory.cloneNode(range_)
			}
			if range_ == location {
				return range_
			}
			if !location {
				return range_
			}
			original := range_.original
			for original && original != location {
				original = original.original
			}
			if !original {
				setOriginalNode(range_, location)
			}
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(getOriginalNode(location)) {
				return setTextRangeWorker(range_, location)
			}
			return range_
		}
		expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(TypeNode UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
			restoreFlags := saveRestoreFlags(context)
			if expr && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
			restoreFlags()
			return result
		}
		expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(TypeNode UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
			if expr {
				typeNode := /* TODO(Node ConditionalExpression): isAssertionExpression(expr) ? expr.type : isJSDocTypeAssertion(expr) ? getJSDocTypeAssertionType(expr) : undefined */ TODO
				if typeNode && !isConstTypeReference(typeNode) {
					result := tryReuseExistingTypeNode(context, typeNode, type_, expr.parent, addUndefined)
					if result {
						return result
					}
				}
			}
			if addUndefined {
				type_ = getOptionalType(type_)
			}
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
			originalType := type_
			if addUndefined {
				type_ = getOptionalType(type_, !isParameter(host))
			}
			clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
			if clone {
				if addUndefined && containsNonMissingUndefinedType(type_) && !someType(getTypeFromTypeNode(context, typeNode), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags & TypeFlagsUndefined)
				}) {
					return factory.createUnionTypeNode([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{clone, factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
				}
				return clone
			}
			if addUndefined && originalType != type_ {
				cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
				if cloneMissingUndefined {
					return factory.createUnionTypeNode([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
				}
			}
			return nil
		}
		tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ any /*  = context.enclosingDeclaration */, annotationType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any /*  = getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
			if annotationType && typeNodeIsEquivalentToType(host, type_, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) {
				result := tryReuseExistingTypeNodeHelper(context, existing)
				if result {
					return result
				}
			}
			return nil
		}
		symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ any {
			if context.internalFlags & InternalNodeBuilderFlagsWriteComputedProps {
				if symbol.valueDeclaration {
					name := getNameOfDeclaration(symbol.valueDeclaration)
					if name && isComputedPropertyName(name) {
						return name
					}
				}
				nameType := getSymbolLinks(symbol).nameType
				if nameType && nameType.flags&(TypeFlagsEnumLiteral|TypeFlagsUniqueESSymbol) {
					context.enclosingDeclaration = nameType.symbol.valueDeclaration
					return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning))
				}
			}
			return symbolToExpression(symbol, context, meaning)
		}
		withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
			moduleResolverHost := /* TODO(Node ConditionalExpression): tracker?.trackSymbol ? tracker.moduleResolverHost : (internalFlags || InternalNodeBuilderFlags.None) & InternalNodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) : undefined */ TODO
			var context NodeBuilderContext = /* TODO(Node ObjectLiteralExpression): { enclosingDeclaration, enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration), flags: flags || NodeBuilderFlags.None, internalFlags: internalFlags || InternalNodeBuilderFlags.None, tracker: undefined!, encounteredError: false, reportedDiagnostic: false, visitedTypes: undefined, symbolDepth: undefined, inferTypeParameters: undefined, approximateLength: 0, trackedSymbols: undefined, bundled: !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)), truncating: false, usedSymbolNames: undefined, remappedSymbolNames: undefined, remappedSymbolReferences: undefined, reverseMappedStack: undefined, mustCreateTypeParameterSymbolList: true, typeParameterSymbolList: undefined, mustCreateTypeParametersNamesLookups: true, typeParameterNames: undefined, typeParameterNamesByText: undefined, typeParameterNamesByTextNextNameCount: undefined, mapper: undefined, } */ TODO
			context.tracker = /* TODO(Node NewExpression): new SymbolTrackerImpl(context, tracker, moduleResolverHost) */ TODO
			resultingNode := cb(context)
			if context.truncating && context.flags&NodeBuilderFlagsNoTruncation {
				context.tracker.reportTruncationError()
			}
			// converted from conditional expression
			switch {
			case context.encounteredError:
				return nil
			default:
				return resultingNode
			}
		}
		saveRestoreFlags := func(context NodeBuilderContext) /* TODO inferred type () => void */ any {
			flags := context.flags
			internalFlags := context.internalFlags
			return restore
			restore := func() {
				context.flags = flags
				context.internalFlags = internalFlags
			}
		}
		checkTruncationLength := func(context NodeBuilderContext) bool {
			if context.truncating {
				return context.truncating
			}
			context.truncating = context.approximateLength > ( /* TODO(Node ConditionalExpression): (context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength */ TODO)
			return context.truncating
		}
		typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
			restoreFlags := saveRestoreFlags(context)
			typeNode := typeToTypeNodeWorker(type_, context)
			restoreFlags()
			return typeNode
		}
		typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			inTypeAlias := context.flags & NodeBuilderFlagsInTypeAlias
			context.flags &= ~NodeBuilderFlagsInTypeAlias
			if !type_ {
				if !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
					context.encounteredError = true
					return nil
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			if !(context.flags & NodeBuilderFlagsNoTypeReduction) {
				type_ = getReducedType(type_)
			}
			if type_.flags & TypeFlagsAny {
				if type_.aliasSymbol {
					return factory.createTypeReferenceNode(symbolToEntityNameNode(type_.aliasSymbol), mapToTypeNodes(type_.aliasTypeArguments, context))
				}
				if type_ == unresolvedType {
					return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "unresolved")
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode( /* TODO(Node ConditionalExpression): type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword */ TODO)
			}
			if type_.flags & TypeFlagsUnknown {
				return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
			}
			if type_.flags & TypeFlagsString {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindStringKeyword)
			}
			if type_.flags & TypeFlagsNumber {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindNumberKeyword)
			}
			if type_.flags & TypeFlagsBigInt {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindBigIntKeyword)
			}
			if type_.flags&TypeFlagsBoolean && !type_.aliasSymbol {
				context.approximateLength += 7
				return factory.createKeywordTypeNode(SyntaxKindBooleanKeyword)
			}
			if type_.flags & TypeFlagsEnumLike {
				if type_.symbol.flags & SymbolFlagsEnumMember {
					parentSymbol := getParentOfSymbol(type_.symbol)
					parentName := symbolToTypeNode(parentSymbol, context, SymbolFlagsType)
					if getDeclaredTypeOfSymbol(parentSymbol) == type_ {
						return parentName
					}
					memberName := symbolName(type_.symbol)
					if isIdentifierText(memberName, ScriptTargetES5) {
						return appendReferenceToType(parentName, factory.createTypeReferenceNode(memberName, nil))
					}
					if isImportTypeNode(parentName) {
						(parentName).isTypeOf = true
						return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else if isTypeReferenceNode(parentName) {
						return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else {
						return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.")
					}
				}
				return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
			}
			if type_.flags & TypeFlagsStringLiteral {
				context.approximateLength += (type_).value.length + 2
				return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type_).value, !!(context.flags&NodeBuilderFlagsUseSingleQuotesForStringLiteralType)), EmitFlagsNoAsciiEscaping))
			}
			if type_.flags & TypeFlagsNumberLiteral {
				value := (type_).value
				context.approximateLength += ("" + value).length
				return factory.createLiteralTypeNode( /* TODO(Node ConditionalExpression): value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value) */ TODO)
			}
			if type_.flags & TypeFlagsBigIntLiteral {
				context.approximateLength += (pseudoBigIntToString((type_).value).length) + 1
				return factory.createLiteralTypeNode(factory.createBigIntLiteral((type_).value))
			}
			if type_.flags & TypeFlagsBooleanLiteral {
				context.approximateLength += (type_).intrinsicName.length
				return factory.createLiteralTypeNode( /* TODO(Node ConditionalExpression): (type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse() */ TODO)
			}
			if type_.flags & TypeFlagsUniqueESSymbol {
				if !(context.flags & NodeBuilderFlagsAllowUniqueESSymbolType) {
					if isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
						context.approximateLength += 6
						return symbolToTypeNode(type_.symbol, context, SymbolFlagsValue)
					}
					if context.tracker.reportInaccessibleUniqueSymbolError {
						context.tracker.reportInaccessibleUniqueSymbolError()
					}
				}
				context.approximateLength += 13
				return factory.createTypeOperatorNode(SyntaxKindUniqueKeyword, factory.createKeywordTypeNode(SyntaxKindSymbolKeyword))
			}
			if type_.flags & TypeFlagsVoid {
				context.approximateLength += 4
				return factory.createKeywordTypeNode(SyntaxKindVoidKeyword)
			}
			if type_.flags & TypeFlagsUndefined {
				context.approximateLength += 9
				return factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)
			}
			if type_.flags & TypeFlagsNull {
				context.approximateLength += 4
				return factory.createLiteralTypeNode(factory.createNull())
			}
			if type_.flags & TypeFlagsNever {
				context.approximateLength += 5
				return factory.createKeywordTypeNode(SyntaxKindNeverKeyword)
			}
			if type_.flags & TypeFlagsESSymbol {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindSymbolKeyword)
			}
			if type_.flags & TypeFlagsNonPrimitive {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindObjectKeyword)
			}
			if isThisTypeParameter(type_) {
				if context.flags & NodeBuilderFlagsInObjectTypeLiteral {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowThisInObjectLiteral) {
						context.encounteredError = true
					}
					context.tracker.reportInaccessibleThisError()
				}
				context.approximateLength += 4
				return factory.createThisTypeNode()
			}
			if !inTypeAlias && type_.aliasSymbol && (context.flags&NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type_.aliasSymbol, context.enclosingDeclaration)) {
				typeArgumentNodes := mapToTypeNodes(type_.aliasTypeArguments, context)
				if isReservedMemberName(type_.aliasSymbol.escapedName) && !(type_.aliasSymbol.flags & SymbolFlagsClass) {
					return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes)
				}
				if length(typeArgumentNodes) == 1 && type_.aliasSymbol == globalArrayType.symbol {
					return factory.createArrayTypeNode(typeArgumentNodes[0])
				}
				return symbolToTypeNode(type_.aliasSymbol, context, SymbolFlagsType, typeArgumentNodes)
			}
			objectFlags := getObjectFlags(type_)
			if objectFlags & ObjectFlagsReference {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				// converted from conditional expression
				switch {
				case (type_).node:
					return visitAndTransformType(type_, typeReferenceToTypeNode)
				default:
					return typeReferenceToTypeNode(type_)
				}
			}
			if type_.flags&TypeFlagsTypeParameter || objectFlags&ObjectFlagsClassOrInterface {
				if type_.flags&TypeFlagsTypeParameter && contains(context.inferTypeParameters, type_) {
					context.approximateLength += symbolName(type_.symbol).length + 6
					var constraintNode *TypeNode
					constraint := getConstraintOfTypeParameter(type_)
					if constraint {
						inferredConstraint := getInferredTypeParameterConstraint(type_, true)
						if !(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint)) {
							context.approximateLength += 9
							constraintNode = constraint && typeToTypeNodeHelper(constraint, context)
						}
					}
					return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type_, context, constraintNode))
				}
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.flags&TypeFlagsTypeParameter {
					name := typeParameterToName(type_, context)
					context.approximateLength += idText(name).length
					return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)), nil)
				}
				if type_.symbol {
					return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
				}
				name := /* TODO(Node ConditionalExpression): (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ? (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?" */ TODO
				return factory.createTypeReferenceNode(factory.createIdentifier(name), nil)
			}
			if type_.flags&TypeFlagsUnion && (type_).origin {
				type_ = (type_).origin
			}
			if type_.flags & (TypeFlagsUnion | TypeFlagsIntersection) {
				types := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? formatUnionTypes((type as UnionType).types) : (type as IntersectionType).types */ TODO
				if length(types) == 1 {
					return typeToTypeNodeHelper(types[0], context)
				}
				typeNodes := mapToTypeNodes(types, context, true)
				if typeNodes && typeNodes.length > 0 {
					// converted from conditional expression
					switch {
					case type_.flags & TypeFlagsUnion:
						return factory.createUnionTypeNode(typeNodes)
					default:
						return factory.createIntersectionTypeNode(typeNodes)
					}
				} else {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
						context.encounteredError = true
					}
					return nil
				}
			}
			if objectFlags & (ObjectFlagsAnonymous | ObjectFlagsMapped) {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				return createAnonymousTypeNode(type_)
			}
			if type_.flags & TypeFlagsIndex {
				indexedType := (type_).type_
				context.approximateLength += 6
				indexTypeNode := typeToTypeNodeHelper(indexedType, context)
				return factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, indexTypeNode)
			}
			if type_.flags & TypeFlagsTemplateLiteral {
				texts := (type_).texts
				types := (type_).types
				templateHead := factory.createTemplateHead(texts[0])
				templateSpans := factory.createNodeArray(map_(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralTypeSpan */ any {
					return factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), ( /* TODO(Node ConditionalExpression): i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail */ TODO)(texts[i+1]))
				}))
				context.approximateLength += 2
				return factory.createTemplateLiteralType(templateHead, templateSpans)
			}
			if type_.flags & TypeFlagsStringMapping {
				typeNode := typeToTypeNodeHelper((type_).type_, context)
				return symbolToTypeNode((type_).symbol, context, SymbolFlagsType, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{typeNode})
			}
			if type_.flags & TypeFlagsIndexedAccess {
				objectTypeNode := typeToTypeNodeHelper((type_).objectType, context)
				indexTypeNode := typeToTypeNodeHelper((type_).indexType, context)
				context.approximateLength += 2
				return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode)
			}
			if type_.flags & TypeFlagsConditional {
				return visitAndTransformType(type_, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ any {
					return conditionalTypeToTypeNode(type_)
				})
			}
			if type_.flags & TypeFlagsSubstitution {
				typeNode := typeToTypeNodeHelper((type_).baseType, context)
				noInferSymbol := isNoInferType(type_) && getGlobalTypeSymbol("NoInfer", false)
				// converted from conditional expression
				switch {
				case noInferSymbol:
					return symbolToTypeNode(noInferSymbol, context, SymbolFlagsType, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{typeNode})
				default:
					return typeNode
				}
			}
			return Debug.fail("Should be unreachable.")
			conditionalTypeToTypeNode := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ any {
				checkTypeNode := typeToTypeNodeHelper(type_.checkType, context)
				context.approximateLength += 15
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.root.isDistributive && !(type_.checkType.flags & TypeFlagsTypeParameter) {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T"))
					name := typeParameterToName(newParam, context)
					newTypeVariable := factory.createTypeReferenceNode(name)
					context.approximateLength += 37
					newMapper := prependTypeMapping(type_.root.checkType, newParam, type_.mapper)
					saveInferTypeParameters := context.inferTypeParameters
					context.inferTypeParameters = type_.root.inferTypeParameters
					extendsTypeNode := typeToTypeNodeHelper(instantiateType(type_.root.extendsType, newMapper), context)
					context.inferTypeParameters = saveInferTypeParameters
					trueTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.trueType), newMapper))
					falseTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.falseType), newMapper))
					return factory.createConditionalTypeNode(checkTypeNode, factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName))), factory.createConditionalTypeNode(factory.createTypeReferenceNode(factory.cloneNode(name)), typeToTypeNodeHelper(type_.checkType, context), factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode), factory.createKeywordTypeNode(SyntaxKindNeverKeyword)), factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				saveInferTypeParameters := context.inferTypeParameters
				context.inferTypeParameters = type_.root.inferTypeParameters
				extendsTypeNode := typeToTypeNodeHelper(type_.extendsType, context)
				context.inferTypeParameters = saveInferTypeParameters
				trueTypeNode := typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type_))
				falseTypeNode := typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type_))
				return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
			}
			typeToTypeNodeOrCircularityElision := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
				if type_.flags & TypeFlagsUnion {
					if context.visitedTypes. /*?*/ has(getTypeId(type_)) {
						if !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
							context.encounteredError = true
							context.tracker. /*?*/ reportCyclicStructureError()
						}
						return createElidedInformationPlaceholder(context)
					}
					return visitAndTransformType(type_, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
						return typeToTypeNodeHelper(type_, context)
					})
				}
				return typeToTypeNodeHelper(type_, context)
			}
			isMappedTypeHomomorphic := func(type_ MappedType) /* TODO inferred type boolean */ any {
				return !!getHomomorphicTypeVariable(type_)
			}
			isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) /* TODO inferred type boolean */ any {
				return !!type_.target && isMappedTypeHomomorphic(type_.target) && !isMappedTypeHomomorphic(type_)
			}
			createMappedTypeNodeFromType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").MappedTypeNode */ any {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				readonlyToken := /* TODO(Node ConditionalExpression): type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined */ TODO
				questionToken := /* TODO(Node ConditionalExpression): type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined */ TODO
				var appropriateConstraintTypeNode TypeNode
				var newTypeVariable *TypeReferenceNode
				needsModifierPreservingWrapper := !isMappedTypeWithKeyofConstraintDeclaration(type_) && !(getModifiersTypeFromMappedType(type_).flags & TypeFlagsUnknown) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && !(getConstraintTypeFromMappedType(type_).flags&TypeFlagsTypeParameter && getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type_)). /*?*/ flags&TypeFlagsIndex)
				if isMappedTypeWithKeyofConstraintDeclaration(type_) {
					if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
						newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T"))
						name := typeParameterToName(newParam, context)
						newTypeVariable = factory.createTypeReferenceNode(name)
					}
					appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context))
				} else if needsModifierPreservingWrapper {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T"))
					name := typeParameterToName(newParam, context)
					newTypeVariable = factory.createTypeReferenceNode(name)
					appropriateConstraintTypeNode = newTypeVariable
				} else {
					appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context)
				}
				typeParameterNode := typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
				nameTypeNode := /* TODO(Node ConditionalExpression): type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined */ TODO
				templateTypeNode := typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type_), !!(getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)), context)
				mappedTypeNode := factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, nil)
				context.approximateLength += 10
				result := setEmitFlags(mappedTypeNode, EmitFlagsSingleLine)
				if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
					originalConstraint := instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type_.declaration.typeParameter.constraint).type_)) || unknownType, type_.mapper)
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* TODO(Node ConditionalExpression): originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context) */, TODO)), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				} else if needsModifierPreservingWrapper {
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName), factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				return result
			}
			createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
				typeId := type_.id
				symbol := type_.symbol
				if symbol {
					isInstantiationExpressionType := !!(getObjectFlags(type_) & ObjectFlagsInstantiationExpressionType)
					if isInstantiationExpressionType {
						instantiationExpressionType := type_
						existing := instantiationExpressionType.node
						if isTypeQueryNode(existing) {
							typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
							if typeNode {
								return typeNode
							}
						}
						if context.visitedTypes. /*?*/ has(typeId) {
							return createElidedInformationPlaceholder(context)
						}
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
					isInstanceType := /* TODO(Node ConditionalExpression): isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
					if isJSConstructor(symbol.valueDeclaration) {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if symbol.flags&SymbolFlagsClass && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, false).accessibility != SymbolAccessibilityAccessible)) || symbol.flags&(SymbolFlagsEnum|SymbolFlagsValueModule) || shouldWriteTypeOfFunctionSymbol() {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if context.visitedTypes. /*?*/ has(typeId) {
						typeAlias := getTypeAliasForTypeLiteral(type_)
						if typeAlias {
							return symbolToTypeNode(typeAlias, context, SymbolFlagsType)
						} else {
							return createElidedInformationPlaceholder(context)
						}
					} else {
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
				} else {
					return createTypeNodeFromObjectType(type_)
				}
				shouldWriteTypeOfFunctionSymbol := func() /* TODO inferred type boolean | undefined */ any {
					isStaticMethodSymbol := !!(symbol.flags & SymbolFlagsMethod) && some(symbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
						return isStatic(declaration)
					})
					isNonLocalFunctionSymbol := !!(symbol.flags & SymbolFlagsFunction) && (symbol.parent || forEach(symbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
						return declaration.parent.kind == SyntaxKindSourceFile || declaration.parent.kind == SyntaxKindModuleBlock
					}))
					if isStaticMethodSymbol || isNonLocalFunctionSymbol {
						return (!!(context.flags & NodeBuilderFlagsUseTypeOfFunction) || (context.visitedTypes. /*?*/ has(typeId))) && (!(context.flags & NodeBuilderFlagsUseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration))
					}
				}
			}
			visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
				typeId := type_.id
				isConstructorObject := getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&SymbolFlagsClass
				id := /* TODO(Node ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) : type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) : type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) : undefined */ TODO
				if !context.visitedTypes {
					context.visitedTypes = /* TODO(Node NewExpression): new Set() */ make(map[any]struct{})
				}
				if id && !context.symbolDepth {
					context.symbolDepth = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
				}
				links := context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration)
				key := /* TODO(Node TemplateExpression): `${getTypeId(type)}|${context.flags}|${context.internalFlags}` */ TODO
				if links {
					/* TODO(Node BinaryExpression): links.serializedTypes ||= new Map() */ TODO
				}
				cachedResult := links. /*?*/ serializedTypes. /*?*/ get(key)
				if cachedResult {
					cachedResult.trackedSymbols. /*?*/ forEach(func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TrackedSymbol */ any) /* TODO inferred type boolean */ any {
						return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
					})
					if cachedResult.truncating {
						context.truncating = true
					}
					context.approximateLength += cachedResult.addedLength
					return deepCloneOrReuseNode(cachedResult.node)
				}
				var depth *number
				if id {
					depth = context.symbolDepth.get(id) || 0
					if depth > 10 {
						return createElidedInformationPlaceholder(context)
					}
					context.symbolDepth.set(id, depth+1)
				}
				context.visitedTypes.add(typeId)
				prevTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				startLength := context.approximateLength
				result := transform(type_)
				addedLength := context.approximateLength - startLength
				if !context.reportedDiagnostic && !context.encounteredError {
					links. /*?*/ serializedTypes. /*?*/ set(key /* TODO(Node ObjectLiteralExpression): { node: result, truncating: context.truncating, addedLength, trackedSymbols: context.trackedSymbols, } */, TODO)
				}
				context.visitedTypes.delete(typeId)
				if id {
					context.symbolDepth.set(id, depth)
				}
				context.trackedSymbols = prevTrackedSymbols
				return result
				deepCloneOrReuseNode := func(node T) T {
					if !nodeIsSynthesized(node) && getParseTreeNode(node) == node {
						return node
					}
					return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode, nil, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
				}
				deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					if nodes && nodes.length == 0 {
						return setTextRangeWorker(factory.createNodeArray(nil, nodes.hasTrailingComma), nodes)
					}
					return visitNodes(nodes, visitor, test, start, count)
				}
			}
			createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
				if isGenericMappedType(type_) || (type_).containsError {
					return createMappedTypeNodeFromType(type_)
				}
				resolved := resolveStructuredTypeMembers(type_)
				if !resolved.properties.length && !resolved.indexInfos.length {
					if !resolved.callSignatures.length && !resolved.constructSignatures.length {
						context.approximateLength += 2
						return setEmitFlags(factory.createTypeLiteralNode(nil), EmitFlagsSingleLine)
					}
					if resolved.callSignatures.length == 1 && !resolved.constructSignatures.length {
						signature := resolved.callSignatures[0]
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindFunctionType, context)
						return signatureNode
					}
					if resolved.constructSignatures.length == 1 && !resolved.callSignatures.length {
						signature := resolved.constructSignatures[0]
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructorType, context)
						return signatureNode
					}
				}
				abstractSignatures := filter(resolved.constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
					return !!(signature.flags & SignatureFlagsAbstract)
				})
				if some(abstractSignatures) {
					types := map_(abstractSignatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
						return getOrCreateTypeFromSignature(s)
					})
					typeElementCount := resolved.callSignatures.length + (resolved.constructSignatures.length - abstractSignatures.length) + resolved.indexInfos.length + ( /* TODO(Node ConditionalExpression): context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ? countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) : length(resolved.properties) */ TODO)
					if typeElementCount {
						types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved))
					}
					return typeToTypeNodeHelper(getIntersectionType(types), context)
				}
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInObjectTypeLiteral
				members := createTypeNodesFromResolvedType(resolved)
				restoreFlags()
				typeLiteralNode := factory.createTypeLiteralNode(members)
				context.approximateLength += 2
				setEmitFlags(typeLiteralNode /* TODO(Node ConditionalExpression): (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine */, TODO)
				return typeLiteralNode
			}
			typeReferenceToTypeNode := func(type_ TypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
				var typeArguments []Type = getTypeArguments(type_)
				if type_.target == globalArrayType || type_.target == globalReadonlyArrayType {
					if context.flags & NodeBuilderFlagsWriteArrayAsGenericType {
						typeArgumentNode := typeToTypeNodeHelper(typeArguments[0], context)
						return factory.createTypeReferenceNode( /* TODO(Node ConditionalExpression): type.target === globalArrayType ? "Array" : "ReadonlyArray" */ TODO, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{typeArgumentNode})
					}
					elementType := typeToTypeNodeHelper(typeArguments[0], context)
					arrayType := factory.createArrayTypeNode(elementType)
					// converted from conditional expression
					switch {
					case type_.target == globalArrayType:
						return arrayType
					default:
						return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, arrayType)
					}
				} else if type_.target.objectFlags & ObjectFlagsTuple {
					typeArguments = sameMap(typeArguments, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return removeMissingType(t, !!((type_.target).elementFlags[i] & ElementFlagsOptional))
					})
					if typeArguments.length > 0 {
						arity := getTypeReferenceArity(type_)
						tupleConstituentNodes := mapToTypeNodes(typeArguments.slice(0, arity), context)
						if tupleConstituentNodes {
							TODO_IDENTIFIER := type_.target
							for i := 0; i < tupleConstituentNodes.length; i++ {
								flags := (type_.target).elementFlags[i]
								labeledElementDeclaration := labeledElementDeclarations[i]
								if labeledElementDeclaration {
									tupleConstituentNodes[i] = factory.createNamedTupleMember( /* TODO(Node ConditionalExpression): flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO, factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))) /* TODO(Node ConditionalExpression): flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */, TODO /* TODO(Node ConditionalExpression): flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i] */, TODO)
								} else {
									tupleConstituentNodes[i] = /* TODO(Node ConditionalExpression): flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) : flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i] */ TODO
								}
							}
							tupleTypeNode := setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlagsSingleLine)
							// converted from conditional expression
							switch {
							case (type_.target).readonly:
								return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, tupleTypeNode)
							default:
								return tupleTypeNode
							}
						}
					}
					if context.encounteredError || (context.flags & NodeBuilderFlagsAllowEmptyTuple) {
						tupleTypeNode := setEmitFlags(factory.createTupleTypeNode([] /* TODO inferred type never */ any{}), EmitFlagsSingleLine)
						// converted from conditional expression
						switch {
						case (type_.target).readonly:
							return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, tupleTypeNode)
						default:
							return tupleTypeNode
						}
					}
					context.encounteredError = true
					return nil
				} else if context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && type_.symbol.valueDeclaration && isClassLike(type_.symbol.valueDeclaration) && !isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
					return createAnonymousTypeNode(type_)
				} else {
					outerTypeParameters := type_.target.outerTypeParameters
					i := 0
					var resultType /* TODO(TypeNode UnionType): TypeReferenceNode | ImportTypeNode | undefined */ any
					if outerTypeParameters {
						length := outerTypeParameters.length
						for i < length {
							start := i
							parent := getParentSymbolOfTypeParameter(outerTypeParameters[i])
							// TODO: refactor do-while loop approximation
							for ok := true; ok; ok = i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) == parent {
								i++
							}
							if !rangeEquals(outerTypeParameters, typeArguments, start, i) {
								typeArgumentSlice := mapToTypeNodes(typeArguments.slice(start, i), context)
								restoreFlags := saveRestoreFlags(context)
								context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
								ref := symbolToTypeNode(parent, context, SymbolFlagsType, typeArgumentSlice)
								restoreFlags()
								resultType = /* TODO(Node ConditionalExpression): !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode) */ TODO
							}
						}
					}
					var typeArgumentNodes *[]TypeNode
					if typeArguments.length > 0 {
						typeParameterCount := 0
						if type_.target.typeParameters {
							typeParameterCount = Math.min(type_.target.typeParameters.length, typeArguments.length)
							if isReferenceToType(type_, getGlobalIterableType(false)) || isReferenceToType(type_, getGlobalIterableIteratorType(false)) || isReferenceToType(type_, getGlobalAsyncIterableType(false)) || isReferenceToType(type_, getGlobalAsyncIterableIteratorType(false)) {
								if !type_.node || !isTypeReferenceNode(type_.node) || !type_.node.typeArguments || type_.node.typeArguments.length < typeParameterCount {
									for typeParameterCount > 0 {
										typeArgument := typeArguments[typeParameterCount-1]
										typeParameter := type_.target.typeParameters[typeParameterCount-1]
										defaultType := getDefaultFromTypeParameter(typeParameter)
										if !defaultType || !isTypeIdenticalTo(typeArgument, defaultType) {
											break
										}
										typeParameterCount--
									}
								}
							}
						}
						typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context)
					}
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
					finalRef := symbolToTypeNode(type_.symbol, context, SymbolFlagsType, typeArgumentNodes)
					restoreFlags()
					// converted from conditional expression
					switch {
					case !resultType:
						return finalRef
					default:
						return appendReferenceToType(resultType, finalRef)
					}
				}
			}
			appendReferenceToType := func(root /* TODO(TypeNode UnionType): TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(TypeNode UnionType): TypeReferenceNode | ImportTypeNode */ any {
				if isImportTypeNode(root) {
					typeArguments := root.typeArguments
					qualifier := root.qualifier
					if qualifier {
						if isIdentifier(qualifier) {
							if typeArguments != getIdentifierTypeArguments(qualifier) {
								qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments)
							}
						} else {
							if typeArguments != getIdentifierTypeArguments(qualifier.right) {
								qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments))
							}
						}
					}
					typeArguments = ref.typeArguments
					ids := getAccessStack(ref)
					for _, id := range ids {
						qualifier = /* TODO(Node ConditionalExpression): qualifier ? factory.createQualifiedName(qualifier, id) : id */ TODO
					}
					return factory.updateImportTypeNode(root, root.argument, root.attributes, qualifier, typeArguments, root.isTypeOf)
				} else {
					typeArguments := root.typeArguments
					typeName := root.typeName
					if isIdentifier(typeName) {
						if typeArguments != getIdentifierTypeArguments(typeName) {
							typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments)
						}
					} else {
						if typeArguments != getIdentifierTypeArguments(typeName.right) {
							typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments))
						}
					}
					typeArguments = ref.typeArguments
					ids := getAccessStack(ref)
					for _, id := range ids {
						typeName = factory.createQualifiedName(typeName, id)
					}
					return factory.updateTypeReferenceNode(root, typeName, typeArguments)
				}
			}
			getAccessStack := func(ref TypeReferenceNode) []Identifier {
				state := ref.typeName
				ids := [] /* TODO inferred type never */ any{}
				for !isIdentifier(state) {
					ids.unshift(state.right)
					state = state.left
				}
				ids.unshift(state)
				return ids
			}
			createTypeNodesFromResolvedType := func(resolvedType ResolvedType) *[]TypeElement {
				if checkTruncationLength(context) {
					return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ any{factory.createPropertySignature(nil, "...", nil, nil)}
				}
				var typeElements []TypeElement = [] /* TODO inferred type never */ any{}
				for _, signature := range resolvedType.callSignatures {
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindCallSignature, context))
				}
				for _, signature := range resolvedType.constructSignatures {
					if signature.flags & SignatureFlagsAbstract {
						continue
					}
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructSignature, context))
				}
				for _, info := range resolvedType.indexInfos {
					typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context /* TODO(Node ConditionalExpression): resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined */, TODO))
				}
				properties := resolvedType.properties
				if !properties {
					return typeElements
				}
				i := 0
				for _, propertySymbol := range properties {
					i++
					if context.flags & NodeBuilderFlagsWriteClassExpressionAsTypeLiteral {
						if propertySymbol.flags & SymbolFlagsPrototype {
							continue
						}
						if getDeclarationModifierFlagsFromSymbol(propertySymbol)&(ModifierFlagsPrivate|ModifierFlagsProtected) && context.tracker.reportPrivateInBaseOfClassExpression {
							context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName))
						}
					}
					if checkTruncationLength(context) && (i+2 < properties.length-1) {
						typeElements.push(factory.createPropertySignature(nil /* TODO(Node TemplateExpression): `... ${properties.length - i} more ...` */, TODO, nil, nil))
						addPropertyToElementList(properties[properties.length-1], context, typeElements)
						break
					}
					addPropertyToElementList(propertySymbol, context, typeElements)
				}
				// converted from conditional expression
				switch {
				case typeElements.length:
					return typeElements
				default:
					return nil
				}
			}
		}
		createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeReferenceNode | import("/home/jabaile/work/TypeScript/src/compiler/types").KeywordTypeNode<import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.AnyKeyword> */ any {
			context.approximateLength += 3
			if !(context.flags & NodeBuilderFlagsNoTruncation) {
				return factory.createTypeReferenceNode(factory.createIdentifier("..."), nil)
			}
			return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
		}
		shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) /* TODO inferred type boolean */ any {
			depth := 3
			return !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped) && (contains(context.reverseMappedStack, propertySymbol) || (context.reverseMappedStack[0] && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlagsAnonymous)) || isDeeplyNestedReverseMappedTypeProperty())
			isDeeplyNestedReverseMappedTypeProperty := func() /* TODO inferred type boolean */ any {
				if ( /* TODO(Node BinaryExpression): context.reverseMappedStack?.length ?? 0 */ TODO) < depth {
					return false
				}
				for i := 0; i < depth; i++ {
					prop := context.reverseMappedStack[context.reverseMappedStack.length-1-i]
					if prop.links.mappedType.symbol != (propertySymbol).links.mappedType.symbol {
						return false
					}
				}
				return true
			}
		}
		addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
			propertyIsReverseMapped := !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped)
			propertyType := /* TODO(Node ConditionalExpression): shouldUsePlaceholderForProperty(propertySymbol, context) ? anyType : getNonMissingTypeOfSymbol(propertySymbol) */ TODO
			saveEnclosingDeclaration := context.enclosingDeclaration
			context.enclosingDeclaration = nil
			if context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName) {
				if propertySymbol.declarations {
					decl := first(propertySymbol.declarations)
					if hasLateBindableName(decl) {
						if isBinaryExpression(decl) {
							name := getNameOfDeclaration(decl)
							if name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression) {
								trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context)
							}
						} else {
							trackComputedName(decl.name.expression, saveEnclosingDeclaration, context)
						}
					}
				} else {
					context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol))
				}
			}
			context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations[0] || saveEnclosingDeclaration
			propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
			context.enclosingDeclaration = saveEnclosingDeclaration
			context.approximateLength += symbolName(propertySymbol).length + 1
			if propertySymbol.flags & SymbolFlagsAccessor {
				writeType := getWriteTypeOfSymbol(propertySymbol)
				if propertyType != writeType && !isErrorType(propertyType) && !isErrorType(writeType) {
					getterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindGetAccessor)
					getterSignature := getSignatureFromDeclaration(getterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(getterSignature, SyntaxKindGetAccessor, context /* TODO(Node ObjectLiteralExpression): { name: propertyName } */, TODO), getterDeclaration))
					setterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindSetAccessor)
					setterSignature := getSignatureFromDeclaration(setterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(setterSignature, SyntaxKindSetAccessor, context /* TODO(Node ObjectLiteralExpression): { name: propertyName } */, TODO), setterDeclaration))
					return
				}
			}
			optionalToken := /* TODO(Node ConditionalExpression): propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			if propertySymbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol) {
				signatures := getSignaturesOfType(filterType(propertyType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !(t.flags & TypeFlagsUndefined)
				}), SignatureKindCall)
				for _, signature := range signatures {
					methodDeclaration := signatureToSignatureDeclarationHelper(signature, SyntaxKindMethodSignature, context /* TODO(Node ObjectLiteralExpression): { name: propertyName, questionToken: optionalToken } */, TODO)
					typeElements.push(preserveCommentsOn(methodDeclaration))
				}
				if signatures.length || !optionalToken {
					return
				}
			}
			var propertyTypeNode TypeNode
			if shouldUsePlaceholderForProperty(propertySymbol, context) {
				propertyTypeNode = createElidedInformationPlaceholder(context)
			} else {
				if propertyIsReverseMapped {
					/* TODO(Node BinaryExpression): context.reverseMappedStack ||= [] */ TODO
					context.reverseMappedStack.push(propertySymbol)
				}
				propertyTypeNode = /* TODO(Node ConditionalExpression): propertyType ? serializeTypeForDeclaration(context, /*declaration* / undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */ TODO
				if propertyIsReverseMapped {
					context.reverseMappedStack.pop()
				}
			}
			modifiers := /* TODO(Node ConditionalExpression): isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO
			if modifiers {
				context.approximateLength += 9
			}
			propertySignature := factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode)
			typeElements.push(preserveCommentsOn(propertySignature))
			preserveCommentsOn := func(node T) /* TODO inferred type T */ any {
				jsdocPropertyTag := propertySymbol.declarations. /*?*/ find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO(TypeNode TypePredicate): d is JSDocPropertyTag */ any {
					return d.kind == SyntaxKindJSDocPropertyTag
				})
				if jsdocPropertyTag {
					commentText := getTextOfJSDocComment(jsdocPropertyTag.comment)
					if commentText {
						setSyntheticLeadingComments(node, [] /* TODO inferred type { kind: import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MultiLineCommentTrivia; text: string; pos: -1; end: -1; hasTrailingNewLine: true; } */ any{ /* TODO(Node ObjectLiteralExpression): { kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true } */ TODO})
					}
				} else if propertySymbol.valueDeclaration {
					setCommentRange(context, node, propertySymbol.valueDeclaration)
				}
				return node
			}
		}
		setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(range_) {
				return setCommentRangeWorker(node, range_)
			}
			return node
		}
		mapToTypeNodes := func(types *[]Type, context NodeBuilderContext, isBareList bool) *[]TypeNode {
			if some(types) {
				if checkTruncationLength(context) {
					if !isBareList {
						return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeReferenceNode */ any{factory.createTypeReferenceNode("...", nil)}
					} else if types.length > 2 {
						return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{typeToTypeNodeHelper(types[0], context), factory.createTypeReferenceNode( /* TODO(Node TemplateExpression): `... ${types.length - 2} more ...` */ TODO, nil), typeToTypeNodeHelper(types[types.length-1], context)}
					}
				}
				mayHaveNameCollisions := !(context.flags & NodeBuilderFlagsUseFullyQualifiedType)
				seenNames := /* TODO(Node ConditionalExpression): mayHaveNameCollisions ? createMultiMap<__String, [Type, number]>() : undefined */ TODO
				var result []TypeNode = [] /* TODO inferred type never */ any{}
				i := 0
				for _, type_ := range types {
					i++
					if checkTruncationLength(context) && (i+2 < types.length-1) {
						result.push(factory.createTypeReferenceNode( /* TODO(Node TemplateExpression): `... ${types.length - i} more ...` */ TODO, nil))
						typeNode := typeToTypeNodeHelper(types[types.length-1], context)
						if typeNode {
							result.push(typeNode)
						}
						break
					}
					context.approximateLength += 2
					typeNode := typeToTypeNodeHelper(type_, context)
					if typeNode {
						result.push(typeNode)
						if seenNames && isIdentifierTypeReference(typeNode) {
							seenNames.add(typeNode.typeName.escapedText, []TODO{type_, result.length - 1})
						}
					}
				}
				if seenNames {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsUseFullyQualifiedType
					seenNames.forEach(func(types /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number][] */ any) {
						if !arrayIsHomogeneous(types, func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number] */ any, TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number] */ any) /* TODO inferred type boolean */ any {
							return typesAreSameReference(a, b)
						}) {
							for _, TODO_IDENTIFIER := range types {
								result[resultIndex] = typeToTypeNodeHelper(type_, context)
							}
						}
					})
					restoreFlags()
				}
				return result
			}
		}
		typesAreSameReference := func(a Type, b Type) bool {
			return a == b || !!a.symbol && a.symbol == b.symbol || !!a.aliasSymbol && a.aliasSymbol == b.aliasSymbol
		}
		indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
			name := getNameFromIndexInfo(indexInfo) || "x"
			indexerTypeNode := typeToTypeNodeHelper(indexInfo.keyType, context)
			indexingParameter := factory.createParameterDeclaration(nil, nil, name, nil, indexerTypeNode, nil)
			if !typeNode {
				typeNode = typeToTypeNodeHelper(indexInfo.type_ || anyType, context)
			}
			if !indexInfo.type_ && !(context.flags & NodeBuilderFlagsAllowEmptyIndexInfoType) {
				context.encounteredError = true
			}
			context.approximateLength += name.length + 4
			return factory.createIndexSignature( /* TODO(Node ConditionalExpression): indexInfo.isReadonly ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any{indexingParameter}, typeNode)
		}
		type SignatureToSignatureDeclarationOptions struct {
			modifiers     []Modifier
			name          PropertyName
			questionToken QuestionToken
		}
		signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(TypeNode IndexedAccessType): SignatureDeclaration["kind"] */ any, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
			var typeParameters *[]TypeParameterDeclaration
			var typeArguments *[]TypeNode
			expandedParams := getExpandedParameters(signature, true)[0]
			cleanup := enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper)
			context.approximateLength += 3
			if context.flags&NodeBuilderFlagsWriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters {
				typeArguments = signature.target.typeParameters.map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
					return typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context)
				})
			} else {
				typeParameters = signature.typeParameters && signature.typeParameters.map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any {
					return typeParameterToDeclaration(parameter, context)
				})
			}
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			parameters := ( /* TODO(Node ConditionalExpression): some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams */ TODO).map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any {
				return symbolToParameterDeclaration(parameter, context, kind == SyntaxKindConstructor)
			})
			thisParameter := /* TODO(Node ConditionalExpression): context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context) */ TODO
			if thisParameter {
				parameters.unshift(thisParameter)
			}
			restoreFlags()
			returnTypeNode := serializeReturnTypeForSignature(context, signature)
			modifiers := options. /*?*/ modifiers
			if (kind == SyntaxKindConstructorType) && signature.flags&SignatureFlagsAbstract {
				flags := modifiersToFlags(modifiers)
				modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlagsAbstract)
			}
			node := /* TODO(Node ConditionalExpression): kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) : kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) : kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) : kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ?? factory.createIdentifier(""), /*questionToken* / undefined, typeParameters, parameters, returnTypeNode, /*body* / undefined) : kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body* / undefined) : kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body* / undefined) : kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body* / undefined) : kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) : kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) : kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) : kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) : kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body* / undefined) : kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) : kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken* / undefined, factory.createBlock([])) : Debug.assertNever(kind) */ TODO
			if typeArguments {
				node.typeArguments = factory.createNodeArray(typeArguments)
			}
			if signature.declaration. /*?*/ kind == SyntaxKindJSDocSignature && signature.declaration.parent.kind == SyntaxKindJSDocOverloadTag {
				comment := getTextOfNode(signature.declaration.parent.parent, true).slice(2, -2).split(regexp.MustParse(`\r\n|\n|\r`)).map_(func(line /* TODO inferred type string */ any) /* TODO inferred type string */ any {
					return line.replace(regexp.MustParse(`^\s+`), " ")
				}).join("\n")
				addSyntheticLeadingComment(node, SyntaxKindMultiLineCommentTrivia, comment, true)
			}
			cleanup()
			return node
		}
		type IntroducesNewScopeNode /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature | MappedTypeNode */ any
		isNewScopeNode := func(node Node) /* TODO(TypeNode TypePredicate): node is IntroducesNewScopeNode */ any {
			return isFunctionLike(node) || isJSDocSignature(node) || isMappedTypeNode(node)
		}
		getTypeParametersInScope := func(node /* TODO(TypeNode UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ any {
			// converted from conditional expression
			switch {
			case isFunctionLike(node) || isJSDocSignature(node):
				return getSignatureFromDeclaration(node).typeParameters
			case isConditionalTypeNode(node):
				return getInferTypeParameters(node)
			default:
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))}
			}
		}
		getParametersInScope := func(node /* TODO(TypeNode UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ any {
			// converted from conditional expression
			switch {
			case isFunctionLike(node) || isJSDocSignature(node):
				return getSignatureFromDeclaration(node).parameters
			default:
				return nil
			}
		}
		enterNewScope := func(context NodeBuilderContext, declaration /* TODO(TypeNode UnionType): IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams *[]Symbol, typeParameters *[]TypeParameter, originalParameters *[]Symbol, mapper TypeMapper) /* TODO inferred type () => void */ any {
			cleanupContext := cloneNodeBuilderContext(context)
			var cleanupParams *func()
			var cleanupTypeParams *func()
			oldEnclosingDecl := context.enclosingDeclaration
			oldMapper := context.mapper
			if mapper {
				context.mapper = mapper
			}
			if context.enclosingDeclaration && declaration {
				cleanupParams = /* TODO(Node ConditionalExpression): !some(expandedParams) ? undefined : pushFakeScope( "params", add => { if (!expandedParams) return; for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) { const param = expandedParams[pIndex]; const originalParam = originalParameters?.[pIndex]; if (originalParameters && originalParam !== param) { // Can't reference parameters that come from an expansion add(param.escapedName, unknownSymbol); // Can't reference the original expanded parameter either if (originalParam) { add(originalParam.escapedName, unknownSymbol); } } else if ( !forEach(param.declarations, d => { if (isParameter(d) && isBindingPattern(d.name)) { bindPattern(d.name); return true; } return undefined; function bindPattern(p: BindingPattern): void { forEach(p.elements, e => { switch (e.kind) { case SyntaxKind.OmittedExpression: return; case SyntaxKind.BindingElement: return bindElement(e); default: return Debug.assertNever(e); } }); } function bindElement(e: BindingElement): void { if (isBindingPattern(e.name)) { return bindPattern(e.name); } const symbol = getSymbolOfDeclaration(e); add(symbol.escapedName, symbol); } }) ) { add(param.escapedName, param); } } }, ) */ TODO
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && some(typeParameters) {
					cleanupTypeParams = pushFakeScope("typeParams", func(add /* TODO inferred type (name: import("/home/jabaile/work/TypeScript/src/compiler/types").__String, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol) => void */ any) {
						for _, typeParam := range /* TODO(Node BinaryExpression): typeParameters ?? emptyArray */ TODO {
							typeParamName := typeParameterToName(typeParam, context).escapedText
							add(typeParamName, typeParam.symbol)
						}
					})
				}
				pushFakeScope := func(kind /* TODO(TypeNode UnionType): "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol))) /* TODO inferred type (() => void) | undefined */ any {
					Debug.assert(context.enclosingDeclaration)
					var existingFakeScope Node
					if getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration
					} else if context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration.parent
					}
					Debug.assertOptionalNode(existingFakeScope, isBlock)
					locals := /* TODO(Node BinaryExpression): existingFakeScope?.locals ?? createSymbolTable() */ TODO
					var newLocals *[]__String
					var oldLocals *[] /* TODO(TypeNode TypeLiteral): { name: __String; oldSymbol: Symbol; } */ any
					addAll(func(name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any, symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
						if existingFakeScope {
							oldSymbol := locals.get(name)
							if !oldSymbol {
								newLocals = append(newLocals, name)
							} else {
								oldLocals = append(oldLocals /* TODO(Node ObjectLiteralExpression): { name, oldSymbol } */, TODO)
							}
						}
						locals.set(name, symbol)
					})
					if !existingFakeScope {
						fakeScope := factory.createBlock(emptyArray)
						getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind
						fakeScope.locals = locals
						setParent(fakeScope, context.enclosingDeclaration)
						context.enclosingDeclaration = fakeScope
					} else {
						return /* TODO(Node FunctionExpression): function undo() { forEach(newLocals, s => locals.delete(s)); forEach(oldLocals, s => locals.set(s.name, s.oldSymbol)); } */ TODO
					}
				}
			}
			return func() {
				cleanupParams()
				cleanupTypeParams()
				cleanupContext()
				context.enclosingDeclaration = oldEnclosingDecl
				context.mapper = oldMapper
			}
		}
		tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ any {
			if signature.thisParameter {
				return symbolToParameterDeclaration(signature.thisParameter, context)
			}
			if signature.declaration && isInJSFile(signature.declaration) {
				thisTag := getJSDocThisTag(signature.declaration)
				if thisTag && thisTag.typeExpression {
					return factory.createParameterDeclaration(nil, nil, "this", nil, typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context))
				}
			}
		}
		typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsWriteTypeParametersInQualifiedName
			modifiers := factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type_))
			name := typeParameterToName(type_, context)
			defaultParameter := getDefaultFromTypeParameter(type_)
			defaultParameterNode := defaultParameter && typeToTypeNodeHelper(defaultParameter, context)
			restoreFlags()
			return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode)
		}
		typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
			return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type_) || typeToTypeNodeHelper(type_, context)
		}
		typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any /*  = getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
			constraintNode := constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type_), context)
			return typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
		}
		typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
			assertsModifier := /* TODO(Node ConditionalExpression): typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? factory.createToken(SyntaxKind.AssertsKeyword) : undefined */ TODO
			parameterName := /* TODO(Node ConditionalExpression): typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ? setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) : factory.createThisTypeNode() */ TODO
			typeNode := typePredicate.type_ && typeToTypeNodeHelper(typePredicate.type_, context)
			return factory.createTypePredicateNode(assertsModifier, parameterName, typeNode)
		}
		getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any {
			var parameterDeclaration /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol, SyntaxKindParameter)
			if parameterDeclaration {
				return parameterDeclaration
			}
			if !isTransientSymbol(parameterSymbol) {
				return getDeclarationOfKind(parameterSymbol, SyntaxKindJSDocParameterTag)
			}
		}
		symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
			parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)
			parameterType := getTypeOfSymbol(parameterSymbol)
			parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)
			modifiers := /* TODO(Node ConditionalExpression): !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined */ TODO
			isRest := parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsRestParameter
			dotDotDotToken := /* TODO(Node ConditionalExpression): isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO
			name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
			isOptional := parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsOptionalParameter
			questionToken := /* TODO(Node ConditionalExpression): isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			parameterNode := factory.createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, nil)
			context.approximateLength += symbolName(parameterSymbol).length + 3
			return parameterNode
		}
		parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO inferred type string | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingName */ any {
			// converted from conditional expression
			switch {
			case parameterDeclaration:
				// converted from conditional expression
				switch {
				case parameterDeclaration.name:
					// converted from conditional expression
					switch {
					case parameterDeclaration.name.kind == SyntaxKindIdentifier:
						return setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlagsNoAsciiEscaping)
					case parameterDeclaration.name.kind == SyntaxKindQualifiedName:
						return setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlagsNoAsciiEscaping)
					default:
						return cloneBindingName(parameterDeclaration.name)
					}
				default:
					return symbolName(parameterSymbol)
				}
			default:
				return symbolName(parameterSymbol)
			}
			cloneBindingName := func(node BindingName) BindingName {
				return elideInitializerAndSetEmitFlags(node)
				elideInitializerAndSetEmitFlags := func(node Node) Node {
					if context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node) {
						trackComputedName(node.expression, context.enclosingDeclaration, context)
					}
					visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags, nil, nil, elideInitializerAndSetEmitFlags)
					if isBindingElement(visited) {
						visited = factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, nil)
					}
					if !nodeIsSynthesized(visited) {
						visited = factory.cloneNode(visited)
					}
					return setEmitFlags(visited, EmitFlagsSingleLine|EmitFlagsNoAsciiEscaping)
				}
			}
		}
		trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
			if !context.tracker.canTrackSymbol {
				return
			}
			firstIdentifier := getFirstIdentifier(accessExpression)
			name := resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsExportValue, nil, true)
			if name {
				context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlagsValue)
			}
		}
		lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
			context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning)
			return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
		}
		lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
			var chain []Symbol
			isTypeParameter := symbol.flags & SymbolFlagsTypeParameter
			if !isTypeParameter && (context.enclosingDeclaration || context.flags&NodeBuilderFlagsUseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlagsDoNotIncludeSymbolChain) {
				chain = Debug.checkDefined(getSymbolChain(symbol, meaning, true))
				Debug.assert(chain && chain.length > 0)
			} else {
				chain = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbol}
			}
			return chain
			getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) *[]Symbol {
				accessibleSymbolChain := getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlagsUseOnlyExternalAliasing))
				var parentSpecifiers []*string
				if !accessibleSymbolChain || needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration /* TODO(Node ConditionalExpression): accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning) */, TODO) {
					parents := getContainersOfSymbol( /* TODO(Node ConditionalExpression): accessibleSymbolChain ? accessibleSymbolChain[0] : symbol */ TODO, context.enclosingDeclaration, meaning)
					if length(parents) {
						parentSpecifiers = parents.map_(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type string | undefined */ any {
							return /* TODO(Node ConditionalExpression): some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) ? getSpecifierForModuleSymbol(symbol, context) : undefined */ TODO
						})
						indices := parents.map_(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, i /* TODO inferred type number */ any) /* TODO inferred type number */ any {
							return i
						})
						indices.sort(sortByBestName)
						sortedParents := indices.map_(func(i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
							return parents[i]
						})
						for _, parent := range sortedParents {
							parentChain := getSymbolChain(parent, getQualifiedLeftMeaning(meaning), false)
							if parentChain {
								if parent.exports && parent.exports.get(InternalSymbolNameExportEquals) && getSymbolIfSameReference(parent.exports.get(InternalSymbolNameExportEquals), symbol) {
									accessibleSymbolChain = parentChain
									break
								}
								accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{getAliasForSymbolInContainer(parent, symbol) || symbol})
								break
							}
						}
					}
				}
				if accessibleSymbolChain {
					return accessibleSymbolChain
				}
				if endOfChain || !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsObjectLiteral)) {
					if !endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
						return
					}
					return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbol}
				}
				sortByBestName := func(a number, b number) /* TODO inferred type number */ any {
					specifierA := parentSpecifiers[a]
					specifierB := parentSpecifiers[b]
					if specifierA && specifierB {
						isBRelative := pathIsRelative(specifierB)
						if pathIsRelative(specifierA) == isBRelative {
							return moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB)
						}
						if isBRelative {
							return -1
						}
						return 1
					}
					return 0
				}
			}
		}
		typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined */ any {
			var typeParameterNodes *NodeArray[TypeParameterDeclaration]
			targetSymbol := getTargetSymbol(symbol)
			if targetSymbol.flags & (SymbolFlagsClass | SymbolFlagsInterface | SymbolFlagsTypeAlias) {
				typeParameterNodes = factory.createNodeArray(map_(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any {
					return typeParameterToDeclaration(tp, context)
				}))
			}
			return typeParameterNodes
		}
		lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode[] | readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] | undefined */ any {
			Debug.assert(chain && 0 <= index && index < chain.length)
			symbol := chain[index]
			symbolId := getSymbolId(symbol)
			if context.typeParameterSymbolList. /*?*/ has(symbolId) {
				return nil
			}
			if context.mustCreateTypeParameterSymbolList {
				context.mustCreateTypeParameterSymbolList = false
				context.typeParameterSymbolList = /* TODO(Node NewExpression): new Set(context.typeParameterSymbolList) */ TODO
			}
			context.typeParameterSymbolList.add(symbolId)
			var typeParameterNodes /* TODO(TypeNode UnionType): readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
			if context.flags&NodeBuilderFlagsWriteTypeParametersInQualifiedName && index < (chain.length-1) {
				parentSymbol := symbol
				nextSymbol := chain[index+1]
				if getCheckFlags(nextSymbol) & CheckFlagsInstantiated {
					params := getTypeParametersOfClassOrInterface( /* TODO(Node ConditionalExpression): parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol */ TODO)
					typeParameterNodes = mapToTypeNodes(map_(params, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return getMappedType(t, (nextSymbol).links.mapper)
					}), context)
				} else {
					typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context)
				}
			}
			return typeParameterNodes
		}
		getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
			if isIndexedAccessTypeNode(top.objectType) {
				return getTopmostIndexedAccessType(top.objectType)
			}
			return top
		}
		getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) /* TODO inferred type string */ any {
			file := getDeclarationOfKind(symbol, SyntaxKindSourceFile)
			if !file {
				equivalentFileSymbol := firstDefined(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
					return getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol)
				})
				if equivalentFileSymbol {
					file = getDeclarationOfKind(equivalentFileSymbol, SyntaxKindSourceFile)
				}
			}
			if file && file.moduleName != nil {
				return file.moduleName
			}
			if !file {
				if ambientModuleSymbolRegex.test(symbol.escapedName) {
					return (symbol.escapedName).substring(1, (symbol.escapedName).length-1)
				}
			}
			if !context.enclosingFile || !context.tracker.moduleResolverHost {
				if ambientModuleSymbolRegex.test(symbol.escapedName) {
					return (symbol.escapedName).substring(1, (symbol.escapedName).length-1)
				}
				return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)).fileName
			}
			enclosingDeclaration := getOriginalNode(context.enclosingDeclaration)
			originalModuleSpecifier := /* TODO(Node ConditionalExpression): canHaveModuleSpecifier(enclosingDeclaration) ? tryGetModuleSpecifierFromDeclaration(enclosingDeclaration) : undefined */ TODO
			contextFile := context.enclosingFile
			resolutionMode := overrideImportMode || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier) || contextFile && host.getDefaultResolutionModeForFile(contextFile)
			cacheKey := createModeAwareCacheKey(contextFile.path, resolutionMode)
			links := getSymbolLinks(symbol)
			specifier := links.specifierCache && links.specifierCache.get(cacheKey)
			if !specifier {
				isBundle := !!compilerOptions.outFile
				TODO_IDENTIFIER := context.tracker
				specifierCompilerOptions := /* TODO(Node ConditionalExpression): isBundle ? { ...compilerOptions, baseUrl: moduleResolverHost.getCommonSourceDirectory() } : compilerOptions */ TODO
				specifier = first(moduleSpecifiers.getModuleSpecifiers(symbol, checker, specifierCompilerOptions, contextFile, moduleResolverHost /* TODO(Node ObjectLiteralExpression): { importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative", importModuleSpecifierEnding: isBundle ? "minimal" : resolutionMode === ModuleKind.ESNext ? "js" : undefined, } */, TODO /* TODO(Node ObjectLiteralExpression): { overrideImportMode } */, TODO))
				/* TODO(Node BinaryExpression): links.specifierCache ??= new Map() */ TODO
				links.specifierCache.set(cacheKey, specifier)
			}
			return specifier
		}
		symbolToEntityNameNode := func(symbol Symbol) EntityName {
			identifier := factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName))
			// converted from conditional expression
			switch {
			case symbol.parent:
				return factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier)
			default:
				return identifier
			}
		}
		symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
			chain := lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope))
			isTypeOf := meaning == SymbolFlagsValue
			if some(chain[0].declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
				nonRootParts := /* TODO(Node ConditionalExpression): chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined */ TODO
				typeParameterNodes := overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context)
				contextFile := getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration))
				targetFile := getSourceFileOfModule(chain[0])
				var specifier *string
				var attributes *ImportAttributes
				if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
					if targetFile. /*?*/ impliedNodeFormat == ModuleKindESNext && targetFile.impliedNodeFormat != contextFile. /*?*/ impliedNodeFormat {
						specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKindESNext)
						attributes = factory.createImportAttributes(factory.createNodeArray([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportAttribute */ any{factory.createImportAttribute(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral("import"))}))
					}
				}
				if !specifier {
					specifier = getSpecifierForModuleSymbol(chain[0], context)
				}
				if !(context.flags & NodeBuilderFlagsAllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(compilerOptions) != ModuleResolutionKindClassic && specifier.includes("/node_modules/") {
					oldSpecifier := specifier
					if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
						swappedMode := /* TODO(Node ConditionalExpression): contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext */ TODO
						specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode)
						if specifier.includes("/node_modules/") {
							specifier = oldSpecifier
						} else {
							attributes = factory.createImportAttributes(factory.createNodeArray([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportAttribute */ any{factory.createImportAttribute(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral( /* TODO(Node ConditionalExpression): swappedMode === ModuleKind.ESNext ? "import" : "require" */ TODO))}))
						}
					}
					if !attributes {
						context.encounteredError = true
						if context.tracker.reportLikelyUnsafeImportRequiredError {
							context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier)
						}
					}
				}
				lit := factory.createLiteralTypeNode(factory.createStringLiteral(specifier))
				context.approximateLength += specifier.length + 10
				if !nonRootParts || isEntityName(nonRootParts) {
					if nonRootParts {
						lastId := /* TODO(Node ConditionalExpression): isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right */ TODO
						setIdentifierTypeArguments(lastId, nil)
					}
					return factory.createImportTypeNode(lit, attributes, nonRootParts, typeParameterNodes, isTypeOf)
				} else {
					splitNode := getTopmostIndexedAccessType(nonRootParts)
					qualifier := (splitNode.objectType).typeName
					return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes, isTypeOf), splitNode.indexType)
				}
			}
			entityName := createAccessFromSymbolChain(chain, chain.length-1, 0)
			if isIndexedAccessTypeNode(entityName) {
				return entityName
			}
			if isTypeOf {
				return factory.createTypeQueryNode(entityName)
			} else {
				lastId := /* TODO(Node ConditionalExpression): isIdentifier(entityName) ? entityName : entityName.right */ TODO
				lastTypeArgs := getIdentifierTypeArguments(lastId)
				setIdentifierTypeArguments(lastId, nil)
				return factory.createTypeReferenceNode(entityName, lastTypeArgs)
			}
			createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(TypeNode UnionType): EntityName | IndexedAccessTypeNode */ any {
				typeParameterNodes := /* TODO(Node ConditionalExpression): index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context) */ TODO
				symbol := chain[index]
				parent := chain[index-1]
				var symbolName *string
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
					symbolName = getNameOfSymbolAsWritten(symbol, context)
					context.approximateLength += ( /* TODO(Node ConditionalExpression): symbolName ? symbolName.length : 0 */ TODO) + 1
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				} else {
					if parent && getExportsOfSymbol(parent) {
						exports := getExportsOfSymbol(parent)
						forEachEntry(exports, func(ex /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) /* TODO inferred type true | undefined */ any {
							if getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && name != InternalSymbolNameExportEquals {
								symbolName = unescapeLeadingUnderscores(name)
								return true
							}
						})
					}
				}
				if symbolName == nil {
					name := firstDefined(symbol.declarations, getNameOfDeclaration)
					if name && isComputedPropertyName(name) && isEntityName(name.expression) {
						LHS := createAccessFromSymbolChain(chain, index-1, stopper)
						if isEntityName(LHS) {
							return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression))
						}
						return LHS
					}
					symbolName = getNameOfSymbolAsWritten(symbol, context)
				}
				context.approximateLength += symbolName.length + 1
				if !(context.flags & NodeBuilderFlagsForbidIndexedAccessSymbolReferences) && parent && getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) && getSymbolIfSameReference(getMembersOfSymbol(parent).get(symbol.escapedName), symbol) {
					LHS := createAccessFromSymbolChain(chain, index-1, stopper)
					if isIndexedAccessTypeNode(LHS) {
						return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					} else {
						return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					}
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol
				if index > stopper {
					LHS := createAccessFromSymbolChain(chain, index-1, stopper)
					if !isEntityName(LHS) {
						return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable")
					}
					return factory.createQualifiedName(LHS, identifier)
				}
				return identifier
			}
		}
		typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) /* TODO inferred type boolean */ any {
			result := resolveName(context.enclosingDeclaration, escapedName, SymbolFlagsType, nil, false)
			if result && result.flags&SymbolFlagsTypeParameter {
				return result != type_.symbol
			}
			return false
		}
		typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier */ any {
			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && context.typeParameterNames {
				cached := context.typeParameterNames.get(getTypeId(type_))
				if cached {
					return cached
				}
			}
			result := symbolToName(type_.symbol, context, SymbolFlagsType, true)
			if !(result.kind & SyntaxKindIdentifier) {
				return factory.createIdentifier("(Missing type parameter)")
			}
			decl := type_.symbol. /*?*/ declarations[0]
			if decl && isTypeParameterDeclaration(decl) {
				result = setTextRange(context, result, decl.name)
			}
			if context.flags & NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
				rawtext := result.escapedText
				i := context.typeParameterNamesByTextNextNameCount. /*?*/ get(rawtext) || 0
				text := rawtext
				for context.typeParameterNamesByText. /*?*/ has(text) || typeParameterShadowsOtherTypeParameterInScope(text, context, type_) {
					i++
					text = /* TODO(Node TemplateExpression): `${rawtext}_${i}` */ TODO
				}
				if text != rawtext {
					typeArguments := getIdentifierTypeArguments(result)
					result = factory.createIdentifier(text)
					setIdentifierTypeArguments(result, typeArguments)
				}
				if context.mustCreateTypeParametersNamesLookups {
					context.mustCreateTypeParametersNamesLookups = false
					context.typeParameterNames = /* TODO(Node NewExpression): new Map(context.typeParameterNames) */ TODO
					context.typeParameterNamesByTextNextNameCount = /* TODO(Node NewExpression): new Map(context.typeParameterNamesByTextNextNameCount) */ TODO
					context.typeParameterNamesByText = /* TODO(Node NewExpression): new Set(context.typeParameterNamesByText) */ TODO
				}
				context.typeParameterNamesByTextNextNameCount.set(rawtext, i)
				context.typeParameterNames.set(getTypeId(type_), result)
				context.typeParameterNamesByText.add(text)
			}
			return result
		}
		/* OVERLOAD: function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: true): Identifier; */
		/* OVERLOAD: function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: false): EntityName; */
		symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
			chain := lookupSymbolChain(symbol, context, meaning)
			if expectsIdentifier && chain.length != 1 && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowQualifiedNameInPlaceOfIdentifier) {
				context.encounteredError = true
			}
			return createEntityNameFromSymbolChain(chain, chain.length-1)
			createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := chain[index]
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol
				// converted from conditional expression
				switch {
				case index > 0:
					return factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index-1), identifier)
				default:
					return identifier
				}
			}
		}
		symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ any {
			chain := lookupSymbolChain(symbol, context, meaning)
			return createExpressionFromSymbolChain(chain, chain.length-1)
			createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := chain[index]
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				firstChar := symbolName.charCodeAt(0)
				if isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context))
				}
				if index == 0 || canUsePropertyAccess(symbolName, languageVersion) {
					identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
					if typeParameterNodes {
						setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
					}
					identifier.symbol = symbol
					// converted from conditional expression
					switch {
					case index > 0:
						return factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index-1), identifier)
					default:
						return identifier
					}
				} else {
					if firstChar == CharacterCodesopenBracket {
						symbolName = symbolName.substring(1, symbolName.length-1)
						firstChar = symbolName.charCodeAt(0)
					}
					var expression *Expression
					if isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlagsEnumMember) {
						expression = factory.createStringLiteral(stripQuotes(symbolName).replace( /* TODO(Node RegularExpressionLiteral): /\\./g */ TODO, func(s /* TODO inferred type string */ any) /* TODO inferred type string */ any {
							return s.substring(1)
						}), firstChar == CharacterCodessingleQuote)
					} else if ("" + +symbolName) == symbolName {
						expression = factory.createNumericLiteral(+symbolName)
					}
					if !expression {
						identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
						if typeParameterNodes {
							setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
						}
						identifier.symbol = symbol
						expression = identifier
					}
					return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain, index-1), expression)
				}
			}
		}
		isStringNamed := func(d Declaration) /* TODO inferred type boolean */ any {
			name := getNameOfDeclaration(d)
			if !name {
				return false
			}
			if isComputedPropertyName(name) {
				type_ := checkExpression(name.expression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			if isElementAccessExpression(name) {
				type_ := checkExpression(name.argumentExpression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			return isStringLiteral(name)
		}
		isSingleQuotedStringNamed := func(d Declaration) /* TODO inferred type boolean */ any {
			name := getNameOfDeclaration(d)
			return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, false), "'")))
		}
		getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ any {
			stringNamed := !!length(symbol.declarations) && every(symbol.declarations, isStringNamed)
			singleQuote := !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed)
			isMethod := !!(symbol.flags & SymbolFlagsMethod)
			fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
			if fromNameType {
				return fromNameType
			}
			rawName := unescapeLeadingUnderscores(symbol.escapedName)
			return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
		}
		getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined */ any {
			nameType := getSymbolLinks(symbol).nameType
			if nameType {
				if nameType.flags & TypeFlagsStringOrNumberLiteral {
					name := "" + (nameType).value
					if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name)) {
						return factory.createStringLiteral(name, !!singleQuote)
					}
					if isNumericLiteralName(name) && startsWith(name, "-") {
						return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-name)))
					}
					return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
				}
				if nameType.flags & TypeFlagsUniqueESSymbol {
					return factory.createComputedPropertyName(symbolToExpression((nameType).symbol, context, SymbolFlagsValue))
				}
			}
		}
		cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO inferred type () => void */ any {
			oldMustCreateTypeParameterSymbolList := context.mustCreateTypeParameterSymbolList
			oldMustCreateTypeParametersNamesLookups := context.mustCreateTypeParametersNamesLookups
			context.mustCreateTypeParameterSymbolList = true
			context.mustCreateTypeParametersNamesLookups = true
			oldTypeParameterNames := context.typeParameterNames
			oldTypeParameterNamesByText := context.typeParameterNamesByText
			oldTypeParameterNamesByTextNextNameCount := context.typeParameterNamesByTextNextNameCount
			oldTypeParameterSymbolList := context.typeParameterSymbolList
			return func() {
				context.typeParameterNames = oldTypeParameterNames
				context.typeParameterNamesByText = oldTypeParameterNamesByText
				context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount
				context.typeParameterSymbolList = oldTypeParameterSymbolList
				context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList
				context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups
			}
		}
		getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ any {
			return symbol.declarations && find(symbol.declarations, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
				return !!getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
					return n == enclosingDeclaration
				}))
			})
		}
		existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) /* TODO inferred type boolean */ any {
			if !(getObjectFlags(type_) & ObjectFlagsReference) {
				return true
			}
			if !isTypeReferenceNode(existing) {
				return true
			}
			getTypeFromTypeReference(existing)
			symbol := getNodeLinks(existing).resolvedSymbol
			existingTarget := symbol && getDeclaredTypeOfSymbol(symbol)
			if !existingTarget || existingTarget != (type_).target {
				return true
			}
			return length(existing.typeArguments) >= getMinTypeArgumentCount((type_).target.typeParameters)
		}
		getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any {
			for getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration {
				enclosingDeclaration = enclosingDeclaration.parent
			}
			return enclosingDeclaration
		}
		serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
			addUndefinedForParameter := declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration)
			enclosingDeclaration := context.enclosingDeclaration
			restoreFlags := saveRestoreFlags(context)
			if declaration && hasInferredType(declaration) && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			if enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) {
				declWithExistingAnnotation := /* TODO(Node ConditionalExpression): declaration && getNonlocalEffectiveTypeAnnotationNode(declaration) ? declaration : getDeclarationWithTypeAnnotation(symbol) */ TODO
				if declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) {
					existing := getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)
					addUndefined := addUndefinedForParameter || !!(symbol.flags&SymbolFlagsProperty && symbol.flags&SymbolFlagsOptional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol).links. /*?*/ mappedType && containsNonMissingUndefinedType(type_))
					result := !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type_, declWithExistingAnnotation, addUndefined)
					if result {
						restoreFlags()
						return result
					}
				}
			}
			if type_.flags&TypeFlagsUniqueESSymbol && type_.symbol == symbol && (!context.enclosingDeclaration || some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
				return getSourceFileOfNode(d) == getSourceFileOfNode(context.enclosingDeclaration)
			})) {
				context.flags |= NodeBuilderFlagsAllowUniqueESSymbolType
			}
			decl := /* TODO(Node BinaryExpression): declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
			expr := /* TODO(Node ConditionalExpression): decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl) ? getPossibleTypeNodeReuseExpression(decl) : undefined */ TODO
			result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
			restoreFlags()
			return result
		}
		typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) /* TODO inferred type boolean */ any {
			if typeFromTypeNode == type_ {
				return true
			}
			if annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken {
				return getTypeWithFacts(type_, TypeFactsNEUndefined) == typeFromTypeNode
			}
			return false
		}
		serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
			suppressAny := context.flags & NodeBuilderFlagsSuppressAnyReturnType
			restoreFlags := saveRestoreFlags(context)
			if suppressAny {
				context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			}
			var returnTypeNode *TypeNode
			returnType := getReturnTypeOfSignature(signature)
			if returnType && !(suppressAny && isTypeAny(returnType)) {
				if signature.declaration && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
					syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context)
				}
				context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
				returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature)
			} else if !suppressAny {
				returnTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			restoreFlags()
			return returnTypeNode
		}
		serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
			typePredicate := getTypePredicateOfSignature(signature)
			type_ := getReturnTypeOfSignature(signature)
			if context.enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration) {
				annotation := getNonlocalEffectiveReturnTypeAnnotationNode(signature.declaration)
				if annotation {
					result := tryReuseExistingTypeNode(context, annotation, type_, context.enclosingDeclaration)
					if result {
						return result
					}
				}
			}
			if typePredicate {
				return typePredicateToTypePredicateNodeHelper(typePredicate, context)
			}
			expr := signature.declaration && getPossibleTypeNodeReuseExpression(signature.declaration)
			return expressionOrTypeToTypeNode(context, expr, type_)
		}
		trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO inferred type { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined; } */ any {
			introducesError := false
			leftmost := getFirstIdentifier(node)
			if isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) {
				introducesError = true
				return /* TODO(Node ObjectLiteralExpression): { introducesError, node } */ TODO
			}
			meaning := getMeaningOfEntityNameReference(node)
			var sym *Symbol
			if isThisIdentifier(leftmost) {
				sym = getSymbolOfDeclaration(getThisContainer(leftmost, false, false))
				if isSymbolAccessible(sym, leftmost, meaning, false).accessibility != SymbolAccessibilityAccessible {
					introducesError = true
					context.tracker.reportInaccessibleThisError()
				}
				return /* TODO(Node ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			sym = resolveEntityName(leftmost, meaning, true, true)
			if context.enclosingDeclaration && !(sym && sym.flags&SymbolFlagsTypeParameter) {
				sym = getExportSymbolOfValueSymbolIfExported(sym)
				symAtLocation := resolveEntityName(leftmost, meaning, true, true, context.enclosingDeclaration)
				if symAtLocation == unknownSymbol || (symAtLocation == nil && sym != nil) || (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) {
					if symAtLocation != unknownSymbol {
						context.tracker.reportInferenceFallback(node)
					}
					introducesError = true
					return /* TODO(Node ObjectLiteralExpression): { introducesError, node, sym } */ TODO
				} else {
					sym = symAtLocation
				}
			}
			if sym {
				if sym.flags&SymbolFlagsFunctionScopedVariable && sym.valueDeclaration {
					if isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration) {
						return /* TODO(Node ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
					}
				}
				if !(sym.flags & SymbolFlagsTypeParameter) && !isDeclarationName(node) && isSymbolAccessible(sym, context.enclosingDeclaration, meaning, false).accessibility != SymbolAccessibilityAccessible {
					context.tracker.reportInferenceFallback(node)
					introducesError = true
				} else {
					context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning)
				}
				return /* TODO(Node ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			return /* TODO(Node ObjectLiteralExpression): { introducesError, node } */ TODO
			attachSymbolToLeftmostIdentifier := func(node Node) Node {
				if node == leftmost {
					type_ := getDeclaredTypeOfSymbol(sym)
					name := /* TODO(Node ConditionalExpression): sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier) */ TODO
					name.symbol = sym
					return setTextRange(context, setEmitFlags(name, EmitFlagsNoAsciiEscaping), node)
				}
				updated := visitEachChildWorker(node, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any {
					return attachSymbolToLeftmostIdentifier(c)
				}, nil)
				if updated != node {
					setTextRange(context, updated, node)
				}
				return updated
			}
		}
		serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
			meaning := /* TODO(Node ConditionalExpression): isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
			symbol := resolveEntityName(node, meaning, true)
			if !symbol {
				return nil
			}
			resolvedSymbol := /* TODO(Node ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO
			if isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, false).accessibility != SymbolAccessibilityAccessible {
				return nil
			}
			return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
		}
		canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO inferred type number | boolean */ any {
			if isInJSFile(existing) {
				if isLiteralImportTypeNode(existing) {
					getTypeFromImportTypeNode(existing)
					nodeSymbol := getNodeLinks(existing).resolvedSymbol
					return (!nodeSymbol || !((!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))))
				}
			}
			if isThisTypeNode(existing) {
				if context.mapper == nil {
					return true
				}
				type_ := getTypeFromTypeNode(context, existing, true)
				return !!type_
			}
			if isTypeReferenceNode(existing) {
				if isConstTypeReference(existing) {
					return false
				}
				type_ := getTypeFromTypeReference(existing)
				symbol := getNodeLinks(existing).resolvedSymbol
				if !symbol {
					return false
				}
				if symbol.flags & SymbolFlagsTypeParameter {
					type_ := getDeclaredTypeOfSymbol(symbol)
					if context.mapper && getMappedType(type_, context.mapper) != type_ {
						return false
					}
				}
				if isInJSDoc(existing) {
					return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) && !getIntendedTypeFromJSDocTypeReference(existing) && (symbol.flags & SymbolFlagsType)
				}
			}
			if isTypeOperatorNode(existing) && existing.operator == SyntaxKindUniqueKeyword && existing.type_.kind == SyntaxKindSymbolKeyword {
				effectiveEnclosingContext := context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration)
				return !!findAncestor(existing, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
					return n == effectiveEnclosingContext
				})
			}
			return true
		}
		serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
			type_ := getTypeFromTypeNode(context, typeNode)
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			hadError := false
			TODO_IDENTIFIER := createRecoveryBoundary()
			transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
			if !finalizeBoundary() {
				return nil
			}
			context.approximateLength += existing.end - existing.pos
			return transformed
			visitExistingNodeTreeSymbols := func(node Node) Node {
				if hadError {
					return node
				}
				recover := startRecoveryScope()
				onExitNewScope := /* TODO(Node ConditionalExpression): isNewScopeNode(node) ? onEnterNewScope(node) : undefined */ TODO
				result := visitExistingNodeTreeSymbolsWorker(node)
				onExitNewScope()
				if hadError {
					if isTypeNode(node) && !isTypePredicateNode(node) {
						recover()
						return serializeExistingTypeNode(context, node)
					}
					return node
				}
				// converted from conditional expression
				switch {
				case result:
					return setTextRange(context, result, node)
				default:
					return nil
				}
			}
			createRecoveryBoundary := func() /* TODO inferred type { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ any {
				var trackedSymbols []TrackedSymbol
				var unreportedErrors []func()
				oldTracker := context.tracker
				oldTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				oldEncounteredError := context.encounteredError
				context.tracker = /* TODO(Node NewExpression): new SymbolTrackerImpl(context, { ...oldTracker.inner, reportCyclicStructureError() { markError(() => oldTracker.reportCyclicStructureError()); }, reportInaccessibleThisError() { markError(() => oldTracker.reportInaccessibleThisError()); }, reportInaccessibleUniqueSymbolError() { markError(() => oldTracker.reportInaccessibleUniqueSymbolError()); }, reportLikelyUnsafeImportRequiredError(specifier) { markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier)); }, reportNonSerializableProperty(name) { markError(() => oldTracker.reportNonSerializableProperty(name)); }, trackSymbol(sym, decl, meaning) { (trackedSymbols ??= []).push([sym, decl, meaning]); return false; }, moduleResolverHost: context.tracker.moduleResolverHost, }, context.tracker.moduleResolverHost) */ TODO
				return /* TODO(Node ObjectLiteralExpression): { startRecoveryScope, finalizeBoundary, } */ TODO
				markError := func(unreportedError func()) {
					hadError = true
					( /* TODO(Node BinaryExpression): unreportedErrors ??= [] */ TODO).push(unreportedError)
				}
				startRecoveryScope := func() /* TODO inferred type () => void */ any {
					trackedSymbolsTop := /* TODO(Node BinaryExpression): trackedSymbols?.length ?? 0 */ TODO
					unreportedErrorsTop := /* TODO(Node BinaryExpression): unreportedErrors?.length ?? 0 */ TODO
					return func() {
						hadError = false
						if trackedSymbols {
							trackedSymbols.length = trackedSymbolsTop
						}
						if unreportedErrors {
							unreportedErrors.length = unreportedErrorsTop
						}
					}
				}
				finalizeBoundary := func() /* TODO inferred type boolean */ any {
					context.tracker = oldTracker
					context.trackedSymbols = oldTrackedSymbols
					context.encounteredError = oldEncounteredError
					unreportedErrors. /*?*/ forEach(func(fn /* TODO inferred type () => void */ any) {
						return fn()
					})
					if hadError {
						return false
					}
					trackedSymbols. /*?*/ forEach(func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TrackedSymbol */ any) /* TODO inferred type boolean */ any {
						return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
					})
					return true
				}
			}
			onEnterNewScope := func(node /* TODO(TypeNode UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO inferred type () => void */ any {
				return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
			}
			tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
				innerNode := skipTypeParentheses(node)
				switch innerNode.kind {
				case SyntaxKindTypeReference:
					return tryVisitTypeReference(innerNode)
				case SyntaxKindTypeQuery:
					return tryVisitTypeQuery(innerNode)
				case SyntaxKindIndexedAccessType:
					return tryVisitIndexedAccess(innerNode)
				case SyntaxKindTypeOperator:
					typeOperatorNode := innerNode
					if typeOperatorNode.operator == SyntaxKindKeyOfKeyword {
						return tryVisitKeyOf(typeOperatorNode)
					}
				}
				return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
			}
			tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
				resultObjectType := tryVisitSimpleTypeNode(node.objectType)
				if resultObjectType == nil {
					return nil
				}
				return factory.updateIndexedAccessTypeNode(node, resultObjectType, visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode))
			}
			tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
				Debug.assertEqual(node.operator, SyntaxKindKeyOfKeyword)
				type_ := tryVisitSimpleTypeNode(node.type_)
				if type_ == nil {
					return nil
				}
				return factory.updateTypeOperatorNode(node, type_)
			}
			tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
				TODO_IDENTIFIER := trackExistingEntityName(node.exprName, context)
				if !introducesError {
					return factory.updateTypeQueryNode(node, exprName, visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode))
				}
				serializedName := serializeTypeName(context, node.exprName, true)
				if serializedName {
					return setTextRange(context, serializedName, node.exprName)
				}
			}
			tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
				if canReuseTypeNode(context, node) {
					TODO_IDENTIFIER := trackExistingEntityName(node.typeName, context)
					typeArguments := visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode)
					if !introducesError {
						updated := factory.updateTypeReferenceNode(node, newName, typeArguments)
						return setTextRange(context, updated, node)
					} else {
						serializedName := serializeTypeName(context, node.typeName, false, typeArguments)
						if serializedName {
							return setTextRange(context, serializedName, node.typeName)
						}
					}
				}
			}
			visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
				if isJSDocTypeExpression(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode)
				}
				if isJSDocAllType(node) || node.kind == SyntaxKindJSDocNamepathType {
					return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
				}
				if isJSDocUnknownType(node) {
					return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
				}
				if isJSDocNullableType(node) {
					return factory.createUnionTypeNode([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode), factory.createLiteralTypeNode(factory.createNull())})
				}
				if isJSDocOptionalType(node) {
					return factory.createUnionTypeNode([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode), factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
				}
				if isJSDocNonNullableType(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols)
				}
				if isJSDocVariadicType(node) {
					return factory.createArrayTypeNode(visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isJSDocTypeLiteral(node) {
					return factory.createTypeLiteralNode(map_(node.jsDocPropertyTags, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocPropertyLikeTag */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ any {
						name := visitNode( /* TODO(Node ConditionalExpression): isIdentifier(t.name) ? t.name : t.name.right */ TODO, visitExistingNodeTreeSymbols, isIdentifier)
						typeViaParent := getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText)
						overrideTypeNode := /* TODO(Node ConditionalExpression): typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined */ TODO
						return factory.createPropertySignature(nil, name /* TODO(Node ConditionalExpression): t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(SyntaxKind.QuestionToken) : undefined */, TODO, overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type_, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}))
				}
				if isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "" {
					return setOriginalNode(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), node)
				}
				if (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node) {
					return factory.createTypeLiteralNode([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration */ any{factory.createIndexSignature(nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any{factory.createParameterDeclaration(nil, nil, "x", nil, visitNode(node.typeArguments[0], visitExistingNodeTreeSymbols, isTypeNode))}, visitNode(node.typeArguments[1], visitExistingNodeTreeSymbols, isTypeNode))})
				}
				if isJSDocFunctionType(node) {
					if isJSDocConstructSignature(node) {
						var newTypeNode *TypeNode
						return factory.createConstructorTypeNode(nil, visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ any {
							return /* TODO(Node ConditionalExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode = p.type, undefined) : factory.createParameterDeclaration( /*modifiers* / undefined, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode), /*initializer* / undefined, ) */ TODO
						}), visitNode(newTypeNode || node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					} else {
						return factory.createFunctionTypeNode(visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any {
							return factory.createParameterDeclaration(nil, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type_, visitExistingNodeTreeSymbols, isTypeNode), nil)
						}), visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}
				}
				if isThisTypeNode(node) {
					if canReuseTypeNode(context, node) {
						return node
					}
					hadError = true
					return node
				}
				if isTypeParameterDeclaration(node) {
					return factory.updateTypeParameterDeclaration(node, visitNodes(node.modifiers, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node), visitNode(node.constraint, visitExistingNodeTreeSymbols, isTypeNode), visitNode(node.default_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isIndexedAccessTypeNode(node) {
					result := tryVisitIndexedAccess(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isTypeReferenceNode(node) {
					result := tryVisitTypeReference(node)
					if result {
						return result
					}
					hadError = true
					return node
				}
				if isLiteralImportTypeNode(node) {
					nodeSymbol := getNodeLinks(node).resolvedSymbol
					if isInJSDoc(node) && nodeSymbol && ((!node.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))) {
						return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
					}
					return factory.updateImportTypeNode(node, factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), visitNode(node.attributes, visitExistingNodeTreeSymbols, isImportAttributes), visitNode(node.qualifier, visitExistingNodeTreeSymbols, isEntityName), visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode), node.isTypeOf)
				}
				if isNamedDeclaration(node) && node.name.kind == SyntaxKindComputedPropertyName && !isLateBindableName(node.name) {
					if !hasDynamicName(node) {
						return visitEachChild(node, visitExistingNodeTreeSymbols)
					}
					if !(context.internalFlags&InternalNodeBuilderFlagsAllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags&TypeFlagsAny) {
						return nil
					}
				}
				if (isFunctionLike(node) && !node.type_) || (isPropertyDeclaration(node) && !node.type_ && !node.initializer) || (isPropertySignature(node) && !node.type_ && !node.initializer) || (isParameter(node) && !node.type_ && !node.initializer) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					if visited == node {
						visited = setTextRange(context, factory.cloneNode(node), node)
					}
					(visited).type_ = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
					if isParameter(node) {
						(visited).modifiers = nil
					}
					return visited
				}
				if isTypeQueryNode(node) {
					result := tryVisitTypeQuery(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isComputedPropertyName(node) && isEntityNameExpression(node.expression) {
					TODO_IDENTIFIER := trackExistingEntityName(node.expression, context)
					if !introducesError {
						return factory.updateComputedPropertyName(node, result)
					} else {
						type_ := getWidenedType(getRegularTypeOfExpression(node.expression))
						computedPropertyNameType := typeToTypeNodeHelper(type_, context)
						var literal TODO
						if isLiteralTypeNode(computedPropertyNameType) {
							literal = computedPropertyNameType.literal
						} else {
							evaluated := evaluateEntityNameExpression(node.expression)
							literalNode := /* TODO(Node ConditionalExpression): typeof evaluated.value === "string" ? factory.createStringLiteral(evaluated.value, /*isSingleQuote* / undefined) : typeof evaluated.value === "number" ? factory.createNumericLiteral(evaluated.value, /*numericLiteralFlags* / 0) : undefined */ TODO
							if !literalNode {
								if isImportTypeNode(computedPropertyNameType) {
									trackComputedName(node.expression, context.enclosingDeclaration, context)
								}
								return node
							}
							literal = literalNode
						}
						if literal.kind == SyntaxKindStringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(compilerOptions)) {
							return factory.createIdentifier(literal.text)
						}
						if literal.kind == SyntaxKindNumericLiteral && !literal.text.startsWith("-") {
							return literal
						}
						return factory.updateComputedPropertyName(node, literal)
					}
				}
				if isTypePredicateNode(node) {
					var parameterName TODO
					if isIdentifier(node.parameterName) {
						TODO_IDENTIFIER := trackExistingEntityName(node.parameterName, context)
						hadError = hadError || introducesError
						parameterName = result
					} else {
						parameterName = factory.cloneNode(node.parameterName)
					}
					return factory.updateTypePredicateNode(node, factory.cloneNode(node.assertsModifier), parameterName, visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					clone := setTextRange(context /* TODO(Node ConditionalExpression): visited === node ? factory.cloneNode(node) : visited */, TODO, node)
					flags := getEmitFlags(clone)
					setEmitFlags(clone, flags|( /* TODO(Node ConditionalExpression): context.flags & NodeBuilderFlags.MultilineObjectLiterals && isTypeLiteralNode(node) ? 0 : EmitFlags.SingleLine */ TODO))
					return clone
				}
				if isStringLiteral(node) && !!(context.flags & NodeBuilderFlagsUseSingleQuotesForStringLiteralType) && !node.singleQuote {
					clone := factory.cloneNode(node)
					(clone).singleQuote = true
					return clone
				}
				if isConditionalTypeNode(node) {
					checkType := visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)
					disposeScope := onEnterNewScope(node)
					extendType := visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)
					trueType := visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)
					disposeScope()
					falseType := visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)
					return factory.updateConditionalTypeNode(node, checkType, extendType, trueType, falseType)
				}
				if isTypeOperatorNode(node) {
					if node.operator == SyntaxKindUniqueKeyword && node.type_.kind == SyntaxKindSymbolKeyword {
						if !canReuseTypeNode(context, node) {
							hadError = true
							return node
						}
					} else if node.operator == SyntaxKindKeyOfKeyword {
						result := tryVisitKeyOf(node)
						if !result {
							hadError = true
							return node
						}
						return result
					}
				}
				return visitEachChild(node, visitExistingNodeTreeSymbols)
				/* OVERLOAD: function visitEachChild<T extends Node>(node: T, visitor: Visitor): T; */
				/* OVERLOAD: function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor): T | undefined; */
				visitEachChild := func(node *T, visitor Visitor) *T {
					nonlocalNode := !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(node)
					return visitEachChildWorker(node, visitor, nil /* TODO(Node ConditionalExpression): nonlocalNode ? visitNodesWithoutCopyingPositions : undefined */, TODO)
				}
				visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					result := visitNodes(nodes, visitor, test, start, count)
					if result {
						if result.pos != -1 || result.end != -1 {
							if result == nodes {
								result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma)
							}
							setTextRangePosEnd(result, -1, -1)
						}
					}
					return result
				}
				getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DotDotDotToken | undefined */ any {
					return p.dotDotDotToken || ( /* TODO(Node ConditionalExpression): p.type && isJSDocVariadicType(p.type) ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO)
				}
				getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) /* TODO inferred type string */ any {
					// converted from conditional expression
					switch {
					case p.name && isIdentifier(p.name) && p.name.escapedText == "this":
						return "this"
					case getEffectiveDotDotDotForParameter(p):
						return `args`
					default:
						return /* TODO(Node TemplateExpression): `arg${index}` */ TODO
					}
				}
				rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral */ any {
					if context.bundled || context.enclosingFile != getSourceFileOfNode(lit) {
						name := lit.text
						nodeSymbol := getNodeLinks(node).resolvedSymbol
						meaning := /* TODO(Node ConditionalExpression): parent.isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
						parentSymbol := nodeSymbol && isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning, false).accessibility == SymbolAccessibilityAccessible && lookupSymbolChain(nodeSymbol, context, meaning, true)[0]
						if parentSymbol && isExternalModuleSymbol(parentSymbol) {
							name = getSpecifierForModuleSymbol(parentSymbol, context)
						} else {
							targetFile := getExternalModuleFileFromDeclaration(parent)
							if targetFile {
								name = getSpecifierForModuleSymbol(targetFile.symbol, context)
							}
						}
						if name.includes("/node_modules/") {
							context.encounteredError = true
							if context.tracker.reportLikelyUnsafeImportRequiredError {
								context.tracker.reportLikelyUnsafeImportRequiredError(name)
							}
						}
						if name != lit.text {
							return setOriginalNode(factory.createStringLiteral(name), lit)
						}
					}
					return visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)
				}
			}
		}
		symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
			serializePropertySymbolForClass := makeSerializePropertySymbol(factory.createPropertyDeclaration, SyntaxKindMethodDeclaration, true)
			serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol(func(mods /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Modifier[] | undefined */ any, name /* TODO inferred type string | import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyName */ any, question /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ any, type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ any {
				return factory.createPropertySignature(mods, name, question, type_)
			}, SyntaxKindMethodSignature, false)
			enclosingDeclaration := context.enclosingDeclaration
			var results []Statement = [] /* TODO inferred type never */ any{}
			visitedSymbols := make(map[number]struct{})
			var deferredPrivatesStack []Map[SymbolId, Symbol] = [] /* TODO inferred type never */ any{}
			oldcontext := context
			context = /* TODO(Node ObjectLiteralExpression): { ...oldcontext, usedSymbolNames: new Set(oldcontext.usedSymbolNames), remappedSymbolNames: new Map(), remappedSymbolReferences: new Map(oldcontext.remappedSymbolReferences?.entries()), tracker: undefined!, } */ TODO
			var tracker SymbolTracker = /* TODO(Node ObjectLiteralExpression): { ...oldcontext.tracker.inner, trackSymbol: (sym, decl, meaning) => { if (context.remappedSymbolNames?.has(getSymbolId(sym))) return false; // If the context has a remapped name for the symbol, it *should* mean it's been made visible const accessibleResult = isSymbolAccessible(sym, decl, meaning, /*shouldComputeAliasesToMakeVisible* / false); if (accessibleResult.accessibility === SymbolAccessibility.Accessible) { // Lookup the root symbol of the chain of refs we'll use to access it and serialize it const chain = lookupSymbolChainWorker(sym, context, meaning); if (!(sym.flags & SymbolFlags.Property)) { // Only include referenced privates in the same file. Weird JS aliases may expose privates // from other files - assume JS transforms will make those available via expected means const root = chain[0]; const contextFile = getSourceFileOfNode(oldcontext.enclosingDeclaration); if (some(root.declarations, d => getSourceFileOfNode(d) === contextFile)) { includePrivateSymbol(root); } } } else if (oldcontext.tracker.inner?.trackSymbol) { return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning); } return false; }, } */ TODO
			context.tracker = /* TODO(Node NewExpression): new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost) */ TODO
			forEachEntry(symbolTable, func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
				baseName := unescapeLeadingUnderscores(name)
				getInternalSymbolName(symbol, baseName)
			})
			addingDeclare := !context.bundled
			exportEquals := symbolTable.get(InternalSymbolNameExportEquals)
			if exportEquals && symbolTable.size > 1 && exportEquals.flags&(SymbolFlagsAlias|SymbolFlagsModule) {
				symbolTable = createSymbolTable()
				symbolTable.set(InternalSymbolNameExportEquals, exportEquals)
			}
			visitSymbolTable(symbolTable)
			return mergeRedundantStatements(results)
			isIdentifierAndNotUndefined := func(node Node) /* TODO(TypeNode TypePredicate): node is Identifier */ any {
				return !!node && node.kind == SyntaxKindIdentifier
			}
			getNamesOfDeclaration := func(statement Statement) []Identifier {
				if isVariableStatement(statement) {
					return filter(map_(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined)
				}
				return filter([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DeclarationName | undefined */ any{getNameOfDeclaration(statement)}, isIdentifierAndNotUndefined)
			}
			flattenExportAssignedNamespace := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ any {
				exportAssignment := find(statements, isExportAssignment)
				nsIndex := findIndex(statements, isModuleDeclaration)
				ns := /* TODO(Node ConditionalExpression): nsIndex !== -1 ? statements[nsIndex] as ModuleDeclaration : undefined */ TODO
				if ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) == idText(exportAssignment.expression) && ns.body && isModuleBlock(ns.body) {
					excessExports := filter(statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
						return !!(getEffectiveModifierFlags(s) & ModifierFlagsExport)
					})
					name := ns.name
					body := ns.body
					if length(excessExports) {
						ns = factory.updateModuleDeclaration(ns, ns.modifiers, ns.name /* TODO(Node BinaryExpression): body = factory.updateModuleBlock( body, factory.createNodeArray([ ...ns.body.statements, factory.createExportDeclaration( /*modifiers* / undefined, /*isTypeOnly* / false, factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))), /*moduleSpecifier* / undefined, ), ]), ) */, TODO)
						statements = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any{ /* TODO(Node SpreadElement): ...statements.slice(0, nsIndex) */ ns /* TODO(Node SpreadElement): ...statements.slice(nsIndex + 1) */}
					}
					if !find(statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
						return s != ns && nodeHasName(s, name)
					}) {
						results = [] /* TODO inferred type never */ any{}
						mixinExportFlag := !some(body.statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
							return hasSyntacticModifier(s, ModifierFlagsExport) || isExportAssignment(s) || isExportDeclaration(s)
						})
						forEach(body.statements, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) {
							addResult(s /* TODO(Node ConditionalExpression): mixinExportFlag ? ModifierFlags.Export : ModifierFlags.None */, TODO)
						})
						statements = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any{ /* TODO(Node SpreadElement): ...filter(statements, s => s !== ns && s !== exportAssignment) */ /* TODO(Node SpreadElement): ...results */ }
					}
				}
				return statements
			}
			mergeExportDeclarations := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ any {
				exports := filter(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
					return isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if length(exports) > 1 {
					nonExports := filter(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
						return !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause
					})
					statements = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any{ /* TODO(Node SpreadElement): ...nonExports */ factory.createExportDeclaration(nil, false, factory.createNamedExports(flatMap(exports, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier> */ any {
						return cast(e.exportClause, isNamedExports).elements
					})), nil)}
				}
				reexports := filter(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
					return isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if length(reexports) > 1 {
					groups := group(reexports, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ any) /* TODO inferred type string */ any {
						return /* TODO(Node ConditionalExpression): isStringLiteral(decl.moduleSpecifier!) ? ">" + decl.moduleSpecifier.text : ">" */ TODO
					})
					if groups.length != reexports.length {
						for _, group := range groups {
							if group.length > 1 {
								statements = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any{ /* TODO(Node SpreadElement): ...filter(statements, s => !group.includes(s as ExportDeclaration)) */ factory.createExportDeclaration(nil, false, factory.createNamedExports(flatMap(group, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier> */ any {
									return cast(e.exportClause, isNamedExports).elements
								})), group[0].moduleSpecifier)}
							}
						}
					}
				}
				return statements
			}
			inlineExportModifiers := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ any {
				index := findIndex(statements, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type boolean */ any {
					return isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause)
				})
				if index >= 0 {
					exportDecl := statements[index]
					replacements := mapDefined(exportDecl.exportClause.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier | undefined */ any {
						if !e.propertyName && e.name.kind != SyntaxKindStringLiteral {
							name := e.name
							indices := indicesOf(statements)
							associatedIndices := filter(indices, func(i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
								return nodeHasName(statements[i], name)
							})
							if length(associatedIndices) && every(associatedIndices, func(i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
								return canHaveExportModifier(statements[i])
							}) {
								for _, index := range associatedIndices {
									statements[index] = addExportModifier(statements[index])
								}
								return nil
							}
						}
						return e
					})
					if !length(replacements) {
						orderedRemoveItemAt(statements, index)
					} else {
						statements[index] = factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.attributes)
					}
				}
				return statements
			}
			mergeRedundantStatements := func(statements []Statement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ any {
				statements = flattenExportAssignedNamespace(statements)
				statements = mergeExportDeclarations(statements)
				statements = inlineExportModifiers(statements)
				if enclosingDeclaration && ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) && (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) {
					statements.push(createEmptyExports(factory))
				}
				return statements
			}
			addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration */ any {
				flags := (getEffectiveModifierFlags(node) | ModifierFlagsExport) & ~ModifierFlagsAmbient
				return factory.replaceModifiers(node, flags)
			}
			removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration */ any {
				flags := getEffectiveModifierFlags(node) & ~ModifierFlagsExport
				return factory.replaceModifiers(node, flags)
			}
			visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
				if !suppressNewPrivateContext {
					deferredPrivatesStack.push( /* TODO(Node NewExpression): new Map() */ make(map[any]any))
				}
				symbolTable.forEach(func(symbol Symbol) {
					serializeSymbol(symbol, false, !!propertyAsAlias)
				})
				if !suppressNewPrivateContext {
					deferredPrivatesStack[deferredPrivatesStack.length-1].forEach(func(symbol Symbol) {
						serializeSymbol(symbol, true, !!propertyAsAlias)
					})
					deferredPrivatesStack.pop()
				}
			}
			serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
				getPropertiesOfType(getTypeOfSymbol(symbol))
				visitedSym := getMergedSymbol(symbol)
				if visitedSymbols.has(getSymbolId(visitedSym)) {
					return
				}
				visitedSymbols.add(getSymbolId(visitedSym))
				skipMembershipCheck := !isPrivate
				if skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return !!findAncestor(d, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
						return n == enclosingDeclaration
					})
				})) {
					scopeCleanup := cloneNodeBuilderContext(context)
					serializeSymbolWorker(symbol, isPrivate, propertyAsAlias)
					scopeCleanup()
				}
			}
			serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any /*  = symbol.escapedName */) {
				symbolName := unescapeLeadingUnderscores(escapedSymbolName)
				isDefault := escapedSymbolName == InternalSymbolNameDefault
				if isPrivate && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault {
					context.encounteredError = true
					return
				}
				needsPostExportDefault := isDefault && !!(symbol.flags&SymbolFlagsExportDoesNotSupportDefaultModifier || (symbol.flags&SymbolFlagsFunction && length(getPropertiesOfType(getTypeOfSymbol(symbol))))) && !(symbol.flags & SymbolFlagsAlias)
				needsExportDeclaration := !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault
				if needsPostExportDefault || needsExportDeclaration {
					isPrivate = true
				}
				modifierFlags := ( /* TODO(Node ConditionalExpression): !isPrivate ? ModifierFlags.Export : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0 */ TODO)
				isConstMergedWithNS := symbol.flags&SymbolFlagsModule && symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty) && escapedSymbolName != InternalSymbolNameExportEquals
				isConstMergedWithNSPrintableAsSignatureMerge := isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol)
				if symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags & SymbolFlagsTypeAlias {
					serializeTypeAlias(symbol, symbolName, modifierFlags)
				}
				if symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty|SymbolFlagsAccessor) && escapedSymbolName != InternalSymbolNameExportEquals && !(symbol.flags & SymbolFlagsPrototype) && !(symbol.flags & SymbolFlagsClass) && !(symbol.flags & SymbolFlagsMethod) && !isConstMergedWithNSPrintableAsSignatureMerge {
					if propertyAsAlias {
						createdExport := serializeMaybeAliasAssignment(symbol)
						if createdExport {
							needsExportDeclaration = false
							needsPostExportDefault = false
						}
					} else {
						type_ := getTypeOfSymbol(symbol)
						localName := getInternalSymbolName(symbol, symbolName)
						if type_.symbol && type_.symbol != symbol && type_.symbol.flags&SymbolFlagsFunction && some(type_.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type_.symbol.members. /*?*/ size || type_.symbol.exports. /*?*/ size) {
							if !context.remappedSymbolReferences {
								context.remappedSymbolReferences = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
							}
							context.remappedSymbolReferences.set(getSymbolId(type_.symbol), symbol)
							serializeSymbolWorker(type_.symbol, isPrivate, propertyAsAlias, escapedSymbolName)
							context.remappedSymbolReferences.delete(getSymbolId(type_.symbol))
						} else if !(symbol.flags & SymbolFlagsFunction) && isTypeRepresentableAsFunctionNamespaceMerge(type_, symbol) {
							serializeAsFunctionNamespaceMerge(type_, symbol, localName, modifierFlags)
						} else {
							flags := /* TODO(Node ConditionalExpression): !(symbol.flags & SymbolFlags.BlockScopedVariable) ? symbol.parent?.valueDeclaration && isSourceFile(symbol.parent?.valueDeclaration) ? NodeFlags.Const // exports are immutable in es6, which is what we emulate and check; so it's safe to mark all exports as `const` (there's no difference to consumers, but it allows unique symbol type declarations) : undefined : isConstantVariable(symbol) ? NodeFlags.Const : NodeFlags.Let */ TODO
							name := /* TODO(Node ConditionalExpression): (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(localName, symbol) */ TODO
							var textRange Node = symbol.declarations && find(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
								return isVariableDeclaration(d)
							})
							if textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length == 1 {
								textRange = textRange.parent.parent
							}
							propertyAccessRequire := symbol.declarations. /*?*/ find(isPropertyAccessExpression)
							if propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right) && type_.symbol. /*?*/ valueDeclaration && isSourceFile(type_.symbol.valueDeclaration) {
								alias := /* TODO(Node ConditionalExpression): localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right */ TODO
								addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ any{factory.createExportSpecifier(false, alias, localName)})), ModifierFlagsNone)
								context.tracker.trackSymbol(type_.symbol, context.enclosingDeclaration, SymbolFlagsValue)
							} else {
								statement := setTextRange(context, factory.createVariableStatement(nil, factory.createVariableDeclarationList([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclaration */ any{factory.createVariableDeclaration(name, nil, serializeTypeForDeclaration(context, nil, type_, symbol))}, flags)), textRange)
								addResult(statement /* TODO(Node ConditionalExpression): name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags */, TODO)
								if name != localName && !isPrivate {
									addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ any{factory.createExportSpecifier(false, name, localName)})), ModifierFlagsNone)
									needsExportDeclaration = false
									needsPostExportDefault = false
								}
							}
						}
					}
				}
				if symbol.flags & SymbolFlagsEnum {
					serializeEnum(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsClass {
					if symbol.flags&SymbolFlagsProperty && symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration.parent) && isClassExpression(symbol.valueDeclaration.parent.right) {
						serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					} else {
						serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					}
				}
				if (symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeModule(symbol, symbolName, modifierFlags)
				}
				if symbol.flags&SymbolFlagsInterface && !(symbol.flags & SymbolFlagsClass) {
					serializeInterface(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsAlias {
					serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags&SymbolFlagsProperty && symbol.escapedName == InternalSymbolNameExportEquals {
					serializeMaybeAliasAssignment(symbol)
				}
				if symbol.flags & SymbolFlagsExportStar {
					if symbol.declarations {
						for _, node := range symbol.declarations {
							resolvedModule := resolveExternalModuleName(node, (node).moduleSpecifier)
							if !resolvedModule {
								continue
							}
							addResult(factory.createExportDeclaration(nil, (node).isTypeOnly, nil, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlagsNone)
						}
					}
				}
				if needsPostExportDefault {
					addResult(factory.createExportAssignment(nil, false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), ModifierFlagsNone)
				} else if needsExportDeclaration {
					addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ any{factory.createExportSpecifier(false, getInternalSymbolName(symbol, symbolName), symbolName)})), ModifierFlagsNone)
				}
			}
			includePrivateSymbol := func(symbol Symbol) {
				if some(symbol.declarations, isPartOfParameterDeclaration) {
					return
				}
				Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length-1])
				getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol)
				isExternalImportAlias := !!(symbol.flags & SymbolFlagsAlias) && !some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return !!findAncestor(d, isExportDeclaration) || isNamespaceExport(d) || (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference))
				})
				deferredPrivatesStack[ /* TODO(Node ConditionalExpression): isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1) */ TODO].set(getSymbolId(symbol), symbol)
			}
			isExportingScope := func(enclosingDeclaration Node) /* TODO inferred type boolean */ any {
				return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) || (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration)))
			}
			addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
				if canHaveModifiers(node) {
					var newModifierFlags ModifierFlags = ModifierFlagsNone
					enclosingDeclaration := context.enclosingDeclaration && ( /* TODO(Node ConditionalExpression): isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration */ TODO)
					if additionalModifierFlags&ModifierFlagsExport && enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) && canHaveExportModifier(node) {
						newModifierFlags |= ModifierFlagsExport
					}
					if addingDeclare && !(newModifierFlags & ModifierFlagsExport) && (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlagsAmbient)) && (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) {
						newModifierFlags |= ModifierFlagsAmbient
					}
					if (additionalModifierFlags & ModifierFlagsDefault) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) {
						newModifierFlags |= ModifierFlagsDefault
					}
					if newModifierFlags {
						node = factory.replaceModifiers(node, newModifierFlags|getEffectiveModifierFlags(node))
					}
				}
				results.push(node)
			}
			serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				aliasType := getDeclaredTypeOfTypeAlias(symbol)
				typeParams := getSymbolLinks(symbol).typeParameters
				typeParamDecls := map_(typeParams, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any {
					return typeParameterToDeclaration(p, context)
				})
				jsdocAliasDecl := symbol.declarations. /*?*/ find(isJSDocTypeAlias)
				commentText := getTextOfJSDocComment( /* TODO(Node ConditionalExpression): jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined */ TODO)
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInTypeAlias
				oldEnclosingDecl := context.enclosingDeclaration
				context.enclosingDeclaration = jsdocAliasDecl
				typeNode := jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(jsdocAliasDecl.typeExpression) && tryReuseExistingNonParameterTypeNode(context, jsdocAliasDecl.typeExpression.type_, aliasType, nil) || typeToTypeNodeHelper(aliasType, context)
				addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode) /* TODO(Node ConditionalExpression): !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO), modifierFlags)
				restoreFlags()
				context.enclosingDeclaration = oldEnclosingDecl
			}
			serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				interfaceType := getDeclaredTypeOfClassOrInterface(symbol)
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any {
					return typeParameterToDeclaration(p, context)
				})
				baseTypes := getBaseTypes(interfaceType)
				baseType := /* TODO(Node ConditionalExpression): length(baseTypes) ? getIntersectionType(baseTypes) : undefined */ TODO
				members := flatMap(getPropertiesOfType(interfaceType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ any {
					return serializePropertySymbolForInterface(p, baseType)
				})
				callSignatures := serializeSignatures(SignatureKindCall, interfaceType, baseType, SyntaxKindCallSignature)
				constructSignatures := serializeSignatures(SignatureKindConstruct, interfaceType, baseType, SyntaxKindConstructSignature)
				indexSignatures := serializeIndexSignatures(interfaceType, baseType)
				heritageClauses := /* TODO(Node ConditionalExpression): !length(baseTypes) ? undefined : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, SymbolFlags.Value)))] */ TODO
				addResult(factory.createInterfaceDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement */ any{ /* TODO(Node SpreadElement): ...indexSignatures */ /* TODO(Node SpreadElement): ...constructSignatures */ /* TODO(Node SpreadElement): ...callSignatures */ /* TODO(Node SpreadElement): ...members */ }), modifierFlags)
			}
			getNamespaceMembersForSerialization := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
				exports := arrayFrom(getExportsOfSymbol(symbol).values())
				merged := getMergedSymbol(symbol)
				if merged != symbol {
					membersSet := /* TODO(Node NewExpression): new Set(exports) */ TODO
					for _, exported := range getExportsOfSymbol(merged).values() {
						if !(getSymbolFlags(resolveSymbol(exported)) & SymbolFlagsValue) {
							membersSet.add(exported)
						}
					}
					exports = arrayFrom(membersSet)
				}
				return filter(exports, func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return isNamespaceMember(m) && isIdentifierText(m.escapedName, ScriptTargetESNext)
				})
			}
			isTypeOnlyNamespace := func(symbol Symbol) /* TODO inferred type boolean */ any {
				return every(getNamespaceMembersForSerialization(symbol), func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return !(getSymbolFlags(resolveSymbol(m)) & SymbolFlagsValue)
				})
			}
			serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				members := getNamespaceMembersForSerialization(symbol)
				locationMap := arrayToMultiMap(members, func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type "real" | "merged" */ any {
					return /* TODO(Node ConditionalExpression): m.parent && m.parent === symbol ? "real" : "merged" */ TODO
				})
				realMembers := locationMap.get("real") || emptyArray
				mergedMembers := locationMap.get("merged") || emptyArray
				if length(realMembers) {
					localName := getInternalSymbolName(symbol, symbolName)
					serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlagsFunction | SymbolFlagsAssignment)))
				}
				if length(mergedMembers) {
					containingFile := getSourceFileOfNode(context.enclosingDeclaration)
					localName := getInternalSymbolName(symbol, symbolName)
					nsBody := factory.createModuleBlock([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ any{factory.createExportDeclaration(nil, false, factory.createNamedExports(mapDefined(filter(mergedMembers, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
						return n.escapedName != InternalSymbolNameExportEquals
					}), func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier | undefined */ any {
						name := unescapeLeadingUnderscores(s.escapedName)
						localName := getInternalSymbolName(s, name)
						aliasDecl := s.declarations && getDeclarationOfAliasSymbol(s)
						if containingFile && ( /* TODO(Node ConditionalExpression): aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile) */ TODO) {
							context.tracker. /*?*/ reportNonlocalAugmentation(containingFile, symbol, s)
							return nil
						}
						target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true)
						includePrivateSymbol(target || s)
						targetName := /* TODO(Node ConditionalExpression): target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName */ TODO
						return factory.createExportSpecifier(false /* TODO(Node ConditionalExpression): name === targetName ? undefined : targetName */, TODO, name)
					})))})
					addResult(factory.createModuleDeclaration(nil, factory.createIdentifier(localName), nsBody, NodeFlagsNamespace), ModifierFlagsNone)
				}
			}
			serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				addResult(factory.createEnumDeclaration(factory.createModifiersFromModifierFlags( /* TODO(Node ConditionalExpression): isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0 */ TODO), getInternalSymbolName(symbol, symbolName), map_(filter(getPropertiesOfType(getTypeOfSymbol(symbol)), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return !!(p.flags & SymbolFlagsEnumMember)
				}), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EnumMember */ any {
					initializedValue := /* TODO(Node ConditionalExpression): p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined */ TODO
					return factory.createEnumMember(unescapeLeadingUnderscores(p.escapedName) /* TODO(Node ConditionalExpression): initializedValue === undefined ? undefined : typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) : factory.createNumericLiteral(initializedValue) */, TODO)
				})), modifierFlags)
			}
			serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
				signatures := getSignaturesOfType(type_, SignatureKindCall)
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, SyntaxKindFunctionDeclaration, context /* TODO(Node ObjectLiteralExpression): { name: factory.createIdentifier(localName) } */, TODO)
					addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags)
				}
				if !(symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && !!symbol.exports && !!symbol.exports.size) {
					props := filter(getPropertiesOfType(type_), isNamespaceMember)
					serializeAsNamespaceDeclaration(props, localName, modifierFlags, true)
				}
			}
			getSignatureTextRangeLocation := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList | import("/home/jabaile/work/TypeScript/src/compiler/types").CatchClause | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocSignature | undefined */ any {
				if signature.declaration && signature.declaration.parent {
					if isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) == AssignmentDeclarationKindProperty {
						return signature.declaration.parent
					}
					if isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent {
						return signature.declaration.parent.parent
					}
				}
				return signature.declaration
			}
			serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
				if length(props) {
					localVsRemoteMap := arrayToMultiMap(props, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type "local" | "remote" */ any {
						return /* TODO(Node ConditionalExpression): !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!)) ? "local" : "remote" */ TODO
					})
					localProps := localVsRemoteMap.get("local") || emptyArray
					fakespace := parseNodeFactory.createModuleDeclaration(nil, factory.createIdentifier(localName), factory.createModuleBlock([] /* TODO inferred type never */ any{}), NodeFlagsNamespace)
					setParent(fakespace, enclosingDeclaration)
					fakespace.locals = createSymbolTable(props)
					fakespace.symbol = props[0].parent
					oldResults := results
					results = [] /* TODO inferred type never */ any{}
					oldAddingDeclare := addingDeclare
					addingDeclare = false
					subcontext := /* TODO(Node ObjectLiteralExpression): { ...context, enclosingDeclaration: fakespace } */ TODO
					oldContext := context
					context = subcontext
					visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext, true)
					context = oldContext
					addingDeclare = oldAddingDeclare
					declarations := results
					results = oldResults
					defaultReplaced := map_(declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ any {
						return /* TODO(Node ConditionalExpression): isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) ? factory.createExportDeclaration( /*modifiers* / undefined, /*isTypeOnly* / false, factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, d.expression, factory.createIdentifier(InternalSymbolName.Default))]), ) : d */ TODO
					})
					exportModifierStripped := /* TODO(Node ConditionalExpression): every(defaultReplaced, d => hasSyntacticModifier(d, ModifierFlags.Export)) ? map(defaultReplaced as Extract<HasModifiers, Statement>[], removeExportModifier) : defaultReplaced */ TODO
					fakespace = factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, factory.createModuleBlock(exportModifierStripped))
					addResult(fakespace, modifierFlags)
				}
			}
			isNamespaceMember := func(p Symbol) /* TODO inferred type boolean */ any {
				return !!(p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) || !(p.flags&SymbolFlagsPrototype || p.escapedName == "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent))
			}
			sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) *[]ExpressionWithTypeArguments {
				result := mapDefined(clauses, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ any {
					oldEnclosing := context.enclosingDeclaration
					context.enclosingDeclaration = e
					expr := e.expression
					if isEntityNameExpression(expr) {
						if isIdentifier(expr) && idText(expr) == "" {
							return cleanup(nil)
						}
						var introducesError bool
						( /* TODO(Node BinaryExpression): { introducesError, node: expr } = trackExistingEntityName(expr, context) */ TODO)
						if introducesError {
							return cleanup(nil)
						}
					}
					return cleanup(factory.createExpressionWithTypeArguments(expr, map_(e.typeArguments, func(a /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
						return tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a)) || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)
					})))
					cleanup := func(result T) T {
						context.enclosingDeclaration = oldEnclosing
						return result
					}
				})
				if result.length == clauses.length {
					return result
				}
				return nil
			}
			serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
				originalDecl := symbol.declarations. /*?*/ find(isClassLike)
				oldEnclosing := context.enclosingDeclaration
				context.enclosingDeclaration = originalDecl || oldEnclosing
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any {
					return typeParameterToDeclaration(p, context)
				})
				classType := getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol))
				baseTypes := getBaseTypes(classType)
				originalImplements := originalDecl && getEffectiveImplementsTypeNodes(originalDecl)
				implementsExpressions := originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(getImplementsTypes(classType), serializeImplementedType)
				staticType := getTypeOfSymbol(symbol)
				isClass := !!staticType.symbol. /*?*/ valueDeclaration && isClassLike(staticType.symbol.valueDeclaration)
				staticBaseType := /* TODO(Node ConditionalExpression): isClass ? getBaseConstructorTypeOfClass(staticType as InterfaceType) : anyType */ TODO
				heritageClauses := [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").HeritageClause */ any{ /* TODO(Node SpreadElement): ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))] */ /* TODO(Node SpreadElement): ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)] */ }
				symbolProps := getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType))
				publicSymbolProps := filter(symbolProps, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					valueDecl := s.valueDeclaration
					return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name))
				})
				hasPrivateIdentifier := some(symbolProps, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					valueDecl := s.valueDeclaration
					return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name)
				})
				privateProperties := /* TODO(Node ConditionalExpression): hasPrivateIdentifier ? [factory.createPropertyDeclaration( /*modifiers* / undefined, factory.createPrivateIdentifier("#private"), /*questionOrExclamationToken* / undefined, /*type* / undefined, /*initializer* / undefined, )] : emptyArray */ TODO
				publicProperties := flatMap(publicSymbolProps, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration)[] */ any {
					return serializePropertySymbolForClass(p, false, baseTypes[0])
				})
				staticMembers := flatMap(filter(getPropertiesOfType(staticType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return !(p.flags & SymbolFlagsPrototype) && p.escapedName != "prototype" && !isNamespaceMember(p)
				}), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration)[] */ any {
					return serializePropertySymbolForClass(p, true, staticBaseType)
				})
				isNonConstructableClassLikeInJsFile := !isClass && !!symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && !some(getSignaturesOfType(staticType, SignatureKindConstruct))
				constructors := /* TODO(Node ConditionalExpression): isNonConstructableClassLikeInJsFile ? [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlags.Private), [], /*body* / undefined)] : serializeSignatures(SignatureKind.Construct, staticType, staticBaseType, SyntaxKind.Constructor) as ConstructorDeclaration[] */ TODO
				indexSignatures := serializeIndexSignatures(classType, baseTypes[0])
				context.enclosingDeclaration = oldEnclosing
				addResult(setTextRange(context, factory.createClassDeclaration(nil, localName, typeParamDecls, heritageClauses, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement */ any{ /* TODO(Node SpreadElement): ...indexSignatures */ /* TODO(Node SpreadElement): ...staticMembers */ /* TODO(Node SpreadElement): ...constructors */ /* TODO(Node SpreadElement): ...publicProperties */ /* TODO(Node SpreadElement): ...privateProperties */ }), symbol.declarations && filter(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return isClassDeclaration(d) || isClassExpression(d)
				})[0]), modifierFlags)
			}
			getSomeTargetNameFromDeclarations := func(declarations *[]Declaration) /* TODO inferred type string | undefined */ any {
				return firstDefined(declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type string | undefined */ any {
					if isImportSpecifier(d) || isExportSpecifier(d) {
						return moduleExportNameTextUnescaped(d.propertyName || d.name)
					}
					if isBinaryExpression(d) || isExportAssignment(d) {
						expression := /* TODO(Node ConditionalExpression): isExportAssignment(d) ? d.expression : d.right */ TODO
						if isPropertyAccessExpression(expression) {
							return idText(expression.name)
						}
					}
					if isAliasSymbolDeclaration(d) {
						name := getNameOfDeclaration(d)
						if name && isIdentifier(name) {
							return idText(name)
						}
					}
					return nil
				})
			}
			serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) /* TODO inferred type undefined */ any {
				node := getDeclarationOfAliasSymbol(symbol)
				if !node {
					return Debug.fail()
				}
				target := getMergedSymbol(getTargetOfAliasDeclaration(node, true))
				if !target {
					return
				}
				verbatimTargetName := isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName)
				if verbatimTargetName == InternalSymbolNameExportEquals && allowSyntheticDefaultImports {
					verbatimTargetName = InternalSymbolNameDefault
				}
				targetName := getInternalSymbolName(target, verbatimTargetName)
				includePrivateSymbol(target)
				switch node.kind {
				case SyntaxKindBindingElement:
					if node.parent. /*?*/ parent. /*?*/ kind == SyntaxKindVariableDeclaration {
						specifier := getSpecifierForModuleSymbol(target.parent || target, context)
						TODO_IDENTIFIER := node
						addResult(factory.createImportDeclaration(nil, factory.createImportClause(false, nil, factory.createNamedImports([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportSpecifier */ any{factory.createImportSpecifier(false /* TODO(Node ConditionalExpression): propertyName && isIdentifier(propertyName) ? factory.createIdentifier(idText(propertyName)) : undefined */, TODO, factory.createIdentifier(localName))})), factory.createStringLiteral(specifier), nil), ModifierFlagsNone)
						break
					}
					Debug.failBadSyntaxKind(node.parent. /*?*/ parent || node, "Unhandled binding element grandparent kind in declaration serialization")
					break
				case SyntaxKindShorthandPropertyAssignment:
					if node.parent. /*?*/ parent. /*?*/ kind == SyntaxKindBinaryExpression {
						serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), targetName)
					}
					break
				case SyntaxKindVariableDeclaration:
					if isPropertyAccessExpression((node).initializer) {
						initializer := (node).initializer
						uniqueName := factory.createUniqueName(localName)
						specifier := getSpecifierForModuleSymbol(target.parent || target, context)
						addResult(factory.createImportEqualsDeclaration(nil, false, uniqueName, factory.createExternalModuleReference(factory.createStringLiteral(specifier))), ModifierFlagsNone)
						addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName), factory.createQualifiedName(uniqueName, initializer.name)), modifierFlags)
						break
					}
					fallthrough
				case SyntaxKindImportEqualsDeclaration:
					if target.escapedName == InternalSymbolNameExportEquals && some(target.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
						return isSourceFile(d) && isJsonSourceFile(d)
					}) {
						serializeMaybeAliasAssignment(symbol)
						break
					}
					isLocalImport := !(target.flags & SymbolFlagsValueModule) && !isVariableDeclaration(node)
					addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName) /* TODO(Node ConditionalExpression): isLocalImport ? symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier* / false) : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))) */, TODO) /* TODO(Node ConditionalExpression): isLocalImport ? modifierFlags : ModifierFlags.None */, TODO)
					break
				case SyntaxKindNamespaceExportDeclaration:
					addResult(factory.createNamespaceExportDeclaration(idText((node).name)), ModifierFlagsNone)
					break
				case SyntaxKindImportClause:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					specifier := /* TODO(Node ConditionalExpression): context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportClause).parent.moduleSpecifier */ TODO
					attributes := /* TODO(Node ConditionalExpression): isImportDeclaration(node.parent) ? node.parent.attributes : undefined */ TODO
					isTypeOnly := isJSDocImportTag((node).parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, factory.createIdentifier(localName), nil), specifier, attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindNamespaceImport:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					specifier := /* TODO(Node ConditionalExpression): context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as NamespaceImport).parent.parent.moduleSpecifier */ TODO
					isTypeOnly := isJSDocImportTag((node).parent.parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, nil, factory.createNamespaceImport(factory.createIdentifier(localName))), specifier, (node).parent.attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindNamespaceExport:
					addResult(factory.createExportDeclaration(nil, false, factory.createNamespaceExport(factory.createIdentifier(localName)), factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), ModifierFlagsNone)
					break
				case SyntaxKindImportSpecifier:
					generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
					specifier := /* TODO(Node ConditionalExpression): context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportSpecifier).parent.parent.parent.moduleSpecifier */ TODO
					isTypeOnly := isJSDocImportTag((node).parent.parent.parent)
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, nil, factory.createNamedImports([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportSpecifier */ any{factory.createImportSpecifier(false /* TODO(Node ConditionalExpression): localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : undefined */, TODO, factory.createIdentifier(localName))})), specifier, (node).parent.parent.parent.attributes), ModifierFlagsNone)
					break
					fallthrough
				case SyntaxKindExportSpecifier:
					specifier := (node.parent.parent).moduleSpecifier
					if specifier {
						propertyName := (node).propertyName
						if propertyName && moduleExportNameIsDefault(propertyName) {
							verbatimTargetName = InternalSymbolNameDefault
						}
					}
					serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName) /* TODO(Node ConditionalExpression): specifier ? verbatimTargetName : targetName */, TODO /* TODO(Node ConditionalExpression): specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : undefined */, TODO)
					break
				case SyntaxKindExportAssignment:
					serializeMaybeAliasAssignment(symbol)
					break
				case SyntaxKindBinaryExpression:
					fallthrough // TODO: merge cases
				case SyntaxKindPropertyAccessExpression:
					fallthrough // TODO: merge cases
				case SyntaxKindElementAccessExpression:
					if symbol.escapedName == InternalSymbolNameDefault || symbol.escapedName == InternalSymbolNameExportEquals {
						serializeMaybeAliasAssignment(symbol)
					} else {
						serializeExportSpecifier(localName, targetName)
					}
					break
				default:
					return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!")
				}
			}
			serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
				addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ any{factory.createExportSpecifier(false /* TODO(Node ConditionalExpression): localName !== targetName ? targetName : undefined */, TODO, localName)}), specifier), ModifierFlagsNone)
			}
			serializeMaybeAliasAssignment := func(symbol Symbol) bool {
				if symbol.flags & SymbolFlagsPrototype {
					return false
				}
				name := unescapeLeadingUnderscores(symbol.escapedName)
				isExportEquals := name == InternalSymbolNameExportEquals
				isDefault := name == InternalSymbolNameDefault
				isExportAssignmentCompatibleSymbolName := isExportEquals || isDefault
				aliasDecl := symbol.declarations && getDeclarationOfAliasSymbol(symbol)
				target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true)
				if target && length(target.declarations) && some(target.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return getSourceFileOfNode(d) == getSourceFileOfNode(enclosingDeclaration)
				}) {
					expr := aliasDecl && ( /* TODO(Node ConditionalExpression): (isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression) */ TODO)
					first := /* TODO(Node ConditionalExpression): expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined */ TODO
					referenced := first && resolveEntityName(first, SymbolFlagsAll, true, true, enclosingDeclaration)
					if referenced || target {
						includePrivateSymbol(referenced || target)
					}
					prevDisableTrackSymbol := context.tracker.disableTrackSymbol
					context.tracker.disableTrackSymbol = true
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, symbolToExpression(target, context, SymbolFlagsAll)))
					} else {
						if first == expr && first {
							serializeExportSpecifier(name, idText(first))
						} else if expr && isClassExpression(expr) {
							serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)))
						} else {
							varName := getUnusedName(name, symbol)
							addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(varName), symbolToName(target, context, SymbolFlagsAll, false)), ModifierFlagsNone)
							serializeExportSpecifier(name, varName)
						}
					}
					context.tracker.disableTrackSymbol = prevDisableTrackSymbol
					return true
				} else {
					varName := getUnusedName(name, symbol)
					typeToSerialize := getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)))
					if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
						serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName /* TODO(Node ConditionalExpression): isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export */, TODO)
					} else {
						flags := /* TODO(Node ConditionalExpression): context.enclosingDeclaration?.kind === SyntaxKind.ModuleDeclaration && (!(symbol.flags & SymbolFlags.Accessor) || symbol.flags & SymbolFlags.SetAccessor) ? NodeFlags.Let : NodeFlags.Const */ TODO
						statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclaration */ any{factory.createVariableDeclaration(varName, nil, serializeTypeForDeclaration(context, nil, typeToSerialize, symbol))}, flags))
						addResult(statement /* TODO(Node ConditionalExpression): target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient : name === varName ? ModifierFlags.Export : ModifierFlags.None */, TODO)
					}
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, factory.createIdentifier(varName)))
						return true
					} else if name != varName {
						serializeExportSpecifier(name, varName)
						return true
					}
					return false
				}
			}
			isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO inferred type boolean | 0 */ any {
				ctxSrc := getSourceFileOfNode(context.enclosingDeclaration)
				return getObjectFlags(typeToSerialize)&(ObjectFlagsAnonymous|ObjectFlagsMapped) && !some(typeToSerialize.symbol. /*?*/ declarations, isTypeNode) && !length(getIndexInfosOfType(typeToSerialize)) && !isClassInstanceSide(typeToSerialize) && !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKindCall))) && !length(getSignaturesOfType(typeToSerialize, SignatureKindConstruct)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return getSourceFileOfNode(d) != ctxSrc
				})) && !some(getPropertiesOfType(typeToSerialize), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return isLateBoundName(p.escapedName)
				}) && !some(getPropertiesOfType(typeToSerialize), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return some(p.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
						return getSourceFileOfNode(d) != ctxSrc
					})
				}) && every(getPropertiesOfType(typeToSerialize), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					if !isIdentifierText(symbolName(p), languageVersion) {
						return false
					}
					if !(p.flags & SymbolFlagsAccessor) {
						return true
					}
					return getNonMissingTypeOfSymbol(p) == getWriteTypeOfSymbol(p)
				})
			}
			/* OVERLOAD: function makeSerializePropertySymbol<T extends Node>( createProperty: ( modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined, ) => T, methodKind: SignatureDeclaration["kind"], useAccessors: true, ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | AccessorDeclaration | (T | AccessorDeclaration)[]; */
			/* OVERLOAD: function makeSerializePropertySymbol<T extends Node>( createProperty: ( modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined, ) => T, methodKind: SignatureDeclaration["kind"], useAccessors: false, ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | T[]; */
			makeSerializePropertySymbol := func(createProperty func(modifiers *[]Modifier, name /* TODO(TypeNode UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(TypeNode IndexedAccessType): SignatureDeclaration["kind"] */ any, useAccessors bool) func(p Symbol, isStatic bool, baseType *Type) /* TODO(TypeNode UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
				return /* TODO(Node FunctionExpression): function serializePropertySymbol(p: Symbol, isStatic: boolean, baseType: Type | undefined): T | AccessorDeclaration | (T | AccessorDeclaration)[] { const modifierFlags = getDeclarationModifierFlagsFromSymbol(p); const isPrivate = !!(modifierFlags & ModifierFlags.Private); if (isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))) { // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols // need to be merged namespace members return []; } if ( p.flags & SymbolFlags.Prototype || p.escapedName === "constructor" || (baseType && getPropertyOfType(baseType, p.escapedName) && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)!) === isReadonlySymbol(p) && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(baseType, p.escapedName)!.flags & SymbolFlags.Optional) && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)!)) ) { return []; } const flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0); const name = getPropertyNameNodeForSymbol(p, context); const firstPropertyLikeDecl = p.declarations?.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression)); if (p.flags & SymbolFlags.Accessor && useAccessors) { const result: AccessorDeclaration[] = []; if (p.flags & SymbolFlags.SetAccessor) { const setter = p.declarations && forEach(p.declarations, d => { if (d.kind === SyntaxKind.SetAccessor) { return d as SetAccessorDeclaration; } if (isCallExpression(d) && isBindableObjectDefinePropertyCall(d)) { return forEach(d.arguments[2].properties, propDecl => { const id = getNameOfDeclaration(propDecl); if (!!id && isIdentifier(id) && idText(id) === "set") { return propDecl; } }); } }); Debug.assert(!!setter); const paramSymbol = isFunctionLikeDeclaration(setter) ? getSignatureFromDeclaration(setter).parameters[0] : undefined; result.push(setTextRange( context, factory.createSetAccessorDeclaration( factory.createModifiersFromModifierFlags(flag), name, [factory.createParameterDeclaration( /*modifiers* / undefined, /*dotDotDotToken* / undefined, paramSymbol ? parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context) : "value", /*questionToken* / undefined, isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p), )], /*body* / undefined, ), p.declarations?.find(isSetAccessor) || firstPropertyLikeDecl, )); } if (p.flags & SymbolFlags.GetAccessor) { const isPrivate = modifierFlags & ModifierFlags.Private; result.push(setTextRange( context, factory.createGetAccessorDeclaration( factory.createModifiersFromModifierFlags(flag), name, [], isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getTypeOfSymbol(p), p), /*body* / undefined, ), p.declarations?.find(isGetAccessor) || firstPropertyLikeDecl, )); } return result; } // This is an else/if as accessors and properties can't merge in TS, but might in JS // If this happens, we assume the accessor takes priority, as it imposes more constraints else if (p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)) { return setTextRange( context, createProperty( factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag), name, p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined, isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p), // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357 // interface members can't have initializers, however class members _can_ /*initializer* / undefined, ), p.declarations?.find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl, ); } if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) { const type = getTypeOfSymbol(p); const signatures = getSignaturesOfType(type, SignatureKind.Call); if (flag & ModifierFlags.Private) { return setTextRange( context, createProperty( factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag), name, p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined, /*type* / undefined, /*initializer* / undefined, ), p.declarations?.find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0], ); } const results = []; for (const sig of signatures) { // Each overload becomes a separate method declaration, in order const decl = signatureToSignatureDeclarationHelper( sig, methodKind, context, { name, questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined, modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : undefined, }, ); const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration; results.push(setTextRange(context, decl, location)); } return results as unknown as T[]; } // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static return Debug.fail(`Unhandled class member kind! ${(p as any).__debugFlags || p.flags}`); } */ TODO
			}
			serializePropertySymbolForInterface := func(p Symbol, baseType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ any {
				return serializePropertySymbolForInterfaceWorker(p, false, baseType)
			}
			serializeSignatures := func(kind SignatureKind, input Type, baseType *Type, outputKind /* TODO(TypeNode IndexedAccessType): SignatureDeclaration["kind"] */ any) /* TODO inferred type (import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").CallSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocFunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration)[] */ any {
				signatures := getSignaturesOfType(input, kind)
				if kind == SignatureKindConstruct {
					if !baseType && every(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
						return length(s.parameters) == 0
					}) {
						return [] /* TODO inferred type never */ any{}
					}
					if baseType {
						baseSigs := getSignaturesOfType(baseType, SignatureKindConstruct)
						if !length(baseSigs) && every(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
							return length(s.parameters) == 0
						}) {
							return [] /* TODO inferred type never */ any{}
						}
						if baseSigs.length == signatures.length {
							failed := false
							for i := 0; i < baseSigs.length; i++ {
								if !compareSignaturesIdentical(signatures[i], baseSigs[i], false, false, true, compareTypesIdentical) {
									failed = true
									break
								}
							}
							if !failed {
								return [] /* TODO inferred type never */ any{}
							}
						}
					}
					var privateProtected ModifierFlags = 0
					for _, s := range signatures {
						if s.declaration {
							privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlagsPrivate|ModifierFlagsProtected)
						}
					}
					if privateProtected {
						return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration */ any{setTextRange(context, factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(privateProtected), [] /* TODO inferred type never */ any{}, nil), signatures[0].declaration)}
					}
				}
				results := [] /* TODO inferred type never */ any{}
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, outputKind, context)
					results.push(setTextRange(context, decl, sig.declaration))
				}
				return results
			}
			serializeIndexSignatures := func(input Type, baseType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[] */ any {
				var results []IndexSignatureDeclaration = [] /* TODO inferred type never */ any{}
				for _, info := range getIndexInfosOfType(input) {
					if baseType {
						baseInfo := getIndexInfoOfType(baseType, info.keyType)
						if baseInfo {
							if isTypeIdenticalTo(info.type_, baseInfo.type_) {
								continue
							}
						}
					}
					results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, nil))
				}
				return results
			}
			serializeBaseType := func(t Type, staticType Type, rootName string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ any {
				ref := trySerializeAsTypeReference(t, SymbolFlagsValue)
				if ref {
					return ref
				}
				tempName := getUnusedName( /* TODO(Node TemplateExpression): `${rootName}_base` */ TODO)
				statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclaration */ any{factory.createVariableDeclaration(tempName, nil, typeToTypeNodeHelper(staticType, context))}, NodeFlagsConst))
				addResult(statement, ModifierFlagsNone)
				return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName), nil)
			}
			trySerializeAsTypeReference := func(t Type, flags SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ any {
				var typeArgs *[]TypeNode
				var reference *Expression
				if (t).target && isSymbolAccessibleByFlags((t).target.symbol, enclosingDeclaration, flags) {
					typeArgs = map_(getTypeArguments(t), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
						return typeToTypeNodeHelper(t, context)
					})
					reference = symbolToExpression((t).target.symbol, context, SymbolFlagsType)
				} else if t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags) {
					reference = symbolToExpression(t.symbol, context, SymbolFlagsType)
				}
				if reference {
					return factory.createExpressionWithTypeArguments(reference, typeArgs)
				}
			}
			serializeImplementedType := func(t Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ any {
				ref := trySerializeAsTypeReference(t, SymbolFlagsType)
				if ref {
					return ref
				}
				if t.symbol {
					return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, SymbolFlagsType), nil)
				}
			}
			getUnusedName := func(input string, symbol Symbol) string {
				id := /* TODO(Node ConditionalExpression): symbol ? getSymbolId(symbol) : undefined */ TODO
				if id {
					if context.remappedSymbolNames.has(id) {
						return context.remappedSymbolNames.get(id)
					}
				}
				if symbol {
					input = getNameCandidateWorker(symbol, input)
				}
				i := 0
				original := input
				for context.usedSymbolNames. /*?*/ has(input) {
					i++
					input = /* TODO(Node TemplateExpression): `${original}_${i}` */ TODO
				}
				context.usedSymbolNames. /*?*/ add(input)
				if id {
					context.remappedSymbolNames.set(id, input)
				}
				return input
			}
			getNameCandidateWorker := func(symbol Symbol, localName string) /* TODO inferred type string */ any {
				if localName == InternalSymbolNameDefault || localName == InternalSymbolNameClass || localName == InternalSymbolNameFunction {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsInInitialEntityName
					nameCandidate := getNameOfSymbolAsWritten(symbol, context)
					restoreFlags()
					localName = /* TODO(Node ConditionalExpression): nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate */ TODO
				}
				if localName == InternalSymbolNameDefault {
					localName = "_default"
				} else if localName == InternalSymbolNameExportEquals {
					localName = "_exports"
				}
				localName = /* TODO(Node ConditionalExpression): isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-z0-9]/gi, "_") */ TODO
				return localName
			}
			getInternalSymbolName := func(symbol Symbol, localName string) /* TODO inferred type string */ any {
				id := getSymbolId(symbol)
				if context.remappedSymbolNames.has(id) {
					return context.remappedSymbolNames.get(id)
				}
				localName = getNameCandidateWorker(symbol, localName)
				context.remappedSymbolNames.set(id, localName)
				return localName
			}
		}
	}
	typePredicateToString := func(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
		// converted from conditional expression
		switch {
		case writer:
			return typePredicateToStringWorker(writer).getText()
		default:
			return usingSingleLineStringWriter(typePredicateToStringWorker)
		}
		typePredicateToStringWorker := func(writer EmitTextWriter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ any {
			nodeBuilderFlags := toNodeBuilderFlags(flags) | NodeBuilderFlagsIgnoreErrors | NodeBuilderFlagsWriteTypeParametersInQualifiedName
			predicate := nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)
			printer := createPrinterWithRemoveComments()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, predicate, sourceFile, writer)
			return writer
		}
	}
	formatUnionTypes := func(types []Type) []Type {
		var result []Type = [] /* TODO inferred type never */ any{}
		flags := 0
		for i := 0; i < types.length; i++ {
			t := types[i]
			flags |= t.flags
			if !(t.flags & TypeFlagsNullable) {
				if t.flags & (TypeFlagsBooleanLiteral | TypeFlagsEnumLike) {
					baseType := /* TODO(Node ConditionalExpression): t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType) */ TODO
					if baseType.flags & TypeFlagsUnion {
						count := (baseType).types.length
						if i+count <= types.length && getRegularTypeOfLiteralType(types[i+count-1]) == getRegularTypeOfLiteralType((baseType).types[count-1]) {
							result.push(baseType)
							i += count - 1
							continue
						}
					}
				}
				result.push(t)
			}
		}
		if flags & TypeFlagsNull {
			result.push(nullType)
		}
		if flags & TypeFlagsUndefined {
			result.push(undefinedType)
		}
		return result || types
	}
	visibilityToString := func(flags ModifierFlags) string {
		if flags == ModifierFlagsPrivate {
			return "private"
		}
		if flags == ModifierFlagsProtected {
			return "protected"
		}
		return "public"
	}
	getTypeAliasForTypeLiteral := func(type_ Type) *Symbol {
		if type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && type_.symbol.declarations {
			node := walkUpParenthesizedTypes(type_.symbol.declarations[0].parent)
			if isTypeAliasDeclaration(node) {
				return getSymbolOfDeclaration(node)
			}
		}
		return nil
	}
	isTopLevelInExternalModuleAugmentation := func(node Node) bool {
		return node && node.parent && node.parent.kind == SyntaxKindModuleBlock && isExternalModuleAugmentation(node.parent.parent)
	}
	isDefaultBindingContext := func(location Node) /* TODO inferred type boolean */ any {
		return location.kind == SyntaxKindSourceFile || isAmbientModule(location)
	}
	getNameOfSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext) /* TODO inferred type string | undefined */ any {
		nameType := getSymbolLinks(symbol).nameType
		if nameType {
			if nameType.flags & TypeFlagsStringOrNumberLiteral {
				name := "" + (nameType).value
				if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) {
					return /* TODO(Node TemplateExpression): `"${escapeString(name, CharacterCodes.doubleQuote)}"` */ TODO
				}
				if isNumericLiteralName(name) && startsWith(name, "-") {
					return /* TODO(Node TemplateExpression): `[${name}]` */ TODO
				}
				return name
			}
			if nameType.flags & TypeFlagsUniqueESSymbol {
				return /* TODO(Node TemplateExpression): `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]` */ TODO
			}
		}
	}
	getNameOfSymbolAsWritten := func(symbol Symbol, context NodeBuilderContext) string {
		if context. /*?*/ remappedSymbolReferences. /*?*/ has(getSymbolId(symbol)) {
			symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))
		}
		if context && symbol.escapedName == InternalSymbolNameDefault && !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope) && (!(context.flags & NodeBuilderFlagsInInitialEntityName) || !symbol.declarations || (context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) != findAncestor(context.enclosingDeclaration, isDefaultBindingContext))) {
			return "default"
		}
		if symbol.declarations && symbol.declarations.length {
			declaration := firstDefined(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ any {
				return /* TODO(Node ConditionalExpression): getNameOfDeclaration(d) ? d : undefined */ TODO
			})
			name := declaration && getNameOfDeclaration(declaration)
			if declaration && name {
				if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
					return symbolName(symbol)
				}
				if isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlagsLate) {
					nameType := getSymbolLinks(symbol).nameType
					if nameType && nameType.flags&TypeFlagsStringOrNumberLiteral {
						result := getNameOfSymbolFromNameType(symbol, context)
						if result != nil {
							return result
						}
					}
				}
				return declarationNameToString(name)
			}
			if !declaration {
				declaration = symbol.declarations[0]
			}
			if declaration.parent && declaration.parent.kind == SyntaxKindVariableDeclaration {
				return declarationNameToString((declaration.parent).name)
			}
			switch declaration.kind {
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				if context && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
					context.encounteredError = true
				}
				// converted from conditional expression
				switch {
				case declaration.kind == SyntaxKindClassExpression:
					return "(Anonymous class)"
				default:
					return "(Anonymous function)"
				}
			}
		}
		name := getNameOfSymbolFromNameType(symbol, context)
		// converted from conditional expression
		switch {
		case name != nil:
			return name
		default:
			return symbolName(symbol)
		}
	}
	isDeclarationVisible := func(node Node) bool {
		if node {
			links := getNodeLinks(node)
			if links.isVisible == nil {
				links.isVisible = !!determineIfDeclarationIsVisible()
			}
			return links.isVisible
		}
		return false
		determineIfDeclarationIsVisible := func() /* TODO inferred type boolean */ any {
			switch node.kind {
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocEnumTag:
				return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent))
			case SyntaxKindBindingElement:
				return isDeclarationVisible(node.parent.parent)
			case SyntaxKindVariableDeclaration:
				if isBindingPattern((node).name) && !((node).name).elements.length {
					return false
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindEnumDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindImportEqualsDeclaration:
				if isExternalModuleAugmentation(node) {
					return true
				}
				parent := getDeclarationContainer(node)
				if !(getCombinedModifierFlagsCached(node) & ModifierFlagsExport) && !(node.kind != SyntaxKindImportEqualsDeclaration && parent.kind != SyntaxKindSourceFile && parent.flags&NodeFlagsAmbient) {
					return isGlobalSourceFile(parent)
				}
				return isDeclarationVisible(parent)
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertySignature:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodSignature:
				if hasEffectiveModifier(node, ModifierFlagsPrivate|ModifierFlagsProtected) {
					return false
				}
				fallthrough
			case SyntaxKindConstructor:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindIndexSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindParameter:
				fallthrough // TODO: merge cases
			case SyntaxKindModuleBlock:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeLiteral:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeReference:
				fallthrough // TODO: merge cases
			case SyntaxKindArrayType:
				fallthrough // TODO: merge cases
			case SyntaxKindTupleType:
				fallthrough // TODO: merge cases
			case SyntaxKindUnionType:
				fallthrough // TODO: merge cases
			case SyntaxKindIntersectionType:
				fallthrough // TODO: merge cases
			case SyntaxKindParenthesizedType:
				fallthrough // TODO: merge cases
			case SyntaxKindNamedTupleMember:
				return isDeclarationVisible(node.parent)
			case SyntaxKindImportClause:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO: merge cases
			case SyntaxKindImportSpecifier:
				return false
			case SyntaxKindTypeParameter:
				fallthrough // TODO: merge cases
			case SyntaxKindSourceFile:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceExportDeclaration:
				return true
			case SyntaxKindExportAssignment:
				return false
			default:
				return false
			}
		}
	}
	collectLinkedAliases := func(node ModuleExportName, setVisibility bool) *[]Node {
		var exportSymbol *Symbol
		if node.kind != SyntaxKindStringLiteral && node.parent && node.parent.kind == SyntaxKindExportAssignment {
			exportSymbol = resolveName(node, node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, false)
		} else if node.parent.kind == SyntaxKindExportSpecifier {
			exportSymbol = getTargetOfExportSpecifier(node.parent, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
		var result *[]Node
		var visited *Set[number]
		if exportSymbol {
			visited = /* TODO(Node NewExpression): new Set() */ make(map[any]struct{})
			visited.add(getSymbolId(exportSymbol))
			buildVisibleNodeList(exportSymbol.declarations)
		}
		return result
		buildVisibleNodeList := func(declarations *[]Declaration) {
			forEach(declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
				resultNode := getAnyImportSyntax(declaration) || declaration
				if setVisibility {
					getNodeLinks(declaration).isVisible = true
				} else {
					result = result || [] /* TODO inferred type never */ any{}
					pushIfUnique(result, resultNode)
				}
				if isInternalModuleImportEqualsDeclaration(declaration) {
					internalModuleReference := declaration.moduleReference
					firstIdentifier := getFirstIdentifier(internalModuleReference)
					importSymbol := resolveName(declaration, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, nil, false)
					if importSymbol && visited {
						if tryAddToSet(visited, getSymbolId(importSymbol)) {
							buildVisibleNodeList(importSymbol.declarations)
						}
					}
				}
			})
		}
	}
	pushTypeResolution := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		resolutionCycleStartIndex := findResolutionCycleStartIndex(target, propertyName)
		if resolutionCycleStartIndex >= 0 {
			TODO_IDENTIFIER := resolutionTargets
			for i := resolutionCycleStartIndex; i < length; i++ {
				resolutionResults[i] = false
			}
			return false
		}
		resolutionTargets.push(target)
		resolutionResults.push(true)
		resolutionPropertyNames.push(propertyName)
		return true
	}
	findResolutionCycleStartIndex := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
		for i := resolutionTargets.length - 1; i >= resolutionStart; i-- {
			if resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i]) {
				return -1
			}
			if resolutionTargets[i] == target && resolutionPropertyNames[i] == propertyName {
				return i
			}
		}
		return -1
	}
	resolutionTargetHasProperty := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		switch propertyName {
		case TypeSystemPropertyNameType:
			return !!getSymbolLinks(target).type_
		case TypeSystemPropertyNameDeclaredType:
			return !!getSymbolLinks(target).declaredType
		case TypeSystemPropertyNameResolvedBaseConstructorType:
			return !!(target).resolvedBaseConstructorType
		case TypeSystemPropertyNameResolvedReturnType:
			return !!(target).resolvedReturnType
		case TypeSystemPropertyNameImmediateBaseConstraint:
			return !!(target).immediateBaseConstraint
		case TypeSystemPropertyNameResolvedTypeArguments:
			return !!(target).resolvedTypeArguments
		case TypeSystemPropertyNameResolvedBaseTypes:
			return !!(target).baseTypesResolved
		case TypeSystemPropertyNameWriteType:
			return !!getSymbolLinks(target).writeType
		case TypeSystemPropertyNameParameterInitializerContainsUndefined:
			return getNodeLinks(target).parameterInitializerContainsUndefined != nil
		}
		return Debug.assertNever(propertyName)
	}
	popTypeResolution := func() bool {
		resolutionTargets.pop()
		resolutionPropertyNames.pop()
		return resolutionResults.pop()
	}
	getDeclarationContainer := func(node Node) Node {
		return findAncestor(getRootDeclaration(node), func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			switch node.kind {
			case SyntaxKindVariableDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindVariableDeclarationList:
				fallthrough // TODO: merge cases
			case SyntaxKindImportSpecifier:
				fallthrough // TODO: merge cases
			case SyntaxKindNamedImports:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO: merge cases
			case SyntaxKindImportClause:
				return false
			default:
				return true
			}
		}).parent
	}
	getTypeOfPrototypeProperty := func(prototype Symbol) Type {
		classType := getDeclaredTypeOfSymbol(getParentOfSymbol(prototype))
		// converted from conditional expression
		switch {
		case classType.typeParameters:
			return createTypeReference(classType, map_(classType.typeParameters, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
				return anyType
			}))
		default:
			return classType
		}
	}
	getTypeOfPropertyOfType := func(type_ Type, name __String) *Type {
		prop := getPropertyOfType(type_, name)
		// converted from conditional expression
		switch {
		case prop:
			return getTypeOfSymbol(prop)
		default:
			return nil
		}
	}
	getTypeOfPropertyOrIndexSignatureOfType := func(type_ Type, name __String) *Type {
		var propType TODO
		return getTypeOfPropertyOfType(type_, name) || ( /* TODO(Node BinaryExpression): propType = getApplicableIndexInfoForName(type, name)?.type */ TODO) && addOptionality(propType, true, true)
	}
	isTypeAny := func(type_ *Type) /* TODO inferred type boolean | undefined */ any {
		return type_ && (type_.flags&TypeFlagsAny) != 0
	}
	isErrorType := func(type_ Type) /* TODO inferred type boolean */ any {
		return type_ == errorType || !!(type_.flags&TypeFlagsAny && type_.aliasSymbol)
	}
	getTypeForBindingElementParent := func(node BindingElementGrandparent, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if checkMode != CheckModeNormal {
			return getTypeForVariableLikeDeclaration(node, false, checkMode)
		}
		symbol := getSymbolOfDeclaration(node)
		return symbol && getSymbolLinks(symbol).type_ || getTypeForVariableLikeDeclaration(node, false, checkMode)
	}
	getRestType := func(source Type, properties []PropertyName, symbol *Symbol) Type {
		source = filterType(source, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !(t.flags & TypeFlagsNullable)
		})
		if source.flags & TypeFlagsNever {
			return emptyObjectType
		}
		if source.flags & TypeFlagsUnion {
			return mapType(source, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getRestType(t, properties, symbol)
			})
		}
		omitKeyType := getUnionType(map_(properties, getLiteralTypeFromPropertyName))
		var spreadableProperties []Symbol = [] /* TODO inferred type never */ any{}
		var unspreadableToRestKeys []Type = [] /* TODO inferred type never */ any{}
		for _, prop := range getPropertiesOfType(source) {
			literalTypeFromProperty := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
			if !isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected)) && isSpreadableProperty(prop) {
				spreadableProperties.push(prop)
			} else {
				unspreadableToRestKeys.push(literalTypeFromProperty)
			}
		}
		if isGenericObjectType(source) || isGenericIndexType(omitKeyType) {
			if unspreadableToRestKeys.length {
				omitKeyType = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{omitKeyType /* TODO(Node SpreadElement): ...unspreadableToRestKeys */})
			}
			if omitKeyType.flags & TypeFlagsNever {
				return source
			}
			omitTypeAlias := getGlobalOmitSymbol()
			if !omitTypeAlias {
				return errorType
			}
			return getTypeAliasInstantiation(omitTypeAlias, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{source, omitKeyType})
		}
		members := createSymbolTable()
		for _, prop := range spreadableProperties {
			members.set(prop.escapedName, getSpreadSymbol(prop, false))
		}
		result := createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source))
		result.objectFlags |= ObjectFlagsObjectRestType
		return result
	}
	isGenericTypeWithUndefinedConstraint := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags & TypeFlagsInstantiable) && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsUndefined)
	}
	getNonUndefinedType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		typeOrConstraint := /* TODO(Node ConditionalExpression): someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type */ TODO
		return getTypeWithFacts(typeOrConstraint, TypeFactsNEUndefined)
	}
	getFlowTypeOfDestructuring := func(node /* TODO(TypeNode UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		reference := getSyntheticElementAccess(node)
		// converted from conditional expression
		switch {
		case reference:
			return getFlowTypeOfReference(reference, declaredType)
		default:
			return declaredType
		}
	}
	getSyntheticElementAccess := func(node /* TODO(TypeNode UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
		parentAccess := getParentElementAccess(node)
		if parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode {
			propName := getDestructuringPropertyName(node)
			if propName {
				literal := setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node)
				lhsExpr := /* TODO(Node ConditionalExpression): isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess) */ TODO
				result := setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node)
				setParent(literal, result)
				setParent(result, node)
				if lhsExpr != parentAccess {
					setParent(lhsExpr, result)
				}
				result.flowNode = parentAccess.flowNode
				return result
			}
		}
	}
	getParentElementAccess := func(node /* TODO(TypeNode UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ any {
		ancestor := node.parent.parent
		switch ancestor.kind {
		case SyntaxKindBindingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAssignment:
			return getSyntheticElementAccess(ancestor)
		case SyntaxKindArrayLiteralExpression:
			return getSyntheticElementAccess(node.parent)
		case SyntaxKindVariableDeclaration:
			return (ancestor).initializer
		case SyntaxKindBinaryExpression:
			return (ancestor).right
		}
	}
	getDestructuringPropertyName := func(node /* TODO(TypeNode UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO inferred type string | undefined */ any {
		parent := node.parent
		if node.kind == SyntaxKindBindingElement && parent.kind == SyntaxKindObjectBindingPattern {
			return getLiteralPropertyNameText((node).propertyName || (node).name)
		}
		if node.kind == SyntaxKindPropertyAssignment || node.kind == SyntaxKindShorthandPropertyAssignment {
			return getLiteralPropertyNameText((node).name)
		}
		return "" + ((parent).elements).indexOf(node)
	}
	getLiteralPropertyNameText := func(name PropertyName) /* TODO inferred type string | undefined */ any {
		type_ := getLiteralTypeFromPropertyName(name)
		// converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsStringLiteral | TypeFlagsNumberLiteral):
			return "" + (type_).value
		default:
			return nil
		}
	}
	getTypeForBindingElement := func(declaration BindingElement) *Type {
		checkMode := /* TODO(Node ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
		parentType := getTypeForBindingElementParent(declaration.parent.parent, checkMode)
		return parentType && getBindingElementTypeFromParentType(declaration, parentType, false)
	}
	getBindingElementTypeFromParentType := func(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
		if isTypeAny(parentType) {
			return parentType
		}
		pattern := declaration.parent
		if strictNullChecks && declaration.flags&NodeFlagsAmbient && isPartOfParameterDeclaration(declaration) {
			parentType = getNonNullableType(parentType)
		} else if strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFactsEQUndefined)) {
			parentType = getTypeWithFacts(parentType, TypeFactsNEUndefined)
		}
		accessFlags := AccessFlagsExpressionPosition | ( /* TODO(Node ConditionalExpression): noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.AllowMissing : 0 */ TODO)
		var type_ *Type
		if pattern.kind == SyntaxKindObjectBindingPattern {
			if declaration.dotDotDotToken {
				parentType = getReducedType(parentType)
				if parentType.flags&TypeFlagsUnknown || !isValidSpreadType(parentType) {
					error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types)
					return errorType
				}
				var literalMembers []PropertyName = [] /* TODO inferred type never */ any{}
				for _, element := range pattern.elements {
					if !element.dotDotDotToken {
						literalMembers.push(element.propertyName || element.name)
					}
				}
				type_ = getRestType(parentType, literalMembers, declaration.symbol)
			} else {
				name := declaration.propertyName || declaration.name
				indexType := getLiteralTypeFromPropertyName(name)
				declaredType := getIndexedAccessType(parentType, indexType, accessFlags, name)
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			}
		} else {
			elementType := checkIteratedTypeOrElementType(IterationUseDestructuring|( /* TODO(Node ConditionalExpression): declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds */ TODO), parentType, undefinedType, pattern)
			index := pattern.elements.indexOf(declaration)
			if declaration.dotDotDotToken {
				baseConstraint := mapType(parentType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.InstantiableNonPrimitive ? getBaseConstraintOrType(t) : t */ TODO
				})
				type_ = /* TODO(Node ConditionalExpression): everyType(baseConstraint, isTupleType) ? mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) : createArrayType(elementType) */ TODO
			} else if isArrayLikeType(parentType) {
				indexType := getNumberLiteralType(index)
				declaredType := getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			} else {
				type_ = elementType
			}
		}
		if !declaration.initializer {
			return type_
		}
		if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
			// converted from conditional expression
			switch {
			case strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined)):
				return getNonUndefinedType(type_)
			default:
				return type_
			}
		}
		return widenTypeInferredFromInitializer(declaration, getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getNonUndefinedType(type_), checkDeclarationInitializer(declaration, CheckModeNormal)}, UnionReductionSubtype))
	}
	getTypeForDeclarationFromJSDocComment := func(declaration Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		jsdocType := getJSDocType(declaration)
		if jsdocType {
			return getTypeFromTypeNode(jsdocType)
		}
		return nil
	}
	isNullOrUndefined := func(node Expression) /* TODO inferred type boolean */ any {
		expr := skipParentheses(node, true)
		return expr.kind == SyntaxKindNullKeyword || expr.kind == SyntaxKindIdentifier && getResolvedSymbol(expr) == undefinedSymbol
	}
	isEmptyArrayLiteral := func(node Expression) /* TODO inferred type boolean */ any {
		expr := skipParentheses(node, true)
		return expr.kind == SyntaxKindArrayLiteralExpression && (expr).elements.length == 0
	}
	addOptionality := func(type_ Type, isProperty /* TODO inferred type boolean */ any /*  = false */, isOptional /* TODO inferred type boolean */ any /*  = true */) Type {
		// converted from conditional expression
		switch {
		case strictNullChecks && isOptional:
			return getOptionalType(type_, isProperty)
		default:
			return type_
		}
	}
	getTypeForVariableLikeDeclaration := func(declaration /* TODO(TypeNode UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) *Type {
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForInStatement {
			indexType := getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, checkMode)))
			// converted from conditional expression
			switch {
			case indexType.flags & (TypeFlagsTypeParameter | TypeFlagsIndex):
				return getExtractStringType(indexType)
			default:
				return stringType
			}
		}
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
			forOfStatement := declaration.parent.parent
			return checkRightHandSideOfForOf(forOfStatement) || anyType
		}
		if isBindingPattern(declaration.parent) {
			return getTypeForBindingElement(declaration)
		}
		isProperty := (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration)
		isOptional := includeOptionality && isOptionalDeclaration(declaration)
		declaredType := tryGetTypeFromEffectiveTypeNode(declaration)
		if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
			if declaredType {
				// converted from conditional expression
				switch {
				case isTypeAny(declaredType) || declaredType == unknownType:
					return declaredType
				default:
					return errorType
				}
			}
			// converted from conditional expression
			switch {
			case useUnknownInCatchVariables:
				return unknownType
			default:
				return anyType
			}
		}
		if declaredType {
			return addOptionality(declaredType, isProperty, isOptional)
		}
		if (noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) && !(getCombinedModifierFlagsCached(declaration) & ModifierFlagsExport) && !(declaration.flags & NodeFlagsAmbient) {
			if !(getCombinedNodeFlagsCached(declaration) & NodeFlagsConstant) && (!declaration.initializer || isNullOrUndefined(declaration.initializer)) {
				return autoType
			}
			if declaration.initializer && isEmptyArrayLiteral(declaration.initializer) {
				return autoArrayType
			}
		}
		if isParameter(declaration) {
			if !declaration.symbol {
				return
			}
			func_ := declaration.parent
			if func_.kind == SyntaxKindSetAccessor && hasBindableName(func_) {
				getter := getDeclarationOfKind(getSymbolOfDeclaration(declaration.parent), SyntaxKindGetAccessor)
				if getter {
					getterSignature := getSignatureFromDeclaration(getter)
					thisParameter := getAccessorThisParameter(func_)
					if thisParameter && declaration == thisParameter {
						Debug.assert(!thisParameter.type_)
						return getTypeOfSymbol(getterSignature.thisParameter)
					}
					return getReturnTypeOfSignature(getterSignature)
				}
			}
			parameterTypeOfTypeTag := getParameterTypeOfTypeTag(func_, declaration)
			if parameterTypeOfTypeTag {
				return parameterTypeOfTypeTag
			}
			type_ := /* TODO(Node ConditionalExpression): declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration) */ TODO
			if type_ {
				return addOptionality(type_, false, isOptional)
			}
		}
		if hasOnlyExpressionInitializer(declaration) && !!declaration.initializer {
			if isInJSFile(declaration) && !isParameter(declaration) {
				containerObjectType := getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
				if containerObjectType {
					return containerObjectType
				}
			}
			type_ := widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode))
			return addOptionality(type_, isProperty, isOptional)
		}
		if isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration)) {
			if !hasStaticModifier(declaration) {
				constructor := findConstructorDeclaration(declaration.parent)
				type_ := /* TODO(Node ConditionalExpression): constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) : getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) : undefined */ TODO
				return type_ && addOptionality(type_, true, isOptional)
			} else {
				staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
				type_ := /* TODO(Node ConditionalExpression): staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) : getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) : undefined */ TODO
				return type_ && addOptionality(type_, true, isOptional)
			}
		}
		if isJsxAttribute(declaration) {
			return trueType
		}
		if isBindingPattern(declaration.name) {
			return getTypeFromBindingPattern(declaration.name, false, true)
		}
		return nil
	}
	isConstructorDeclaredProperty := func(symbol Symbol) /* TODO inferred type boolean */ any {
		if symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isConstructorDeclaredProperty == nil {
				links.isConstructorDeclaredProperty = false
				links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return isBinaryExpression(declaration) && isPossiblyAliasedThisProperty(declaration) && (declaration.left.kind != SyntaxKindElementAccessExpression || isStringOrNumericLiteralLike((declaration.left).argumentExpression)) && !getAnnotatedTypeForAssignmentDeclaration(nil, declaration, symbol, declaration)
				})
			}
			return links.isConstructorDeclaredProperty
		}
		return false
	}
	isAutoTypedProperty := func(symbol Symbol) /* TODO inferred type boolean | undefined */ any {
		declaration := symbol.valueDeclaration
		return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && !declaration.initializer && (noImplicitAny || isInJSFile(declaration))
	}
	getDeclaringConstructor := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | undefined */ any {
		if !symbol.declarations {
			return
		}
		for _, declaration := range symbol.declarations {
			container := getThisContainer(declaration, false, false)
			if container && (container.kind == SyntaxKindConstructor || isJSConstructor(container)) {
				return container
			}
		}
	}
	getFlowTypeFromCommonJSExport := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		file := getSourceFileOfNode(symbol.declarations[0])
		accessName := unescapeLeadingUnderscores(symbol.escapedName)
		areAllModuleExports := symbol.declarations.every(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
			return isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression)
		})
		reference := /* TODO(Node ConditionalExpression): areAllModuleExports ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName) : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName) */ TODO
		if areAllModuleExports {
			setParent((reference.expression).expression, reference.expression)
		}
		setParent(reference.expression, reference)
		setParent(reference, file)
		reference.flowNode = file.endFlowNode
		return getFlowTypeOfReference(reference, autoType, undefinedType)
	}
	getFlowTypeInStaticBlocks := func(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		accessName := /* TODO(Node ConditionalExpression): startsWith(symbol.escapedName as string, "__#") ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1]) : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		for _, staticBlock := range staticBlocks {
			reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
			setParent(reference.expression, reference)
			setParent(reference, staticBlock)
			reference.flowNode = staticBlock.returnFlowNode
			flowType := getFlowTypeOfProperty(reference, symbol)
			if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
				error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
			}
			if everyType(flowType, isNullableType) {
				continue
			}
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeInConstructor := func(symbol Symbol, constructor ConstructorDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		accessName := /* TODO(Node ConditionalExpression): startsWith(symbol.escapedName as string, "__#") ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1]) : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfProperty(reference, symbol)
		if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
			error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
		}
		// converted from conditional expression
		switch {
		case everyType(flowType, isNullableType):
			return nil
		default:
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeOfProperty := func(reference Node, prop *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		initialType := prop. /*?*/ valueDeclaration && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration)&ModifierFlagsAmbient) && getTypeOfPropertyInBaseClass(prop) || undefinedType
		return getFlowTypeOfReference(reference, autoType, initialType)
	}
	getWidenedTypeForAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		container := getAssignedExpandoInitializer(symbol.valueDeclaration)
		if container {
			tag := /* TODO(Node ConditionalExpression): isInJSFile(container) ? getJSDocTypeTag(container) : undefined */ TODO
			if tag && tag.typeExpression {
				return getTypeFromTypeNode(tag.typeExpression)
			}
			containerObjectType := symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container)
			return containerObjectType || getWidenedLiteralType(checkExpressionCached(container))
		}
		var type_ TODO
		definedInConstructor := false
		definedInMethod := false
		if isConstructorDeclaredProperty(symbol) {
			type_ = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol))
		}
		if !type_ {
			var types *[]Type
			if symbol.declarations {
				var jsdocType *Type
				for _, declaration := range symbol.declarations {
					expression := /* TODO(Node ConditionalExpression): (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration : isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration : undefined */ TODO
					if !expression {
						continue
					}
					kind := /* TODO(Node ConditionalExpression): isAccessExpression(expression) ? getAssignmentDeclarationPropertyAccessKind(expression) : getAssignmentDeclarationKind(expression) */ TODO
					if kind == AssignmentDeclarationKindThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind) {
						if isDeclarationInConstructor(expression) {
							definedInConstructor = true
						} else {
							definedInMethod = true
						}
					}
					if !isCallExpression(expression) {
						jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration)
					}
					if !jsdocType {
						(types || ( /* TODO(Node BinaryExpression): types = [] */ TODO)).push( /* TODO(Node ConditionalExpression): (isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType */ TODO)
					}
				}
				type_ = jsdocType
			}
			if !type_ {
				if !length(types) {
					return errorType
				}
				constructorTypes := /* TODO(Node ConditionalExpression): definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined */ TODO
				if definedInMethod {
					propType := getTypeOfPropertyInBaseClass(symbol)
					if propType {
						(constructorTypes || ( /* TODO(Node BinaryExpression): constructorTypes = [] */ TODO)).push(propType)
						definedInConstructor = true
					}
				}
				sourceTypes := /* TODO(Node ConditionalExpression): some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types */ TODO
				type_ = getUnionType(sourceTypes)
			}
		}
		widened := getWidenedType(addOptionality(type_, false, definedInMethod && !definedInConstructor))
		if symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & ~TypeFlagsNullable)
		}) == neverType {
			reportImplicitAny(symbol.valueDeclaration, anyType)
			return anyType
		}
		return widened
	}
	getJSContainerObjectType := func(decl Node, symbol Symbol, init *Expression) *Type {
		if !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length {
			return nil
		}
		exports := createSymbolTable()
		for isBinaryExpression(decl) || isPropertyAccessExpression(decl) {
			s := getSymbolOfNode(decl)
			if s. /*?*/ exports. /*?*/ size {
				mergeSymbolTable(exports, s.exports)
			}
			decl = /* TODO(Node ConditionalExpression): isBinaryExpression(decl) ? decl.parent : decl.parent.parent */ TODO
		}
		s := getSymbolOfNode(decl)
		if s. /*?*/ exports. /*?*/ size {
			mergeSymbolTable(exports, s.exports)
		}
		type_ := createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
		type_.objectFlags |= ObjectFlagsJSLiteral
		return type_
	}
	getAnnotatedTypeForAssignmentDeclaration := func(declaredType *Type, expression Expression, symbol Symbol, declaration Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		typeNode := getEffectiveTypeAnnotationNode(expression.parent)
		if typeNode {
			type_ := getWidenedType(getTypeFromTypeNode(typeNode))
			if !declaredType {
				return type_
			} else if !isErrorType(declaredType) && !isErrorType(type_) && !isTypeIdenticalTo(declaredType, type_) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(nil, declaredType, declaration, type_)
			}
		}
		if symbol.parent. /*?*/ valueDeclaration {
			possiblyAnnotatedSymbol := getFunctionExpressionParentSymbolOrSymbol(symbol.parent)
			if possiblyAnnotatedSymbol.valueDeclaration {
				typeNode := getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration)
				if typeNode {
					annotationSymbol := getPropertyOfType(getTypeFromTypeNode(typeNode), symbol.escapedName)
					if annotationSymbol {
						return getNonMissingTypeOfSymbol(annotationSymbol)
					}
				}
			}
		}
		return declaredType
	}
	getInitializerTypeFromAssignmentDeclaration := func(symbol Symbol, resolvedSymbol *Symbol, expression /* TODO(TypeNode UnionType): BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if isCallExpression(expression) {
			if resolvedSymbol {
				return getTypeOfSymbol(resolvedSymbol)
			}
			objectLitType := checkExpressionCached((expression).arguments[2])
			valueType := getTypeOfPropertyOfType(objectLitType, "value")
			if valueType {
				return valueType
			}
			getFunc := getTypeOfPropertyOfType(objectLitType, "get")
			if getFunc {
				getSig := getSingleCallSignature(getFunc)
				if getSig {
					return getReturnTypeOfSignature(getSig)
				}
			}
			setFunc := getTypeOfPropertyOfType(objectLitType, "set")
			if setFunc {
				setSig := getSingleCallSignature(setFunc)
				if setSig {
					return getTypeOfFirstParameterOfSignature(setSig)
				}
			}
			return anyType
		}
		if containsSameNamedThisProperty(expression.left, expression.right) {
			return anyType
		}
		isDirectExport := kind == AssignmentDeclarationKindExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)))
		type_ := /* TODO(Node ConditionalExpression): resolvedSymbol ? getTypeOfSymbol(resolvedSymbol) : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right)) : getWidenedLiteralType(checkExpressionCached(expression.right)) */ TODO
		if type_.flags&TypeFlagsObject && kind == AssignmentDeclarationKindModuleExports && symbol.escapedName == InternalSymbolNameExportEquals {
			exportedType := resolveStructuredTypeMembers(type_)
			members := createSymbolTable()
			copyEntries(exportedType.members, members)
			initialSize := members.size
			if resolvedSymbol && !resolvedSymbol.exports {
				resolvedSymbol.exports = createSymbolTable()
			}
			(resolvedSymbol || symbol).exports.forEach(func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
				exportedMember := members.get(name)
				if exportedMember && exportedMember != s && !(s.flags & SymbolFlagsAlias) {
					if s.flags&SymbolFlagsValue && exportedMember.flags&SymbolFlagsValue {
						if s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) != getSourceFileOfNode(exportedMember.valueDeclaration) {
							unescapedName := unescapeLeadingUnderscores(s.escapedName)
							exportedMemberName := tryCast(exportedMember.valueDeclaration, isNamedDeclaration). /*?*/ name || exportedMember.valueDeclaration
							addRelatedInfo(error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName))
							addRelatedInfo(error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName))
						}
						union := createSymbol(s.flags|exportedMember.flags, name)
						union.links.type_ = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)})
						union.valueDeclaration = exportedMember.valueDeclaration
						union.declarations = concatenate(exportedMember.declarations, s.declarations)
						members.set(name, union)
					} else {
						members.set(name, mergeSymbol(s, exportedMember))
					}
				} else {
					members.set(name, s)
				}
			})
			result := createAnonymousType( /* TODO(Node ConditionalExpression): initialSize !== members.size ? undefined : exportedType.symbol */ TODO, members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos)
			if initialSize == members.size {
				if type_.aliasSymbol {
					result.aliasSymbol = type_.aliasSymbol
					result.aliasTypeArguments = type_.aliasTypeArguments
				}
				if getObjectFlags(type_) & ObjectFlagsReference {
					result.aliasSymbol = (type_).symbol
					args := getTypeArguments(type_)
					result.aliasTypeArguments = /* TODO(Node ConditionalExpression): length(args) ? args : undefined */ TODO
				}
			}
			result.objectFlags |= getPropagatingFlagsOfTypes([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_}) | getObjectFlags(type_)&(ObjectFlagsJSLiteral|ObjectFlagsArrayLiteral|ObjectFlagsObjectLiteral)
			if result.symbol && result.symbol.flags&SymbolFlagsClass && type_ == getDeclaredTypeOfClassOrInterface(result.symbol) {
				result.objectFlags |= ObjectFlagsIsClassInstanceClone
			}
			return result
		}
		if isEmptyArrayLiteralType(type_) {
			reportImplicitAny(expression, anyArrayType)
			return anyArrayType
		}
		return type_
	}
	containsSameNamedThisProperty := func(thisProperty Expression, expression Expression) /* TODO inferred type boolean | undefined */ any {
		return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind == SyntaxKindThisKeyword && forEachChildRecursively(expression, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return isMatchingReference(thisProperty, n)
		})
	}
	isDeclarationInConstructor := func(expression Expression) /* TODO inferred type boolean */ any {
		thisContainer := getThisContainer(expression, false, false)
		return thisContainer.kind == SyntaxKindConstructor || thisContainer.kind == SyntaxKindFunctionDeclaration || (thisContainer.kind == SyntaxKindFunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent))
	}
	getConstructorDefinedThisAssignmentTypes := func(types []Type, declarations []Declaration) *[]Type {
		Debug.assert(types.length == declarations.length)
		return types.filter(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type boolean | undefined */ any {
			declaration := declarations[i]
			expression := /* TODO(Node ConditionalExpression): isBinaryExpression(declaration) ? declaration : isBinaryExpression(declaration.parent) ? declaration.parent : undefined */ TODO
			return expression && isDeclarationInConstructor(expression)
		})
	}
	getTypeFromBindingElement := func(element BindingElement, includePatternInType bool, reportErrors bool) Type {
		if element.initializer {
			contextualType := /* TODO(Node ConditionalExpression): isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType* / true, /*reportErrors* / false) : unknownType */ TODO
			return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, CheckModeNormal, contextualType)))
		}
		if isBindingPattern(element.name) {
			return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors)
		}
		if reportErrors && !declarationBelongsToPrivateAmbientMember(element) {
			reportImplicitAny(element, anyType)
		}
		// converted from conditional expression
		switch {
		case includePatternInType:
			return nonInferrableAnyType
		default:
			return anyType
		}
	}
	getTypeFromObjectBindingPattern := func(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
		members := createSymbolTable()
		var stringIndexInfo *IndexInfo
		objectFlags := ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		forEach(pattern.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement */ any) {
			name := e.propertyName || e.name
			if e.dotDotDotToken {
				stringIndexInfo = createIndexInfo(stringType, anyType, false)
				return
			}
			exprType := getLiteralTypeFromPropertyName(name)
			if !isTypeUsableAsPropertyName(exprType) {
				objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
				return
			}
			text := getPropertyNameFromType(exprType)
			flags := SymbolFlagsProperty | ( /* TODO(Node ConditionalExpression): e.initializer ? SymbolFlags.Optional : 0 */ TODO)
			symbol := createSymbol(flags, text)
			symbol.links.type_ = getTypeFromBindingElement(e, includePatternInType, reportErrors)
			symbol.links.bindingElement = e
			members.set(symbol.escapedName, symbol)
		})
		result := createAnonymousType(nil, members, emptyArray, emptyArray /* TODO(Node ConditionalExpression): stringIndexInfo ? [stringIndexInfo] : emptyArray */, TODO)
		result.objectFlags |= objectFlags
		if includePatternInType {
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	getTypeFromArrayBindingPattern := func(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
		elements := pattern.elements
		lastElement := lastOrUndefined(elements)
		restElement := /* TODO(Node ConditionalExpression): lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined */ TODO
		if elements.length == 0 || elements.length == 1 && restElement {
			// converted from conditional expression
			switch {
			case languageVersion >= ScriptTargetES2015:
				return createIterableType(anyType)
			default:
				return anyArrayType
			}
		}
		elementTypes := map_(elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors) */ TODO
		})
		minLength := findLastIndex(elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ any) /* TODO inferred type boolean */ any {
			return !(e == restElement || isOmittedExpression(e) || hasDefaultValue(e))
		}, elements.length-1) + 1
		elementFlags := map_(elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest */ any {
			return /* TODO(Node ConditionalExpression): e === restElement ? ElementFlags.Rest : i >= minLength ? ElementFlags.Optional : ElementFlags.Required */ TODO
		})
		result := createTupleType(elementTypes, elementFlags)
		if includePatternInType {
			result = cloneTypeReference(result)
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	getTypeFromBindingPattern := func(pattern BindingPattern, includePatternInType /* TODO inferred type boolean */ any /*  = false */, reportErrors /* TODO inferred type boolean */ any /*  = false */) Type {
		if includePatternInType {
			contextualBindingPatterns.push(pattern)
		}
		result := /* TODO(Node ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors) : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) */ TODO
		if includePatternInType {
			contextualBindingPatterns.pop()
		}
		return result
	}
	getWidenedTypeForVariableLikeDeclaration := func(declaration /* TODO(TypeNode UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
		return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, true, CheckModeNormal), declaration, reportErrors)
	}
	getTypeFromImportAttributes := func(node ImportAttributes) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			symbol := createSymbol(SymbolFlagsObjectLiteral, InternalSymbolNameImportAttributes)
			members := createSymbolTable()
			forEach(node.elements, func(attr /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportAttribute */ any) {
				member := createSymbol(SymbolFlagsProperty, getNameFromImportAttribute(attr))
				member.parent = symbol
				member.links.type_ = checkImportAttribute(attr)
				member.links.target = member
				members.set(member.escapedName, member)
			})
			type_ := createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
			type_.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsNonInferrableType
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	isGlobalSymbolConstructor := func(node Node) /* TODO inferred type boolean | undefined */ any {
		symbol := getSymbolOfNode(node)
		globalSymbol := getGlobalESSymbolConstructorTypeSymbol(false)
		return globalSymbol && symbol && symbol == globalSymbol
	}
	widenTypeForVariableLikeDeclaration := func(type_ *Type, declaration any, reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if type_ {
			if type_.flags&TypeFlagsESSymbol && isGlobalSymbolConstructor(declaration.parent) {
				type_ = getESSymbolLikeTypeForNode(declaration)
			}
			if reportErrors {
				reportErrorsFromWidening(declaration, type_)
			}
			if type_.flags&TypeFlagsUniqueESSymbol && (isBindingElement(declaration) || !declaration.type_) && type_.symbol != getSymbolOfDeclaration(declaration) {
				type_ = esSymbolType
			}
			return getWidenedType(type_)
		}
		type_ = /* TODO(Node ConditionalExpression): isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType */ TODO
		if reportErrors {
			if !declarationBelongsToPrivateAmbientMember(declaration) {
				reportImplicitAny(declaration, type_)
			}
		}
		return type_
	}
	declarationBelongsToPrivateAmbientMember := func(declaration VariableLikeDeclaration) /* TODO inferred type boolean */ any {
		root := getRootDeclaration(declaration)
		memberDeclaration := /* TODO(Node ConditionalExpression): root.kind === SyntaxKind.Parameter ? root.parent : root */ TODO
		return isPrivateWithinAmbient(memberDeclaration)
	}
	tryGetTypeFromEffectiveTypeNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		typeNode := getEffectiveTypeAnnotationNode(node)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
	}
	isParameterOfContextSensitiveSignature := func(symbol Symbol) /* TODO inferred type boolean */ any {
		decl := symbol.valueDeclaration
		if !decl {
			return false
		}
		if isBindingElement(decl) {
			decl = walkUpBindingElementsAndPatterns(decl)
		}
		if isParameter(decl) {
			return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent)
		}
		return false
	}
	getTypeOfVariableOrParameterOrProperty := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			type_ := getTypeOfVariableOrParameterOrPropertyWorker(symbol)
			if !links.type_ && !isParameterOfContextSensitiveSignature(symbol) {
				links.type_ = type_
			}
			return type_
		}
		return links.type_
	}
	getTypeOfVariableOrParameterOrPropertyWorker := func(symbol Symbol) Type {
		if symbol.flags & SymbolFlagsPrototype {
			return getTypeOfPrototypeProperty(symbol)
		}
		if symbol == requireSymbol {
			return anyType
		}
		if symbol.flags&SymbolFlagsModuleExports && symbol.valueDeclaration {
			fileSymbol := getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration))
			result := createSymbol(fileSymbol.flags, "exports")
			result.declarations = /* TODO(Node ConditionalExpression): fileSymbol.declarations ? fileSymbol.declarations.slice() : [] */ TODO
			result.parent = symbol
			result.links.target = fileSymbol
			if fileSymbol.valueDeclaration {
				result.valueDeclaration = fileSymbol.valueDeclaration
			}
			if fileSymbol.members {
				result.members = /* TODO(Node NewExpression): new Map(fileSymbol.members) */ TODO
			}
			if fileSymbol.exports {
				result.exports = /* TODO(Node NewExpression): new Map(fileSymbol.exports) */ TODO
			}
			members := createSymbolTable()
			members.set("exports", result)
			return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		Debug.assertIsDefined(symbol.valueDeclaration)
		declaration := symbol.valueDeclaration
		if isSourceFile(declaration) && isJsonSourceFile(declaration) {
			if !declaration.statements.length {
				return emptyObjectType
			}
			return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)))
		}
		if isAccessor(declaration) {
			return getTypeOfAccessors(symbol)
		}
		if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		var type_ Type
		if declaration.kind == SyntaxKindExportAssignment {
			type_ = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration).expression), declaration)
		} else if isBinaryExpression(declaration) || (isInJSFile(declaration) && (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) {
			type_ = getWidenedTypeForAssignmentDeclaration(symbol)
		} else if isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration)) || isMethodSignature(declaration) || isSourceFile(declaration) {
			if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			type_ = /* TODO(Node ConditionalExpression): isBinaryExpression(declaration.parent) ? getWidenedTypeForAssignmentDeclaration(symbol) : tryGetTypeFromEffectiveTypeNode(declaration) || anyType */ TODO
		} else if isPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration)
		} else if isJsxAttribute(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration)
		} else if isShorthandPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckModeNormal)
		} else if isObjectLiteralMethod(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckModeNormal)
		} else if isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration) {
			type_ = getWidenedTypeForVariableLikeDeclaration(declaration, true)
		} else if isEnumDeclaration(declaration) {
			type_ = getTypeOfFuncClassEnumModule(symbol)
		} else if isEnumMember(declaration) {
			type_ = getTypeOfEnumMember(symbol)
		} else {
			return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol))
		}
		if !popTypeResolution() {
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		return type_
	}
	getAnnotatedAccessorTypeNode := func(accessor /* TODO(TypeNode UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
		if accessor {
			switch accessor.kind {
			case SyntaxKindGetAccessor:
				getterTypeAnnotation := getEffectiveReturnTypeNode(accessor)
				return getterTypeAnnotation
			case SyntaxKindSetAccessor:
				setterTypeAnnotation := getEffectiveSetAccessorTypeAnnotationNode(accessor)
				return setterTypeAnnotation
			case SyntaxKindPropertyDeclaration:
				Debug.assert(hasAccessorModifier(accessor))
				accessorTypeAnnotation := getEffectiveTypeAnnotationNode(accessor)
				return accessorTypeAnnotation
			}
		}
		return nil
	}
	getAnnotatedAccessorType := func(accessor /* TODO(TypeNode UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *Type {
		node := getAnnotatedAccessorTypeNode(accessor)
		return node && getTypeFromTypeNode(node)
	}
	getAnnotatedAccessorThisParameter := func(accessor AccessorDeclaration) *Symbol {
		parameter := getAccessorThisParameter(accessor)
		return parameter && parameter.symbol
	}
	getThisTypeOfDeclaration := func(declaration SignatureDeclaration) *Type {
		return getThisTypeOfSignature(getSignatureFromDeclaration(declaration))
	}
	getTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
			setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
			accessor := tryCast(getDeclarationOfKind(symbol, SyntaxKindPropertyDeclaration), isAutoAccessorPropertyDeclaration)
			type_ := getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) || getAnnotatedAccessorType(getter) || getAnnotatedAccessorType(setter) || getAnnotatedAccessorType(accessor) || getter && getter.body && getReturnTypeFromBody(getter) || accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor, true)
			if !type_ {
				if setter && !isPrivateWithinAmbient(setter) {
					errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol))
				} else if getter && !isPrivateWithinAmbient(getter) {
					errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol))
				} else if accessor && !isPrivateWithinAmbient(accessor) {
					errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any")
				}
				type_ = anyType
			}
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(getter) {
					error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(accessor) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getter && noImplicitAny {
					error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol))
				}
				type_ = anyType
			}
			/* TODO(Node BinaryExpression): links.type ??= type */ TODO
		}
		return links.type_
	}
	getWriteTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.writeType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameWriteType) {
				return errorType
			}
			setter := /* TODO(Node BinaryExpression): getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor) ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
			writeType := getAnnotatedAccessorType(setter)
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				}
				writeType = anyType
			}
			/* TODO(Node BinaryExpression): links.writeType ??= writeType || getTypeOfAccessors(symbol) */ TODO
		}
		return links.writeType
	}
	getBaseTypeVariableOfClass := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		baseConstructorType := getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol))
		// converted from conditional expression
		switch {
		case baseConstructorType.flags & TypeFlagsTypeVariable:
			return baseConstructorType
		case baseConstructorType.flags & TypeFlagsIntersection:
			return find((baseConstructorType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !!(t.flags & TypeFlagsTypeVariable)
			})
		default:
			return nil
		}
	}
	getTypeOfFuncClassEnumModule := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.type_ {
			expando := symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, false)
			if expando {
				merged := mergeJSSymbols(symbol, expando)
				if merged {
					symbol = merged
					links = merged.links
				}
			}
			originalLinks.type_ = /* TODO(Node BinaryExpression): links.type = getTypeOfFuncClassEnumModuleWorker(symbol) */ TODO
		}
		return links.type_
	}
	getTypeOfFuncClassEnumModuleWorker := func(symbol Symbol) Type {
		declaration := symbol.valueDeclaration
		if symbol.flags&SymbolFlagsModule && isShorthandAmbientModuleSymbol(symbol) {
			return anyType
		} else if declaration && (declaration.kind == SyntaxKindBinaryExpression || isAccessExpression(declaration) && declaration.parent.kind == SyntaxKindBinaryExpression) {
			return getWidenedTypeForAssignmentDeclaration(symbol)
		} else if symbol.flags&SymbolFlagsValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator {
			resolvedModule := resolveExternalModuleSymbol(symbol)
			if resolvedModule != symbol {
				if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
					return errorType
				}
				exportEquals := getMergedSymbol(symbol.exports.get(InternalSymbolNameExportEquals))
				type_ := getWidenedTypeForAssignmentDeclaration(exportEquals /* TODO(Node ConditionalExpression): exportEquals === resolvedModule ? undefined : resolvedModule */, TODO)
				if !popTypeResolution() {
					return reportCircularityError(symbol)
				}
				return type_
			}
		}
		type_ := createObjectType(ObjectFlagsAnonymous, symbol)
		if symbol.flags & SymbolFlagsClass {
			baseTypeVariable := getBaseTypeVariableOfClass(symbol)
			// converted from conditional expression
			switch {
			case baseTypeVariable:
				return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, baseTypeVariable})
			default:
				return type_
			}
		} else {
			// converted from conditional expression
			switch {
			case strictNullChecks && symbol.flags&SymbolFlagsOptional:
				return getOptionalType(type_, true)
			default:
				return type_
			}
		}
	}
	getTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(Node BinaryExpression): links.type = getDeclaredTypeOfEnumMember(symbol) */ TODO)
	}
	getTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			targetSymbol := resolveAlias(symbol)
			exportSymbol := symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol), true)
			declaredType := firstDefined(exportSymbol. /*?*/ declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
				return /* TODO(Node ConditionalExpression): isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : undefined */ TODO
			})
			/* TODO(Node BinaryExpression): links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol) : isDuplicatedCommonJSExport(symbol.declarations) ? autoType : declaredType ? declaredType : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol) : errorType */ TODO
			if !popTypeResolution() {
				reportCircularityError( /* TODO(Node BinaryExpression): exportSymbol ?? symbol */ TODO)
				return /* TODO(Node BinaryExpression): links.type ??= errorType */ TODO
			}
		}
		return links.type_
	}
	getTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(Node BinaryExpression): links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	getWriteTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.writeType || ( /* TODO(Node BinaryExpression): links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	reportCircularityError := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
		declaration := symbol.valueDeclaration
		if declaration {
			if getEffectiveTypeAnnotationNode(declaration) {
				error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				return errorType
			}
			if noImplicitAny && (declaration.kind != SyntaxKindParameter || (declaration).initializer) {
				error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol))
			}
		} else if symbol.flags & SymbolFlagsAlias {
			node := getDeclarationOfAliasSymbol(symbol)
			if node {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		}
		return anyType
	}
	getTypeOfSymbolWithDeferredType := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			links.type_ = /* TODO(Node ConditionalExpression): links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents) */ TODO
		}
		return links.type_
	}
	getWriteTypeOfSymbolWithDeferredType := func(symbol Symbol) *Type {
		links := getSymbolLinks(symbol)
		if !links.writeType && links.deferralWriteConstituents {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			links.writeType = /* TODO(Node ConditionalExpression): links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents) */ TODO
		}
		return links.writeType
	}
	getWriteTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if symbol.flags & SymbolFlagsProperty {
			// converted from conditional expression
			switch {
			case checkFlags & CheckFlagsSyntheticProperty:
				// converted from conditional expression
				switch {
				case checkFlags & CheckFlagsDeferredType:
					return getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol)
				default:
					return (symbol).links.writeType || (symbol).links.type_
				}
			default:
				return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
			}
		}
		if symbol.flags & SymbolFlagsAccessor {
			// converted from conditional expression
			switch {
			case checkFlags & CheckFlagsInstantiated:
				return getWriteTypeOfInstantiatedSymbol(symbol)
			default:
				return getWriteTypeOfAccessors(symbol)
			}
		}
		return getTypeOfSymbol(symbol)
	}
	getTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if checkFlags & CheckFlagsDeferredType {
			return getTypeOfSymbolWithDeferredType(symbol)
		}
		if checkFlags & CheckFlagsInstantiated {
			return getTypeOfInstantiatedSymbol(symbol)
		}
		if checkFlags & CheckFlagsMapped {
			return getTypeOfMappedSymbol(symbol)
		}
		if checkFlags & CheckFlagsReverseMapped {
			return getTypeOfReverseMappedSymbol(symbol)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			return getTypeOfVariableOrParameterOrProperty(symbol)
		}
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
			return getTypeOfFuncClassEnumModule(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAccessor {
			return getTypeOfAccessors(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getTypeOfAlias(symbol)
		}
		return errorType
	}
	getNonMissingTypeOfSymbol := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
	}
	isReferenceToSomeType := func(type_ Type, targets []Type) /* TODO inferred type boolean */ any {
		if type_ == nil || (getObjectFlags(type_)&ObjectFlagsReference) == 0 {
			return false
		}
		for _, target := range targets {
			if (type_).target == target {
				return true
			}
		}
		return false
	}
	isReferenceToType := func(type_ Type, target Type) /* TODO inferred type boolean */ any {
		return type_ != nil && target != nil && (getObjectFlags(type_)&ObjectFlagsReference) != 0 && (type_).target == target
	}
	getTargetType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsReference:
			return (type_).target
		default:
			return type_
		}
	}
	hasBaseType := func(type_ Type, checkBase *Type) /* TODO inferred type boolean */ any {
		return check(type_)
		check := func(type_ Type) bool {
			if getObjectFlags(type_) & (ObjectFlagsClassOrInterface | ObjectFlagsReference) {
				target := getTargetType(type_)
				return target == checkBase || some(getBaseTypes(target), check)
			} else if type_.flags & TypeFlagsIntersection {
				return some((type_).types, check)
			}
			return false
		}
	}
	appendTypeParameters := func(typeParameters *[]TypeParameter, declarations []TypeParameterDeclaration) *[]TypeParameter {
		for _, declaration := range declarations {
			typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)))
		}
		return typeParameters
	}
	getOuterTypeParameters := func(node Node, includeThisTypes bool) *[]TypeParameter {
		for true {
			node = node.parent
			if node && isBinaryExpression(node) {
				assignmentKind := getAssignmentDeclarationKind(node)
				if assignmentKind == AssignmentDeclarationKindPrototype || assignmentKind == AssignmentDeclarationKindPrototypeProperty {
					symbol := getSymbolOfDeclaration(node.left)
					if symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
						return node == d
					}) {
						node = symbol.parent.valueDeclaration
					}
				}
			}
			if !node {
				return nil
			}
			kind := node.kind
			switch kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTemplateTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocEnumTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO: merge cases
			case SyntaxKindMappedType:
				fallthrough // TODO: merge cases
			case SyntaxKindConditionalType:
				outerTypeParameters := getOuterTypeParameters(node, includeThisTypes)
				if (kind == SyntaxKindFunctionExpression || kind == SyntaxKindArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node) {
					signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKindCall))
					if signature && signature.typeParameters {
						return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{ /* TODO(Node SpreadElement): ...(outerTypeParameters || emptyArray) */ /* TODO(Node SpreadElement): ...signature.typeParameters */ }
					}
				}
				if kind == SyntaxKindMappedType {
					return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node).typeParameter)))
				} else if kind == SyntaxKindConditionalType {
					return concatenate(outerTypeParameters, getInferTypeParameters(node))
				}
				outerAndOwnTypeParameters := appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node))
				thisType := includeThisTypes && (kind == SyntaxKindClassDeclaration || kind == SyntaxKindClassExpression || kind == SyntaxKindInterfaceDeclaration || isJSConstructor(node)) && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node)).thisType
				// converted from conditional expression
				switch {
				case thisType:
					return append(outerAndOwnTypeParameters, thisType)
				default:
					return outerAndOwnTypeParameters
				}
				fallthrough
			case SyntaxKindJSDocParameterTag:
				paramSymbol := getParameterSymbolFromJSDoc(node)
				if paramSymbol {
					node = paramSymbol.valueDeclaration
				}
				break
			case SyntaxKindJSDoc:
				outerTypeParameters := getOuterTypeParameters(node, includeThisTypes)
				// converted from conditional expression
				switch {
				case (node).tags:
					return appendTypeParameters(outerTypeParameters, flatMap((node).tags, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocTag */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined */ any {
						return /* TODO(Node ConditionalExpression): isJSDocTemplateTag(t) ? t.typeParameters : undefined */ TODO
					}))
				default:
					return outerTypeParameters
				}
			}
		}
	}
	getOuterTypeParametersOfClassOrInterface := func(symbol Symbol) *[]TypeParameter {
		declaration := /* TODO(Node ConditionalExpression): (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function) ? symbol.valueDeclaration : symbol.declarations?.find(decl => { if (decl.kind === SyntaxKind.InterfaceDeclaration) { return true; } if (decl.kind !== SyntaxKind.VariableDeclaration) { return false; } const initializer = (decl as VariableDeclaration).initializer; return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.ArrowFunction); })! */ TODO
		Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations")
		return getOuterTypeParameters(declaration)
	}
	getLocalTypeParametersOfClassOrInterfaceOrTypeAlias := func(symbol Symbol) *[]TypeParameter {
		if !symbol.declarations {
			return
		}
		var result *[]TypeParameter
		for _, node := range symbol.declarations {
			if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression || isJSConstructor(node) || isTypeAlias(node) {
				declaration := node
				result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration))
			}
		}
		return result
	}
	getTypeParametersOfClassOrInterface := func(symbol Symbol) *[]TypeParameter {
		return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
	}
	isMixinConstructorType := func(type_ Type) /* TODO inferred type boolean */ any {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length == 1 {
			s := signatures[0]
			if !s.typeParameters && s.parameters.length == 1 && signatureHasRestParameter(s) {
				paramType := getTypeOfParameter(s.parameters[0])
				return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) == anyType
			}
		}
		return false
	}
	isConstructorType := func(type_ Type) bool {
		if getSignaturesOfType(type_, SignatureKindConstruct).length > 0 {
			return true
		}
		if type_.flags & TypeFlagsTypeVariable {
			constraint := getBaseConstraintOfType(type_)
			return !!constraint && isMixinConstructorType(constraint)
		}
		return false
	}
	getBaseTypeNodeOfClass := func(type_ InterfaceType) *ExpressionWithTypeArguments {
		decl := getClassLikeDeclarationOfSymbol(type_.symbol)
		return decl && getEffectiveBaseTypeNode(decl)
	}
	getConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes *[]TypeNode, location Node) []Signature {
		typeArgCount := length(typeArgumentNodes)
		isJavascript := isInJSFile(location)
		return filter(getSignaturesOfType(type_, SignatureKindConstruct), func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
			return (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters)
		})
	}
	getInstantiatedConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes *[]TypeNode, location Node) []Signature {
		signatures := getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
		typeArguments := map_(typeArgumentNodes, getTypeFromTypeNode)
		return sameMap(signatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
			return /* TODO(Node ConditionalExpression): some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig */ TODO
		})
	}
	getBaseConstructorTypeOfClass := func(type_ InterfaceType) Type {
		if !type_.resolvedBaseConstructorType {
			decl := getClassLikeDeclarationOfSymbol(type_.symbol)
			extended := decl && getEffectiveBaseTypeNode(decl)
			baseTypeNode := getBaseTypeNodeOfClass(type_)
			if !baseTypeNode {
				type_.resolvedBaseConstructorType = undefinedType
				return type_.resolvedBaseConstructorType
			}
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseConstructorType) {
				return errorType
			}
			baseConstructorType := checkExpression(baseTypeNode.expression)
			if extended && baseTypeNode != extended {
				Debug.assert(!extended.typeArguments)
				checkExpression(extended.expression)
			}
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection) {
				resolveStructuredTypeMembers(baseConstructorType)
			}
			if !popTypeResolution() {
				error(type_.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type_.symbol))
				return /* TODO(Node BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			if !(baseConstructorType.flags & TypeFlagsAny) && baseConstructorType != nullWideningType && !isConstructorType(baseConstructorType) {
				err := error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType))
				if baseConstructorType.flags & TypeFlagsTypeParameter {
					constraint := getConstraintFromTypeParameter(baseConstructorType)
					var ctorReturn Type = unknownType
					if constraint {
						ctorSig := getSignaturesOfType(constraint, SignatureKindConstruct)
						if ctorSig[0] {
							ctorReturn = getReturnTypeOfSignature(ctorSig[0])
						}
					}
					if baseConstructorType.symbol.declarations {
						addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)))
					}
				}
				return /* TODO(Node BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			/* TODO(Node BinaryExpression): type.resolvedBaseConstructorType ??= baseConstructorType */ TODO
		}
		return type_.resolvedBaseConstructorType
	}
	getImplementsTypes := func(type_ InterfaceType) []BaseType {
		var resolvedImplementsTypes []BaseType = emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				implementsTypeNodes := getEffectiveImplementsTypeNodes(declaration)
				if !implementsTypeNodes {
					continue
				}
				for _, node := range implementsTypeNodes {
					implementsType := getTypeFromTypeNode(node)
					if !isErrorType(implementsType) {
						if resolvedImplementsTypes == emptyArray {
							resolvedImplementsTypes = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any{implementsType}
						} else {
							resolvedImplementsTypes.push(implementsType)
						}
					}
				}
			}
		}
		return resolvedImplementsTypes
	}
	reportCircularBaseType := func(node Node, type_ Type) {
		error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType))
	}
	getBaseTypes := func(type_ InterfaceType) []BaseType {
		if !type_.baseTypesResolved {
			if pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseTypes) {
				if type_.objectFlags & ObjectFlagsTuple {
					type_.resolvedBaseTypes = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any{getTupleBaseType(type_)}
				} else if type_.symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
					if type_.symbol.flags & SymbolFlagsClass {
						resolveBaseTypesOfClass(type_)
					}
					if type_.symbol.flags & SymbolFlagsInterface {
						resolveBaseTypesOfInterface(type_)
					}
				} else {
					Debug.fail("type must be class or interface")
				}
				if !popTypeResolution() && type_.symbol.declarations {
					for _, declaration := range type_.symbol.declarations {
						if declaration.kind == SyntaxKindClassDeclaration || declaration.kind == SyntaxKindInterfaceDeclaration {
							reportCircularBaseType(declaration, type_)
						}
					}
				}
			}
			type_.baseTypesResolved = true
		}
		return type_.resolvedBaseTypes
	}
	getTupleBaseType := func(type_ TupleType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		elementTypes := sameMap(type_.typeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): type.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */ TODO
		})
		return createArrayType(getUnionType(elementTypes || emptyArray), type_.readonly)
	}
	resolveBaseTypesOfClass := func(type_ InterfaceType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BaseType[] */ any {
		type_.resolvedBaseTypes = resolvingEmptyArray
		baseConstructorType := getApparentType(getBaseConstructorTypeOfClass(type_))
		if !(baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsAny)) {
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		baseTypeNode := getBaseTypeNodeOfClass(type_)
		var baseType Type
		originalBaseType := /* TODO(Node ConditionalExpression): baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined */ TODO
		if baseConstructorType.symbol && baseConstructorType.symbol.flags&SymbolFlagsClass && areAllOuterTypeParametersApplied(originalBaseType) {
			baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol)
		} else if baseConstructorType.flags & TypeFlagsAny {
			baseType = baseConstructorType
		} else {
			constructors := getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode)
			if !constructors.length {
				error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments)
				type_.resolvedBaseTypes = emptyArray
				return type_.resolvedBaseTypes
			}
			baseType = getReturnTypeOfSignature(constructors[0])
		}
		if isErrorType(baseType) {
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		reducedBaseType := getReducedType(baseType)
		if !isValidBaseType(reducedBaseType) {
			elaboration := elaborateNeverIntersection(nil, baseType)
			diagnostic := chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType))
			diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic))
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		if type_ == reducedBaseType || hasBaseType(reducedBaseType, type_) {
			error(type_.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType))
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		if type_.resolvedBaseTypes == resolvingEmptyArray {
			type_.members = nil
		}
		type_.resolvedBaseTypes = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BaseType */ any{reducedBaseType}
		return type_.resolvedBaseTypes
	}
	areAllOuterTypeParametersApplied := func(type_ Type) bool {
		outerTypeParameters := (type_).outerTypeParameters
		if outerTypeParameters {
			last := outerTypeParameters.length - 1
			typeArguments := getTypeArguments(type_)
			return outerTypeParameters[last].symbol != typeArguments[last].symbol
		}
		return true
	}
	isValidBaseType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is BaseType */ any {
		if type_.flags & TypeFlagsTypeParameter {
			constraint := getBaseConstraintOfType(type_)
			if constraint {
				return isValidBaseType(constraint)
			}
		}
		return !!(type_.flags&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsAny) && !isGenericMappedType(type_) || type_.flags&TypeFlagsIntersection && every((type_).types, isValidBaseType))
	}
	resolveBaseTypesOfInterface := func(type_ InterfaceType) {
		type_.resolvedBaseTypes = type_.resolvedBaseTypes || emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				if declaration.kind == SyntaxKindInterfaceDeclaration && getInterfaceBaseTypeNodes(declaration) {
					for _, node := range getInterfaceBaseTypeNodes(declaration) {
						baseType := getReducedType(getTypeFromTypeNode(node))
						if !isErrorType(baseType) {
							if isValidBaseType(baseType) {
								if type_ != baseType && !hasBaseType(baseType, type_) {
									if type_.resolvedBaseTypes == emptyArray {
										type_.resolvedBaseTypes = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any{baseType}
									} else {
										type_.resolvedBaseTypes.push(baseType)
									}
								} else {
									reportCircularBaseType(declaration, type_)
								}
							} else {
								error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members)
							}
						}
					}
				}
			}
		}
	}
	isThislessInterface := func(symbol Symbol) bool {
		if !symbol.declarations {
			return true
		}
		for _, declaration := range symbol.declarations {
			if declaration.kind == SyntaxKindInterfaceDeclaration {
				if declaration.flags & NodeFlagsContainsThis {
					return false
				}
				baseTypeNodes := getInterfaceBaseTypeNodes(declaration)
				if baseTypeNodes {
					for _, node := range baseTypeNodes {
						if isEntityNameExpression(node.expression) {
							baseSymbol := resolveEntityName(node.expression, SymbolFlagsType, true)
							if !baseSymbol || !(baseSymbol.flags & SymbolFlagsInterface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType {
								return false
							}
						}
					}
				}
			}
		}
		return true
	}
	getDeclaredTypeOfClassOrInterface := func(symbol Symbol) InterfaceType {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.declaredType {
			kind := /* TODO(Node ConditionalExpression): symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface */ TODO
			merged := mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration))
			if merged {
				symbol = merged
				links = merged.links
			}
			type_ := /* TODO(Node BinaryExpression): originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
			outerTypeParameters := getOuterTypeParametersOfClassOrInterface(symbol)
			localTypeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			if outerTypeParameters || localTypeParameters || kind == ObjectFlagsClass || !isThislessInterface(symbol) {
				type_.objectFlags |= ObjectFlagsReference
				type_.typeParameters = concatenate(outerTypeParameters, localTypeParameters)
				type_.outerTypeParameters = outerTypeParameters
				type_.localTypeParameters = localTypeParameters
				(type_).instantiations = make(map[string]TypeReference)
				(type_).instantiations.set(getTypeListId(type_.typeParameters), type_)
				(type_).target = type_
				(type_).resolvedTypeArguments = type_.typeParameters
				type_.thisType = createTypeParameter(symbol)
				type_.thisType.isThisType = true
				type_.thisType.constraint = type_
			}
		}
		return links.declaredType
	}
	getDeclaredTypeOfTypeAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameDeclaredType) {
				return errorType
			}
			declaration := Debug.checkDefined(symbol.declarations. /*?*/ find(isTypeAlias), "Type alias symbol with no valid declaration found")
			typeNode := /* TODO(Node ConditionalExpression): isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type */ TODO
			type_ := /* TODO(Node ConditionalExpression): typeNode ? getTypeFromTypeNode(typeNode) : errorType */ TODO
			if popTypeResolution() {
				typeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				if typeParameters {
					links.typeParameters = typeParameters
					links.instantiations = make(map[string]Type)
					links.instantiations.set(getTypeListId(typeParameters), type_)
				}
				if type_ == intrinsicMarkerType && symbol.escapedName == "BuiltinIteratorReturn" {
					type_ = getBuiltinIteratorReturnType()
				}
			} else {
				type_ = errorType
				if declaration.kind == SyntaxKindJSDocEnumTag {
					error(declaration.typeExpression.type_, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				} else {
					error( /* TODO(Node ConditionalExpression): isNamedDeclaration(declaration) ? declaration.name || declaration : declaration */ TODO, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				}
			}
			/* TODO(Node BinaryExpression): links.declaredType ??= type */ TODO
		}
		return links.declaredType
	}
	getBaseTypeOfEnumLikeType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags&TypeFlagsEnumLike && type_.symbol.flags&SymbolFlagsEnumMember:
			return getDeclaredTypeOfSymbol(getParentOfSymbol(type_.symbol))
		default:
			return type_
		}
	}
	getDeclaredTypeOfEnum := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			var memberTypeList []Type = [] /* TODO inferred type never */ any{}
			if symbol.declarations {
				for _, declaration := range symbol.declarations {
					if declaration.kind == SyntaxKindEnumDeclaration {
						for _, member := range (declaration).members {
							if hasBindableName(member) {
								memberSymbol := getSymbolOfDeclaration(member)
								value := getEnumMemberValue(member).value
								memberType := getFreshTypeOfLiteralType( /* TODO(Node ConditionalExpression): value !== undefined ? getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) : createComputedEnumType(memberSymbol) */ TODO)
								getSymbolLinks(memberSymbol).declaredType = memberType
								memberTypeList.push(getRegularTypeOfLiteralType(memberType))
							}
						}
					}
				}
			}
			enumType := /* TODO(Node ConditionalExpression): memberTypeList.length ? getUnionType(memberTypeList, UnionReduction.Literal, symbol, /*aliasTypeArguments* / undefined) : createComputedEnumType(symbol) */ TODO
			if enumType.flags & TypeFlagsUnion {
				enumType.flags |= TypeFlagsEnumLiteral
				enumType.symbol = symbol
			}
			links.declaredType = enumType
		}
		return links.declaredType
	}
	createComputedEnumType := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EnumType */ any {
		regularType := createTypeWithSymbol(TypeFlagsEnum, symbol)
		freshType := createTypeWithSymbol(TypeFlagsEnum, symbol)
		regularType.regularType = regularType
		regularType.freshType = freshType
		freshType.regularType = regularType
		freshType.freshType = freshType
		return regularType
	}
	getDeclaredTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			enumType := getDeclaredTypeOfEnum(getParentOfSymbol(symbol))
			if !links.declaredType {
				links.declaredType = enumType
			}
		}
		return links.declaredType
	}
	getDeclaredTypeOfTypeParameter := func(symbol Symbol) TypeParameter {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(Node BinaryExpression): links.declaredType = createTypeParameter(symbol) */ TODO)
	}
	getDeclaredTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(Node BinaryExpression): links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)) */ TODO)
	}
	getDeclaredTypeOfSymbol := func(symbol Symbol) Type {
		return tryGetDeclaredTypeOfSymbol(symbol) || errorType
	}
	tryGetDeclaredTypeOfSymbol := func(symbol Symbol) *Type {
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getDeclaredTypeOfClassOrInterface(symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getDeclaredTypeOfTypeAlias(symbol)
		}
		if symbol.flags & SymbolFlagsTypeParameter {
			return getDeclaredTypeOfTypeParameter(symbol)
		}
		if symbol.flags & SymbolFlagsEnum {
			return getDeclaredTypeOfEnum(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getDeclaredTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getDeclaredTypeOfAlias(symbol)
		}
		return nil
	}
	isThislessType := func(node TypeNode) bool {
		switch node.kind {
		case SyntaxKindAnyKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindUnknownKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindStringKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNumberKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindBooleanKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindSymbolKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindVoidKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindUndefinedKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNeverKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindLiteralType:
			return true
		case SyntaxKindArrayType:
			return isThislessType((node).elementType)
		case SyntaxKindTypeReference:
			return !(node).typeArguments || (node).typeArguments.every(isThislessType)
		}
		return false
	}
	isThislessTypeParameter := func(node TypeParameterDeclaration) /* TODO inferred type boolean */ any {
		constraint := getEffectiveConstraintOfTypeParameter(node)
		return !constraint || isThislessType(constraint)
	}
	isThislessVariableLikeDeclaration := func(node VariableLikeDeclaration) bool {
		typeNode := getEffectiveTypeAnnotationNode(node)
		// converted from conditional expression
		switch {
		case typeNode:
			return isThislessType(typeNode)
		default:
			return !hasInitializer(node)
		}
	}
	isThislessFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		returnType := getEffectiveReturnTypeNode(node)
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		return (node.kind == SyntaxKindConstructor || (!!returnType && isThislessType(returnType))) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter)
	}
	isThisless := func(symbol Symbol) bool {
		if symbol.declarations && symbol.declarations.length == 1 {
			declaration := symbol.declarations[0]
			if declaration {
				switch declaration.kind {
				case SyntaxKindPropertyDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindPropertySignature:
					return isThislessVariableLikeDeclaration(declaration)
				case SyntaxKindMethodDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindMethodSignature:
					fallthrough // TODO: merge cases
				case SyntaxKindConstructor:
					fallthrough // TODO: merge cases
				case SyntaxKindGetAccessor:
					fallthrough // TODO: merge cases
				case SyntaxKindSetAccessor:
					return isThislessFunctionLikeDeclaration(declaration)
				}
			}
		}
		return false
	}
	createInstantiatedSymbolTable := func(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
		result := createSymbolTable()
		for _, symbol := range symbols {
			result.set(symbol.escapedName /* TODO(Node ConditionalExpression): mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper) */, TODO)
		}
		return result
	}
	addInheritedMembers := func(symbols SymbolTable, baseSymbols []Symbol) {
		for _, base := range baseSymbols {
			if isStaticPrivateIdentifierProperty(base) {
				continue
			}
			derived := symbols.get(base.escapedName)
			if !derived || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) && !isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock(derived.valueDeclaration) {
				symbols.set(base.escapedName, base)
				symbols.set(base.escapedName, base)
			}
		}
	}
	isStaticPrivateIdentifierProperty := func(s Symbol) bool {
		return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration)
	}
	resolveDeclaredMembers := func(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
		if !(type_).declaredProperties {
			symbol := type_.symbol
			members := getMembersOfSymbol(symbol)
			(type_).declaredProperties = getNamedMembers(members)
			(type_).declaredCallSignatures = emptyArray
			(type_).declaredConstructSignatures = emptyArray
			(type_).declaredIndexInfos = emptyArray
			(type_).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			(type_).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			(type_).declaredIndexInfos = getIndexInfosOfSymbol(symbol)
		}
		return type_
	}
	isLateBindableName := func(node DeclarationName) /* TODO(TypeNode TypePredicate): node is LateBoundName */ any {
		if !isComputedPropertyName(node) && !isElementAccessExpression(node) {
			return false
		}
		expr := /* TODO(Node ConditionalExpression): isComputedPropertyName(node) ? node.expression : node.argumentExpression */ TODO
		return isEntityNameExpression(expr) && isTypeUsableAsPropertyName( /* TODO(Node ConditionalExpression): isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr) */ TODO)
	}
	isLateBoundName := func(name __String) bool {
		return (name).charCodeAt(0) == CharacterCodes_ && (name).charCodeAt(1) == CharacterCodes_ && (name).charCodeAt(2) == CharacterCodesat
	}
	hasLateBindableName := func(node Declaration) /* TODO(TypeNode TypePredicate): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any {
		name := getNameOfDeclaration(node)
		return !!name && isLateBindableName(name)
	}
	hasBindableName := func(node Declaration) /* TODO inferred type boolean */ any {
		return !hasDynamicName(node) || hasLateBindableName(node)
	}
	isNonBindableDynamicName := func(node DeclarationName) /* TODO inferred type boolean */ any {
		return isDynamicName(node) && !isLateBindableName(node)
	}
	addDeclarationToLateBoundSymbol := func(symbol Symbol, member /* TODO(TypeNode UnionType): LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
		Debug.assert(!!(getCheckFlags(symbol) & CheckFlagsLate), "Expected a late-bound symbol.")
		symbol.flags |= symbolFlags
		getSymbolLinks(member.symbol).lateSymbol = symbol
		if !symbol.declarations {
			symbol.declarations = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").LateBoundDeclaration */ any{member}
		} else if !member.symbol.isReplaceableByMethod {
			symbol.declarations.push(member)
		}
		if symbolFlags & SymbolFlagsValue {
			if !symbol.valueDeclaration || symbol.valueDeclaration.kind != member.kind {
				symbol.valueDeclaration = member
			}
		}
	}
	lateBindMember := func(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(TypeNode UnionType): LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		Debug.assert(!!decl.symbol, "The member is expected to have a symbol.")
		links := getNodeLinks(decl)
		if !links.resolvedSymbol {
			links.resolvedSymbol = decl.symbol
			declName := /* TODO(Node ConditionalExpression): isBinaryExpression(decl) ? decl.left : decl.name */ TODO
			type_ := /* TODO(Node ConditionalExpression): isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName) */ TODO
			if isTypeUsableAsPropertyName(type_) {
				memberName := getPropertyNameFromType(type_)
				symbolFlags := decl.symbol.flags
				lateSymbol := lateSymbols.get(memberName)
				if !lateSymbol {
					lateSymbols.set(memberName /* TODO(Node BinaryExpression): lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late) */, TODO)
				}
				earlySymbol := earlySymbols && earlySymbols.get(memberName)
				if !(parent.flags & SymbolFlagsClass) && lateSymbol.flags&getExcludedSymbolFlags(symbolFlags) {
					declarations := /* TODO(Node ConditionalExpression): earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations */ TODO
					name := !(type_.flags&TypeFlagsUniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName)
					forEach(declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ any {
						return error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name)
					})
					error(declName || decl, Diagnostics.Duplicate_property_0, name)
					lateSymbol = createSymbol(SymbolFlagsNone, memberName, CheckFlagsLate)
				}
				lateSymbol.links.nameType = type_
				addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags)
				if lateSymbol.parent {
					Debug.assert(lateSymbol.parent == parent, "Existing symbol parent should match new one")
				} else {
					lateSymbol.parent = parent
				}
				links.resolvedSymbol = lateSymbol
				return links.resolvedSymbol
			}
		}
		return links.resolvedSymbol
	}
	getResolvedMembersOrExportsOfSymbol := func(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
		links := getSymbolLinks(symbol)
		if !links[resolutionKind] {
			isStatic := resolutionKind == MembersOrExportsResolutionKindresolvedExports
			earlySymbols := /* TODO(Node ConditionalExpression): !isStatic ? symbol.members : symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(symbol).exports : symbol.exports */ TODO
			links[resolutionKind] = earlySymbols || emptySymbols
			lateSymbols := createSymbolTable()
			for _, decl := range symbol.declarations || emptyArray {
				members := getMembersOfDeclaration(decl)
				if members {
					for _, member := range members {
						if isStatic == hasStaticModifier(member) {
							if hasLateBindableName(member) {
								lateBindMember(symbol, earlySymbols, lateSymbols, member)
							}
						}
					}
				}
			}
			assignments := getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers
			if assignments {
				decls := arrayFrom(assignments.values())
				for _, member := range decls {
					assignmentKind := getAssignmentDeclarationKind(member)
					isInstanceMember := assignmentKind == AssignmentDeclarationKindPrototypeProperty || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind == AssignmentDeclarationKindObjectDefinePrototypeProperty || assignmentKind == AssignmentDeclarationKindPrototype
					if isStatic == !isInstanceMember {
						if hasLateBindableName(member) {
							lateBindMember(symbol, earlySymbols, lateSymbols, member)
						}
					}
				}
			}
			resolved := combineSymbolTables(earlySymbols, lateSymbols)
			if symbol.flags&SymbolFlagsTransient && links.cjsExportMerged && symbol.declarations {
				for _, decl := range symbol.declarations {
					original := getSymbolLinks(decl.symbol)[resolutionKind]
					if !resolved {
						resolved = original
						continue
					}
					if !original {
						continue
					}
					original.forEach(func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, name /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
						existing := resolved.get(name)
						if !existing {
							resolved.set(name, s)
						} else if existing == s {
							return
						} else {
							resolved.set(name, mergeSymbol(existing, s))
						}
					})
				}
			}
			links[resolutionKind] = resolved || emptySymbols
		}
		return links[resolutionKind]
	}
	getMembersOfSymbol := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ any {
		// converted from conditional expression
		switch {
		case symbol.flags & SymbolFlagsLateBindingContainer:
			return getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKindresolvedMembers)
		default:
			return symbol.members || emptySymbols
		}
	}
	getLateBoundSymbol := func(symbol Symbol) Symbol {
		if symbol.flags&SymbolFlagsClassMember && symbol.escapedName == InternalSymbolNameComputed {
			links := getSymbolLinks(symbol)
			if !links.lateSymbol && some(symbol.declarations, hasLateBindableName) {
				parent := getMergedSymbol(symbol.parent)
				if some(symbol.declarations, hasStaticModifier) {
					getExportsOfSymbol(parent)
				} else {
					getMembersOfSymbol(parent)
				}
			}
			return links.lateSymbol || ( /* TODO(Node BinaryExpression): links.lateSymbol = symbol */ TODO)
		}
		return symbol
	}
	getTypeWithThisArgument := func(type_ Type, thisArgument Type, needApparentType bool) Type {
		if getObjectFlags(type_) & ObjectFlagsReference {
			target := (type_).target
			typeArguments := getTypeArguments(type_)
			// converted from conditional expression
			switch {
			case length(target.typeParameters) == length(typeArguments):
				return createTypeReference(target, concatenate(typeArguments, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisArgument || target.thisType}))
			default:
				return type_
			}
		} else if type_.flags & TypeFlagsIntersection {
			types := sameMap((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getTypeWithThisArgument(t, thisArgument, needApparentType)
			})
			// converted from conditional expression
			switch {
			case types != (type_).types:
				return getIntersectionType(types)
			default:
				return type_
			}
		}
		// converted from conditional expression
		switch {
		case needApparentType:
			return getApparentType(type_)
		default:
			return type_
		}
	}
	resolveObjectTypeMembers := func(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
		var mapper *TypeMapper
		var members SymbolTable
		var callSignatures []Signature
		var constructSignatures []Signature
		var indexInfos []IndexInfo
		if rangeEquals(typeParameters, typeArguments, 0, typeParameters.length) {
			members = /* TODO(Node ConditionalExpression): source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties) */ TODO
			callSignatures = source.declaredCallSignatures
			constructSignatures = source.declaredConstructSignatures
			indexInfos = source.declaredIndexInfos
		} else {
			mapper = createTypeMapper(typeParameters, typeArguments)
			members = createInstantiatedSymbolTable(source.declaredProperties, mapper, typeParameters.length == 1)
			callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper)
			constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper)
			indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper)
		}
		baseTypes := getBaseTypes(source)
		if baseTypes.length {
			if source.symbol && members == getMembersOfSymbol(source.symbol) {
				symbolTable := createSymbolTable(source.declaredProperties)
				sourceIndex := getIndexSymbol(source.symbol)
				if sourceIndex {
					symbolTable.set(InternalSymbolNameIndex, sourceIndex)
				}
				members = symbolTable
			}
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			thisArgument := lastOrUndefined(typeArguments)
			for _, baseType := range baseTypes {
				instantiatedBaseType := /* TODO(Node ConditionalExpression): thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType */ TODO
				addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType))
				callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindCall))
				constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindConstruct))
				inheritedIndexInfos := /* TODO(Node ConditionalExpression): instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly* / false)] */ TODO
				indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type boolean */ any {
					return !findIndexInfo(indexInfos, info.keyType)
				}))
			}
		}
		setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
	}
	resolveClassOrInterfaceMembers := func(type_ InterfaceType) {
		resolveObjectTypeMembers(type_, resolveDeclaredMembers(type_), emptyArray, emptyArray)
	}
	resolveTypeReferenceMembers := func(type_ TypeReference) {
		source := resolveDeclaredMembers(type_.target)
		typeParameters := concatenate(source.typeParameters, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{source.thisType})
		typeArguments := getTypeArguments(type_)
		paddedTypeArguments := /* TODO(Node ConditionalExpression): typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]) */ TODO
		resolveObjectTypeMembers(type_, source, typeParameters, paddedTypeArguments)
	}
	createSignature := func(declaration /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters *[]TypeParameter, thisParameter *Symbol, parameters []Symbol, resolvedReturnType *Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
		sig := /* TODO(Node NewExpression): new Signature(checker, flags) */ TODO
		sig.declaration = declaration
		sig.typeParameters = typeParameters
		sig.parameters = parameters
		sig.thisParameter = thisParameter
		sig.resolvedReturnType = resolvedReturnType
		sig.resolvedTypePredicate = resolvedTypePredicate
		sig.minArgumentCount = minArgumentCount
		sig.resolvedMinArgumentCount = nil
		sig.target = nil
		sig.mapper = nil
		sig.compositeSignatures = nil
		sig.compositeKind = nil
		return sig
	}
	cloneSignature := func(sig Signature) Signature {
		result := createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, nil, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
		result.target = sig.target
		result.mapper = sig.mapper
		result.compositeSignatures = sig.compositeSignatures
		result.compositeKind = sig.compositeKind
		return result
	}
	createUnionSignature := func(signature Signature, unionSignatures []Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		result := cloneSignature(signature)
		result.compositeSignatures = unionSignatures
		result.compositeKind = TypeFlagsUnion
		result.target = nil
		result.mapper = nil
		return result
	}
	getOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
		if (signature.flags & SignatureFlagsCallChainFlags) == callChainFlags {
			return signature
		}
		if !signature.optionalCallSignatureCache {
			signature.optionalCallSignatureCache = /* TODO(Node ObjectLiteralExpression): {} */ TODO
		}
		key := /* TODO(Node ConditionalExpression): callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer" */ TODO
		return signature.optionalCallSignatureCache[key] || ( /* TODO(Node BinaryExpression): signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags) */ TODO)
	}
	createOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		Debug.assert(callChainFlags == SignatureFlagsIsInnerCallChain || callChainFlags == SignatureFlagsIsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.")
		result := cloneSignature(signature)
		result.flags |= callChainFlags
		return result
	}
	getExpandedParameters := func(sig Signature, skipUnionExpanding bool) [][]Symbol {
		if signatureHasRestParameter(sig) {
			restIndex := sig.parameters.length - 1
			restSymbol := sig.parameters[restIndex]
			restType := getTypeOfSymbol(restSymbol)
			if isTupleType(restType) {
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any{expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)}
			} else if !skipUnionExpanding && restType.flags&TypeFlagsUnion && every((restType).types, isTupleType) {
				return map_((restType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
					return expandSignatureParametersWithTupleMembers(t, restIndex, restSymbol)
				})
			}
		}
		return [] /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any{sig.parameters}
		expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
			elementTypes := getTypeArguments(restType)
			associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
			restParams := map_(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
				name := /* TODO(Node ConditionalExpression): associatedNames && associatedNames[i] ? associatedNames[i] : getParameterNameAtPosition(sig, restIndex + i, restType) */ TODO
				flags := restType.target.elementFlags[i]
				checkFlags := /* TODO(Node ConditionalExpression): flags & ElementFlags.Variable ? CheckFlags.RestParameter : flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0 */ TODO
				symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name, checkFlags)
				symbol.links.type_ = /* TODO(Node ConditionalExpression): flags & ElementFlags.Rest ? createArrayType(t) : t */ TODO
				return symbol
			})
			return concatenate(sig.parameters.slice(0, restIndex), restParams)
		}
		getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String[] | undefined */ any {
			names := map_(type_.target.labeledElementDeclarations, func(labeledElement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any {
				return getTupleElementLabel(labeledElement, i, type_.target.elementFlags[i], restSymbol)
			})
			if names {
				var duplicates []number = [] /* TODO inferred type never */ any{}
				uniqueNames := make(map[__String]struct{})
				for i := 0; i < names.length; i++ {
					name := names[i]
					if !tryAddToSet(uniqueNames, name) {
						duplicates.push(i)
					}
				}
				counters := make(map[__String]number)
				for _, i := range duplicates {
					counter := /* TODO(Node BinaryExpression): counters.get(names[i]) ?? 1 */ TODO
					var name __String
					for !tryAddToSet(uniqueNames /* TODO(Node BinaryExpression): name = `${names[i]}_${counter}` as __String */, TODO) {
						counter++
					}
					names[i] = name
					counters.set(names[i], counter+1)
				}
			}
			return names
		}
	}
	getDefaultConstructSignatures := func(classType InterfaceType) []Signature {
		baseConstructorType := getBaseConstructorTypeOfClass(classType)
		baseSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
		declaration := getClassLikeDeclarationOfSymbol(classType.symbol)
		isAbstract := !!declaration && hasSyntacticModifier(declaration, ModifierFlagsAbstract)
		if baseSignatures.length == 0 {
			return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{createSignature(nil, classType.localTypeParameters, nil, emptyArray, classType, nil, 0 /* TODO(Node ConditionalExpression): isAbstract ? SignatureFlags.Abstract : SignatureFlags.None */, TODO)}
		}
		baseTypeNode := getBaseTypeNodeOfClass(classType)
		isJavaScript := isInJSFile(baseTypeNode)
		typeArguments := typeArgumentsFromTypeReferenceNode(baseTypeNode)
		typeArgCount := length(typeArguments)
		var result []Signature = [] /* TODO inferred type never */ any{}
		for _, baseSig := range baseSignatures {
			minTypeArgumentCount := getMinTypeArgumentCount(baseSig.typeParameters)
			typeParamCount := length(baseSig.typeParameters)
			if isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount {
				sig := /* TODO(Node ConditionalExpression): typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig) */ TODO
				sig.typeParameters = classType.localTypeParameters
				sig.resolvedReturnType = classType
				sig.flags = /* TODO(Node ConditionalExpression): isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract */ TODO
				result.push(sig)
			}
		}
		return result
	}
	findMatchingSignature := func(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
		for _, s := range signatureList {
			if compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes /* TODO(Node ConditionalExpression): partialMatch ? compareTypesSubtypeOf : compareTypesIdentical */, TODO) {
				return s
			}
		}
	}
	findMatchingSignatures := func(signatureLists [][]Signature, signature Signature, listIndex number) *[]Signature {
		if signature.typeParameters {
			if listIndex > 0 {
				return nil
			}
			for i := 1; i < signatureLists.length; i++ {
				if !findMatchingSignature(signatureLists[i], signature, false, false, false) {
					return nil
				}
			}
			return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{signature}
		}
		var result *[]Signature
		for i := 0; i < signatureLists.length; i++ {
			match := /* TODO(Node ConditionalExpression): i === listIndex ? signature : findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true) || findMatchingSignature(signatureLists[i], signature, /*partialMatch* / true, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true) */ TODO
			if !match {
				return nil
			}
			result = appendIfUnique(result, match)
		}
		return result
	}
	getUnionSignatures := func(signatureLists [][]Signature) []Signature {
		var result *[]Signature
		var indexWithLengthOverOne *number
		for i := 0; i < signatureLists.length; i++ {
			if signatureLists[i].length == 0 {
				return emptyArray
			}
			if signatureLists[i].length > 1 {
				indexWithLengthOverOne = /* TODO(Node ConditionalExpression): indexWithLengthOverOne === undefined ? i : -1 */ TODO
			}
			for _, signature := range signatureLists[i] {
				if !result || !findMatchingSignature(result, signature, false, false, true) {
					unionSignatures := findMatchingSignatures(signatureLists, signature, i)
					if unionSignatures {
						s := signature
						if unionSignatures.length > 1 {
							thisParameter := signature.thisParameter
							firstThisParameterOfUnionSignatures := forEach(unionSignatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
								return sig.thisParameter
							})
							if firstThisParameterOfUnionSignatures {
								thisType := getIntersectionType(mapDefined(unionSignatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
									return sig.thisParameter && getTypeOfSymbol(sig.thisParameter)
								}))
								thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType)
							}
							s = createUnionSignature(signature, unionSignatures)
							s.thisParameter = thisParameter
						}
						(result || ( /* TODO(Node BinaryExpression): result = [] */ TODO)).push(s)
					}
				}
			}
		}
		if !length(result) && indexWithLengthOverOne != -1 {
			masterList := signatureLists[ /* TODO(Node ConditionalExpression): indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0 */ TODO]
			var results *[]Signature = masterList.slice()
			for _, signatures := range signatureLists {
				if signatures != masterList {
					signature := signatures[0]
					Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass")
					results = /* TODO(Node ConditionalExpression): !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature)) */ TODO
					if !results {
						break
					}
				}
			}
			result = results
		}
		return result || emptyArray
	}
	compareTypeParametersIdentical := func(sourceParams *[]TypeParameter, targetParams *[]TypeParameter) bool {
		if length(sourceParams) != length(targetParams) {
			return false
		}
		if !sourceParams || !targetParams {
			return true
		}
		mapper := createTypeMapper(targetParams, sourceParams)
		for i := 0; i < sourceParams.length; i++ {
			source := sourceParams[i]
			target := targetParams[i]
			if source == target {
				continue
			}
			if !isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper)) {
				return false
			}
		}
		return true
	}
	combineUnionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)})
		return createSymbolWithType(left, thisType)
	}
	combineUnionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(Node ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(Node ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(Node ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(Node NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		for i := 0; i < longestCount; i++ {
			longestParamType := tryGetTypeAtPosition(longest, i)
			if longest == right {
				longestParamType = instantiateType(longestParamType, mapper)
			}
			shorterParamType := tryGetTypeAtPosition(shorter, i) || unknownType
			if shorter == right {
				shorterParamType = instantiateType(shorterParamType, mapper)
			}
			unionParamType := getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{longestParamType, shorterParamType})
			isRestParam := eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount-1)
			isOptional := i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter)
			leftName := /* TODO(Node ConditionalExpression): i >= leftCount ? undefined : getParameterNameAtPosition(left, i) */ TODO
			rightName := /* TODO(Node ConditionalExpression): i >= rightCount ? undefined : getParameterNameAtPosition(right, i) */ TODO
			paramName := /* TODO(Node ConditionalExpression): leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : undefined */ TODO
			paramSymbol := createSymbol(SymbolFlagsFunctionScopedVariable|( /* TODO(Node ConditionalExpression): isOptional && !isRestParam ? SymbolFlags.Optional : 0 */ TODO), paramName || /* TODO(Node TemplateExpression): `arg${i}` */ TODO /* TODO(Node ConditionalExpression): isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0 */, TODO)
			paramSymbol.links.type_ = /* TODO(Node ConditionalExpression): isRestParam ? createArrayType(unionParamType) : unionParamType */ TODO
			params[i] = paramSymbol
		}
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args", CheckFlagsRestParameter)
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			params[longestCount] = restParamSymbol
		}
		return params
	}
	combineSignaturesOfUnionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
		}
		declaration := left.declaration
		params := combineUnionParameters(left, right, paramMapper)
		thisParam := combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsUnion
		result.compositeSignatures = concatenate(left.compositeKind != TypeFlagsIntersection && left.compositeSignatures || [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{left}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{right})
		if paramMapper {
			result.mapper = /* TODO(Node ConditionalExpression): left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper */ TODO
		} else if left.compositeKind != TypeFlagsIntersection && left.mapper && left.compositeSignatures {
			result.mapper = left.mapper
		}
		return result
	}
	getUnionIndexInfos := func(types []Type) []IndexInfo {
		sourceInfos := getIndexInfosOfType(types[0])
		if sourceInfos {
			result := [] /* TODO inferred type never */ any{}
			for _, info := range sourceInfos {
				indexType := info.keyType
				if every(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!getIndexInfoOfType(t, indexType)
				}) {
					result.push(createIndexInfo(indexType, getUnionType(map_(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return getIndexTypeOfType(t, indexType)
					})), some(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return getIndexInfoOfType(t, indexType).isReadonly
					})))
				}
			}
			return result
		}
		return emptyArray
	}
	resolveUnionTypeMembers := func(type_ UnionType) {
		callSignatures := getUnionSignatures(map_(type_.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ any {
			return /* TODO(Node ConditionalExpression): t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, SignatureKind.Call) */ TODO
		}))
		constructSignatures := getUnionSignatures(map_(type_.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ any {
			return getSignaturesOfType(t, SignatureKindConstruct)
		}))
		indexInfos := getUnionIndexInfos(type_.types)
		setStructuredTypeMembers(type_, emptySymbols, callSignatures, constructSignatures, indexInfos)
	}
	/* OVERLOAD: function intersectTypes(type1: Type, type2: Type): Type; */
	/* OVERLOAD: function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined; */
	intersectTypes := func(type1 *Type, type2 *Type) *Type {
		// converted from conditional expression
		switch {
		case !type1:
			return type2
		case !type2:
			return type1
		default:
			return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type1, type2})
		}
	}
	findMixins := func(types []Type) []bool {
		constructorTypeCount := countWhere(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return getSignaturesOfType(t, SignatureKindConstruct).length > 0
		})
		mixinFlags := map_(types, isMixinConstructorType)
		if constructorTypeCount > 0 && constructorTypeCount == countWhere(mixinFlags, func(b /* TODO inferred type boolean */ any) /* TODO inferred type boolean */ any {
			return b
		}) {
			firstMixinIndex := mixinFlags.indexOf(true)
			mixinFlags[firstMixinIndex] = false
		}
		return mixinFlags
	}
	includeMixinType := func(type_ Type, types []Type, mixinFlags []bool, index number) Type {
		var mixedTypes []Type = [] /* TODO inferred type never */ any{}
		for i := 0; i < types.length; i++ {
			if i == index {
				mixedTypes.push(type_)
			} else if mixinFlags[i] {
				mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKindConstruct)[0]))
			}
		}
		return getIntersectionType(mixedTypes)
	}
	resolveIntersectionTypeMembers := func(type_ IntersectionType) {
		var callSignatures *[]Signature
		var constructSignatures *[]Signature
		var indexInfos *[]IndexInfo
		types := type_.types
		mixinFlags := findMixins(types)
		mixinCount := countWhere(mixinFlags, func(b /* TODO inferred type boolean */ any) /* TODO inferred type boolean */ any {
			return b
		})
		for i := 0; i < types.length; i++ {
			t := type_.types[i]
			if !mixinFlags[i] {
				signatures := getSignaturesOfType(t, SignatureKindConstruct)
				if signatures.length && mixinCount > 0 {
					signatures = map_(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
						clone := cloneSignature(s)
						clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i)
						return clone
					})
				}
				constructSignatures = appendSignatures(constructSignatures, signatures)
			}
			callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKindCall))
			indexInfos = reduceLeft(getIndexInfosOfType(t), func(infos /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] | undefined */ any, newInfo /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ any {
				return appendIndexInfo(infos, newInfo, false)
			}, indexInfos)
		}
		setStructuredTypeMembers(type_, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray)
	}
	appendSignatures := func(signatures *[]Signature, newSignatures []Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] | undefined */ any {
		for _, sig := range newSignatures {
			if !signatures || every(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
				return !compareSignaturesIdentical(s, sig, false, false, false, compareTypesIdentical)
			}) {
				signatures = append(signatures, sig)
			}
		}
		return signatures
	}
	appendIndexInfo := func(indexInfos *[]IndexInfo, newInfo IndexInfo, union bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ any {
		if indexInfos {
			for i := 0; i < indexInfos.length; i++ {
				info := indexInfos[i]
				if info.keyType == newInfo.keyType {
					indexInfos[i] = createIndexInfo(info.keyType /* TODO(Node ConditionalExpression): union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]) */, TODO /* TODO(Node ConditionalExpression): union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly */, TODO)
					return indexInfos
				}
			}
		}
		return append(indexInfos, newInfo)
	}
	resolveAnonymousTypeMembers := func(type_ AnonymousType) {
		if type_.target {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := createInstantiatedSymbolTable(getPropertiesOfObjectType(type_.target), type_.mapper, false)
			callSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindCall), type_.mapper)
			constructSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindConstruct), type_.mapper)
			indexInfos := instantiateIndexInfos(getIndexInfosOfType(type_.target), type_.mapper)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		symbol := getMergedSymbol(type_.symbol)
		if symbol.flags & SymbolFlagsTypeLiteral {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := getMembersOfSymbol(symbol)
			callSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			constructSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			indexInfos := getIndexInfosOfSymbol(symbol)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		members := getExportsOfSymbol(symbol)
		var indexInfos *[]IndexInfo
		if symbol == globalThisSymbol {
			varsOnly := make(map[__String]Symbol)
			members.forEach(func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
				if !(p.flags & SymbolFlagsBlockScoped) && !(p.flags&SymbolFlagsValueModule && p.declarations. /*?*/ length && every(p.declarations, isAmbientModule)) {
					varsOnly.set(p.escapedName, p)
				}
			})
			members = varsOnly
		}
		var baseConstructorIndexInfo *IndexInfo
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, emptyArray)
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			baseConstructorType := getBaseConstructorTypeOfClass(classType)
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsTypeVariable) {
				members = createSymbolTable(getNamedOrIndexSignatureMembers(members))
				addInheritedMembers(members, getPropertiesOfType(baseConstructorType))
			} else if baseConstructorType == anyType {
				baseConstructorIndexInfo = createIndexInfo(stringType, anyType, false)
			}
		}
		indexSymbol := getIndexSymbolFromSymbolTable(members)
		if indexSymbol {
			indexInfos = getIndexInfosOfIndexSymbol(indexSymbol)
		} else {
			if baseConstructorIndexInfo {
				indexInfos = append(indexInfos, baseConstructorIndexInfo)
			}
			if symbol.flags&SymbolFlagsEnum && (getDeclaredTypeOfSymbol(symbol).flags&TypeFlagsEnum || some(type_.properties, func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
				return !!(getTypeOfSymbol(prop).flags & TypeFlagsNumberLike)
			})) {
				indexInfos = append(indexInfos, enumNumberIndexInfo)
			}
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			type_.callSignatures = getSignaturesOfSymbol(symbol)
		}
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			constructSignatures := /* TODO(Node ConditionalExpression): symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray */ TODO
			if symbol.flags & SymbolFlagsFunction {
				constructSignatures = addRange(constructSignatures.slice(), mapDefined(type_.callSignatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
					return /* TODO(Node ConditionalExpression): isJSConstructor(sig.declaration) ? createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate* / undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) : undefined */ TODO
				}))
			}
			if !constructSignatures.length {
				constructSignatures = getDefaultConstructSignatures(classType)
			}
			type_.constructSignatures = constructSignatures
		}
	}
	type ReplaceableIndexedAccessType /* TODO(TypeNode IntersectionType): IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ any
	replaceIndexedAccess := func(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return instantiateType(instantiable, createTypeMapper([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type & import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{type_.indexType, type_.objectType}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getNumberLiteralType(0), createTupleType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{replacement})}))
	}
	getLimitedConstraint := func(type_ ReverseMappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		constraint := getConstraintTypeFromMappedType(type_.mappedType)
		if !(constraint.flags&TypeFlagsUnion || constraint.flags&TypeFlagsIntersection) {
			return
		}
		origin := /* TODO(Node ConditionalExpression): (constraint.flags & TypeFlags.Union) ? (constraint as UnionType).origin : (constraint as IntersectionType) */ TODO
		if !origin || !(origin.flags & TypeFlagsIntersection) {
			return
		}
		limitedConstraint := getIntersectionType((origin).types.filter(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return t != type_.constraintType
		}))
		// converted from conditional expression
		switch {
		case limitedConstraint != neverType:
			return limitedConstraint
		default:
			return nil
		}
	}
	resolveReverseMappedTypeMembers := func(type_ ReverseMappedType) {
		indexInfo := getIndexInfoOfType(type_.source, stringType)
		modifiers := getMappedTypeModifiers(type_.mappedType)
		readonlyMask := /* TODO(Node ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? false : true */ TODO
		optionalMask := /* TODO(Node ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional */ TODO
		indexInfos := /* TODO(Node ConditionalExpression): indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray */ TODO
		members := createSymbolTable()
		limitedConstraint := getLimitedConstraint(type_)
		for _, prop := range getPropertiesOfType(type_.source) {
			if limitedConstraint {
				propertyNameType := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
				if !isTypeAssignableTo(propertyNameType, limitedConstraint) {
					continue
				}
			}
			checkFlags := CheckFlagsReverseMapped | ( /* TODO(Node ConditionalExpression): readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0 */ TODO)
			inferredProp := createSymbol(SymbolFlagsProperty|prop.flags&optionalMask, prop.escapedName, checkFlags)
			inferredProp.declarations = prop.declarations
			inferredProp.links.nameType = getSymbolLinks(prop).nameType
			inferredProp.links.propertyType = getTypeOfSymbol(prop)
			if type_.constraintType.type_.flags&TypeFlagsIndexedAccess && (type_.constraintType.type_).objectType.flags&TypeFlagsTypeParameter && (type_.constraintType.type_).indexType.flags&TypeFlagsTypeParameter {
				newTypeParam := (type_.constraintType.type_).objectType
				newMappedType := replaceIndexedAccess(type_.mappedType, type_.constraintType.type_, newTypeParam)
				inferredProp.links.mappedType = newMappedType
				inferredProp.links.constraintType = getIndexType(newTypeParam)
			} else {
				inferredProp.links.mappedType = type_.mappedType
				inferredProp.links.constraintType = type_.constraintType
			}
			members.set(prop.escapedName, inferredProp)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos)
	}
	getLowerBoundOfKeyType := func(type_ Type) Type {
		if type_.flags & TypeFlagsIndex {
			t := getApparentType((type_).type_)
			// converted from conditional expression
			switch {
			case isGenericTupleType(t):
				return getKnownKeysOfTupleType(t)
			default:
				return getIndexType(t)
			}
		}
		if type_.flags & TypeFlagsConditional {
			if (type_).root.isDistributive {
				checkType := (type_).checkType
				constraint := getLowerBoundOfKeyType(checkType)
				if constraint != checkType {
					return getConditionalTypeInstantiation(type_, prependTypeMapping((type_).root.checkType, constraint, (type_).mapper), false)
				}
			}
			return type_
		}
		if type_.flags & TypeFlagsUnion {
			return mapType(type_, getLowerBoundOfKeyType, true)
		}
		if type_.flags & TypeFlagsIntersection {
			types := (type_).types
			if types.length == 2 && !!(types[0].flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) && types[1] == emptyTypeLiteralType {
				return type_
			}
			return getIntersectionType(sameMap((type_).types, getLowerBoundOfKeyType))
		}
		return type_
	}
	getIsLateCheckFlag := func(s Symbol) CheckFlags {
		return getCheckFlags(s) & CheckFlagsLate
	}
	forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType := func(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type)) {
		for _, prop := range getPropertiesOfType(type_) {
			cb(getLiteralTypeFromProperty(prop, include))
		}
		if type_.flags & TypeFlagsAny {
			cb(stringType)
		} else {
			for _, info := range getIndexInfosOfType(type_) {
				if !stringsOnly || info.keyType.flags&(TypeFlagsString|TypeFlagsTemplateLiteral) {
					cb(info.keyType)
				}
			}
		}
	}
	resolveMappedTypeMembers := func(type_ MappedType) {
		var members SymbolTable = createSymbolTable()
		var indexInfos *[]IndexInfo
		setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		mappedType := (type_.target) || type_
		nameType := getNameTypeFromMappedType(mappedType)
		shouldLinkPropDeclarations := getMappedTypeNameTypeKind(mappedType) != MappedTypeNameTypeKindRemapping
		templateType := getTemplateTypeFromMappedType(mappedType)
		modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
		templateModifiers := getMappedTypeModifiers(type_)
		include := TypeFlagsStringOrNumberLiteralOrUnique
		if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, false, addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(Node ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			forEachType(propNameType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
				return addMemberForKeyTypeWorker(keyType, t)
			})
		}
		addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
			if isTypeUsableAsPropertyName(propNameType) {
				propName := getPropertyNameFromType(propNameType)
				existingProp := members.get(propName)
				if existingProp {
					existingProp.links.nameType = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{existingProp.links.nameType, propNameType})
					existingProp.links.keyType = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{existingProp.links.keyType, keyType})
				} else {
					modifiersProp := /* TODO(Node ConditionalExpression): isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined */ TODO
					isOptional := !!(templateModifiers&MappedTypeModifiersIncludeOptional || !(templateModifiers&MappedTypeModifiersExcludeOptional) && modifiersProp && modifiersProp.flags&SymbolFlagsOptional)
					isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp))
					stripOptional := strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags&SymbolFlagsOptional
					var lateFlag CheckFlags = /* TODO(Node ConditionalExpression): modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0 */ TODO
					prop := createSymbol(SymbolFlagsProperty|( /* TODO(Node ConditionalExpression): isOptional ? SymbolFlags.Optional : 0 */ TODO), propName, lateFlag|CheckFlagsMapped|( /* TODO(Node ConditionalExpression): isReadonly ? CheckFlags.Readonly : 0 */ TODO)|( /* TODO(Node ConditionalExpression): stripOptional ? CheckFlags.StripOptional : 0 */ TODO))
					prop.links.mappedType = type_
					prop.links.nameType = propNameType
					prop.links.keyType = keyType
					if modifiersProp {
						prop.links.syntheticOrigin = modifiersProp
						prop.declarations = /* TODO(Node ConditionalExpression): shouldLinkPropDeclarations ? modifiersProp.declarations : undefined */ TODO
					}
					members.set(propName, prop)
				}
			} else if isValidIndexKeyType(propNameType) || propNameType.flags&(TypeFlagsAny|TypeFlagsEnum) {
				indexKeyType := /* TODO(Node ConditionalExpression): propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType : propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType : propNameType */ TODO
				propType := instantiateType(templateType, appendTypeMapping(type_.mapper, typeParameter, keyType))
				modifiersIndexInfo := getApplicableIndexInfo(modifiersType, propNameType)
				isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersIndexInfo. /*?*/ isReadonly)
				indexInfo := createIndexInfo(indexKeyType, propType, isReadonly)
				indexInfos = appendIndexInfo(indexInfos, indexInfo, true)
			}
		}
	}
	getTypeOfMappedSymbol := func(symbol MappedSymbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !symbol.links.type_ {
			mappedType := symbol.links.mappedType
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				mappedType.containsError = true
				return errorType
			}
			templateType := getTemplateTypeFromMappedType(mappedType.target || mappedType)
			mapper := appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType)
			propType := instantiateType(templateType, mapper)
			type_ := /* TODO(Node ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) : symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) : propType */ TODO
			if !popTypeResolution() {
				error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType))
				type_ = errorType
			}
			/* TODO(Node BinaryExpression): symbol.links.type ??= type */ TODO
		}
		return symbol.links.type_
	}
	getTypeParameterFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
		return type_.typeParameter || ( /* TODO(Node BinaryExpression): type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)) */ TODO)
	}
	getConstraintTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return type_.constraintType || ( /* TODO(Node BinaryExpression): type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType */ TODO)
	}
	getNameTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		// converted from conditional expression
		switch {
		case type_.declaration.nameType:
			return type_.nameType || ( /* TODO(Node BinaryExpression): type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper) */ TODO)
		default:
			return nil
		}
	}
	getTemplateTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return type_.templateType || ( /* TODO(Node BinaryExpression): type.templateType = type.declaration.type ? instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) : errorType */ TODO)
	}
	getConstraintDeclarationForMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
		return getEffectiveConstraintOfTypeParameter(type_.declaration.typeParameter)
	}
	isMappedTypeWithKeyofConstraintDeclaration := func(type_ MappedType) /* TODO inferred type boolean */ any {
		constraintDeclaration := getConstraintDeclarationForMappedType(type_)
		return constraintDeclaration.kind == SyntaxKindTypeOperator && (constraintDeclaration).operator == SyntaxKindKeyOfKeyword
	}
	getModifiersTypeFromMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !type_.modifiersType {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				type_.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type_)).type_), type_.mapper)
			} else {
				declaredType := getTypeFromMappedTypeNode(type_.declaration)
				constraint := getConstraintTypeFromMappedType(declaredType)
				extendedConstraint := /* TODO(Node ConditionalExpression): constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint */ TODO
				type_.modifiersType = /* TODO(Node ConditionalExpression): extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType */ TODO
			}
		}
		return type_.modifiersType
	}
	getMappedTypeModifiers := func(type_ MappedType) MappedTypeModifiers {
		declaration := type_.declaration
		return ( /* TODO(Node ConditionalExpression): declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional : 0 */ TODO)
	}
	getMappedTypeOptionality := func(type_ MappedType) number {
		modifiers := getMappedTypeModifiers(type_)
		// converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersExcludeOptional:
			return -1
		case modifiers & MappedTypeModifiersIncludeOptional:
			return 1
		default:
			return 0
		}
	}
	getCombinedMappedTypeOptionality := func(type_ Type) number {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			return getMappedTypeOptionality(type_) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type_))
		}
		if type_.flags & TypeFlagsIntersection {
			optionality := getCombinedMappedTypeOptionality((type_).types[0])
			// converted from conditional expression
			switch {
			case every((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
				return i == 0 || getCombinedMappedTypeOptionality(t) == optionality
			}):
				return optionality
			default:
				return 0
			}
		}
		return 0
	}
	isPartialMappedType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(getObjectFlags(type_)&ObjectFlagsMapped && getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)
	}
	isGenericMappedType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is MappedType */ any {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			constraint := getConstraintTypeFromMappedType(type_)
			if isGenericIndexType(constraint) {
				return true
			}
			nameType := getNameTypeFromMappedType(type_)
			if nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type_), constraint))) {
				return true
			}
		}
		return false
	}
	getMappedTypeNameTypeKind := func(type_ MappedType) MappedTypeNameTypeKind {
		nameType := getNameTypeFromMappedType(type_)
		if !nameType {
			return MappedTypeNameTypeKindNone
		}
		// converted from conditional expression
		switch {
		case isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type_)):
			return MappedTypeNameTypeKindFiltering
		default:
			return MappedTypeNameTypeKindRemapping
		}
	}
	resolveStructuredTypeMembers := func(type_ StructuredType) ResolvedType {
		if !(type_).members {
			if type_.flags & TypeFlagsObject {
				if (type_).objectFlags & ObjectFlagsReference {
					resolveTypeReferenceMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsClassOrInterface {
					resolveClassOrInterfaceMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsReverseMapped {
					resolveReverseMappedTypeMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsAnonymous {
					resolveAnonymousTypeMembers(type_)
				} else if (type_).objectFlags & ObjectFlagsMapped {
					resolveMappedTypeMembers(type_)
				} else {
					Debug.fail("Unhandled object type " + Debug.formatObjectFlags(type_.objectFlags))
				}
			} else if type_.flags & TypeFlagsUnion {
				resolveUnionTypeMembers(type_)
			} else if type_.flags & TypeFlagsIntersection {
				resolveIntersectionTypeMembers(type_)
			} else {
				Debug.fail("Unhandled type " + Debug.formatTypeFlags(type_.flags))
			}
		}
		return type_
	}
	getPropertiesOfObjectType := func(type_ Type) []Symbol {
		if type_.flags & TypeFlagsObject {
			return resolveStructuredTypeMembers(type_).properties
		}
		return emptyArray
	}
	getPropertyOfObjectType := func(type_ Type, name __String) *Symbol {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			symbol := resolved.members.get(name)
			if symbol && symbolIsValue(symbol) {
				return symbol
			}
		}
	}
	getPropertiesOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType) []Symbol {
		if !type_.resolvedProperties {
			members := createSymbolTable()
			for _, current := range type_.types {
				for _, prop := range getPropertiesOfType(current) {
					if !members.has(prop.escapedName) {
						combinedProp := getPropertyOfUnionOrIntersectionType(type_, prop.escapedName, !!(type_.flags & TypeFlagsIntersection))
						if combinedProp {
							members.set(prop.escapedName, combinedProp)
						}
					}
				}
				if type_.flags&TypeFlagsUnion && getIndexInfosOfType(current).length == 0 {
					break
				}
			}
			type_.resolvedProperties = getNamedMembers(members)
		}
		return type_.resolvedProperties
	}
	getPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getReducedApparentType(type_)
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnionOrIntersection:
			return getPropertiesOfUnionOrIntersectionType(type_)
		default:
			return getPropertiesOfObjectType(type_)
		}
	}
	forEachPropertyOfType := func(type_ Type, action func(symbol Symbol, escapedName __String)) {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsStructuredType {
			resolveStructuredTypeMembers(type_).members.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, escapedName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
				if isNamedMember(symbol, escapedName) {
					action(symbol, escapedName)
				}
			})
		}
	}
	isTypeInvalidDueToUnionDiscriminant := func(contextualType Type, obj /* TODO(TypeNode UnionType): ObjectLiteralExpression | JsxAttributes */ any) bool {
		list := obj.properties
		return list.some(func(property /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralElementLike | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeLike */ any) /* TODO inferred type boolean */ any {
			nameType := property.name && ( /* TODO(Node ConditionalExpression): isJsxNamespacedName(property.name) ? getStringLiteralType(getTextOfJsxAttributeName(property.name)) : getLiteralTypeFromPropertyName(property.name) */ TODO)
			name := /* TODO(Node ConditionalExpression): nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
			expected := /* TODO(Node ConditionalExpression): name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name) */ TODO
			return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected)
		})
	}
	getAllPossiblePropertiesOfTypes := func(types []Type) []Symbol {
		unionType := getUnionType(types)
		if !(unionType.flags & TypeFlagsUnion) {
			return getAugmentedPropertiesOfType(unionType)
		}
		props := createSymbolTable()
		for _, memberType := range types {
			for _, TODO_IDENTIFIER := range getAugmentedPropertiesOfType(memberType) {
				if !props.has(escapedName) {
					prop := createUnionOrIntersectionProperty(unionType, escapedName)
					if prop {
						props.set(escapedName, prop)
					}
				}
			}
		}
		return arrayFrom(props.values())
	}
	getConstraintOfType := func(type_ /* TODO(TypeNode UnionType): InstantiableType | UnionOrIntersectionType */ any) *Type {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsTypeParameter:
			return getConstraintOfTypeParameter(type_)
		case type_.flags & TypeFlagsIndexedAccess:
			return getConstraintOfIndexedAccess(type_)
		case type_.flags & TypeFlagsConditional:
			return getConstraintOfConditionalType(type_)
		default:
			return getBaseConstraintOfType(type_)
		}
	}
	getConstraintOfTypeParameter := func(typeParameter TypeParameter) *Type {
		// converted from conditional expression
		switch {
		case hasNonCircularBaseConstraint(typeParameter):
			return getConstraintFromTypeParameter(typeParameter)
		default:
			return nil
		}
	}
	isConstMappedType := func(type_ MappedType, depth number) bool {
		typeVariable := getHomomorphicTypeVariable(type_)
		return !!typeVariable && isConstTypeVariable(typeVariable, depth)
	}
	isConstTypeVariable := func(type_ *Type, depth /* TODO inferred type number */ any /*  = 0 */) bool {
		return depth < 5 && !!(type_ && (type_.flags&TypeFlagsTypeParameter && some((type_).symbol. /*?*/ declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
			return hasSyntacticModifier(d, ModifierFlagsConst)
		}) || type_.flags&TypeFlagsUnionOrIntersection && some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return isConstTypeVariable(t, depth)
		}) || type_.flags&TypeFlagsIndexedAccess && isConstTypeVariable((type_).objectType, depth+1) || type_.flags&TypeFlagsConditional && isConstTypeVariable(getConstraintOfConditionalType(type_), depth+1) || type_.flags&TypeFlagsSubstitution && isConstTypeVariable((type_).baseType, depth) || getObjectFlags(type_)&ObjectFlagsMapped && isConstMappedType(type_, depth) || isGenericTupleType(type_) && findIndex(getElementTypes(type_), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
			return !!(type_.target.elementFlags[i] & ElementFlagsVariadic) && isConstTypeVariable(t, depth)
		}) >= 0))
	}
	getConstraintOfIndexedAccess := func(type_ IndexedAccessType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		// converted from conditional expression
		switch {
		case hasNonCircularBaseConstraint(type_):
			return getConstraintFromIndexedAccess(type_)
		default:
			return nil
		}
	}
	getSimplifiedTypeOrConstraint := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		simplified := getSimplifiedType(type_, false)
		// converted from conditional expression
		switch {
		case simplified != type_:
			return simplified
		default:
			return getConstraintOfType(type_)
		}
	}
	getConstraintFromIndexedAccess := func(type_ IndexedAccessType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if isMappedTypeGenericIndexedAccess(type_) {
			return substituteIndexedMappedType(type_.objectType, type_.indexType)
		}
		indexConstraint := getSimplifiedTypeOrConstraint(type_.indexType)
		if indexConstraint && indexConstraint != type_.indexType {
			indexedAccess := getIndexedAccessTypeOrUndefined(type_.objectType, indexConstraint, type_.accessFlags)
			if indexedAccess {
				return indexedAccess
			}
		}
		objectConstraint := getSimplifiedTypeOrConstraint(type_.objectType)
		if objectConstraint && objectConstraint != type_.objectType {
			return getIndexedAccessTypeOrUndefined(objectConstraint, type_.indexType, type_.accessFlags)
		}
		return nil
	}
	getDefaultConstraintOfConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !type_.resolvedDefaultConstraint {
			trueConstraint := getInferredTrueTypeFromConditionalType(type_)
			falseConstraint := getFalseTypeFromConditionalType(type_)
			type_.resolvedDefaultConstraint = /* TODO(Node ConditionalExpression): isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]) */ TODO
		}
		return type_.resolvedDefaultConstraint
	}
	getConstraintOfDistributiveConditionalType := func(type_ ConditionalType) *Type {
		if type_.resolvedConstraintOfDistributive != nil {
			return type_.resolvedConstraintOfDistributive || nil
		}
		if type_.root.isDistributive && type_.restrictiveInstantiation != type_ {
			simplified := getSimplifiedType(type_.checkType, false)
			constraint := /* TODO(Node ConditionalExpression): simplified === type.checkType ? getConstraintOfType(simplified) : simplified */ TODO
			if constraint && constraint != type_.checkType {
				instantiated := getConditionalTypeInstantiation(type_, prependTypeMapping(type_.root.checkType, constraint, type_.mapper), true)
				if !(instantiated.flags & TypeFlagsNever) {
					type_.resolvedConstraintOfDistributive = instantiated
					return instantiated
				}
			}
		}
		type_.resolvedConstraintOfDistributive = false
		return nil
	}
	getConstraintFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getConstraintOfDistributiveConditionalType(type_) || getDefaultConstraintOfConditionalType(type_)
	}
	getConstraintOfConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		// converted from conditional expression
		switch {
		case hasNonCircularBaseConstraint(type_):
			return getConstraintFromConditionalType(type_)
		default:
			return nil
		}
	}
	getEffectiveConstraintOfIntersection := func(types []Type, targetIsUnion bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		var constraints *[]Type
		hasDisjointDomainType := false
		for _, t := range types {
			if t.flags & TypeFlagsInstantiable {
				constraint := getConstraintOfType(t)
				for constraint && constraint.flags&(TypeFlagsTypeParameter|TypeFlagsIndex|TypeFlagsConditional) {
					constraint = getConstraintOfType(constraint)
				}
				if constraint {
					constraints = append(constraints, constraint)
					if targetIsUnion {
						constraints = append(constraints, t)
					}
				}
			} else if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
				hasDisjointDomainType = true
			}
		}
		if constraints && (targetIsUnion || hasDisjointDomainType) {
			if hasDisjointDomainType {
				for _, t := range types {
					if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
						constraints = append(constraints, t)
					}
				}
			}
			return getNormalizedType(getIntersectionType(constraints, IntersectionFlagsNoConstraintReduction), false)
		}
		return nil
	}
	getBaseConstraintOfType := func(type_ Type) *Type {
		if type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsUnionOrIntersection|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || isGenericTupleType(type_) {
			constraint := getResolvedBaseConstraint(type_)
			// converted from conditional expression
			switch {
			case constraint != noConstraintType && constraint != circularConstraintType:
				return constraint
			default:
				return nil
			}
		}
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIndex:
			return stringNumberSymbolType
		default:
			return nil
		}
	}
	getBaseConstraintOrType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getBaseConstraintOfType(type_) || type_
	}
	hasNonCircularBaseConstraint := func(type_ InstantiableType) bool {
		return getResolvedBaseConstraint(type_) != circularConstraintType
	}
	getResolvedBaseConstraint := func(type_ /* TODO(TypeNode UnionType): InstantiableType | UnionOrIntersectionType */ any) Type {
		if type_.resolvedBaseConstraint {
			return type_.resolvedBaseConstraint
		}
		var stack [] /* TODO(Node ObjectKeyword): object */ any = [] /* TODO inferred type never */ any{}
		type_.resolvedBaseConstraint = getImmediateBaseConstraint(type_)
		return type_.resolvedBaseConstraint
		getImmediateBaseConstraint := func(t Type) Type {
			if !t.immediateBaseConstraint {
				if !pushTypeResolution(t, TypeSystemPropertyNameImmediateBaseConstraint) {
					return circularConstraintType
				}
				var result TODO
				identity := getRecursionIdentity(t)
				if stack.length < 10 || stack.length < 50 && !contains(stack, identity) {
					stack.push(identity)
					result = computeBaseConstraint(getSimplifiedType(t, false))
					stack.pop()
				}
				if !popTypeResolution() {
					if t.flags & TypeFlagsTypeParameter {
						errorNode := getConstraintDeclaration(t)
						if errorNode {
							diagnostic := error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t))
							if currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode) {
								addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location))
							}
						}
					}
					result = circularConstraintType
				}
				/* TODO(Node BinaryExpression): t.immediateBaseConstraint ??= result || noConstraintType */ TODO
			}
			return t.immediateBaseConstraint
		}
		getBaseConstraint := func(t Type) *Type {
			c := getImmediateBaseConstraint(t)
			// converted from conditional expression
			switch {
			case c != noConstraintType && c != circularConstraintType:
				return c
			default:
				return nil
			}
		}
		computeBaseConstraint := func(t Type) *Type {
			if t.flags & TypeFlagsTypeParameter {
				constraint := getConstraintFromTypeParameter(t)
				// converted from conditional expression
				switch {
				case (t).isThisType || !constraint:
					return constraint
				default:
					return getBaseConstraint(constraint)
				}
			}
			if t.flags & TypeFlagsUnionOrIntersection {
				types := (t).types
				var baseTypes []Type = [] /* TODO inferred type never */ any{}
				different := false
				for _, type_ := range types {
					baseType := getBaseConstraint(type_)
					if baseType {
						if baseType != type_ {
							different = true
						}
						baseTypes.push(baseType)
					} else {
						different = true
					}
				}
				if !different {
					return t
				}
				// converted from conditional expression
				switch {
				case t.flags&TypeFlagsUnion && baseTypes.length == types.length:
					return getUnionType(baseTypes)
				case t.flags&TypeFlagsIntersection && baseTypes.length:
					return getIntersectionType(baseTypes)
				default:
					return nil
				}
			}
			if t.flags & TypeFlagsIndex {
				return stringNumberSymbolType
			}
			if t.flags & TypeFlagsTemplateLiteral {
				types := (t).types
				constraints := mapDefined(types, getBaseConstraint)
				// converted from conditional expression
				switch {
				case constraints.length == types.length:
					return getTemplateLiteralType((t).texts, constraints)
				default:
					return stringType
				}
			}
			if t.flags & TypeFlagsStringMapping {
				constraint := getBaseConstraint((t).type_)
				// converted from conditional expression
				switch {
				case constraint && constraint != (t).type_:
					return getStringMappingType((t).symbol, constraint)
				default:
					return stringType
				}
			}
			if t.flags & TypeFlagsIndexedAccess {
				if isMappedTypeGenericIndexedAccess(t) {
					return getBaseConstraint(substituteIndexedMappedType((t).objectType, (t).indexType))
				}
				baseObjectType := getBaseConstraint((t).objectType)
				baseIndexType := getBaseConstraint((t).indexType)
				baseIndexedAccess := baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t).accessFlags)
				return baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
			}
			if t.flags & TypeFlagsConditional {
				constraint := getConstraintFromConditionalType(t)
				return constraint && getBaseConstraint(constraint)
			}
			if t.flags & TypeFlagsSubstitution {
				return getBaseConstraint(getSubstitutionIntersection(t))
			}
			if isGenericTupleType(t) {
				newElements := map_(getElementTypes(t), func(v /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					constraint := v.flags&TypeFlagsTypeParameter && t.target.elementFlags[i]&ElementFlagsVariadic && getBaseConstraint(v) || v
					// converted from conditional expression
					switch {
					case constraint != v && everyType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return isArrayOrTupleType(c) && !isGenericTupleType(c)
					}):
						return constraint
					default:
						return v
					}
				})
				return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations)
			}
			return t
		}
	}
	getApparentTypeOfIntersectionType := func(type_ IntersectionType, thisArgument Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if type_ == thisArgument {
			return type_.resolvedApparentType || ( /* TODO(Node BinaryExpression): type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true) */ TODO)
		}
		key := /* TODO(Node TemplateExpression): `I${getTypeId(type)},${getTypeId(thisArgument)}` */ TODO
		return /* TODO(Node BinaryExpression): getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
	}
	getResolvedTypeParameterDefault := func(typeParameter TypeParameter) *Type {
		if !typeParameter.default_ {
			if typeParameter.target {
				targetDefault := getResolvedTypeParameterDefault(typeParameter.target)
				typeParameter.default_ = /* TODO(Node ConditionalExpression): targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType */ TODO
			} else {
				typeParameter.default_ = resolvingDefaultType
				defaultDeclaration := typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
					return isTypeParameterDeclaration(decl) && decl.default_
				})
				defaultType := /* TODO(Node ConditionalExpression): defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType */ TODO
				if typeParameter.default_ == resolvingDefaultType {
					typeParameter.default_ = defaultType
				}
			}
		} else if typeParameter.default_ == resolvingDefaultType {
			typeParameter.default_ = circularConstraintType
		}
		return typeParameter.default_
	}
	getDefaultFromTypeParameter := func(typeParameter TypeParameter) *Type {
		defaultType := getResolvedTypeParameterDefault(typeParameter)
		// converted from conditional expression
		switch {
		case defaultType != noConstraintType && defaultType != circularConstraintType:
			return defaultType
		default:
			return nil
		}
	}
	hasNonCircularTypeParameterDefault := func(typeParameter TypeParameter) /* TODO inferred type boolean */ any {
		return getResolvedTypeParameterDefault(typeParameter) != circularConstraintType
	}
	hasTypeParameterDefault := func(typeParameter TypeParameter) bool {
		return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
			return isTypeParameterDeclaration(decl) && decl.default_
		}))
	}
	getApparentTypeOfMappedType := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return type_.resolvedApparentType || ( /* TODO(Node BinaryExpression): type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type) */ TODO)
	}
	getResolvedApparentTypeOfMappedType := func(type_ MappedType) Type {
		target := ( /* TODO(Node BinaryExpression): type.target ?? type */ TODO)
		typeVariable := getHomomorphicTypeVariable(target)
		if typeVariable && !target.declaration.nameType {
			modifiersType := getModifiersTypeFromMappedType(type_)
			baseConstraint := /* TODO(Node ConditionalExpression): isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType) */ TODO
			if baseConstraint && everyType(baseConstraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isArrayOrTupleType(t) || isArrayOrTupleOrIntersection(t)
			}) {
				return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type_.mapper))
			}
		}
		return type_
	}
	isArrayOrTupleOrIntersection := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags & TypeFlagsIntersection) && every((type_).types, isArrayOrTupleType)
	}
	isMappedTypeGenericIndexedAccess := func(type_ Type) /* TODO inferred type boolean */ any {
		var objectType TODO
		return !!(type_.flags&TypeFlagsIndexedAccess && getObjectFlags( /* TODO(Node BinaryExpression): objectType = (type as IndexedAccessType).objectType */ TODO)&ObjectFlagsMapped && !isGenericMappedType(objectType) && isGenericIndexType((type_).indexType) && !(getMappedTypeModifiers(objectType) & MappedTypeModifiersExcludeOptional) && !(objectType).declaration.nameType)
	}
	getApparentType := func(type_ Type) Type {
		t := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type */ TODO
		objectFlags := getObjectFlags(t)
		// converted from conditional expression
		switch {
		case objectFlags & ObjectFlagsMapped:
			return getApparentTypeOfMappedType(t)
		case objectFlags&ObjectFlagsReference && t != type_:
			return getTypeWithThisArgument(t, type_)
		case t.flags & TypeFlagsIntersection:
			return getApparentTypeOfIntersectionType(t, type_)
		case t.flags & TypeFlagsStringLike:
			return globalStringType
		case t.flags & TypeFlagsNumberLike:
			return globalNumberType
		case t.flags & TypeFlagsBigIntLike:
			return getGlobalBigIntType()
		case t.flags & TypeFlagsBooleanLike:
			return globalBooleanType
		case t.flags & TypeFlagsESSymbolLike:
			return getGlobalESSymbolType()
		case t.flags & TypeFlagsNonPrimitive:
			return emptyObjectType
		case t.flags & TypeFlagsIndex:
			return stringNumberSymbolType
		case t.flags&TypeFlagsUnknown && !strictNullChecks:
			return emptyObjectType
		default:
			return t
		}
	}
	getReducedApparentType := func(type_ Type) Type {
		return getReducedType(getApparentType(getReducedType(type_)))
	}
	createUnionOrIntersectionProperty := func(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		var singleProp *Symbol
		var propSet *Map[SymbolId, Symbol]
		var indexTypes *[]Type
		isUnion := containingType.flags & TypeFlagsUnion
		var optionalFlag *SymbolFlags
		syntheticFlag := CheckFlagsSyntheticMethod
		checkFlags := /* TODO(Node ConditionalExpression): isUnion ? 0 : CheckFlags.Readonly */ TODO
		mergedInstantiations := false
		for _, current := range containingType.types {
			type_ := getApparentType(current)
			if !(isErrorType(type_) || type_.flags&TypeFlagsNever) {
				prop := getPropertyOfType(type_, name, skipObjectFunctionPropertyAugment)
				modifiers := /* TODO(Node ConditionalExpression): prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0 */ TODO
				if prop {
					if prop.flags & SymbolFlagsClassMember {
						/* TODO(Node BinaryExpression): optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional */ TODO
						if isUnion {
							optionalFlag |= prop.flags & SymbolFlagsOptional
						} else {
							optionalFlag &= prop.flags
						}
					}
					if !singleProp {
						singleProp = prop
					} else if prop != singleProp {
						isInstantiation := (getTargetSymbol(prop) || prop) == (getTargetSymbol(singleProp) || singleProp)
						if isInstantiation && compareProperties(singleProp, prop, func(a /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, b /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.False | import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.True */ any {
							return /* TODO(Node ConditionalExpression): a === b ? Ternary.True : Ternary.False */ TODO
						}) == TernaryTrue {
							mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent))
						} else {
							if !propSet {
								propSet = make(map[SymbolId]Symbol)
								propSet.set(getSymbolId(singleProp), singleProp)
							}
							id := getSymbolId(prop)
							if !propSet.has(id) {
								propSet.set(id, prop)
							}
						}
					}
					if isUnion && isReadonlySymbol(prop) {
						checkFlags |= CheckFlagsReadonly
					} else if !isUnion && !isReadonlySymbol(prop) {
						checkFlags &= ~CheckFlagsReadonly
					}
					checkFlags |= ( /* TODO(Node ConditionalExpression): !(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0 */ TODO)
					if !isPrototypeProperty(prop) {
						syntheticFlag = CheckFlagsSyntheticProperty
					}
				} else if isUnion {
					indexInfo := !isLateBoundName(name) && getApplicableIndexInfoForName(type_, name)
					if indexInfo {
						checkFlags |= CheckFlagsWritePartial | ( /* TODO(Node ConditionalExpression): indexInfo.isReadonly ? CheckFlags.Readonly : 0 */ TODO)
						indexTypes = append(indexTypes /* TODO(Node ConditionalExpression): isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type */, TODO)
					} else if isObjectLiteralType(type_) && !(getObjectFlags(type_) & ObjectFlagsContainsSpread) {
						checkFlags |= CheckFlagsWritePartial
						indexTypes = append(indexTypes, undefinedType)
					} else {
						checkFlags |= CheckFlagsReadPartial
					}
				}
			}
		}
		if !singleProp || isUnion && (propSet || checkFlags&CheckFlagsPartial) && checkFlags&(CheckFlagsContainsPrivate|CheckFlagsContainsProtected) && !(propSet && getCommonDeclarationsOfSymbols(propSet.values())) {
			return nil
		}
		if !propSet && !(checkFlags & CheckFlagsReadPartial) && !indexTypes {
			if mergedInstantiations {
				links := tryCast(singleProp, isTransientSymbol). /*?*/ links
				clone := createSymbolWithType(singleProp, links. /*?*/ type_)
				clone.parent = singleProp.valueDeclaration. /*?*/ symbol. /*?*/ parent
				clone.links.containingType = containingType
				clone.links.mapper = links. /*?*/ mapper
				clone.links.writeType = getWriteTypeOfSymbol(singleProp)
				return clone
			} else {
				return singleProp
			}
		}
		props := /* TODO(Node ConditionalExpression): propSet ? arrayFrom(propSet.values()) : [singleProp] */ TODO
		var declarations *[]Declaration
		var firstType *Type
		var nameType *Type
		var propTypes []Type = [] /* TODO inferred type never */ any{}
		var writeTypes *[]Type
		var firstValueDeclaration Declaration
		hasNonUniformValueDeclaration := false
		for _, prop := range props {
			if !firstValueDeclaration {
				firstValueDeclaration = prop.valueDeclaration
			} else if prop.valueDeclaration && prop.valueDeclaration != firstValueDeclaration {
				hasNonUniformValueDeclaration = true
			}
			declarations = addRange(declarations, prop.declarations)
			type_ := getTypeOfSymbol(prop)
			if !firstType {
				firstType = type_
				nameType = getSymbolLinks(prop).nameType
			}
			writeType := getWriteTypeOfSymbol(prop)
			if writeTypes || writeType != type_ {
				writeTypes = append( /* TODO(Node ConditionalExpression): !writeTypes ? propTypes.slice() : writeTypes */ TODO, writeType)
			}
			if type_ != firstType {
				checkFlags |= CheckFlagsHasNonUniformType
			}
			if isLiteralType(type_) || isPatternLiteralType(type_) {
				checkFlags |= CheckFlagsHasLiteralType
			}
			if type_.flags&TypeFlagsNever && type_ != uniqueLiteralType {
				checkFlags |= CheckFlagsHasNeverType
			}
			propTypes.push(type_)
		}
		addRange(propTypes, indexTypes)
		result := createSymbol(SymbolFlagsProperty|( /* TODO(Node BinaryExpression): optionalFlag ?? 0 */ TODO), name, syntheticFlag|checkFlags)
		result.links.containingType = containingType
		if !hasNonUniformValueDeclaration && firstValueDeclaration {
			result.valueDeclaration = firstValueDeclaration
			if firstValueDeclaration.symbol.parent {
				result.parent = firstValueDeclaration.symbol.parent
			}
		}
		result.declarations = declarations
		result.links.nameType = nameType
		if propTypes.length > 2 {
			result.links.checkFlags |= CheckFlagsDeferredType
			result.links.deferralParent = containingType
			result.links.deferralConstituents = propTypes
			result.links.deferralWriteConstituents = writeTypes
		} else {
			result.links.type_ = /* TODO(Node ConditionalExpression): isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes) */ TODO
			if writeTypes {
				result.links.writeType = /* TODO(Node ConditionalExpression): isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes) */ TODO
			}
		}
		return result
	}
	getUnionOrIntersectionProperty := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := /* TODO(Node ConditionalExpression): skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) : type.propertyCache?.get(name) */ TODO
		if !property {
			property = createUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
			if property {
				properties := /* TODO(Node ConditionalExpression): skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() : type.propertyCache ||= createSymbolTable() */ TODO
				properties.set(name, property)
				if skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlagsPartial) && !type_.propertyCache. /*?*/ get(name) {
					properties := /* TODO(Node BinaryExpression): type.propertyCache ||= createSymbolTable() */ TODO
					properties.set(name, property)
				}
			}
		}
		return property
	}
	getCommonDeclarationsOfSymbols := func(symbols Iterable[Symbol]) /* TODO inferred type Set<import("/home/jabaile/work/TypeScript/src/compiler/types").Node> | undefined */ any {
		var commonDeclarations *Set[Node]
		for _, symbol := range symbols {
			if !symbol.declarations {
				return nil
			}
			if !commonDeclarations {
				commonDeclarations = /* TODO(Node NewExpression): new Set(symbol.declarations) */ TODO
				continue
			}
			commonDeclarations.forEach(func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) {
				if !contains(symbol.declarations, declaration) {
					commonDeclarations.delete(declaration)
				}
			})
			if commonDeclarations.size == 0 {
				return nil
			}
		}
		return commonDeclarations
	}
	getPropertyOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
		// converted from conditional expression
		switch {
		case property && !(getCheckFlags(property) & CheckFlagsReadPartial):
			return property
		default:
			return nil
		}
	}
	getReducedType := func(type_ Type) Type {
		if type_.flags&TypeFlagsUnion && (type_).objectFlags&ObjectFlagsContainsIntersections {
			return (type_).resolvedReducedType || ( /* TODO(Node BinaryExpression): (type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType) */ TODO)
		} else if type_.flags & TypeFlagsIntersection {
			if !((type_).objectFlags & ObjectFlagsIsNeverIntersectionComputed) {
				(type_).objectFlags |= ObjectFlagsIsNeverIntersectionComputed | ( /* TODO(Node ConditionalExpression): some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0 */ TODO)
			}
			// converted from conditional expression
			switch {
			case (type_).objectFlags & ObjectFlagsIsNeverIntersection:
				return neverType
			default:
				return type_
			}
		}
		return type_
	}
	getReducedUnionType := func(unionType UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		reducedTypes := sameMap(unionType.types, getReducedType)
		if reducedTypes == unionType.types {
			return unionType
		}
		reduced := getUnionType(reducedTypes)
		if reduced.flags & TypeFlagsUnion {
			(reduced).resolvedReducedType = reduced
		}
		return reduced
	}
	isNeverReducedProperty := func(prop Symbol) /* TODO inferred type boolean */ any {
		return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop)
	}
	isDiscriminantWithNeverType := func(prop Symbol) /* TODO inferred type boolean */ any {
		return !(prop.flags & SymbolFlagsOptional) && (getCheckFlags(prop)&(CheckFlagsDiscriminant|CheckFlagsHasNeverType)) == CheckFlagsDiscriminant && !!(getTypeOfSymbol(prop).flags & TypeFlagsNever)
	}
	isConflictingPrivateProperty := func(prop Symbol) /* TODO inferred type boolean */ any {
		return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlagsContainsPrivate)
	}
	isGenericReducibleType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnion && (type_).objectFlags&ObjectFlagsContainsIntersections && some((type_).types, isGenericReducibleType) || type_.flags&TypeFlagsIntersection && isReducibleIntersection(type_))
	}
	isReducibleIntersection := func(type_ IntersectionType) /* TODO inferred type boolean */ any {
		uniqueFilled := type_.uniqueLiteralFilledInstantiation || ( /* TODO(Node BinaryExpression): type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper) */ TODO)
		return getReducedType(uniqueFilled) != uniqueFilled
	}
	elaborateNeverIntersection := func(errorInfo *DiagnosticMessageChain, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ any {
		if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsNeverIntersection {
			neverProp := find(getPropertiesOfUnionOrIntersectionType(type_), isDiscriminantWithNeverType)
			if neverProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type_, nil, TypeFormatFlagsNoTypeReduction), symbolToString(neverProp))
			}
			privateProp := find(getPropertiesOfUnionOrIntersectionType(type_), isConflictingPrivateProperty)
			if privateProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type_, nil, TypeFormatFlagsNoTypeReduction), symbolToString(privateProp))
			}
		}
		return errorInfo
	}
	getPropertyOfType := func(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) *Symbol {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			symbol := resolved.members.get(name)
			if symbol && !includeTypeOnlyMembers && type_.symbol. /*?*/ flags&SymbolFlagsValueModule && getSymbolLinks(type_.symbol).typeOnlyExportStarMap. /*?*/ has(name) {
				return nil
			}
			if symbol && symbolIsValue(symbol, includeTypeOnlyMembers) {
				return symbol
			}
			if skipObjectFunctionPropertyAugment {
				return nil
			}
			functionType := /* TODO(Node ConditionalExpression): resolved === anyFunctionType ? globalFunctionType : resolved.callSignatures.length ? globalCallableFunctionType : resolved.constructSignatures.length ? globalNewableFunctionType : undefined */ TODO
			if functionType {
				symbol := getPropertyOfObjectType(functionType, name)
				if symbol {
					return symbol
				}
			}
			return getPropertyOfObjectType(globalObjectType, name)
		}
		if type_.flags & TypeFlagsIntersection {
			prop := getPropertyOfUnionOrIntersectionType(type_, name, true)
			if prop {
				return prop
			}
			if !skipObjectFunctionPropertyAugment {
				return getPropertyOfUnionOrIntersectionType(type_, name, skipObjectFunctionPropertyAugment)
			}
			return nil
		}
		if type_.flags & TypeFlagsUnion {
			return getPropertyOfUnionOrIntersectionType(type_, name, skipObjectFunctionPropertyAugment)
		}
		return nil
	}
	getSignaturesOfStructuredType := func(type_ Type, kind SignatureKind) []Signature {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_)
			// converted from conditional expression
			switch {
			case kind == SignatureKindCall:
				return resolved.callSignatures
			default:
				return resolved.constructSignatures
			}
		}
		return emptyArray
	}
	getSignaturesOfType := func(type_ Type, kind SignatureKind) []Signature {
		result := getSignaturesOfStructuredType(getReducedApparentType(type_), kind)
		if kind == SignatureKindCall && !length(result) && type_.flags&TypeFlagsUnion {
			if (type_).arrayFallbackSignatures {
				return (type_).arrayFallbackSignatures
			}
			var memberName __String
			if everyType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !!t.symbol. /*?*/ parent && isArrayOrTupleSymbol(t.symbol.parent) && ( /* TODO(Node ConditionalExpression): !memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName */ TODO)
			}) {
				arrayArg := mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getMappedType(( /* TODO(Node ConditionalExpression): isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType */ TODO).typeParameters[0], (t).mapper)
				})
				arrayType := createArrayType(arrayArg, someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isReadonlyArraySymbol(t.symbol.parent)
				}))
				(type_).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName), kind)
				return (type_).arrayFallbackSignatures
			}
			(type_).arrayFallbackSignatures = result
		}
		return result
	}
	isArrayOrTupleSymbol := func(symbol *Symbol) /* TODO inferred type boolean */ any {
		if !symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	isReadonlyArraySymbol := func(symbol *Symbol) /* TODO inferred type boolean */ any {
		if !symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	findIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ any {
		return find(indexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type boolean */ any {
			return info.keyType == keyType
		})
	}
	findApplicableIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ any {
		var stringIndexInfo *IndexInfo
		var applicableInfo *IndexInfo
		var applicableInfos *[]IndexInfo
		for _, info := range indexInfos {
			if info.keyType == stringType {
				stringIndexInfo = info
			} else if isApplicableIndexType(keyType, info.keyType) {
				if !applicableInfo {
					applicableInfo = info
				} else {
					(applicableInfos || ( /* TODO(Node BinaryExpression): applicableInfos = [applicableInfo] */ TODO)).push(info)
				}
			}
		}
		// converted from conditional expression
		switch {
		case applicableInfos:
			return createIndexInfo(unknownType, getIntersectionType(map_(applicableInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return info.type_
			})), reduceLeft(applicableInfos, func(isReadonly /* TODO inferred type boolean */ any, info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type boolean */ any {
				return isReadonly && info.isReadonly
			}, true))
		case applicableInfo:
			return applicableInfo
		case stringIndexInfo && isApplicableIndexType(keyType, stringType):
			return stringIndexInfo
		default:
			return nil
		}
	}
	isApplicableIndexType := func(source Type, target Type) bool {
		return isTypeAssignableTo(source, target) || target == stringType && isTypeAssignableTo(source, numberType) || target == numberType && (source == numericStringType || !!(source.flags&TypeFlagsStringLiteral) && isNumericLiteralName((source).value))
	}
	getIndexInfosOfStructuredType := func(type_ Type) []IndexInfo {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_)
			return resolved.indexInfos
		}
		return emptyArray
	}
	getIndexInfosOfType := func(type_ Type) []IndexInfo {
		return getIndexInfosOfStructuredType(getReducedApparentType(type_))
	}
	getIndexInfoOfType := func(type_ Type, keyType Type) *IndexInfo {
		return findIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getIndexTypeOfType := func(type_ Type, keyType Type) *Type {
		return getIndexInfoOfType(type_, keyType). /*?*/ type_
	}
	getApplicableIndexInfos := func(type_ Type, keyType Type) []IndexInfo {
		return getIndexInfosOfType(type_).filter(func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type boolean */ any {
			return isApplicableIndexType(keyType, info.keyType)
		})
	}
	getApplicableIndexInfo := func(type_ Type, keyType Type) *IndexInfo {
		return findApplicableIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getApplicableIndexInfoForName := func(type_ Type, name __String) *IndexInfo {
		return getApplicableIndexInfo(type_ /* TODO(Node ConditionalExpression): isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)) */, TODO)
	}
	getTypeParametersFromDeclaration := func(declaration DeclarationWithTypeParameters) *[]TypeParameter {
		var result *[]TypeParameter
		for _, node := range getEffectiveTypeParameterDeclarations(declaration) {
			result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol))
		}
		// converted from conditional expression
		switch {
		case result. /*?*/ length:
			return result
		case isFunctionDeclaration(declaration):
			return getSignatureOfTypeTag(declaration). /*?*/ typeParameters
		default:
			return nil
		}
	}
	symbolsToArray := func(symbols SymbolTable) []Symbol {
		var result []Symbol = [] /* TODO inferred type never */ any{}
		symbols.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
			if !isReservedMemberName(id) {
				result.push(symbol)
			}
		})
		return result
	}
	tryFindAmbientModule := func(moduleName string, withAugmentations bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		if isExternalModuleNameRelative(moduleName) {
			return nil
		}
		symbol := getSymbol(globals, '"'+moduleName+'"', SymbolFlagsValueModule)
		// converted from conditional expression
		switch {
		case symbol && withAugmentations:
			return getMergedSymbol(symbol)
		default:
			return symbol
		}
	}
	hasEffectiveQuestionToken := func(node /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO inferred type boolean */ any {
		return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node)
	}
	isOptionalParameter := func(node /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO inferred type boolean */ any {
		if hasEffectiveQuestionToken(node) {
			return true
		}
		if !isParameter(node) {
			return false
		}
		if node.initializer {
			signature := getSignatureFromDeclaration(node.parent)
			parameterIndex := node.parent.parameters.indexOf(node)
			Debug.assert(parameterIndex >= 0)
			return parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlagsStrongArityForUntypedJS|MinArgumentCountFlagsVoidIsNonOptional)
		}
		iife := getImmediatelyInvokedFunctionExpression(node.parent)
		if iife {
			return !node.type_ && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length
		}
		return false
	}
	isOptionalPropertyDeclaration := func(node Declaration) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ any {
		return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken
	}
	createTypePredicate := func(kind TypePredicateKind, parameterName *string, parameterIndex *number, type_ *Type) TypePredicate {
		return /* TODO(Node ObjectLiteralExpression): { kind, parameterName, parameterIndex, type } */ TODO
	}
	getMinTypeArgumentCount := func(typeParameters *[]TypeParameter) number {
		minTypeArgumentCount := 0
		if typeParameters {
			for i := 0; i < typeParameters.length; i++ {
				if !hasTypeParameterDefault(typeParameters[i]) {
					minTypeArgumentCount = i + 1
				}
			}
		}
		return minTypeArgumentCount
	}
	/* OVERLOAD: function fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[]; */
	/* OVERLOAD: function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[] | undefined; */
	fillMissingTypeArguments := func(typeArguments *[]Type, typeParameters *[]TypeParameter, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ any {
		numTypeParameters := length(typeParameters)
		if !numTypeParameters {
			return [] /* TODO inferred type never */ any{}
		}
		numTypeArguments := length(typeArguments)
		if isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
			result := /* TODO(Node ConditionalExpression): typeArguments ? typeArguments.slice() : [] */ TODO
			for i := numTypeArguments; i < numTypeParameters; i++ {
				result[i] = errorType
			}
			baseDefaultType := getDefaultTypeArgumentType(isJavaScriptImplicitAny)
			for i := numTypeArguments; i < numTypeParameters; i++ {
				defaultType := getDefaultFromTypeParameter(typeParameters[i])
				if isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType)) {
					defaultType = anyType
				}
				result[i] = /* TODO(Node ConditionalExpression): defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType */ TODO
			}
			result.length = typeParameters.length
			return result
		}
		return typeArguments && typeArguments.slice()
	}
	getSignatureFromDeclaration := func(declaration /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature */ any) Signature {
		links := getNodeLinks(declaration)
		if !links.resolvedSignature {
			var parameters []Symbol = [] /* TODO inferred type never */ any{}
			flags := SignatureFlagsNone
			minArgumentCount := 0
			var thisParameter *Symbol
			var thisTag *JSDocThisTag = /* TODO(Node ConditionalExpression): isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined */ TODO
			hasThisParameter := false
			iife := getImmediatelyInvokedFunctionExpression(declaration)
			isJSConstructSignature := isJSDocConstructSignature(declaration)
			isUntypedSignatureInJSFile := !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration)
			if isUntypedSignatureInJSFile {
				flags |= SignatureFlagsIsUntypedSignatureInJSFile
			}
			for i := /* TODO(Node ConditionalExpression): isJSConstructSignature ? 1 : 0 */ TODO; i < declaration.parameters.length; i++ {
				param := declaration.parameters[i]
				if isInJSFile(param) && isJSDocThisTag(param) {
					thisTag = param
					continue
				}
				paramSymbol := param.symbol
				type_ := /* TODO(Node ConditionalExpression): isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type */ TODO
				if paramSymbol && !!(paramSymbol.flags & SymbolFlagsProperty) && !isBindingPattern(param.name) {
					resolvedSymbol := resolveName(param, paramSymbol.escapedName, SymbolFlagsValue, nil, false)
					paramSymbol = resolvedSymbol
				}
				if i == 0 && paramSymbol.escapedName == InternalSymbolNameThis {
					hasThisParameter = true
					thisParameter = param.symbol
				} else {
					parameters.push(paramSymbol)
				}
				if type_ && type_.kind == SyntaxKindLiteralType {
					flags |= SignatureFlagsHasLiteralTypes
				}
				isOptionalParameter := hasEffectiveQuestionToken(param) || isParameter(param) && param.initializer || isRestParameter(param) || iife && parameters.length > iife.arguments.length && !type_
				if !isOptionalParameter {
					minArgumentCount = parameters.length
				}
			}
			if (declaration.kind == SyntaxKindGetAccessor || declaration.kind == SyntaxKindSetAccessor) && hasBindableName(declaration) && (!hasThisParameter || !thisParameter) {
				otherKind := /* TODO(Node ConditionalExpression): declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
				other := getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind)
				if other {
					thisParameter = getAnnotatedAccessorThisParameter(other)
				}
			}
			if thisTag && thisTag.typeExpression {
				thisParameter = createSymbolWithType(createSymbol(SymbolFlagsFunctionScopedVariable, InternalSymbolNameThis), getTypeFromTypeNode(thisTag.typeExpression))
			}
			hostDeclaration := /* TODO(Node ConditionalExpression): isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration */ TODO
			classType := /* TODO(Node ConditionalExpression): hostDeclaration && isConstructorDeclaration(hostDeclaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol)) : undefined */ TODO
			typeParameters := /* TODO(Node ConditionalExpression): classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration) */ TODO
			if hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters) {
				flags |= SignatureFlagsHasRestParameter
			}
			if isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlagsAbstract) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlagsAbstract) {
				flags |= SignatureFlagsAbstract
			}
			links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, nil, nil, minArgumentCount, flags)
		}
		return links.resolvedSignature
	}
	maybeAddJsSyntheticRestParameter := func(declaration /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
		if isJSDocSignature(declaration) || !containsArgumentsReference(declaration) {
			return false
		}
		lastParam := lastOrUndefined(declaration.parameters)
		lastParamTags := /* TODO(Node ConditionalExpression): lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag) */ TODO
		lastParamVariadicType := firstDefined(lastParamTags, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocParameterTag */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocVariadicType | undefined */ any {
			return /* TODO(Node ConditionalExpression): p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : undefined */ TODO
		})
		syntheticArgsSymbol := createSymbol(SymbolFlagsVariable, "args", CheckFlagsRestParameter)
		if lastParamVariadicType {
			syntheticArgsSymbol.links.type_ = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type_))
		} else {
			syntheticArgsSymbol.links.checkFlags |= CheckFlagsDeferredType
			syntheticArgsSymbol.links.deferralParent = neverType
			syntheticArgsSymbol.links.deferralConstituents = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{anyArrayType}
			syntheticArgsSymbol.links.deferralWriteConstituents = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{anyArrayType}
		}
		if lastParamVariadicType {
			parameters.pop()
		}
		parameters.push(syntheticArgsSymbol)
		return true
	}
	getSignatureOfTypeTag := func(node /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
		if !(isInJSFile(node) && isFunctionLikeDeclaration(node)) {
			return nil
		}
		typeTag := getJSDocTypeTag(node)
		return typeTag. /*?*/ typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
	}
	getParameterTypeOfTypeTag := func(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		signature := getSignatureOfTypeTag(func_)
		if !signature {
			return nil
		}
		pos := func_.parameters.indexOf(parameter)
		// converted from conditional expression
		switch {
		case parameter.dotDotDotToken:
			return getRestTypeAtPosition(signature, pos)
		default:
			return getTypeAtPosition(signature, pos)
		}
	}
	getReturnTypeOfTypeTag := func(node /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		signature := getSignatureOfTypeTag(node)
		return signature && getReturnTypeOfSignature(signature)
	}
	containsArgumentsReference := func(declaration SignatureDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.containsArgumentsReference == nil {
			if links.flags & NodeCheckFlagsCaptureArguments {
				links.containsArgumentsReference = true
			} else {
				links.containsArgumentsReference = traverse((declaration).body)
			}
		}
		return links.containsArgumentsReference
		traverse := func(node Node) bool {
			if !node {
				return false
			}
			switch node.kind {
			case SyntaxKindIdentifier:
				return (node).escapedText == argumentsSymbol.escapedName && getReferencedValueSymbol(node) == argumentsSymbol
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				return (node).name.kind == SyntaxKindComputedPropertyName && traverse((node).name)
			case SyntaxKindPropertyAccessExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindElementAccessExpression:
				return traverse((node).expression)
			case SyntaxKindPropertyAssignment:
				return traverse((node).initializer)
			default:
				return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse)
			}
		}
	}
	getSignaturesOfSymbol := func(symbol *Symbol) []Signature {
		if !symbol || !symbol.declarations {
			return emptyArray
		}
		var result []Signature = [] /* TODO inferred type never */ any{}
		for i := 0; i < symbol.declarations.length; i++ {
			decl := symbol.declarations[i]
			if !isFunctionLike(decl) {
				continue
			}
			if i > 0 && (decl).body {
				previous := symbol.declarations[i-1]
				if decl.parent == previous.parent && decl.kind == previous.kind && decl.pos == previous.end {
					continue
				}
			}
			if isInJSFile(decl) && decl.jsDoc {
				tags := getJSDocOverloadTags(decl)
				if length(tags) {
					for _, tag := range tags {
						jsDocSignature := tag.typeExpression
						if jsDocSignature.type_ == nil && !isConstructorDeclaration(decl) {
							reportImplicitAny(jsDocSignature, anyType)
						}
						result.push(getSignatureFromDeclaration(jsDocSignature))
					}
					continue
				}
			}
			result.push((!isFunctionExpressionOrArrowFunction(decl) && !isObjectLiteralMethod(decl) && getSignatureOfTypeTag(decl)) || getSignatureFromDeclaration(decl))
		}
		return result
	}
	resolveExternalModuleTypeByLiteral := func(name StringLiteral) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		moduleSym := resolveExternalModuleName(name, name)
		if moduleSym {
			resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
			if resolvedModuleSymbol {
				return getTypeOfSymbol(resolvedModuleSymbol)
			}
		}
		return anyType
	}
	getThisTypeOfSignature := func(signature Signature) *Type {
		if signature.thisParameter {
			return getTypeOfSymbol(signature.thisParameter)
		}
	}
	getTypePredicateOfSignature := func(signature Signature) *TypePredicate {
		if !signature.resolvedTypePredicate {
			if signature.target {
				targetTypePredicate := getTypePredicateOfSignature(signature.target)
				signature.resolvedTypePredicate = /* TODO(Node ConditionalExpression): targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate */ TODO
			} else if signature.compositeSignatures {
				signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate
			} else {
				type_ := signature.declaration && getEffectiveReturnTypeNode(signature.declaration)
				var jsdocPredicate *TypePredicate
				if !type_ {
					jsdocSignature := getSignatureOfTypeTag(signature.declaration)
					if jsdocSignature && signature != jsdocSignature {
						jsdocPredicate = getTypePredicateOfSignature(jsdocSignature)
					}
				}
				if type_ || jsdocPredicate {
					signature.resolvedTypePredicate = /* TODO(Node ConditionalExpression): type && isTypePredicateNode(type) ? createTypePredicateFromTypePredicateNode(type, signature) : jsdocPredicate || noTypePredicate */ TODO
				} else if signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags&TypeFlagsBoolean) && getParameterCount(signature) > 0 {
					TODO_IDENTIFIER := signature
					signature.resolvedTypePredicate = noTypePredicate
					signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate
				} else {
					signature.resolvedTypePredicate = noTypePredicate
				}
			}
			Debug.assert(!!signature.resolvedTypePredicate)
		}
		// converted from conditional expression
		switch {
		case signature.resolvedTypePredicate == noTypePredicate:
			return nil
		default:
			return signature.resolvedTypePredicate
		}
	}
	createTypePredicateFromTypePredicateNode := func(node TypePredicateNode, signature Signature) TypePredicate {
		parameterName := node.parameterName
		type_ := node.type_ && getTypeFromTypeNode(node.type_)
		// converted from conditional expression
		switch {
		case parameterName.kind == SyntaxKindThisType:
			return createTypePredicate( /* TODO(Node ConditionalExpression): node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This */ TODO, nil, nil, type_)
		default:
			return createTypePredicate( /* TODO(Node ConditionalExpression): node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier */ TODO, parameterName.escapedText, findIndex(signature.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
				return p.escapedName == parameterName.escapedText
			}), type_)
		}
	}
	getUnionOrIntersectionType := func(types []Type, kind *TypeFlags, unionReduction UnionReduction) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case kind != TypeFlagsIntersection:
			return getUnionType(types, unionReduction)
		default:
			return getIntersectionType(types)
		}
	}
	getReturnTypeOfSignature := func(signature Signature) Type {
		if !signature.resolvedReturnType {
			if !pushTypeResolution(signature, TypeSystemPropertyNameResolvedReturnType) {
				return errorType
			}
			type_ := /* TODO(Node ConditionalExpression): signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) : signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) : getReturnTypeFromAnnotation(signature.declaration!) || (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration)) */ TODO
			if signature.flags & SignatureFlagsIsInnerCallChain {
				type_ = addOptionalTypeMarker(type_)
			} else if signature.flags & SignatureFlagsIsOuterCallChain {
				type_ = getOptionalType(type_)
			}
			if !popTypeResolution() {
				if signature.declaration {
					typeNode := getEffectiveReturnTypeNode(signature.declaration)
					if typeNode {
						error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself)
					} else if noImplicitAny {
						declaration := signature.declaration
						name := getNameOfDeclaration(declaration)
						if name {
							error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name))
						} else {
							error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions)
						}
					}
				}
				type_ = anyType
			}
			/* TODO(Node BinaryExpression): signature.resolvedReturnType ??= type */ TODO
		}
		return signature.resolvedReturnType
	}
	getReturnTypeFromAnnotation := func(declaration /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if declaration.kind == SyntaxKindConstructor {
			return getDeclaredTypeOfClassOrInterface(getMergedSymbol((declaration.parent).symbol))
		}
		typeNode := getEffectiveReturnTypeNode(declaration)
		if isJSDocSignature(declaration) {
			root := getJSDocRoot(declaration)
			if root && isConstructorDeclaration(root.parent) && !typeNode {
				return getDeclaredTypeOfClassOrInterface(getMergedSymbol((root.parent.parent).symbol))
			}
		}
		if isJSDocConstructSignature(declaration) {
			return getTypeFromTypeNode((declaration.parameters[0]).type_)
		}
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		if declaration.kind == SyntaxKindGetAccessor && hasBindableName(declaration) {
			jsDocType := isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration)
			if jsDocType {
				return jsDocType
			}
			setter := getDeclarationOfKind(getSymbolOfDeclaration(declaration), SyntaxKindSetAccessor)
			setterType := getAnnotatedAccessorType(setter)
			if setterType {
				return setterType
			}
		}
		return getReturnTypeOfTypeTag(declaration)
	}
	isResolvingReturnTypeOfSignature := func(signature Signature) bool {
		return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) || !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyNameResolvedReturnType) >= 0
	}
	getRestTypeOfSignature := func(signature Signature) Type {
		return tryGetRestTypeOfSignature(signature) || anyType
	}
	tryGetRestTypeOfSignature := func(signature Signature) *Type {
		if signatureHasRestParameter(signature) {
			sigRestType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			restType := /* TODO(Node ConditionalExpression): isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType */ TODO
			return restType && getIndexTypeOfType(restType, numberType)
		}
		return nil
	}
	getSignatureInstantiation := func(signature Signature, typeArguments *[]Type, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
		instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript))
		if inferredTypeParameters {
			returnSignature := getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature))
			if returnSignature {
				newReturnSignature := cloneSignature(returnSignature)
				newReturnSignature.typeParameters = inferredTypeParameters
				newInstantiatedSignature := cloneSignature(instantiatedSignature)
				newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature)
				return newInstantiatedSignature
			}
		}
		return instantiatedSignature
	}
	getSignatureInstantiationWithoutFillingInTypeArguments := func(signature Signature, typeArguments *[]Type) Signature {
		instantiations := signature.instantiations || ( /* TODO(Node BinaryExpression): signature.instantiations = new Map<string, Signature>() */ TODO)
		id := getTypeListId(typeArguments)
		instantiation := instantiations.get(id)
		if !instantiation {
			instantiations.set(id /* TODO(Node BinaryExpression): instantiation = createSignatureInstantiation(signature, typeArguments) */, TODO)
		}
		return instantiation
	}
	createSignatureInstantiation := func(signature Signature, typeArguments *[]Type) Signature {
		return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), true)
	}
	getTypeParametersForMapper := func(signature Signature) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ any {
		return sameMap(signature.typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): tp.mapper ? instantiateType(tp, tp.mapper) : tp */ TODO
		})
	}
	createSignatureTypeMapper := func(signature Signature, typeArguments *[]Type) TypeMapper {
		return createTypeMapper(getTypeParametersForMapper(signature), typeArguments)
	}
	getErasedSignature := func(signature Signature) Signature {
		// converted from conditional expression
		switch {
		case signature.typeParameters:
			return signature.erasedSignatureCache || ( /* TODO(Node BinaryExpression): signature.erasedSignatureCache = createErasedSignature(signature) */ TODO)
		default:
			return signature
		}
	}
	createErasedSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		return instantiateSignature(signature, createTypeEraser(signature.typeParameters), true)
	}
	getCanonicalSignature := func(signature Signature) Signature {
		// converted from conditional expression
		switch {
		case signature.typeParameters:
			return signature.canonicalSignatureCache || ( /* TODO(Node BinaryExpression): signature.canonicalSignatureCache = createCanonicalSignature(signature) */ TODO)
		default:
			return signature
		}
	}
	createCanonicalSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		return getSignatureInstantiation(signature, map_(signature.typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
			return /* TODO(Node ConditionalExpression): tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp */ TODO
		}), isInJSFile(signature.declaration))
	}
	getImplementationSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		// converted from conditional expression
		switch {
		case signature.typeParameters:
			return /* TODO(Node BinaryExpression): signature.implementationSignatureCache ||= createImplementationSignature(signature) */ TODO
		default:
			return signature
		}
	}
	createImplementationSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		// converted from conditional expression
		switch {
		case signature.typeParameters:
			return instantiateSignature(signature, createTypeMapper([] /* TODO inferred type never */ any{}, [] /* TODO inferred type never */ any{}))
		default:
			return signature
		}
	}
	getBaseSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		typeParameters := signature.typeParameters
		if typeParameters {
			if signature.baseSignatureCache {
				return signature.baseSignatureCache
			}
			typeEraser := createTypeEraser(typeParameters)
			baseConstraintMapper := createTypeMapper(typeParameters, map_(typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getConstraintOfTypeParameter(tp) || unknownType
			}))
			var baseConstraints []Type = map_(typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return instantiateType(tp, baseConstraintMapper) || unknownType
			})
			for i := 0; i < typeParameters.length-1; i++ {
				baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper)
			}
			baseConstraints = instantiateTypes(baseConstraints, typeEraser)
			signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), true)
			return signature.baseSignatureCache
		}
		return signature
	}
	getOrCreateTypeFromSignature := func(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
		if !signature.isolatedSignatureType {
			kind := signature.declaration. /*?*/ kind
			isConstructor := kind == nil || kind == SyntaxKindConstructor || kind == SyntaxKindConstructSignature || kind == SyntaxKindConstructorType
			type_ := createObjectType(ObjectFlagsAnonymous|ObjectFlagsSingleSignatureType, createSymbol(SymbolFlagsFunction, InternalSymbolNameFunction))
			if signature.declaration && !nodeIsSynthesized(signature.declaration) {
				type_.symbol.declarations = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocSignature */ any{signature.declaration}
				type_.symbol.valueDeclaration = signature.declaration
			}
			/* TODO(Node BinaryExpression): outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes* / true) */ TODO
			type_.outerTypeParameters = outerTypeParameters
			type_.members = emptySymbols
			type_.properties = emptyArray
			type_.callSignatures = /* TODO(Node ConditionalExpression): !isConstructor ? [signature] : emptyArray */ TODO
			type_.constructSignatures = /* TODO(Node ConditionalExpression): isConstructor ? [signature] : emptyArray */ TODO
			type_.indexInfos = emptyArray
			signature.isolatedSignatureType = type_
		}
		return signature.isolatedSignatureType
	}
	getIndexSymbol := func(symbol Symbol) *Symbol {
		// converted from conditional expression
		switch {
		case symbol.members:
			return getIndexSymbolFromSymbolTable(symbol.members)
		default:
			return nil
		}
	}
	getIndexSymbolFromSymbolTable := func(symbolTable SymbolTable) *Symbol {
		return symbolTable.get(InternalSymbolNameIndex)
	}
	createIndexInfo := func(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
		return /* TODO(Node ObjectLiteralExpression): { keyType, type, isReadonly, declaration } */ TODO
	}
	getIndexInfosOfSymbol := func(symbol Symbol) []IndexInfo {
		indexSymbol := getIndexSymbol(symbol)
		// converted from conditional expression
		switch {
		case indexSymbol:
			return getIndexInfosOfIndexSymbol(indexSymbol)
		default:
			return emptyArray
		}
	}
	getIndexInfosOfIndexSymbol := func(indexSymbol Symbol) []IndexInfo {
		if indexSymbol.declarations {
			var indexInfos []IndexInfo = [] /* TODO inferred type never */ any{}
			for _, declaration := range indexSymbol.declarations {
				if declaration.parameters.length == 1 {
					parameter := declaration.parameters[0]
					if parameter.type_ {
						forEachType(getTypeFromTypeNode(parameter.type_), func(keyType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
							if isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType) {
								indexInfos.push(createIndexInfo(keyType /* TODO(Node ConditionalExpression): declaration.type ? getTypeFromTypeNode(declaration.type) : anyType */, TODO, hasEffectiveModifier(declaration, ModifierFlagsReadonly), declaration))
							}
						})
					}
				}
			}
			return indexInfos
		}
		return emptyArray
	}
	isValidIndexKeyType := func(type_ Type) bool {
		return !!(type_.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsESSymbol)) || isPatternLiteralType(type_) || !!(type_.flags&TypeFlagsIntersection) && !isGenericType(type_) && some((type_).types, isValidIndexKeyType)
	}
	getConstraintDeclaration := func(type_ TypeParameter) *TypeNode {
		return mapDefined(filter(type_.symbol && type_.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0]
	}
	getInferredTypeParameterConstraint := func(typeParameter TypeParameter, omitTypeReferences bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		var inferences *[]Type
		if typeParameter.symbol. /*?*/ declarations {
			for _, declaration := range typeParameter.symbol.declarations {
				if declaration.parent.kind == SyntaxKindInferType {
					TODO_IDENTIFIER := walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent)
					if grandParent.kind == SyntaxKindTypeReference && !omitTypeReferences {
						typeReference := grandParent
						typeParameters := getTypeParametersForTypeReferenceOrImport(typeReference)
						if typeParameters {
							index := typeReference.typeArguments.indexOf(childTypeParameter)
							if index < typeParameters.length {
								declaredConstraint := getConstraintOfTypeParameter(typeParameters[index])
								if declaredConstraint {
									mapper := makeDeferredTypeMapper(typeParameters, typeParameters.map_(func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any, index /* TODO inferred type number */ any) /* TODO inferred type () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
										return func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
											return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index)
										}
									}))
									constraint := instantiateType(declaredConstraint, mapper)
									if constraint != typeParameter {
										inferences = append(inferences, constraint)
									}
								}
							}
						}
					} else if grandParent.kind == SyntaxKindParameter && (grandParent).dotDotDotToken || grandParent.kind == SyntaxKindRestType || grandParent.kind == SyntaxKindNamedTupleMember && (grandParent).dotDotDotToken {
						inferences = append(inferences, createArrayType(unknownType))
					} else if grandParent.kind == SyntaxKindTemplateLiteralTypeSpan {
						inferences = append(inferences, stringType)
					} else if grandParent.kind == SyntaxKindTypeParameter && grandParent.parent.kind == SyntaxKindMappedType {
						inferences = append(inferences, stringNumberSymbolType)
					} else if grandParent.kind == SyntaxKindMappedType && (grandParent).type_ && skipParentheses((grandParent).type_) == declaration.parent && grandParent.parent.kind == SyntaxKindConditionalType && (grandParent.parent).extendsType == grandParent && (grandParent.parent).checkType.kind == SyntaxKindMappedType && ((grandParent.parent).checkType).type_ {
						checkMappedType := (grandParent.parent).checkType
						nodeType := getTypeFromTypeNode(checkMappedType.type_)
						inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)) /* TODO(Node ConditionalExpression): checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType */, TODO)))
					}
				}
			}
		}
		return inferences && getIntersectionType(inferences)
	}
	getConstraintFromTypeParameter := func(typeParameter TypeParameter) *Type {
		if !typeParameter.constraint {
			if typeParameter.target {
				targetConstraint := getConstraintOfTypeParameter(typeParameter.target)
				typeParameter.constraint = /* TODO(Node ConditionalExpression): targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType */ TODO
			} else {
				constraintDeclaration := getConstraintDeclaration(typeParameter)
				if !constraintDeclaration {
					typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType
				} else {
					type_ := getTypeFromTypeNode(constraintDeclaration)
					if type_.flags&TypeFlagsAny && !isErrorType(type_) {
						type_ = /* TODO(Node ConditionalExpression): constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType */ TODO
					}
					typeParameter.constraint = type_
				}
			}
		}
		// converted from conditional expression
		switch {
		case typeParameter.constraint == noConstraintType:
			return nil
		default:
			return typeParameter.constraint
		}
	}
	getParentSymbolOfTypeParameter := func(typeParameter TypeParameter) *Symbol {
		tp := getDeclarationOfKind(typeParameter.symbol, SyntaxKindTypeParameter)
		host := /* TODO(Node ConditionalExpression): isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent */ TODO
		return host && getSymbolOfNode(host)
	}
	getTypeListId := func(types *[]Type) /* TODO inferred type string */ any {
		result := ""
		if types {
			length := types.length
			i := 0
			for i < length {
				startId := types[i].id
				count := 1
				for i+count < length && types[i+count].id == startId+count {
					count++
				}
				if result.length {
					result += ","
				}
				result += startId
				if count > 1 {
					result += ":" + count
				}
				i += count
			}
		}
		return result
	}
	getAliasId := func(aliasSymbol *Symbol, aliasTypeArguments *[]Type) /* TODO inferred type string */ any {
		// converted from conditional expression
		switch {
		case aliasSymbol:
			return /* TODO(Node TemplateExpression): `@${getSymbolId(aliasSymbol)}` */ TODO + ( /* TODO(Node ConditionalExpression): aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "" */ TODO)
		default:
			return ""
		}
	}
	getPropagatingFlagsOfTypes := func(types []Type, excludeKinds TypeFlags) ObjectFlags {
		var result ObjectFlags = 0
		for _, type_ := range types {
			if excludeKinds == nil || !(type_.flags & excludeKinds) {
				result |= getObjectFlags(type_)
			}
		}
		return result & ObjectFlagsPropagatingFlags
	}
	tryCreateTypeReference := func(target GenericType, typeArguments *[]Type) Type {
		if some(typeArguments) && target == emptyGenericType {
			return unknownType
		}
		return createTypeReference(target, typeArguments)
	}
	createTypeReference := func(target GenericType, typeArguments *[]Type) TypeReference {
		id := getTypeListId(typeArguments)
		type_ := target.instantiations.get(id)
		if !type_ {
			type_ = createObjectType(ObjectFlagsReference, target.symbol)
			target.instantiations.set(id, type_)
			type_.objectFlags |= /* TODO(Node ConditionalExpression): typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0 */ TODO
			type_.target = target
			type_.resolvedTypeArguments = typeArguments
		}
		return type_
	}
	cloneTypeReference := func(source TypeReference) TypeReference {
		type_ := createTypeWithSymbol(source.flags, source.symbol)
		type_.objectFlags = source.objectFlags
		type_.target = source.target
		type_.resolvedTypeArguments = source.resolvedTypeArguments
		return type_
	}
	createDeferredTypeReference := func(target GenericType, node /* TODO(TypeNode UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
		if !aliasSymbol {
			aliasSymbol = getAliasSymbolForTypeNode(node)
			localAliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			aliasTypeArguments = /* TODO(Node ConditionalExpression): mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments */ TODO
		}
		type_ := createObjectType(ObjectFlagsReference, target.symbol)
		type_.target = target
		type_.node = node
		type_.mapper = mapper
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	getTypeArguments := func(type_ TypeReference) []Type {
		if !type_.resolvedTypeArguments {
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedTypeArguments) {
				return concatenate(type_.target.outerTypeParameters, type_.target.localTypeParameters. /*?*/ map_(func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
					return errorType
				})) || emptyArray
			}
			node := type_.node
			typeArguments := /* TODO(Node ConditionalExpression): !node ? emptyArray : node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) : node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode) */ TODO
			if popTypeResolution() {
				/* TODO(Node BinaryExpression): type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments */ TODO
			} else {
				/* TODO(Node BinaryExpression): type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray) */ TODO
				error(type_.node || currentNode /* TODO(Node ConditionalExpression): type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves */, TODO, type_.target.symbol && symbolToString(type_.target.symbol))
			}
		}
		return type_.resolvedTypeArguments
	}
	getTypeReferenceArity := func(type_ TypeReference) number {
		return length(type_.target.typeParameters)
	}
	getTypeFromClassOrInterfaceReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		type_ := getDeclaredTypeOfSymbol(getMergedSymbol(symbol))
		typeParameters := type_.localTypeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			isJs := isInJSFile(node)
			isJsImplicitAny := !noImplicitAny && isJs
			if !isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
				missingAugmentsTag := isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent)
				diag := /* TODO(Node ConditionalExpression): minTypeArgumentCount === typeParameters.length ? missingAugmentsTag ? Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag : Diagnostics.Generic_type_0_requires_1_type_argument_s : missingAugmentsTag ? Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag : Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */ TODO
				typeStr := typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType)
				error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length)
				if !isJs {
					return errorType
				}
			}
			if node.kind == SyntaxKindTypeReference && isDeferredTypeReferenceNode(node, length(node.typeArguments) != typeParameters.length) {
				return createDeferredTypeReference(type_, node, nil)
			}
			typeArguments := concatenate(type_.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
			return createTypeReference(type_, typeArguments)
		}
		// converted from conditional expression
		switch {
		case checkNoTypeArguments(node, symbol):
			return type_
		default:
			return errorType
		}
	}
	getTypeAliasInstantiation := func(symbol Symbol, typeArguments *[]Type, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		type_ := getDeclaredTypeOfSymbol(symbol)
		if type_ == intrinsicMarkerType {
			typeKind := intrinsicTypeKinds.get(symbol.escapedName)
			if typeKind != nil && typeArguments && typeArguments.length == 1 {
				// converted from conditional expression
				switch {
				case typeKind == IntrinsicTypeKindNoInfer:
					return getNoInferType(typeArguments[0])
				default:
					return getStringMappingType(symbol, typeArguments[0])
				}
			}
		}
		links := getSymbolLinks(symbol)
		typeParameters := links.typeParameters
		id := getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments)
		instantiation := links.instantiations.get(id)
		if !instantiation {
			links.instantiations.set(id /* TODO(Node BinaryExpression): instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments) */, TODO)
		}
		return instantiation
	}
	getTypeFromTypeAliasReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if getCheckFlags(symbol) & CheckFlagsUnresolved {
			typeArguments := typeArgumentsFromTypeReferenceNode(node)
			id := getAliasId(symbol, typeArguments)
			errorType := errorTypes.get(id)
			if !errorType {
				errorType = createIntrinsicType(TypeFlagsAny, "error", nil /* TODO(Node TemplateExpression): `alias ${id}` */, TODO)
				errorType.aliasSymbol = symbol
				errorType.aliasTypeArguments = typeArguments
				errorTypes.set(id, errorType)
			}
			return errorType
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeParameters := getSymbolLinks(symbol).typeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			if numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length {
				error(node /* TODO(Node ConditionalExpression): minTypeArgumentCount === typeParameters.length ? Diagnostics.Generic_type_0_requires_1_type_argument_s : Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */, TODO, symbolToString(symbol), minTypeArgumentCount, typeParameters.length)
				return errorType
			}
			aliasSymbol := getAliasSymbolForTypeNode(node)
			newAliasSymbol := /* TODO(Node ConditionalExpression): aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined */ TODO
			var aliasTypeArguments *[]Type
			if newAliasSymbol {
				aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol)
			} else if isTypeReferenceType(node) {
				aliasSymbol := resolveTypeReferenceName(node, SymbolFlagsAlias, true)
				if aliasSymbol && aliasSymbol != unknownSymbol {
					resolved := resolveAlias(aliasSymbol)
					if resolved && resolved.flags&SymbolFlagsTypeAlias {
						newAliasSymbol = resolved
						aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || ( /* TODO(Node ConditionalExpression): typeParameters ? [] : undefined */ TODO)
					}
				}
			}
			return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
		}
		// converted from conditional expression
		switch {
		case checkNoTypeArguments(node, symbol):
			return type_
		default:
			return errorType
		}
	}
	isLocalTypeAlias := func(symbol Symbol) /* TODO inferred type boolean */ any {
		declaration := symbol.declarations. /*?*/ find(isTypeAlias)
		return !!(declaration && getContainingFunction(declaration))
	}
	getTypeReferenceName := func(node TypeReferenceType) *EntityNameOrEntityNameExpression {
		switch node.kind {
		case SyntaxKindTypeReference:
			return node.typeName
		case SyntaxKindExpressionWithTypeArguments:
			expr := node.expression
			if isEntityNameExpression(expr) {
				return expr
			}
		}
		return nil
	}
	getSymbolPath := func(symbol Symbol) string {
		// converted from conditional expression
		switch {
		case symbol.parent:
			return /* TODO(Node TemplateExpression): `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` */ TODO
		default:
			return symbol.escapedName
		}
	}
	getUnresolvedSymbolForEntityName := func(name EntityNameOrEntityNameExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
		identifier := /* TODO(Node ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right : name.kind === SyntaxKind.PropertyAccessExpression ? name.name : name */ TODO
		text := identifier.escapedText
		if text {
			parentSymbol := /* TODO(Node ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) : name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) : undefined */ TODO
			path := /* TODO(Node ConditionalExpression): parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string */ TODO
			result := unresolvedSymbols.get(path)
			if !result {
				unresolvedSymbols.set(path /* TODO(Node BinaryExpression): result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved) */, TODO)
				result.parent = parentSymbol
				result.links.declaredType = unresolvedType
			}
			return result
		}
		return unknownSymbol
	}
	resolveTypeReferenceName := func(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		name := getTypeReferenceName(typeReference)
		if !name {
			return unknownSymbol
		}
		symbol := resolveEntityName(name, meaning, ignoreErrors)
		// converted from conditional expression
		switch {
		case symbol && symbol != unknownSymbol:
			return symbol
		case ignoreErrors:
			return unknownSymbol
		default:
			return getUnresolvedSymbolForEntityName(name)
		}
	}
	getTypeReferenceType := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if symbol == unknownSymbol {
			return errorType
		}
		symbol = getExpandoSymbol(symbol) || symbol
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getTypeFromClassOrInterfaceReference(node, symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getTypeFromTypeAliasReference(node, symbol)
		}
		res := tryGetDeclaredTypeOfSymbol(symbol)
		if res {
			// converted from conditional expression
			switch {
			case checkNoTypeArguments(node, symbol):
				return getRegularTypeOfLiteralType(res)
			default:
				return errorType
			}
		}
		if symbol.flags&SymbolFlagsValue && isJSDocTypeReference(node) {
			jsdocType := getTypeFromJSDocValueReference(node, symbol)
			if jsdocType {
				return jsdocType
			} else {
				resolveTypeReferenceName(node, SymbolFlagsType)
				return getTypeOfSymbol(symbol)
			}
		}
		return errorType
	}
	getTypeFromJSDocValueReference := func(node NodeWithTypeArguments, symbol Symbol) *Type {
		links := getNodeLinks(node)
		if !links.resolvedJSDocType {
			valueType := getTypeOfSymbol(symbol)
			typeType := valueType
			if symbol.valueDeclaration {
				isImportTypeWithQualifier := node.kind == SyntaxKindImportType && (node).qualifier
				if valueType.symbol && valueType.symbol != symbol && isImportTypeWithQualifier {
					typeType = getTypeReferenceType(node, valueType.symbol)
				}
			}
			links.resolvedJSDocType = typeType
		}
		return links.resolvedJSDocType
	}
	getNoInferType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case isNoInferTargetType(type_):
			return getOrCreateSubstitutionType(type_, unknownType)
		default:
			return type_
		}
	}
	isNoInferTargetType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnionOrIntersection && some((type_).types, isNoInferTargetType) || type_.flags&TypeFlagsSubstitution && !isNoInferType(type_) && isNoInferTargetType((type_).baseType) || type_.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(type_) || type_.flags&(TypeFlagsInstantiable&~TypeFlagsSubstitution) && !isPatternLiteralType(type_))
	}
	isNoInferType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags&TypeFlagsSubstitution && (type_).constraint.flags&TypeFlagsUnknown)
	}
	getSubstitutionType := func(baseType Type, constraint Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case constraint.flags&TypeFlagsAnyOrUnknown || constraint == baseType || baseType.flags&TypeFlagsAny:
			return baseType
		default:
			return getOrCreateSubstitutionType(baseType, constraint)
		}
	}
	getOrCreateSubstitutionType := func(baseType Type, constraint Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SubstitutionType */ any {
		id := /* TODO(Node TemplateExpression): `${getTypeId(baseType)}>${getTypeId(constraint)}` */ TODO
		cached := substitutionTypes.get(id)
		if cached {
			return cached
		}
		result := createType(TypeFlagsSubstitution)
		result.baseType = baseType
		result.constraint = constraint
		substitutionTypes.set(id, result)
		return result
	}
	getSubstitutionIntersection := func(substitutionType SubstitutionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case isNoInferType(substitutionType):
			return substitutionType.baseType
		default:
			return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{substitutionType.constraint, substitutionType.baseType})
		}
	}
	isUnaryTupleTypeNode := func(node TypeNode) /* TODO inferred type boolean */ any {
		return node.kind == SyntaxKindTupleType && (node).elements.length == 1
	}
	getImpliedConstraint := func(type_ Type, checkNode TypeNode, extendsNode TypeNode) *Type {
		// converted from conditional expression
		switch {
		case isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode):
			return getImpliedConstraint(type_, (checkNode).elements[0], (extendsNode).elements[0])
		case getActualTypeVariable(getTypeFromTypeNode(checkNode)) == getActualTypeVariable(type_):
			return getTypeFromTypeNode(extendsNode)
		default:
			return nil
		}
	}
	getConditionalFlowTypeOfType := func(type_ Type, node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		var constraints *[]Type
		covariant := true
		for node && !isStatement(node) && node.kind != SyntaxKindJSDoc {
			parent := node.parent
			if parent.kind == SyntaxKindParameter {
				covariant = !covariant
			}
			if (covariant || type_.flags&TypeFlagsTypeVariable) && parent.kind == SyntaxKindConditionalType && node == (parent).trueType {
				constraint := getImpliedConstraint(type_, (parent).checkType, (parent).extendsType)
				if constraint {
					constraints = append(constraints, constraint)
				}
			} else if type_.flags&TypeFlagsTypeParameter && parent.kind == SyntaxKindMappedType && !(parent).nameType && node == (parent).type_ {
				mappedType := getTypeFromTypeNode(parent)
				if getTypeParameterFromMappedType(mappedType) == getActualTypeVariable(type_) {
					typeParameter := getHomomorphicTypeVariable(mappedType)
					if typeParameter {
						constraint := getConstraintOfTypeParameter(typeParameter)
						if constraint && everyType(constraint, isArrayOrTupleType) {
							constraints = append(constraints, getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{numberType, numericStringType}))
						}
					}
				}
			}
			node = parent
		}
		// converted from conditional expression
		switch {
		case constraints:
			return getSubstitutionType(type_, getIntersectionType(constraints))
		default:
			return type_
		}
	}
	isJSDocTypeReference := func(node Node) /* TODO(TypeNode TypePredicate): node is TypeReferenceNode */ any {
		return !!(node.flags & NodeFlagsJSDoc) && (node.kind == SyntaxKindTypeReference || node.kind == SyntaxKindImportType)
	}
	checkNoTypeArguments := func(node NodeWithTypeArguments, symbol Symbol) /* TODO inferred type boolean */ any {
		if node.typeArguments {
			error(node, Diagnostics.Type_0_is_not_generic /* TODO(Node ConditionalExpression): symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon */, TODO)
			return false
		}
		return true
	}
	getIntendedTypeFromJSDocTypeReference := func(node TypeReferenceNode) *Type {
		if isIdentifier(node.typeName) {
			typeArgs := node.typeArguments
			switch node.typeName.escapedText {
			case "String":
				checkNoTypeArguments(node)
				return stringType
			case "Number":
				checkNoTypeArguments(node)
				return numberType
			case "Boolean":
				checkNoTypeArguments(node)
				return booleanType
			case "Void":
				checkNoTypeArguments(node)
				return voidType
			case "Undefined":
				checkNoTypeArguments(node)
				return undefinedType
			case "Null":
				checkNoTypeArguments(node)
				return nullType
			case "Function":
				fallthrough // TODO: merge cases
			case "function":
				checkNoTypeArguments(node)
				return globalFunctionType
			case "array":
				// converted from conditional expression
				switch {
				case (!typeArgs || !typeArgs.length) && !noImplicitAny:
					return anyArrayType
				default:
					return nil
				}
			case "promise":
				// converted from conditional expression
				switch {
				case (!typeArgs || !typeArgs.length) && !noImplicitAny:
					return createPromiseType(anyType)
				default:
					return nil
				}
			case "Object":
				if typeArgs && typeArgs.length == 2 {
					if isJSDocIndexSignature(node) {
						indexed := getTypeFromTypeNode(typeArgs[0])
						target := getTypeFromTypeNode(typeArgs[1])
						indexInfo := /* TODO(Node ConditionalExpression): indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly* / false)] : emptyArray */ TODO
						return createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, indexInfo)
					}
					return anyType
				}
				checkNoTypeArguments(node)
				// converted from conditional expression
				switch {
				case !noImplicitAny:
					return anyType
				default:
					return nil
				}
			}
		}
	}
	getTypeFromJSDocNullableTypeNode := func(node JSDocNullableType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		type_ := getTypeFromTypeNode(node.type_)
		// converted from conditional expression
		switch {
		case strictNullChecks:
			return getNullableType(type_, TypeFlagsNull)
		default:
			return type_
		}
	}
	getTypeFromTypeReference := func(node TypeReferenceType) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if isConstTypeReference(node) && isAssertionExpression(node.parent) {
				links.resolvedSymbol = unknownSymbol
				links.resolvedType = checkExpressionCached(node.parent.expression)
				return links.resolvedType
			}
			var symbol *Symbol
			var type_ *Type
			meaning := SymbolFlagsType
			if isJSDocTypeReference(node) {
				type_ = getIntendedTypeFromJSDocTypeReference(node)
				if !type_ {
					symbol = resolveTypeReferenceName(node, meaning, true)
					if symbol == unknownSymbol {
						symbol = resolveTypeReferenceName(node, meaning|SymbolFlagsValue)
					} else {
						resolveTypeReferenceName(node, meaning)
					}
					type_ = getTypeReferenceType(node, symbol)
				}
			}
			if !type_ {
				symbol = resolveTypeReferenceName(node, meaning)
				type_ = getTypeReferenceType(node, symbol)
			}
			links.resolvedSymbol = symbol
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	typeArgumentsFromTypeReferenceNode := func(node NodeWithTypeArguments) *[]Type {
		return map_(node.typeArguments, getTypeFromTypeNode)
	}
	getTypeFromTypeQueryNode := func(node TypeQueryNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := checkExpressionWithTypeArguments(node)
			links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type_))
		}
		return links.resolvedType
	}
	getTypeOfGlobalSymbol := func(symbol *Symbol, arity number) ObjectType {
		getTypeDeclaration := func(symbol Symbol) Declaration {
			declarations := symbol.declarations
			if declarations {
				for _, declaration := range declarations {
					switch declaration.kind {
					case SyntaxKindClassDeclaration:
						fallthrough // TODO: merge cases
					case SyntaxKindInterfaceDeclaration:
						fallthrough // TODO: merge cases
					case SyntaxKindEnumDeclaration:
						return declaration
					}
				}
			}
		}
		if !symbol {
			// converted from conditional expression
			switch {
			case arity:
				return emptyGenericType
			default:
				return emptyObjectType
			}
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		if !(type_.flags & TypeFlagsObject) {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol))
			// converted from conditional expression
			switch {
			case arity:
				return emptyGenericType
			default:
				return emptyObjectType
			}
		}
		if length((type_).typeParameters) != arity {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
			// converted from conditional expression
			switch {
			case arity:
				return emptyGenericType
			default:
				return emptyObjectType
			}
		}
		return type_
	}
	getGlobalValueSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name, SymbolFlagsValue /* TODO(Node ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined */, TODO)
	}
	getGlobalTypeSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name, SymbolFlagsType /* TODO(Node ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
	}
	getGlobalTypeAliasSymbol := func(name __String, arity number, reportErrors bool) *Symbol {
		symbol := getGlobalSymbol(name, SymbolFlagsType /* TODO(Node ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
		if symbol {
			getDeclaredTypeOfSymbol(symbol)
			if length(getSymbolLinks(symbol).typeParameters) != arity {
				decl := symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration)
				error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
				return nil
			}
		}
		return symbol
	}
	getGlobalSymbol := func(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) *Symbol {
		return resolveName(nil, name, meaning, diagnostic, false, false)
	}
	/* OVERLOAD: function getGlobalType(name: __String, arity: 0, reportErrors: true): ObjectType; */
	/* OVERLOAD: function getGlobalType(name: __String, arity: 0, reportErrors: boolean): ObjectType | undefined; */
	/* OVERLOAD: function getGlobalType(name: __String, arity: number, reportErrors: true): GenericType; */
	/* OVERLOAD: function getGlobalType(name: __String, arity: number, reportErrors: boolean): GenericType | undefined; */
	getGlobalType := func(name __String, arity number, reportErrors bool) *ObjectType {
		symbol := getGlobalTypeSymbol(name, reportErrors)
		// converted from conditional expression
		switch {
		case symbol || reportErrors:
			return getTypeOfGlobalSymbol(symbol, arity)
		default:
			return nil
		}
	}
	/* OVERLOAD: function getGlobalBuiltinTypes(typeNames: readonly string[], arity: 0): ObjectType[]; */
	/* OVERLOAD: function getGlobalBuiltinTypes(typeNames: readonly string[], arity: number): GenericType[]; */
	getGlobalBuiltinTypes := func(typeNames []string, arity number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ any {
		var types *[]Type
		for _, typeName := range typeNames {
			types = append(types, getGlobalType(typeName, arity, false))
		}
		return /* TODO(Node BinaryExpression): types ?? emptyArray */ TODO
	}
	getGlobalTypedPropertyDescriptorType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity* / 1, /*reportErrors* / true) || emptyGenericType */ TODO
	}
	getGlobalTemplateStringsArrayType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return /* TODO(Node BinaryExpression): deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return /* TODO(Node BinaryExpression): deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaExpressionType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		if !deferredGlobalImportMetaExpressionType {
			symbol := createSymbol(SymbolFlagsNone, "ImportMetaExpression")
			importMetaType := getGlobalImportMetaType()
			metaPropertySymbol := createSymbol(SymbolFlagsProperty, "meta", CheckFlagsReadonly)
			metaPropertySymbol.parent = symbol
			metaPropertySymbol.links.type_ = importMetaType
			members := createSymbolTable([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{metaPropertySymbol})
			symbol.members = members
			deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		return deferredGlobalImportMetaExpressionType
	}
	getGlobalImportCallOptionsType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalImportAttributesType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalESSymbolConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(Node BinaryExpression): deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolConstructorTypeSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(Node BinaryExpression): deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalPromiseType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseLikeType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(Node BinaryExpression): deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors) */ TODO
	}
	getGlobalPromiseConstructorLikeType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncIterableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIterableIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalBuiltinAsyncIteratorTypes := func() /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ any {
		return /* TODO(Node BinaryExpression): deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
	}
	getGlobalAsyncIteratorObjectType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncGeneratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableIteratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getBuiltinIteratorReturnType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
		// converted from conditional expression
		switch {
		case strictBuiltinIteratorReturn:
			return undefinedType
		default:
			return anyType
		}
	}
	getGlobalBuiltinIteratorTypes := func() /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ any {
		return /* TODO(Node BinaryExpression): deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
	}
	getGlobalIteratorObjectType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalGeneratorType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorYieldResultType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorReturnResultType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalDisposableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncDisposableType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalTypeOrUndefined := func(name __String, arity /* TODO inferred type number */ any /*  = 0 */) *ObjectType {
		symbol := getGlobalSymbol(name, SymbolFlagsType, nil)
		return symbol && getTypeOfGlobalSymbol(symbol, arity)
	}
	getGlobalExtractSymbol := func() *Symbol {
		/* TODO(Node BinaryExpression): deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol */ TODO
		// converted from conditional expression
		switch {
		case deferredGlobalExtractSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalExtractSymbol
		}
	}
	getGlobalOmitSymbol := func() *Symbol {
		/* TODO(Node BinaryExpression): deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol */ TODO
		// converted from conditional expression
		switch {
		case deferredGlobalOmitSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalOmitSymbol
		}
	}
	getGlobalAwaitedSymbol := func(reportErrors bool) *Symbol {
		/* TODO(Node BinaryExpression): deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity* / 1, reportErrors) || (reportErrors ? unknownSymbol : undefined) */ TODO
		// converted from conditional expression
		switch {
		case deferredGlobalAwaitedSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalAwaitedSymbol
		}
	}
	getGlobalBigIntType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return ( /* TODO(Node BinaryExpression): deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalClassDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassMethodDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassGetterDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassSetterDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorTargetType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorResultType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassFieldDecoratorContextType := func(reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ any {
		return /* TODO(Node BinaryExpression): (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalNaNSymbol := func() *Symbol {
		return ( /* TODO(Node BinaryExpression): deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false) */ TODO)
	}
	getGlobalRecordSymbol := func() *Symbol {
		/* TODO(Node BinaryExpression): deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol */ TODO
		// converted from conditional expression
		switch {
		case deferredGlobalRecordSymbol == unknownSymbol:
			return nil
		default:
			return deferredGlobalRecordSymbol
		}
	}
	createTypeFromGenericGlobalType := func(genericGlobalType GenericType, typeArguments []Type) ObjectType {
		// converted from conditional expression
		switch {
		case genericGlobalType != emptyGenericType:
			return createTypeReference(genericGlobalType, typeArguments)
		default:
			return emptyObjectType
		}
	}
	createTypedPropertyDescriptorType := func(propertyType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{propertyType})
	}
	createIterableType := func(iteratedType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalIterableType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{iteratedType, voidType, undefinedType})
	}
	createArrayType := func(elementType Type, readonly bool) ObjectType {
		return createTypeFromGenericGlobalType( /* TODO(Node ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{elementType})
	}
	getTupleElementFlags := func(node TypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ any {
		switch node.kind {
		case SyntaxKindOptionalType:
			return ElementFlagsOptional
		case SyntaxKindRestType:
			return getRestTypeElementFlags(node)
		case SyntaxKindNamedTupleMember:
			// converted from conditional expression
			switch {
			case (node).questionToken:
				return ElementFlagsOptional
			case (node).dotDotDotToken:
				return getRestTypeElementFlags(node)
			default:
				return ElementFlagsRequired
			}
		default:
			return ElementFlagsRequired
		}
	}
	getRestTypeElementFlags := func(node /* TODO(TypeNode UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ any {
		// converted from conditional expression
		switch {
		case getArrayElementTypeNode(node.type_):
			return ElementFlagsRest
		default:
			return ElementFlagsVariadic
		}
	}
	getArrayOrTupleTargetType := func(node /* TODO(TypeNode UnionType): ArrayTypeNode | TupleTypeNode */ any) GenericType {
		readonly := isReadonlyTypeOperator(node.parent)
		elementType := getArrayElementTypeNode(node)
		if elementType {
			// converted from conditional expression
			switch {
			case readonly:
				return globalReadonlyArrayType
			default:
				return globalArrayType
			}
		}
		elementFlags := map_((node).elements, getTupleElementFlags)
		return getTupleTargetType(elementFlags, readonly, map_((node).elements, memberIfLabeledElementDeclaration))
	}
	memberIfLabeledElementDeclaration := func(member Node) /* TODO(TypeNode UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any {
		// converted from conditional expression
		switch {
		case isNamedTupleMember(member) || isParameter(member):
			return member
		default:
			return nil
		}
	}
	isDeferredTypeReferenceNode := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) /* TODO inferred type boolean */ any {
		return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && ( /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) : node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) : hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias) */ TODO)
	}
	isResolvedByTypeAlias := func(node Node) bool {
		parent := node.parent
		switch parent.kind {
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindNamedTupleMember:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeReference:
			fallthrough // TODO: merge cases
		case SyntaxKindUnionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIntersectionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIndexedAccessType:
			fallthrough // TODO: merge cases
		case SyntaxKindConditionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeOperator:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayType:
			fallthrough // TODO: merge cases
		case SyntaxKindTupleType:
			return isResolvedByTypeAlias(parent)
		case SyntaxKindTypeAliasDeclaration:
			return true
		}
		return false
	}
	mayResolveTypeAlias := func(node Node) bool {
		switch node.kind {
		case SyntaxKindTypeReference:
			return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node, SymbolFlagsType).flags & SymbolFlagsTypeAlias)
		case SyntaxKindTypeQuery:
			return true
		case SyntaxKindTypeOperator:
			return (node).operator != SyntaxKindUniqueKeyword && mayResolveTypeAlias((node).type_)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindOptionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindNamedTupleMember:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocOptionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeExpression:
			return mayResolveTypeAlias((node).type_)
		case SyntaxKindRestType:
			return (node).type_.kind != SyntaxKindArrayType || mayResolveTypeAlias(((node).type_).elementType)
		case SyntaxKindUnionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIntersectionType:
			return some((node).types, mayResolveTypeAlias)
		case SyntaxKindIndexedAccessType:
			return mayResolveTypeAlias((node).objectType) || mayResolveTypeAlias((node).indexType)
		case SyntaxKindConditionalType:
			return mayResolveTypeAlias((node).checkType) || mayResolveTypeAlias((node).extendsType) || mayResolveTypeAlias((node).trueType) || mayResolveTypeAlias((node).falseType)
		}
		return false
	}
	getTypeFromArrayOrTupleTypeNode := func(node /* TODO(TypeNode UnionType): ArrayTypeNode | TupleTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			target := getArrayOrTupleTargetType(node)
			if target == emptyGenericType {
				links.resolvedType = emptyObjectType
			} else if !(node.kind == SyntaxKindTupleType && some(node.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember */ any) /* TODO inferred type boolean */ any {
				return !!(getTupleElementFlags(e) & ElementFlagsVariadic)
			})) && isDeferredTypeReferenceNode(node) {
				links.resolvedType = /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target : createDeferredTypeReference(target, node, /*mapper* / undefined) */ TODO
			} else {
				elementTypes := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode) */ TODO
				links.resolvedType = createNormalizedTypeReference(target, elementTypes)
			}
		}
		return links.resolvedType
	}
	isReadonlyTypeOperator := func(node Node) /* TODO inferred type boolean */ any {
		return isTypeOperatorNode(node) && node.operator == SyntaxKindReadonlyKeyword
	}
	createTupleType := func(elementTypes []Type, elementFlags []ElementFlags, readonly /* TODO inferred type boolean */ any /*  = false */, namedMemberDeclarations [] /* TODO(TypeNode UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any /*  = [] */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		tupleTarget := getTupleTargetType(elementFlags || map_(elementTypes, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required */ any {
			return ElementFlagsRequired
		}), readonly, namedMemberDeclarations)
		// converted from conditional expression
		switch {
		case tupleTarget == emptyGenericType:
			return emptyObjectType
		case elementTypes.length:
			return createNormalizedTypeReference(tupleTarget, elementTypes)
		default:
			return tupleTarget
		}
	}
	getTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(TypeNode UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
		if elementFlags.length == 1 && elementFlags[0]&ElementFlagsRest {
			// converted from conditional expression
			switch {
			case readonly:
				return globalReadonlyArrayType
			default:
				return globalArrayType
			}
		}
		key := map_(elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any) /* TODO inferred type "#" | "?" | "." | "*" */ any {
			return /* TODO(Node ConditionalExpression): f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*" */ TODO
		}).join() + ( /* TODO(Node ConditionalExpression): readonly ? "R" : "" */ TODO) + ( /* TODO(Node ConditionalExpression): some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "" */ TODO)
		type_ := tupleTypes.get(key)
		if !type_ {
			tupleTypes.set(key /* TODO(Node BinaryExpression): type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) */, TODO)
		}
		return type_
	}
	createTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(TypeNode UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
		arity := elementFlags.length
		minLength := countWhere(elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any) /* TODO inferred type boolean */ any {
			return !!(f & (ElementFlagsRequired | ElementFlagsVariadic))
		})
		var typeParameters *[]TypeParameter
		var properties []Symbol = [] /* TODO inferred type never */ any{}
		combinedFlags := 0
		if arity {
			typeParameters = /* TODO(Node NewExpression): new Array(arity) */ TODO
			for i := 0; i < arity; i++ {
				typeParameter := /* TODO(Node BinaryExpression): typeParameters[i] = createTypeParameter() */ TODO
				flags := elementFlags[i]
				combinedFlags |= flags
				if !(combinedFlags & ElementFlagsVariable) {
					property := createSymbol(SymbolFlagsProperty|( /* TODO(Node ConditionalExpression): flags & ElementFlags.Optional ? SymbolFlags.Optional : 0 */ TODO), ""+i /* TODO(Node ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */, TODO)
					property.links.tupleLabelDeclaration = namedMemberDeclarations[i]
					property.links.type_ = typeParameter
					properties.push(property)
				}
			}
		}
		fixedLength := properties.length
		lengthSymbol := createSymbol(SymbolFlagsProperty, "length" /* TODO(Node ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */, TODO)
		if combinedFlags & ElementFlagsVariable {
			lengthSymbol.links.type_ = numberType
		} else {
			literalTypes := [] /* TODO inferred type never */ any{}
			for i := minLength; i <= arity; i++ {
				literalTypes.push(getNumberLiteralType(i))
			}
			lengthSymbol.links.type_ = getUnionType(literalTypes)
		}
		properties.push(lengthSymbol)
		type_ := createObjectType(ObjectFlagsTuple | ObjectFlagsReference)
		type_.typeParameters = typeParameters
		type_.outerTypeParameters = nil
		type_.localTypeParameters = typeParameters
		type_.instantiations = make(map[string]TypeReference)
		type_.instantiations.set(getTypeListId(type_.typeParameters), type_)
		type_.target = type_
		type_.resolvedTypeArguments = type_.typeParameters
		type_.thisType = createTypeParameter()
		type_.thisType.isThisType = true
		type_.thisType.constraint = type_
		type_.declaredProperties = properties
		type_.declaredCallSignatures = emptyArray
		type_.declaredConstructSignatures = emptyArray
		type_.declaredIndexInfos = emptyArray
		type_.elementFlags = elementFlags
		type_.minLength = minLength
		type_.fixedLength = fixedLength
		type_.hasRestElement = !!(combinedFlags & ElementFlagsVariable)
		type_.combinedFlags = combinedFlags
		type_.readonly = readonly
		type_.labeledElementDeclarations = namedMemberDeclarations
		return type_
	}
	createNormalizedTypeReference := func(target GenericType, typeArguments *[]Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case target.objectFlags & ObjectFlagsTuple:
			return createNormalizedTupleType(target, typeArguments)
		default:
			return createTypeReference(target, typeArguments)
		}
	}
	createNormalizedTupleType := func(target TupleType, elementTypes []Type) Type {
		if !(target.combinedFlags & ElementFlagsNonRequired) {
			return createTypeReference(target, elementTypes)
		}
		if target.combinedFlags & ElementFlagsVariadic {
			unionIndex := findIndex(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
				return !!(target.elementFlags[i]&ElementFlagsVariadic && t.flags&(TypeFlagsNever|TypeFlagsUnion))
			})
			if unionIndex >= 0 {
				// converted from conditional expression
				switch {
				case checkCrossProductUnion(map_(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return /* TODO(Node ConditionalExpression): target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType */ TODO
				})):
					return mapType(elementTypes[unionIndex], func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))
					})
				default:
					return errorType
				}
			}
		}
		var expandedTypes []Type = [] /* TODO inferred type never */ any{}
		var expandedFlags []ElementFlags = [] /* TODO inferred type never */ any{}
		var expandedDeclarations [] /* TODO(TypeNode UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any = [] /* TODO inferred type never */ any{}
		lastRequiredIndex := -1
		firstRestIndex := -1
		lastOptionalOrRestIndex := -1
		for i := 0; i < elementTypes.length; i++ {
			type_ := elementTypes[i]
			flags := target.elementFlags[i]
			if flags & ElementFlagsVariadic {
				if type_.flags & TypeFlagsAny {
					addElement(type_, ElementFlagsRest, target.labeledElementDeclarations[i])
				} else if type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericMappedType(type_) {
					addElement(type_, ElementFlagsVariadic, target.labeledElementDeclarations[i])
				} else if isTupleType(type_) {
					elements := getElementTypes(type_)
					if elements.length+expandedTypes.length >= 10_000 {
						error(currentNode /* TODO(Node ConditionalExpression): isPartOfTypeNode(currentNode!) ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent */, TODO)
						return errorType
					}
					forEach(elements, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, n /* TODO inferred type number */ any) {
						return addElement(t, type_.target.elementFlags[n], type_.target.labeledElementDeclarations[n])
					})
				} else {
					addElement(isArrayLikeType(type_) && getIndexTypeOfType(type_, numberType) || errorType, ElementFlagsRest, target.labeledElementDeclarations[i])
				}
			} else {
				addElement(type_, flags, target.labeledElementDeclarations[i])
			}
		}
		for i := 0; i < lastRequiredIndex; i++ {
			if expandedFlags[i] & ElementFlagsOptional {
				expandedFlags[i] = ElementFlagsRequired
			}
		}
		if firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex {
			expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex+1), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): expandedFlags[firstRestIndex + i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */ TODO
			}))
			expandedTypes.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
			expandedFlags.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
			expandedDeclarations.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
		}
		tupleTarget := getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations)
		// converted from conditional expression
		switch {
		case tupleTarget == emptyGenericType:
			return emptyObjectType
		case expandedFlags.length:
			return createTypeReference(tupleTarget, expandedTypes)
		default:
			return tupleTarget
		}
		addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(TypeNode UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) {
			if flags & ElementFlagsRequired {
				lastRequiredIndex = expandedFlags.length
			}
			if flags&ElementFlagsRest && firstRestIndex < 0 {
				firstRestIndex = expandedFlags.length
			}
			if flags & (ElementFlagsOptional | ElementFlagsRest) {
				lastOptionalOrRestIndex = expandedFlags.length
			}
			expandedTypes.push( /* TODO(Node ConditionalExpression): flags & ElementFlags.Optional ? addOptionality(type, /*isProperty* / true) : type */ TODO)
			expandedFlags.push(flags)
			expandedDeclarations.push(declaration)
		}
	}
	sliceTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO inferred type number */ any /*  = 0 */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		target := type_.target
		endIndex := getTypeReferenceArity(type_) - endSkipCount
		// converted from conditional expression
		switch {
		case index > target.fixedLength:
			return getRestArrayTypeOfTupleType(type_) || createTupleType(emptyArray)
		default:
			return createTupleType(getTypeArguments(type_).slice(index, endIndex), target.elementFlags.slice(index, endIndex), false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex))
		}
	}
	getKnownKeysOfTupleType := func(type_ TupleTypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getUnionType(append(arrayOf(type_.target.fixedLength, func(i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType */ any {
			return getStringLiteralType("" + i)
		}), getIndexType( /* TODO(Node ConditionalExpression): type.target.readonly ? globalReadonlyArrayType : globalArrayType */ TODO)))
	}
	getStartElementCount := func(type_ TupleType, flags ElementFlags) /* TODO inferred type number */ any {
		index := findIndex(type_.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any) /* TODO inferred type boolean */ any {
			return !(f & flags)
		})
		// converted from conditional expression
		switch {
		case index >= 0:
			return index
		default:
			return type_.elementFlags.length
		}
	}
	getEndElementCount := func(type_ TupleType, flags ElementFlags) /* TODO inferred type number */ any {
		return type_.elementFlags.length - findLastIndex(type_.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any) /* TODO inferred type boolean */ any {
			return !(f & flags)
		}) - 1
	}
	getTotalFixedElementCount := func(type_ TupleType) /* TODO inferred type number */ any {
		return type_.fixedLength + getEndElementCount(type_, ElementFlagsFixed)
	}
	getElementTypes := func(type_ TupleTypeReference) []Type {
		typeArguments := getTypeArguments(type_)
		arity := getTypeReferenceArity(type_)
		// converted from conditional expression
		switch {
		case typeArguments.length == arity:
			return typeArguments
		default:
			return typeArguments.slice(0, arity)
		}
	}
	getTypeFromOptionalTypeNode := func(node OptionalTypeNode) Type {
		return addOptionality(getTypeFromTypeNode(node.type_), true)
	}
	getTypeId := func(type_ Type) TypeId {
		return type_.id
	}
	containsType := func(types []Type, type_ Type) bool {
		return binarySearch(types, type_, getTypeId, compareValues) >= 0
	}
	insertType := func(types []Type, type_ Type) bool {
		index := binarySearch(types, type_, getTypeId, compareValues)
		if index < 0 {
			types.splice(~index, 0, type_)
			return true
		}
		return false
	}
	addTypeToUnion := func(typeSet []Type, includes TypeFlags, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ any {
		flags := type_.flags
		if !(flags & TypeFlagsNever) {
			includes |= flags & TypeFlagsIncludesMask
			if flags & TypeFlagsInstantiable {
				includes |= TypeFlagsIncludesInstantiable
			}
			if flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				includes |= TypeFlagsIncludesConstrainedTypeVariable
			}
			if type_ == wildcardType {
				includes |= TypeFlagsIncludesWildcard
			}
			if isErrorType(type_) {
				includes |= TypeFlagsIncludesError
			}
			if !strictNullChecks && flags&TypeFlagsNullable {
				if !(getObjectFlags(type_) & ObjectFlagsContainsWideningType) {
					includes |= TypeFlagsIncludesNonWideningType
				}
			} else {
				len := typeSet.length
				index := /* TODO(Node ConditionalExpression): len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues) */ TODO
				if index < 0 {
					typeSet.splice(~index, 0, type_)
				}
			}
		}
		return includes
	}
	addTypesToUnion := func(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
		var lastType *Type
		for _, type_ := range types {
			if type_ != lastType {
				includes = /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) : addTypeToUnion(typeSet, includes, type) */ TODO
				lastType = type_
			}
		}
		return includes
	}
	removeSubtypes := func(types []Type, hasObjectTypes bool) *[]Type {
		if types.length < 2 {
			return types
		}
		id := getTypeListId(types)
		match := subtypeReductionCache.get(id)
		if match {
			return match
		}
		hasEmptyObject := hasObjectTypes && some(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & TypeFlagsObject) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t))
		})
		len := types.length
		i := len
		count := 0
		for i > 0 {
			i--
			source := types[i]
			if hasEmptyObject || source.flags&TypeFlagsStructuredOrInstantiable {
				if source.flags&TypeFlagsTypeParameter && getBaseConstraintOrType(source).flags&TypeFlagsUnion {
					if isTypeRelatedTo(source, getUnionType(map_(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return /* TODO(Node ConditionalExpression): t === source ? neverType : t */ TODO
					})), strictSubtypeRelation) {
						orderedRemoveItemAt(types, i)
					}
					continue
				}
				keyProperty := /* TODO(Node ConditionalExpression): source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ? find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) : undefined */ TODO
				keyPropertyType := keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty))
				for _, target := range types {
					if source != target {
						if count == 100000 {
							estimatedCount := (count / (len - i)) * len
							if estimatedCount > 1000000 {
								tracing. /*?*/ instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit" /* TODO(Node ObjectLiteralExpression): { typeIds: types.map(t => t.id) } */, TODO)
								error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
								return nil
							}
						}
						count++
						if keyProperty && target.flags&(TypeFlagsObject|TypeFlagsIntersection|TypeFlagsInstantiableNonPrimitive) {
							t := getTypeOfPropertyOfType(target, keyProperty.escapedName)
							if t && isUnitType(t) && getRegularTypeOfLiteralType(t) != keyPropertyType {
								continue
							}
						}
						if isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(getObjectFlags(getTargetType(source)) & ObjectFlagsClass) || !(getObjectFlags(getTargetType(target)) & ObjectFlagsClass) || isTypeDerivedFrom(source, target)) {
							orderedRemoveItemAt(types, i)
							break
						}
					}
				}
			}
		}
		subtypeReductionCache.set(id, types)
		return types
	}
	removeRedundantLiteralTypes := func(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
		i := types.length
		for i > 0 {
			i--
			t := types[i]
			flags := t.flags
			remove := flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsString || flags&TypeFlagsNumberLiteral && includes&TypeFlagsNumber || flags&TypeFlagsBigIntLiteral && includes&TypeFlagsBigInt || flags&TypeFlagsUniqueESSymbol && includes&TypeFlagsESSymbol || reduceVoidUndefined && flags&TypeFlagsUndefined && includes&TypeFlagsVoid || isFreshLiteralType(t) && containsType(types, (t).regularType)
			if remove {
				orderedRemoveItemAt(types, i)
			}
		}
	}
	removeStringLiteralsMatchedByTemplateLiterals := func(types []Type) {
		templates := filter(types, isPatternLiteralType)
		if templates.length {
			i := types.length
			for i > 0 {
				i--
				t := types[i]
				if t.flags&TypeFlagsStringLiteral && some(templates, func(template /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ any) /* TODO inferred type boolean */ any {
					return isTypeMatchedByTemplateLiteralOrStringMapping(t, template)
				}) {
					orderedRemoveItemAt(types, i)
				}
			}
		}
	}
	isTypeMatchedByTemplateLiteralOrStringMapping := func(type_ Type, template /* TODO(TypeNode UnionType): TemplateLiteralType | StringMappingType */ any) /* TODO inferred type boolean */ any {
		// converted from conditional expression
		switch {
		case template.flags & TypeFlagsTemplateLiteral:
			return isTypeMatchedByTemplateLiteralType(type_, template)
		default:
			return isMemberOfStringMapping(type_, template)
		}
	}
	removeConstrainedTypeVariables := func(types []Type) {
		var typeVariables []TypeVariable = [] /* TODO inferred type never */ any{}
		for _, type_ := range types {
			if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				index := /* TODO(Node ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
				pushIfUnique(typeVariables, (type_).types[index])
			}
		}
		for _, typeVariable := range typeVariables {
			var primitives []Type = [] /* TODO inferred type never */ any{}
			for _, type_ := range types {
				if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
					index := /* TODO(Node ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
					if (type_).types[index] == typeVariable {
						insertType(primitives, (type_).types[1-index])
					}
				}
			}
			constraint := getBaseConstraintOfType(typeVariable)
			if everyType(constraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return containsType(primitives, t)
			}) {
				i := types.length
				for i > 0 {
					i--
					type_ := types[i]
					if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
						index := /* TODO(Node ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
						if (type_).types[index] == typeVariable && containsType(primitives, (type_).types[1-index]) {
							orderedRemoveItemAt(types, i)
						}
					}
				}
				insertType(types, typeVariable)
			}
		}
	}
	isNamedUnionType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags&TypeFlagsUnion && (type_.aliasSymbol || (type_).origin))
	}
	addNamedUnions := func(namedUnions []Type, types []Type) {
		for _, t := range types {
			if t.flags & TypeFlagsUnion {
				origin := (t).origin
				if t.aliasSymbol || origin && !(origin.flags&TypeFlagsUnion) {
					pushIfUnique(namedUnions, t)
				} else if origin && origin.flags&TypeFlagsUnion {
					addNamedUnions(namedUnions, (origin).types)
				}
			}
		}
	}
	createOriginUnionOrIntersectionType := func(flags TypeFlags, types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").UnionOrIntersectionType */ any {
		result := createOriginType(flags)
		result.types = types
		return result
	}
	getUnionType := func(types []Type, unionReduction UnionReduction /*  = UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return types[0]
		}
		if types.length == 2 && !origin && (types[0].flags&TypeFlagsUnion || types[1].flags&TypeFlagsUnion) {
			infix := /* TODO(Node ConditionalExpression): unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L" */ TODO
			index := /* TODO(Node ConditionalExpression): types[0].id < types[1].id ? 0 : 1 */ TODO
			id := types[index].id + infix + types[1-index].id + getAliasId(aliasSymbol, aliasTypeArguments)
			type_ := unionOfUnionTypes.get(id)
			if !type_ {
				type_ = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, nil)
				unionOfUnionTypes.set(id, type_)
			}
			return type_
		}
		return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionTypeWorker := func(types []Type, unionReduction UnionReduction, aliasSymbol *Symbol, aliasTypeArguments *[]Type, origin *Type) Type {
		var typeSet *[]Type = [] /* TODO inferred type never */ any{}
		includes := addTypesToUnion(typeSet, 0, types)
		if unionReduction != UnionReductionNone {
			if includes & TypeFlagsAnyOrUnknown {
				// converted from conditional expression
				switch {
				case includes & TypeFlagsAny:
					// converted from conditional expression
					switch {
					case includes & TypeFlagsIncludesWildcard:
						return wildcardType
					case includes & TypeFlagsIncludesError:
						return errorType
					default:
						return anyType
					}
				default:
					return unknownType
				}
			}
			if includes & TypeFlagsUndefined {
				if typeSet.length >= 2 && typeSet[0] == undefinedType && typeSet[1] == missingType {
					orderedRemoveItemAt(typeSet, 1)
				}
			}
			if includes&(TypeFlagsEnum|TypeFlagsLiteral|TypeFlagsUniqueESSymbol|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsVoid && includes&TypeFlagsUndefined {
				removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReductionSubtype))
			}
			if includes&TypeFlagsStringLiteral && includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) {
				removeStringLiteralsMatchedByTemplateLiterals(typeSet)
			}
			if includes & TypeFlagsIncludesConstrainedTypeVariable {
				removeConstrainedTypeVariables(typeSet)
			}
			if unionReduction == UnionReductionSubtype {
				typeSet = removeSubtypes(typeSet, !!(includes & TypeFlagsObject))
				if !typeSet {
					return errorType
				}
			}
			if typeSet.length == 0 {
				// converted from conditional expression
				switch {
				case includes & TypeFlagsNull:
					// converted from conditional expression
					switch {
					case includes & TypeFlagsIncludesNonWideningType:
						return nullType
					default:
						return nullWideningType
					}
				case includes & TypeFlagsUndefined:
					// converted from conditional expression
					switch {
					case includes & TypeFlagsIncludesNonWideningType:
						return undefinedType
					default:
						return undefinedWideningType
					}
				default:
					return neverType
				}
			}
		}
		if !origin && includes&TypeFlagsUnion {
			var namedUnions []Type = [] /* TODO inferred type never */ any{}
			addNamedUnions(namedUnions, types)
			var reducedTypes []Type = [] /* TODO inferred type never */ any{}
			for _, t := range typeSet {
				if !some(namedUnions, func(union /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return containsType((union).types, t)
				}) {
					reducedTypes.push(t)
				}
			}
			if !aliasSymbol && namedUnions.length == 1 && reducedTypes.length == 0 {
				return namedUnions[0]
			}
			namedTypesCount := reduceLeft(namedUnions, func(sum /* TODO inferred type number */ any, union /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
				return sum + (union).types.length
			}, 0)
			if namedTypesCount+reducedTypes.length == typeSet.length {
				for _, t := range namedUnions {
					insertType(reducedTypes, t)
				}
				origin = createOriginUnionOrIntersectionType(TypeFlagsUnion, reducedTypes)
			}
		}
		objectFlags := ( /* TODO(Node ConditionalExpression): includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion */ TODO) | ( /* TODO(Node ConditionalExpression): includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0 */ TODO)
		return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionOrIntersectionTypePredicate := func(signatures []Signature, kind *TypeFlags) *TypePredicate {
		var last *TypePredicate
		var types []Type = [] /* TODO inferred type never */ any{}
		for _, sig := range signatures {
			pred := getTypePredicateOfSignature(sig)
			if pred {
				if pred.kind != TypePredicateKindThis && pred.kind != TypePredicateKindIdentifier || last && !typePredicateKindsMatch(last, pred) {
					return nil
				}
				last = pred
				types.push(pred.type_)
			} else {
				returnType := /* TODO(Node ConditionalExpression): kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined */ TODO
				if returnType != falseType && returnType != regularFalseType {
					return nil
				}
			}
		}
		if !last {
			return nil
		}
		compositeType := getUnionOrIntersectionType(types, kind)
		return createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType)
	}
	typePredicateKindsMatch := func(a TypePredicate, b TypePredicate) bool {
		return a.kind == b.kind && a.parameterIndex == b.parameterIndex
	}
	getUnionTypeFromSortedList := func(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return types[0]
		}
		typeKey := /* TODO(Node ConditionalExpression): !origin ? getTypeListId(types) : origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` : origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` : `#${(origin as IndexType).type.id}|${getTypeListId(types)}` */ TODO
		id := typeKey + getAliasId(aliasSymbol, aliasTypeArguments)
		type_ := unionTypes.get(id)
		if !type_ {
			type_ = createType(TypeFlagsUnion)
			type_.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, TypeFlagsNullable)
			type_.types = types
			type_.origin = origin
			type_.aliasSymbol = aliasSymbol
			type_.aliasTypeArguments = aliasTypeArguments
			if types.length == 2 && types[0].flags&TypeFlagsBooleanLiteral && types[1].flags&TypeFlagsBooleanLiteral {
				type_.flags |= TypeFlagsBoolean
				(type_).intrinsicName = "boolean"
			}
			unionTypes.set(id, type_)
		}
		return type_
	}
	getTypeFromUnionTypeNode := func(node UnionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			links.resolvedType = getUnionType(map_(node.types, getTypeFromTypeNode), UnionReductionLiteral, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	addTypeToIntersection := func(typeSet Map[string, Type], includes TypeFlags, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ any {
		flags := type_.flags
		if flags & TypeFlagsIntersection {
			return addTypesToIntersection(typeSet, includes, (type_).types)
		}
		if isEmptyAnonymousObjectType(type_) {
			if !(includes & TypeFlagsIncludesEmptyObject) {
				includes |= TypeFlagsIncludesEmptyObject
				typeSet.set(type_.id.toString(), type_)
			}
		} else {
			if flags & TypeFlagsAnyOrUnknown {
				if type_ == wildcardType {
					includes |= TypeFlagsIncludesWildcard
				}
				if isErrorType(type_) {
					includes |= TypeFlagsIncludesError
				}
			} else if strictNullChecks || !(flags & TypeFlagsNullable) {
				if type_ == missingType {
					includes |= TypeFlagsIncludesMissingType
					type_ = undefinedType
				}
				if !typeSet.has(type_.id.toString()) {
					if type_.flags&TypeFlagsUnit && includes&TypeFlagsUnit {
						includes |= TypeFlagsNonPrimitive
					}
					typeSet.set(type_.id.toString(), type_)
				}
			}
			includes |= flags & TypeFlagsIncludesMask
		}
		return includes
	}
	addTypesToIntersection := func(typeSet Map[string, Type], includes TypeFlags, types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ any {
		for _, type_ := range types {
			includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type_))
		}
		return includes
	}
	removeRedundantSupertypes := func(types []Type, includes TypeFlags) {
		i := types.length
		for i > 0 {
			i--
			t := types[i]
			remove := t.flags&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || t.flags&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || t.flags&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || t.flags&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || t.flags&TypeFlagsVoid && includes&TypeFlagsUndefined || isEmptyAnonymousObjectType(t) && includes&TypeFlagsDefinitelyNonNullable
			if remove {
				orderedRemoveItemAt(types, i)
			}
		}
	}
	eachUnionContains := func(unionTypes []UnionType, type_ Type) /* TODO inferred type boolean */ any {
		for _, u := range unionTypes {
			if !containsType(u.types, type_) {
				if type_ == missingType {
					return containsType(u.types, undefinedType)
				}
				if type_ == undefinedType {
					return containsType(u.types, missingType)
				}
				primitive := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.StringLiteral ? stringType : type.flags & (TypeFlags.Enum | TypeFlags.NumberLiteral) ? numberType : type.flags & TypeFlags.BigIntLiteral ? bigintType : type.flags & TypeFlags.UniqueESSymbol ? esSymbolType : undefined */ TODO
				if !primitive || !containsType(u.types, primitive) {
					return false
				}
			}
		}
		return true
	}
	extractRedundantTemplateLiterals := func(types []Type) bool {
		i := types.length
		literals := filter(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & TypeFlagsStringLiteral)
		})
		for i > 0 {
			i--
			t := types[i]
			if !(t.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) {
				continue
			}
			for _, t2 := range literals {
				if isTypeSubtypeOf(t2, t) {
					orderedRemoveItemAt(types, i)
					break
				} else if isPatternLiteralType(t) {
					return true
				}
			}
		}
		return false
	}
	removeFromEach := func(types []Type, flag TypeFlags) {
		for i := 0; i < types.length; i++ {
			types[i] = filterType(types[i], func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !(t.flags & flag)
			})
		}
	}
	intersectUnionsOfPrimitiveTypes := func(types []Type) /* TODO inferred type boolean */ any {
		var unionTypes *[]UnionType
		index := findIndex(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(getObjectFlags(t) & ObjectFlagsPrimitiveUnion)
		})
		if index < 0 {
			return false
		}
		i := index + 1
		for i < types.length {
			t := types[i]
			if getObjectFlags(t) & ObjectFlagsPrimitiveUnion {
				(unionTypes || ( /* TODO(Node BinaryExpression): unionTypes = [types[index] as UnionType] */ TODO)).push(t)
				orderedRemoveItemAt(types, i)
			} else {
				i++
			}
		}
		if !unionTypes {
			return false
		}
		var checked []Type = [] /* TODO inferred type never */ any{}
		var result []Type = [] /* TODO inferred type never */ any{}
		for _, u := range unionTypes {
			for _, t := range u.types {
				if insertType(checked, t) {
					if eachUnionContains(unionTypes, t) {
						if t == undefinedType && result.length && result[0] == missingType {
							continue
						}
						if t == missingType && result.length && result[0] == undefinedType {
							result[0] = missingType
							continue
						}
						insertType(result, t)
					}
				}
			}
		}
		types[index] = getUnionTypeFromSortedList(result, ObjectFlagsPrimitiveUnion)
		return true
	}
	createIntersectionType := func(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionType */ any {
		result := createType(TypeFlagsIntersection)
		result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, TypeFlagsNullable)
		result.types = types
		result.aliasSymbol = aliasSymbol
		result.aliasTypeArguments = aliasTypeArguments
		return result
	}
	getIntersectionType := func(types []Type, flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionFlags */ any /*  = IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeMembershipMap := make(map[string]Type)
		includes := addTypesToIntersection(typeMembershipMap, 0, types)
		var typeSet []Type = arrayFrom(typeMembershipMap.values())
		objectFlags := ObjectFlagsNone
		if includes & TypeFlagsNever {
			// converted from conditional expression
			switch {
			case contains(typeSet, silentNeverType):
				return silentNeverType
			default:
				return neverType
			}
		}
		if strictNullChecks && includes&TypeFlagsNullable && includes&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsIncludesEmptyObject) || includes&TypeFlagsNonPrimitive && includes&(TypeFlagsDisjointDomains&~TypeFlagsNonPrimitive) || includes&TypeFlagsStringLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsStringLike) || includes&TypeFlagsNumberLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsNumberLike) || includes&TypeFlagsBigIntLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsBigIntLike) || includes&TypeFlagsESSymbolLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsESSymbolLike) || includes&TypeFlagsVoidLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsVoidLike) {
			return neverType
		}
		if includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsStringLiteral && extractRedundantTemplateLiterals(typeSet) {
			return neverType
		}
		if includes & TypeFlagsAny {
			// converted from conditional expression
			switch {
			case includes & TypeFlagsIncludesWildcard:
				return wildcardType
			case includes & TypeFlagsIncludesError:
				return errorType
			default:
				return anyType
			}
		}
		if !strictNullChecks && includes&TypeFlagsNullable {
			// converted from conditional expression
			switch {
			case includes & TypeFlagsIncludesEmptyObject:
				return neverType
			case includes & TypeFlagsUndefined:
				return undefinedType
			default:
				return nullType
			}
		}
		if includes&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || includes&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || includes&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || includes&TypeFlagsVoid && includes&TypeFlagsUndefined || includes&TypeFlagsIncludesEmptyObject && includes&TypeFlagsDefinitelyNonNullable {
			if !(flags & IntersectionFlagsNoSupertypeReduction) {
				removeRedundantSupertypes(typeSet, includes)
			}
		}
		if includes & TypeFlagsIncludesMissingType {
			typeSet[typeSet.indexOf(undefinedType)] = missingType
		}
		if typeSet.length == 0 {
			return unknownType
		}
		if typeSet.length == 1 {
			return typeSet[0]
		}
		if typeSet.length == 2 && !(flags & IntersectionFlagsNoConstraintReduction) {
			typeVarIndex := /* TODO(Node ConditionalExpression): typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
			typeVariable := typeSet[typeVarIndex]
			primitiveType := typeSet[1-typeVarIndex]
			if typeVariable.flags&TypeFlagsTypeVariable && (primitiveType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) && !isGenericStringLikeType(primitiveType) || includes&TypeFlagsIncludesEmptyObject) {
				constraint := getBaseConstraintOfType(typeVariable)
				if constraint && everyType(constraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive)) || isEmptyAnonymousObjectType(t)
				}) {
					if isTypeStrictSubtypeOf(constraint, primitiveType) {
						return typeVariable
					}
					if !(constraint.flags&TypeFlagsUnion && someType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return isTypeStrictSubtypeOf(c, primitiveType)
					})) {
						if !isTypeStrictSubtypeOf(primitiveType, constraint) {
							return neverType
						}
					}
					objectFlags = ObjectFlagsIsConstrainedTypeVariable
				}
			}
		}
		id := getTypeListId(typeSet) + ( /* TODO(Node ConditionalExpression): flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments) */ TODO)
		result := intersectionTypes.get(id)
		if !result {
			if includes & TypeFlagsUnion {
				if intersectUnionsOfPrimitiveTypes(typeSet) {
					result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags&TypeFlagsUnion && (t).types[0].flags&TypeFlagsUndefined)
				}) {
					containedUndefinedType := /* TODO(Node ConditionalExpression): some(typeSet, containsMissingType) ? missingType : undefinedType */ TODO
					removeFromEach(typeSet, TypeFlagsUndefined)
					result = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getIntersectionType(typeSet, flags), containedUndefinedType}, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags&TypeFlagsUnion && ((t).types[0].flags&TypeFlagsNull || (t).types[1].flags&TypeFlagsNull))
				}) {
					removeFromEach(typeSet, TypeFlagsNull)
					result = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getIntersectionType(typeSet, flags), nullType}, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if typeSet.length >= 3 && types.length > 2 {
					middle := Math.floor(typeSet.length / 2)
					result = getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)}, flags, aliasSymbol, aliasTypeArguments)
				} else {
					if !checkCrossProductUnion(typeSet) {
						return errorType
					}
					constituents := getCrossProductIntersections(typeSet, flags)
					origin := /* TODO(Node ConditionalExpression): some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined */ TODO
					result = getUnionType(constituents, UnionReductionLiteral, aliasSymbol, aliasTypeArguments, origin)
				}
			} else {
				result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments)
			}
			intersectionTypes.set(id, result)
		}
		return result
	}
	getCrossProductUnionSize := func(types []Type) /* TODO inferred type number */ any {
		return reduceLeft(types, func(n /* TODO inferred type number */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
			return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Union ? n * (t as UnionType).types.length : t.flags & TypeFlags.Never ? 0 : n */ TODO
		}, 1)
	}
	checkCrossProductUnion := func(types []Type) /* TODO inferred type boolean */ any {
		size := getCrossProductUnionSize(types)
		if size >= 100000 {
			tracing. /*?*/ instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit" /* TODO(Node ObjectLiteralExpression): { typeIds: types.map(t => t.id), size } */, TODO)
			error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
			return false
		}
		return true
	}
	getCrossProductIntersections := func(types []Type, flags IntersectionFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ any {
		count := getCrossProductUnionSize(types)
		var intersections []Type = [] /* TODO inferred type never */ any{}
		for i := 0; i < count; i++ {
			constituents := types.slice()
			n := i
			for j := types.length - 1; j >= 0; j-- {
				if types[j].flags & TypeFlagsUnion {
					sourceTypes := (types[j]).types
					length := sourceTypes.length
					constituents[j] = sourceTypes[ /* TODO(Node BinaryExpression): n % length */ TODO]
					n = Math.floor(n / length)
				}
			}
			t := getIntersectionType(constituents, flags)
			if !(t.flags & TypeFlagsNever) {
				intersections.push(t)
			}
		}
		return intersections
	}
	getConstituentCount := func(type_ Type) number {
		// converted from conditional expression
		switch {
		case !(type_.flags & TypeFlagsUnionOrIntersection) || type_.aliasSymbol:
			return 1
		case type_.flags&TypeFlagsUnion && (type_).origin:
			return getConstituentCount((type_).origin)
		default:
			return getConstituentCountOfTypes((type_).types)
		}
	}
	getConstituentCountOfTypes := func(types []Type) number {
		return reduceLeft(types, func(n /* TODO inferred type number */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
			return n + getConstituentCount(t)
		}, 0)
	}
	getTypeFromIntersectionTypeNode := func(node IntersectionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			types := map_(node.types, getTypeFromTypeNode)
			emptyIndex := /* TODO(Node ConditionalExpression): types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1 */ TODO
			t := /* TODO(Node ConditionalExpression): emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType */ TODO
			noSupertypeReduction := !!(t.flags&(TypeFlagsString|TypeFlagsNumber|TypeFlagsBigInt) || t.flags&TypeFlagsTemplateLiteral && isPatternLiteralType(t))
			links.resolvedType = getIntersectionType(types /* TODO(Node ConditionalExpression): noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0 */, TODO, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	createIndexType := func(type_ /* TODO(TypeNode UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ any {
		result := createType(TypeFlagsIndex)
		result.type_ = type_
		result.indexFlags = indexFlags
		return result
	}
	createOriginIndexType := func(type_ /* TODO(TypeNode UnionType): InstantiableType | UnionOrIntersectionType */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ any {
		result := createOriginType(TypeFlagsIndex)
		result.type_ = type_
		return result
	}
	getIndexTypeForGenericType := func(type_ /* TODO(TypeNode UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ any {
		// converted from conditional expression
		switch {
		case indexFlags & IndexFlagsStringsOnly:
			return type_.resolvedStringIndexType || ( /* TODO(Node BinaryExpression): type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly) */ TODO)
		default:
			return type_.resolvedIndexType || ( /* TODO(Node BinaryExpression): type.resolvedIndexType = createIndexType(type, IndexFlags.None) */ TODO)
		}
	}
	getIndexTypeForMappedType := func(type_ MappedType, indexFlags IndexFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		nameType := getNameTypeFromMappedType(type_.target || type_)
		if !nameType && !(indexFlags & IndexFlagsNoIndexSignatures) {
			return constraintType
		}
		var keyTypes []Type = [] /* TODO inferred type never */ any{}
		if isGenericIndexType(constraintType) {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				return getIndexTypeForGenericType(type_, indexFlags)
			}
			forEachType(constraintType, addMemberForKeyType)
		} else if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlagsStringsOnly), addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		result := /* TODO(Node ConditionalExpression): indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes) */ TODO
		if result.flags&TypeFlagsUnion && constraintType.flags&TypeFlagsUnion && getTypeListId((result).types) == getTypeListId((constraintType).types) {
			return constraintType
		}
		return result
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(Node ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			keyTypes.push( /* TODO(Node ConditionalExpression): propNameType === stringType ? stringOrNumberType : propNameType */ TODO)
		}
	}
	hasDistributiveNameType := func(mappedType MappedType) /* TODO inferred type boolean */ any {
		typeVariable := getTypeParameterFromMappedType(mappedType)
		return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable)
		isDistributive := func(type_ Type) bool {
			// converted from conditional expression
			switch {
			case type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsPrimitive | TypeFlagsNever | TypeFlagsTypeParameter | TypeFlagsObject | TypeFlagsNonPrimitive):
				return true
			case type_.flags & TypeFlagsConditional:
				return (type_).root.isDistributive && (type_).checkType == typeVariable
			case type_.flags & (TypeFlagsUnionOrIntersection | TypeFlagsTemplateLiteral):
				return every((type_).types, isDistributive)
			case type_.flags & TypeFlagsIndexedAccess:
				return isDistributive((type_).objectType) && isDistributive((type_).indexType)
			case type_.flags & TypeFlagsSubstitution:
				return isDistributive((type_).baseType) && isDistributive((type_).constraint)
			case type_.flags & TypeFlagsStringMapping:
				return isDistributive((type_).type_)
			default:
				return false
			}
		}
	}
	getLiteralTypeFromPropertyName := func(name /* TODO(TypeNode UnionType): PropertyName | JsxAttributeName */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if isPrivateIdentifier(name) {
			return neverType
		}
		if isNumericLiteral(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		if isComputedPropertyName(name) {
			return getRegularTypeOfLiteralType(checkComputedPropertyName(name))
		}
		propertyName := getPropertyNameForPropertyNameNode(name)
		if propertyName != nil {
			return getStringLiteralType(unescapeLeadingUnderscores(propertyName))
		}
		if isExpression(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		return neverType
	}
	getLiteralTypeFromProperty := func(prop Symbol, include TypeFlags, includeNonPublic bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlagsNonPublicAccessibilityModifier) {
			type_ := getSymbolLinks(getLateBoundSymbol(prop)).nameType
			if !type_ {
				name := getNameOfDeclaration(prop.valueDeclaration)
				type_ = /* TODO(Node ConditionalExpression): prop.escapedName === InternalSymbolName.Default ? getStringLiteralType("default") : name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined) */ TODO
			}
			if type_ && type_.flags&include {
				return type_
			}
		}
		return neverType
	}
	isKeyTypeIncluded := func(keyType Type, include TypeFlags) bool {
		return !!(keyType.flags&include || keyType.flags&TypeFlagsIntersection && some((keyType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return isKeyTypeIncluded(t, include)
		}))
	}
	getLiteralTypeFromProperties := func(type_ Type, include TypeFlags, includeOrigin bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		origin := /* TODO(Node ConditionalExpression): includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined */ TODO
		propertyTypes := map_(getPropertiesOfType(type_), func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return getLiteralTypeFromProperty(prop, include)
		})
		indexKeyTypes := map_(getIndexInfosOfType(type_), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ? info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType : neverType */ TODO
		})
		return getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReductionLiteral, nil, nil, origin)
	}
	shouldDeferIndexType := func(type_ Type, indexFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ any /*  = IndexFlags.None */) /* TODO inferred type boolean */ any {
		return !!(type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericTupleType(type_) || isGenericMappedType(type_) && (!hasDistributiveNameType(type_) || getMappedTypeNameTypeKind(type_) == MappedTypeNameTypeKindRemapping) || type_.flags&TypeFlagsUnion && !(indexFlags&IndexFlagsNoReducibleCheck) && isGenericReducibleType(type_) || type_.flags&TypeFlagsIntersection && maybeTypeOfKind(type_, TypeFlagsInstantiable) && some((type_).types, isEmptyAnonymousObjectType))
	}
	getIndexType := func(type_ Type, indexFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ any /*  = IndexFlags.None */) Type {
		type_ = getReducedType(type_)
		// converted from conditional expression
		switch {
		case isNoInferType(type_):
			return getNoInferType(getIndexType((type_).baseType, indexFlags))
		case shouldDeferIndexType(type_, indexFlags):
			return getIndexTypeForGenericType(type_, indexFlags)
		case type_.flags & TypeFlagsUnion:
			return getIntersectionType(map_((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getIndexType(t, indexFlags)
			}))
		case type_.flags & TypeFlagsIntersection:
			return getUnionType(map_((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getIndexType(t, indexFlags)
			}))
		case getObjectFlags(type_) & ObjectFlagsMapped:
			return getIndexTypeForMappedType(type_, indexFlags)
		case type_ == wildcardType:
			return wildcardType
		case type_.flags & TypeFlagsUnknown:
			return neverType
		case type_.flags & (TypeFlagsAny | TypeFlagsNever):
			return stringNumberSymbolType
		default:
			return getLiteralTypeFromProperties(type_, ( /* TODO(Node ConditionalExpression): indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike */ TODO)|( /* TODO(Node ConditionalExpression): indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike */ TODO), indexFlags == IndexFlagsNone)
		}
	}
	getExtractStringType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		extractTypeAlias := getGlobalExtractSymbol()
		// converted from conditional expression
		switch {
		case extractTypeAlias:
			return getTypeAliasInstantiation(extractTypeAlias, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, stringType})
		default:
			return stringType
		}
	}
	getIndexTypeOrString := func(type_ Type) Type {
		indexType := getExtractStringType(getIndexType(type_))
		// converted from conditional expression
		switch {
		case indexType.flags & TypeFlagsNever:
			return stringType
		default:
			return indexType
		}
	}
	getTypeFromTypeOperatorNode := func(node TypeOperatorNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			switch node.operator {
			case SyntaxKindKeyOfKeyword:
				links.resolvedType = getIndexType(getTypeFromTypeNode(node.type_))
				break
			case SyntaxKindUniqueKeyword:
				links.resolvedType = /* TODO(Node ConditionalExpression): node.type.kind === SyntaxKind.SymbolKeyword ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent)) : errorType */ TODO
				break
			case SyntaxKindReadonlyKeyword:
				links.resolvedType = getTypeFromTypeNode(node.type_)
				break
			default:
				Debug.assertNever(node.operator)
			}
		}
		return links.resolvedType
	}
	getTypeFromTemplateTypeNode := func(node TemplateLiteralTypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getTemplateLiteralType([] /* TODO inferred type string */ any{node.head.text /* TODO(Node SpreadElement): ...map(node.templateSpans, span => span.literal.text) */}, map_(node.templateSpans, func(span /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralTypeSpan */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getTypeFromTypeNode(span.type_)
			}))
		}
		return links.resolvedType
	}
	getTemplateLiteralType := func(texts []string, types []Type) Type {
		unionIndex := findIndex(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & (TypeFlagsNever | TypeFlagsUnion))
		})
		if unionIndex >= 0 {
			// converted from conditional expression
			switch {
			case checkCrossProductUnion(types):
				return mapType(types[unionIndex], func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))
				})
			default:
				return errorType
			}
		}
		if contains(types, wildcardType) {
			return wildcardType
		}
		var newTypes []Type = [] /* TODO inferred type never */ any{}
		var newTexts []string = [] /* TODO inferred type never */ any{}
		text := texts[0]
		if !addSpans(texts, types) {
			return stringType
		}
		if newTypes.length == 0 {
			return getStringLiteralType(text)
		}
		newTexts.push(text)
		if every(newTexts, func(t /* TODO inferred type string */ any) /* TODO inferred type boolean */ any {
			return t == ""
		}) {
			if every(newTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !!(t.flags & TypeFlagsString)
			}) {
				return stringType
			}
			if newTypes.length == 1 && isPatternLiteralType(newTypes[0]) {
				return newTypes[0]
			}
		}
		id := /* TODO(Node TemplateExpression): `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}` */ TODO
		type_ := templateLiteralTypes.get(id)
		if !type_ {
			templateLiteralTypes.set(id /* TODO(Node BinaryExpression): type = createTemplateLiteralType(newTexts, newTypes) */, TODO)
		}
		return type_
		addSpans := func(texts []string, types []Type) bool {
			for i := 0; i < types.length; i++ {
				t := types[i]
				if t.flags & (TypeFlagsLiteral | TypeFlagsNull | TypeFlagsUndefined) {
					text += getTemplateStringForType(t) || ""
					text += texts[i+1]
				} else if t.flags & TypeFlagsTemplateLiteral {
					text += (t).texts[0]
					if !addSpans((t).texts, (t).types) {
						return false
					}
					text += texts[i+1]
				} else if isGenericIndexType(t) || isPatternLiteralPlaceholderType(t) {
					newTypes.push(t)
					newTexts.push(text)
					text = texts[i+1]
				} else {
					return false
				}
			}
			return true
		}
	}
	getTemplateStringForType := func(type_ Type) /* TODO inferred type string | undefined */ any {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsStringLiteral:
			return (type_).value
		case type_.flags & TypeFlagsNumberLiteral:
			return "" + (type_).value
		case type_.flags & TypeFlagsBigIntLiteral:
			return pseudoBigIntToString((type_).value)
		case type_.flags & (TypeFlagsBooleanLiteral | TypeFlagsNullable):
			return (type_).intrinsicName
		default:
			return nil
		}
	}
	createTemplateLiteralType := func(texts []string, types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ any {
		type_ := createType(TypeFlagsTemplateLiteral)
		type_.texts = texts
		type_.types = types
		return type_
	}
	getStringMappingType := func(symbol Symbol, type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsUnion | TypeFlagsNever):
			return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getStringMappingType(symbol, t)
			})
		case type_.flags & TypeFlagsStringLiteral:
			return getStringLiteralType(applyStringMapping(symbol, (type_).value))
		case type_.flags & TypeFlagsTemplateLiteral:
			return getTemplateLiteralType(applyTemplateStringMapping(symbol, (type_).texts, (type_).types)...)
		case type_.flags&TypeFlagsStringMapping && symbol == type_.symbol:
			return type_
		case type_.flags&(TypeFlagsAny|TypeFlagsString|TypeFlagsStringMapping) || isGenericIndexType(type_):
			return getStringMappingTypeForGenericType(symbol, type_)
		case isPatternLiteralPlaceholderType(type_):
			return getStringMappingTypeForGenericType(symbol, getTemplateLiteralType([] /* TODO inferred type string */ any{"", ""}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_}))
		default:
			return type_
		}
	}
	applyStringMapping := func(symbol Symbol, str string) /* TODO inferred type string */ any {
		switch intrinsicTypeKinds.get(symbol.escapedName) {
		case IntrinsicTypeKindUppercase:
			return str.toUpperCase()
		case IntrinsicTypeKindLowercase:
			return str.toLowerCase()
		case IntrinsicTypeKindCapitalize:
			return str.charAt(0).toUpperCase() + str.slice(1)
		case IntrinsicTypeKindUncapitalize:
			return str.charAt(0).toLowerCase() + str.slice(1)
		}
		return str
	}
	applyTemplateStringMapping := func(symbol Symbol, texts []string, types []Type) /* TODO(TypeNode TupleType): [texts: readonly string[], types: readonly Type[]] */ any {
		switch intrinsicTypeKinds.get(symbol.escapedName) {
		case IntrinsicTypeKindUppercase:
			return []TODO{texts.map_(func(t /* TODO inferred type string */ any) /* TODO inferred type string */ any {
				return t.toUpperCase()
			}), types.map_(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getStringMappingType(symbol, t)
			})}
		case IntrinsicTypeKindLowercase:
			return []TODO{texts.map_(func(t /* TODO inferred type string */ any) /* TODO inferred type string */ any {
				return t.toLowerCase()
			}), types.map_(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getStringMappingType(symbol, t)
			})}
		case IntrinsicTypeKindCapitalize:
			return []TODO{ /* TODO(Node ConditionalExpression): texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)] */ TODO /* TODO(Node ConditionalExpression): texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types */, TODO}
		case IntrinsicTypeKindUncapitalize:
			return []TODO{ /* TODO(Node ConditionalExpression): texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)] */ TODO /* TODO(Node ConditionalExpression): texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types */, TODO}
		}
		return []TODO{texts, types}
	}
	getStringMappingTypeForGenericType := func(symbol Symbol, type_ Type) Type {
		id := /* TODO(Node TemplateExpression): `${getSymbolId(symbol)},${getTypeId(type)}` */ TODO
		result := stringMappingTypes.get(id)
		if !result {
			stringMappingTypes.set(id /* TODO(Node BinaryExpression): result = createStringMappingType(symbol, type) */, TODO)
		}
		return result
	}
	createStringMappingType := func(symbol Symbol, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ any {
		result := createTypeWithSymbol(TypeFlagsStringMapping, symbol)
		result.type_ = type_
		return result
	}
	createIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol *Symbol, aliasTypeArguments *[]Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexedAccessType */ any {
		type_ := createType(TypeFlagsIndexedAccess)
		type_.objectType = objectType
		type_.indexType = indexType
		type_.accessFlags = accessFlags
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	isJSLiteralType := func(type_ Type) bool {
		if noImplicitAny {
			return false
		}
		if getObjectFlags(type_) & ObjectFlagsJSLiteral {
			return true
		}
		if type_.flags & TypeFlagsUnion {
			return every((type_).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getResolvedBaseConstraint(type_)
			return constraint != type_ && isJSLiteralType(constraint)
		}
		return false
	}
	getPropertyNameFromIndex := func(indexType Type, accessNode /* TODO(TypeNode UnionType): PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		// converted from conditional expression
		switch {
		case isTypeUsableAsPropertyName(indexType):
			return getPropertyNameFromType(indexType)
		case accessNode && isPropertyName(accessNode):
			return getPropertyNameForPropertyNameNode(accessNode)
		default:
			return nil
		}
	}
	isUncalledFunctionReference := func(node Node, symbol Symbol) /* TODO inferred type boolean */ any {
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			parent := findAncestor(node.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
				return !isAccessExpression(n)
			}) || node.parent
			if isCallLikeExpression(parent) {
				return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node)
			}
			return every(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
				return !isFunctionLike(d) || isDeprecatedDeclaration(d)
			})
		}
		return true
	}
	getPropertyTypeForIndexType := func(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(TypeNode UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		accessExpression := /* TODO(Node ConditionalExpression): accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined */ TODO
		propName := /* TODO(Node ConditionalExpression): accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode) */ TODO
		if propName != nil {
			if accessFlags & AccessFlagsContextual {
				return getTypeOfPropertyOfContextualType(objectType, propName) || anyType
			}
			prop := getPropertyOfType(objectType, propName)
			if prop {
				if accessFlags&AccessFlagsReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop) {
					deprecatedNode := /* TODO(Node BinaryExpression): accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
					addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName)
				}
				if accessExpression {
					markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol))
					if isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
						error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop))
						return nil
					}
					if accessFlags & AccessFlagsCacheSymbol {
						getNodeLinks(accessNode).resolvedSymbol = prop
					}
					if isThisPropertyAccessInConstructor(accessExpression, prop) {
						return autoType
					}
				}
				propType := /* TODO(Node ConditionalExpression): accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
				// converted from conditional expression
				switch {
				case accessExpression && getAssignmentTargetKind(accessExpression) != AssignmentKindDefinite:
					return getFlowTypeOfReference(accessExpression, propType)
				case accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType):
					return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{propType, undefinedType})
				default:
					return propType
				}
			}
			if everyType(objectType, isTupleType) && isNumericLiteralName(propName) {
				index := +propName
				if accessNode && everyType(objectType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !((t).target.combinedFlags & ElementFlagsVariable)
				}) && !(accessFlags & AccessFlagsAllowMissing) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					if isTupleType(objectType) {
						if index < 0 {
							error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value)
							return undefinedType
						}
						error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName))
					} else {
						error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
					}
				}
				if index >= 0 {
					errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType))
					return getTupleElementTypeOutOfStartCount(objectType, index /* TODO(Node ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined */, TODO)
				}
			}
		}
		if !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) {
			if objectType.flags & (TypeFlagsAny | TypeFlagsNever) {
				return objectType
			}
			indexInfo := getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType)
			if indexInfo {
				if accessFlags&AccessFlagsNoIndexSignatures && indexInfo.keyType != numberType {
					if accessExpression {
						if accessFlags & AccessFlagsWriting {
							error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType))
						} else {
							error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType))
						}
					}
					return nil
				}
				if accessNode && indexInfo.keyType == stringType && !isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType))
					// converted from conditional expression
					switch {
					case accessFlags & AccessFlagsIncludeUndefined:
						return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{indexInfo.type_, missingType})
					default:
						return indexInfo.type_
					}
				}
				errorIfWritingToReadonlyIndex(indexInfo)
				if (accessFlags & AccessFlagsIncludeUndefined) && !(objectType.symbol && objectType.symbol.flags&(SymbolFlagsRegularEnum|SymbolFlagsConstEnum) && (indexType.symbol && indexType.flags&TypeFlagsEnumLiteral && getParentOfSymbol(indexType.symbol) == objectType.symbol)) {
					return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{indexInfo.type_, missingType})
				}
				return indexInfo.type_
			}
			if indexType.flags & TypeFlagsNever {
				return neverType
			}
			if isJSLiteralType(objectType) {
				return anyType
			}
			if accessExpression && !isConstEnumObjectType(objectType) {
				if isObjectLiteralType(objectType) {
					if noImplicitAny && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
						diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType).value, typeToString(objectType)))
						return undefinedType
					} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
						types := map_((objectType).properties, func(property /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
							return getTypeOfSymbol(property)
						})
						return getUnionType(append(types, undefinedType))
					}
				}
				if objectType.symbol == globalThisSymbol && propName != nil && globalThisSymbol.exports.has(propName) && (globalThisSymbol.exports.get(propName).flags & SymbolFlagsBlockScoped) {
					error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
				} else if noImplicitAny && !(accessFlags & AccessFlagsSuppressNoImplicitAnyError) {
					if propName != nil && typeHasStaticProperty(propName, objectType) {
						typeName := typeToString(objectType)
						error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName+"["+getTextOfNode(accessExpression.argumentExpression)+"]")
					} else if getIndexTypeOfType(objectType, numberType) {
						error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number)
					} else {
						var suggestion *string
						if propName != nil && ( /* TODO(Node BinaryExpression): suggestion = getSuggestionForNonexistentProperty(propName as string, objectType) */ TODO) {
							if suggestion != nil {
								error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion)
							}
						} else {
							suggestion := getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
							if suggestion != nil {
								error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion)
							} else {
								var errorInfo *DiagnosticMessageChain
								if indexType.flags & TypeFlagsEnumLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, "["+typeToString(indexType)+"]", typeToString(objectType))
								} else if indexType.flags & TypeFlagsUniqueESSymbol {
									symbolName := getFullyQualifiedName((indexType).symbol, accessExpression)
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, "["+symbolName+"]", typeToString(objectType))
								} else if indexType.flags & TypeFlagsStringLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType).value, typeToString(objectType))
								} else if indexType.flags & TypeFlagsNumberLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType).value, typeToString(objectType))
								} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType))
								}
								errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType))
								diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo))
							}
						}
					}
				}
				return nil
			}
		}
		if accessFlags&AccessFlagsAllowMissing && isObjectLiteralType(objectType) {
			return undefinedType
		}
		if isJSLiteralType(objectType) {
			return anyType
		}
		if accessNode {
			indexNode := getIndexNodeForAccessExpression(accessNode)
			if indexNode.kind != SyntaxKindBigIntLiteral && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
				error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, ""+(indexType).value, typeToString(objectType))
			} else if indexType.flags & (TypeFlagsString | TypeFlagsNumber) {
				error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType))
			} else {
				typeString := /* TODO(Node ConditionalExpression): indexNode.kind === SyntaxKind.BigIntLiteral ? "bigint" : typeToString(indexType) */ TODO
				error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString)
			}
		}
		if isTypeAny(indexType) {
			return indexType
		}
		return nil
		errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
			if indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) {
				error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
		}
	}
	getIndexNodeForAccessExpression := func(accessNode /* TODO(TypeNode UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrayBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any {
		// converted from conditional expression
		switch {
		case accessNode.kind == SyntaxKindElementAccessExpression:
			return accessNode.argumentExpression
		case accessNode.kind == SyntaxKindIndexedAccessType:
			return accessNode.indexType
		case accessNode.kind == SyntaxKindComputedPropertyName:
			return accessNode.expression
		default:
			return accessNode
		}
	}
	isPatternLiteralPlaceholderType := func(type_ Type) bool {
		if type_.flags & TypeFlagsIntersection {
			seenPlaceholder := false
			for _, t := range (type_).types {
				if t.flags&(TypeFlagsLiteral|TypeFlagsNullable) || isPatternLiteralPlaceholderType(t) {
					seenPlaceholder = true
				} else if !(t.flags & TypeFlagsObject) {
					return false
				}
			}
			return seenPlaceholder
		}
		return !!(type_.flags & (TypeFlagsAny | TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) || isPatternLiteralType(type_)
	}
	isPatternLiteralType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags&TypeFlagsTemplateLiteral) && every((type_).types, isPatternLiteralPlaceholderType) || !!(type_.flags&TypeFlagsStringMapping) && isPatternLiteralPlaceholderType((type_).type_)
	}
	isGenericStringLikeType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) && !isPatternLiteralType(type_)
	}
	isGenericType := func(type_ Type) bool {
		return !!getGenericObjectFlags(type_)
	}
	isGenericObjectType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericObjectType)
	}
	isGenericIndexType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericIndexType)
	}
	getGenericObjectFlags := func(type_ Type) ObjectFlags {
		if type_.flags & (TypeFlagsUnionOrIntersection) {
			if !((type_).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_).objectFlags |= ObjectFlagsIsGenericTypeComputed | reduceLeft((type_).types, func(flags /* TODO inferred type number */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
					return flags | getGenericObjectFlags(t)
				}, 0)
			}
			return (type_).objectFlags & ObjectFlagsIsGenericType
		}
		if type_.flags & TypeFlagsSubstitution {
			if !((type_).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_).objectFlags |= ObjectFlagsIsGenericTypeComputed | getGenericObjectFlags((type_).baseType) | getGenericObjectFlags((type_).constraint)
			}
			return (type_).objectFlags & ObjectFlagsIsGenericType
		}
		return ( /* TODO(Node ConditionalExpression): type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0 */ TODO)
	}
	getSimplifiedType := func(type_ Type, writing bool) Type {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIndexedAccess:
			return getSimplifiedIndexedAccessType(type_, writing)
		case type_.flags & TypeFlagsConditional:
			return getSimplifiedConditionalType(type_, writing)
		default:
			return type_
		}
	}
	distributeIndexOverObjectType := func(objectType Type, indexType Type, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if objectType.flags&TypeFlagsUnion || objectType.flags&TypeFlagsIntersection && !shouldDeferIndexType(objectType) {
			types := map_((objectType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getSimplifiedType(getIndexedAccessType(t, indexType), writing)
			})
			// converted from conditional expression
			switch {
			case objectType.flags&TypeFlagsIntersection || writing:
				return getIntersectionType(types)
			default:
				return getUnionType(types)
			}
		}
	}
	distributeObjectOverIndexType := func(objectType Type, indexType Type, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if indexType.flags & TypeFlagsUnion {
			types := map_((indexType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getSimplifiedType(getIndexedAccessType(objectType, t), writing)
			})
			// converted from conditional expression
			switch {
			case writing:
				return getIntersectionType(types)
			default:
				return getUnionType(types)
			}
		}
	}
	getSimplifiedIndexedAccessType := func(type_ IndexedAccessType, writing bool) Type {
		cache := /* TODO(Node ConditionalExpression): writing ? "simplifiedForWriting" : "simplifiedForReading" */ TODO
		if type_[cache] {
			// converted from conditional expression
			switch {
			case type_[cache] == circularConstraintType:
				return type_
			default:
				return type_[cache]
			}
		}
		type_[cache] = circularConstraintType
		objectType := getSimplifiedType(type_.objectType, writing)
		indexType := getSimplifiedType(type_.indexType, writing)
		distributedOverIndex := distributeObjectOverIndexType(objectType, indexType, writing)
		if distributedOverIndex {
			type_[cache] = distributedOverIndex
			return type_[cache]
		}
		if !(indexType.flags & TypeFlagsInstantiable) {
			distributedOverObject := distributeIndexOverObjectType(objectType, indexType, writing)
			if distributedOverObject {
				type_[cache] = distributedOverObject
				return type_[cache]
			}
		}
		if isGenericTupleType(objectType) && indexType.flags&TypeFlagsNumberLike {
			elementType := getElementTypeOfSliceOfTupleType(objectType /* TODO(Node ConditionalExpression): indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength */, TODO, 0, writing)
			if elementType {
				type_[cache] = elementType
				return type_[cache]
			}
		}
		if isGenericMappedType(objectType) {
			if getMappedTypeNameTypeKind(objectType) != MappedTypeNameTypeKindRemapping {
				type_[cache] = mapType(substituteIndexedMappedType(objectType, type_.indexType), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getSimplifiedType(t, writing)
				})
				return type_[cache]
			}
		}
		type_[cache] = type_
		return type_[cache]
	}
	getSimplifiedConditionalType := func(type_ ConditionalType, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		checkType := type_.checkType
		extendsType := type_.extendsType
		trueType := getTrueTypeFromConditionalType(type_)
		falseType := getFalseTypeFromConditionalType(type_)
		if falseType.flags&TypeFlagsNever && getActualTypeVariable(trueType) == getActualTypeVariable(checkType) {
			if checkType.flags&TypeFlagsAny || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return getSimplifiedType(trueType, writing)
			} else if isIntersectionEmpty(checkType, extendsType) {
				return neverType
			}
		} else if trueType.flags&TypeFlagsNever && getActualTypeVariable(falseType) == getActualTypeVariable(checkType) {
			if !(checkType.flags & TypeFlagsAny) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return neverType
			} else if checkType.flags&TypeFlagsAny || isIntersectionEmpty(checkType, extendsType) {
				return getSimplifiedType(falseType, writing)
			}
		}
		return type_
	}
	isIntersectionEmpty := func(type1 Type, type2 Type) /* TODO inferred type boolean */ any {
		return !!(getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{intersectTypes(type1, type2), neverType}).flags & TypeFlagsNever)
	}
	substituteIndexedMappedType := func(objectType MappedType, index Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		mapper := createTypeMapper([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{getTypeParameterFromMappedType(objectType)}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{index})
		templateMapper := combineTypeMappers(objectType.mapper, mapper)
		instantiatedTemplateType := instantiateType(getTemplateTypeFromMappedType(objectType.target || objectType), templateMapper)
		isOptional := getMappedTypeOptionality(objectType) > 0 || ( /* TODO(Node ConditionalExpression): isGenericType(objectType) ? getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 : couldAccessOptionalProperty(objectType, index) */ TODO)
		return addOptionality(instantiatedTemplateType, true, isOptional)
	}
	couldAccessOptionalProperty := func(objectType Type, indexType Type) /* TODO inferred type boolean */ any {
		indexConstraint := getBaseConstraintOfType(indexType)
		return !!indexConstraint && some(getPropertiesOfType(objectType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return !!(p.flags & SymbolFlagsOptional) && isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlagsStringOrNumberLiteralOrUnique), indexConstraint)
		})
	}
	getIndexedAccessType := func(objectType Type, indexType Type, accessFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ any /*  = AccessFlags.None */, accessNode /* TODO(TypeNode UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || ( /* TODO(Node ConditionalExpression): accessNode ? errorType : unknownType */ TODO)
	}
	indexTypeLessThan := func(indexType Type, limit number) /* TODO inferred type boolean */ any {
		return everyType(indexType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			if t.flags & TypeFlagsStringOrNumberLiteral {
				propName := getPropertyNameFromType(t)
				if isNumericLiteralName(propName) {
					index := +propName
					return index >= 0 && index < limit
				}
			}
			return false
		})
	}
	getIndexedAccessTypeOrUndefined := func(objectType Type, indexType Type, accessFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ any /*  = AccessFlags.None */, accessNode /* TODO(TypeNode UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) *Type {
		if objectType == wildcardType || indexType == wildcardType {
			return wildcardType
		}
		objectType = getReducedType(objectType)
		if isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
			indexType = stringType
		}
		if compilerOptions.noUncheckedIndexedAccess && accessFlags&AccessFlagsExpressionPosition {
			accessFlags |= AccessFlagsIncludeUndefined
		}
		if isGenericIndexType(indexType) || ( /* TODO(Node ConditionalExpression): accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ? isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)) : isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType) */ TODO) {
			if objectType.flags & TypeFlagsAnyOrUnknown {
				return objectType
			}
			persistentAccessFlags := accessFlags & AccessFlagsPersistent
			id := objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments)
			type_ := indexedAccessTypes.get(id)
			if !type_ {
				indexedAccessTypes.set(id /* TODO(Node BinaryExpression): type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments) */, TODO)
			}
			return type_
		}
		apparentObjectType := getReducedApparentType(objectType)
		if indexType.flags&TypeFlagsUnion && !(indexType.flags & TypeFlagsBoolean) {
			var propTypes []Type = [] /* TODO inferred type never */ any{}
			wasMissingProp := false
			for _, t := range (indexType).types {
				propType := getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags|( /* TODO(Node ConditionalExpression): wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0 */ TODO))
				if propType {
					propTypes.push(propType)
				} else if !accessNode {
					return nil
				} else {
					wasMissingProp = true
				}
			}
			if wasMissingProp {
				return nil
			}
			// converted from conditional expression
			switch {
			case accessFlags & AccessFlagsWriting:
				return getIntersectionType(propTypes, IntersectionFlagsNone, aliasSymbol, aliasTypeArguments)
			default:
				return getUnionType(propTypes, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
			}
		}
		return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags|AccessFlagsCacheSymbol|AccessFlagsReportDeprecated)
	}
	getTypeFromIndexedAccessTypeNode := func(node IndexedAccessTypeNode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		links := getNodeLinks(node)
		if !links.resolvedType {
			objectType := getTypeFromTypeNode(node.objectType)
			indexType := getTypeFromTypeNode(node.indexType)
			potentialAlias := getAliasSymbolForTypeNode(node)
			links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlagsNone, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias))
		}
		return links.resolvedType
	}
	getTypeFromMappedTypeNode := func(node MappedTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := createObjectType(ObjectFlagsMapped, node.symbol)
			type_.declaration = node
			type_.aliasSymbol = getAliasSymbolForTypeNode(node)
			type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type_.aliasSymbol)
			links.resolvedType = type_
			getConstraintTypeFromMappedType(type_)
		}
		return links.resolvedType
	}
	getActualTypeVariable := func(type_ Type) Type {
		if type_.flags & TypeFlagsSubstitution {
			return getActualTypeVariable((type_).baseType)
		}
		if type_.flags&TypeFlagsIndexedAccess && ((type_).objectType.flags&TypeFlagsSubstitution || (type_).indexType.flags&TypeFlagsSubstitution) {
			return getIndexedAccessType(getActualTypeVariable((type_).objectType), getActualTypeVariable((type_).indexType))
		}
		return type_
	}
	isSimpleTupleType := func(node TypeNode) bool {
		return isTupleTypeNode(node) && length(node.elements) > 0 && !some(node.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember */ any) /* TODO inferred type boolean */ any {
			return isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken)
		})
	}
	isDeferredType := func(type_ Type, checkTuples bool) /* TODO inferred type boolean */ any {
		return isGenericType(type_) || checkTuples && isTupleType(type_) && some(getElementTypes(type_), isGenericType)
	}
	getConditionalType := func(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		var result TODO
		var extraTypes *[]Type
		tailCount := 0
		for true {
			if tailCount == 1000 {
				error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
				return errorType
			}
			checkType := instantiateType(getActualTypeVariable(root.checkType), mapper)
			extendsType := instantiateType(root.extendsType, mapper)
			if checkType == errorType || extendsType == errorType {
				return errorType
			}
			if checkType == wildcardType || extendsType == wildcardType {
				return wildcardType
			}
			checkTypeNode := skipTypeParentheses(root.node.checkType)
			extendsTypeNode := skipTypeParentheses(root.node.extendsType)
			checkTuples := isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) && length((checkTypeNode).elements) == length((extendsTypeNode).elements)
			checkTypeDeferred := isDeferredType(checkType, checkTuples)
			var combinedMapper *TypeMapper
			if root.inferTypeParameters {
				context := createInferenceContext(root.inferTypeParameters, nil, InferenceFlagsNone)
				if mapper {
					context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper)
				}
				if !checkTypeDeferred {
					inferTypes(context.inferences, checkType, extendsType, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
				}
				combinedMapper = /* TODO(Node ConditionalExpression): mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper */ TODO
			}
			inferredExtendsType := /* TODO(Node ConditionalExpression): combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType */ TODO
			if !checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples) {
				if !(inferredExtendsType.flags & TypeFlagsAnyOrUnknown) && (checkType.flags&TypeFlagsAny || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType))) {
					if checkType.flags&TypeFlagsAny || forConstraint && !(inferredExtendsType.flags&TypeFlagsNever) && someType(getPermissiveInstantiation(inferredExtendsType), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return isTypeAssignableTo(t, getPermissiveInstantiation(checkType))
					}) {
						(extraTypes || ( /* TODO(Node BinaryExpression): extraTypes = [] */ TODO)).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper))
					}
					falseType := getTypeFromTypeNode(root.node.falseType)
					if falseType.flags & TypeFlagsConditional {
						newRoot := (falseType).root
						if newRoot.node.parent == root.node && (!newRoot.isDistributive || newRoot.checkType == root.checkType) {
							root = newRoot
							continue
						}
						if canTailRecurse(falseType, mapper) {
							continue
						}
					}
					result = instantiateType(falseType, mapper)
					break
				}
				if inferredExtendsType.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType)) {
					trueType := getTypeFromTypeNode(root.node.trueType)
					trueMapper := combinedMapper || mapper
					if canTailRecurse(trueType, trueMapper) {
						continue
					}
					result = instantiateType(trueType, trueMapper)
					break
				}
			}
			result = createType(TypeFlagsConditional)
			result.root = root
			result.checkType = instantiateType(root.checkType, mapper)
			result.extendsType = instantiateType(root.extendsType, mapper)
			result.mapper = mapper
			result.combinedMapper = combinedMapper
			result.aliasSymbol = aliasSymbol || root.aliasSymbol
			result.aliasTypeArguments = /* TODO(Node ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!) */ TODO
			break
		}
		// converted from conditional expression
		switch {
		case extraTypes:
			return getUnionType(append(extraTypes, result))
		default:
			return result
		}
		canTailRecurse := func(newType Type, newMapper *TypeMapper) /* TODO inferred type boolean */ any {
			if newType.flags&TypeFlagsConditional && newMapper {
				newRoot := (newType).root
				if newRoot.outerTypeParameters {
					typeParamMapper := combineTypeMappers((newType).mapper, newMapper)
					typeArguments := map_(newRoot.outerTypeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return getMappedType(t, typeParamMapper)
					})
					newRootMapper := createTypeMapper(newRoot.outerTypeParameters, typeArguments)
					newCheckType := /* TODO(Node ConditionalExpression): newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined */ TODO
					if !newCheckType || newCheckType == newRoot.checkType || !(newCheckType.flags & (TypeFlagsUnion | TypeFlagsNever)) {
						root = newRoot
						mapper = newRootMapper
						aliasSymbol = nil
						aliasTypeArguments = nil
						if newRoot.aliasSymbol {
							tailCount++
						}
						return true
					}
				}
			}
			return false
		}
	}
	getTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return type_.resolvedTrueType || ( /* TODO(Node BinaryExpression): type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper) */ TODO)
	}
	getFalseTypeFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return type_.resolvedFalseType || ( /* TODO(Node BinaryExpression): type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper) */ TODO)
	}
	getInferredTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return type_.resolvedInferredTrueType || ( /* TODO(Node BinaryExpression): type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type) */ TODO)
	}
	getInferTypeParameters := func(node ConditionalTypeNode) *[]TypeParameter {
		var result *[]TypeParameter
		if node.locals {
			node.locals.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
				if symbol.flags & SymbolFlagsTypeParameter {
					result = append(result, getDeclaredTypeOfSymbol(symbol))
				}
			})
		}
		return result
	}
	isDistributionDependent := func(root ConditionalRoot) /* TODO inferred type boolean */ any {
		return root.isDistributive && (isTypeParameterPossiblyReferenced(root.checkType, root.node.trueType) || isTypeParameterPossiblyReferenced(root.checkType, root.node.falseType))
	}
	getTypeFromConditionalTypeNode := func(node ConditionalTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			checkType := getTypeFromTypeNode(node.checkType)
			aliasSymbol := getAliasSymbolForTypeNode(node)
			aliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			allOuterTypeParameters := getOuterTypeParameters(node, true)
			outerTypeParameters := /* TODO(Node ConditionalExpression): aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node)) */ TODO
			var root ConditionalRoot = /* TODO(Node ObjectLiteralExpression): { node, checkType, extendsType: getTypeFromTypeNode(node.extendsType), isDistributive: !!(checkType.flags & TypeFlags.TypeParameter), inferTypeParameters: getInferTypeParameters(node), outerTypeParameters, instantiations: undefined, aliasSymbol, aliasTypeArguments, } */ TODO
			links.resolvedType = getConditionalType(root, nil, false)
			if outerTypeParameters {
				root.instantiations = make(map[string]Type)
				root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType)
			}
		}
		return links.resolvedType
	}
	getTypeFromInferTypeNode := func(node InferTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))
		}
		return links.resolvedType
	}
	getIdentifierChain := func(node EntityName) []Identifier {
		if isIdentifier(node) {
			return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier */ any{node}
		} else {
			return append(getIdentifierChain(node.left), node.right)
		}
	}
	getTypeFromImportTypeNode := func(node ImportTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if !isLiteralImportTypeNode(node) {
				error(node.argument, Diagnostics.String_literal_expected)
				links.resolvedSymbol = unknownSymbol
				links.resolvedType = errorType
				return links.resolvedType
			}
			targetMeaning := /* TODO(Node ConditionalExpression): node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type */ TODO
			innerModuleSymbol := resolveExternalModuleName(node, node.argument.literal)
			if !innerModuleSymbol {
				links.resolvedSymbol = unknownSymbol
				links.resolvedType = errorType
				return links.resolvedType
			}
			isExportEquals := !!innerModuleSymbol.exports. /*?*/ get(InternalSymbolNameExportEquals)
			moduleSymbol := resolveExternalModuleSymbol(innerModuleSymbol, false)
			if !nodeIsMissing(node.qualifier) {
				var nameStack []Identifier = getIdentifierChain(node.qualifier)
				currentNamespace := moduleSymbol
				var current *Identifier
				for /* TODO(Node BinaryExpression): current = nameStack.shift() */ TODO {
					meaning := /* TODO(Node ConditionalExpression): nameStack.length ? SymbolFlags.Namespace : targetMeaning */ TODO
					mergedResolvedSymbol := getMergedSymbol(resolveSymbol(currentNamespace))
					symbolFromVariable := /* TODO(Node ConditionalExpression): node.isTypeOf || isInJSFile(node) && isExportEquals ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment* / false, /*includeTypeOnlyMembers* / true) : undefined */ TODO
					symbolFromModule := /* TODO(Node ConditionalExpression): node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning) */ TODO
					next := /* TODO(Node BinaryExpression): symbolFromModule ?? symbolFromVariable */ TODO
					if !next {
						error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current))
						links.resolvedType = errorType
						return links.resolvedType
					}
					getNodeLinks(current).resolvedSymbol = next
					getNodeLinks(current.parent).resolvedSymbol = next
					currentNamespace = next
				}
				links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning)
			} else {
				if moduleSymbol.flags & targetMeaning {
					links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning)
				} else {
					errorMessage := /* TODO(Node ConditionalExpression): targetMeaning === SymbolFlags.Value ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 */ TODO
					error(node, errorMessage, node.argument.literal.text)
					links.resolvedSymbol = unknownSymbol
					links.resolvedType = errorType
				}
			}
		}
		return links.resolvedType
	}
	resolveImportSymbolType := func(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		resolvedSymbol := resolveSymbol(symbol)
		links.resolvedSymbol = resolvedSymbol
		if meaning == SymbolFlagsValue {
			return getInstantiationExpressionType(getTypeOfSymbol(symbol), node)
		} else {
			return getTypeReferenceType(node, resolvedSymbol)
		}
	}
	getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode := func(node /* TODO(TypeNode UnionType): TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			if getMembersOfSymbol(node.symbol).size == 0 && !aliasSymbol {
				links.resolvedType = emptyTypeLiteralType
			} else {
				type_ := createObjectType(ObjectFlagsAnonymous, node.symbol)
				type_.aliasSymbol = aliasSymbol
				type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol)
				if isJSDocTypeLiteral(node) && node.isArrayType {
					type_ = createArrayType(type_)
				}
				links.resolvedType = type_
			}
		}
		return links.resolvedType
	}
	getAliasSymbolForTypeNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		host := node.parent
		for isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator == SyntaxKindReadonlyKeyword {
			host = host.parent
		}
		// converted from conditional expression
		switch {
		case isTypeAlias(host):
			return getSymbolOfDeclaration(host)
		default:
			return nil
		}
	}
	getTypeArgumentsForAliasSymbol := func(symbol *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ any {
		// converted from conditional expression
		switch {
		case symbol:
			return getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
		default:
			return nil
		}
	}
	isNonGenericObjectType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags & TypeFlagsObject) && !isGenericMappedType(type_)
	}
	isEmptyObjectTypeOrSpreadsIntoEmptyObject := func(type_ Type) /* TODO inferred type boolean */ any {
		return isEmptyObjectType(type_) || !!(type_.flags & (TypeFlagsNull | TypeFlagsUndefined | TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex))
	}
	tryMergeUnionOfObjectTypeAndEmptyObject := func(type_ Type, readonly bool) Type {
		if !(type_.flags & TypeFlagsUnion) {
			return type_
		}
		if every((type_).types, isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
			return find((type_).types, isEmptyObjectType) || emptyObjectType
		}
		firstType := find((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
		})
		if !firstType {
			return type_
		}
		secondType := find((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return t != firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
		})
		if secondType {
			return type_
		}
		return getAnonymousPartialType(firstType)
		getAnonymousPartialType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ any {
			members := createSymbolTable()
			for _, prop := range getPropertiesOfType(type_) {
				if getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				} else if isSpreadableProperty(prop) {
					isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
					flags := SymbolFlagsProperty | SymbolFlagsOptional
					result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|( /* TODO(Node ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO))
					result.links.type_ = /* TODO(Node ConditionalExpression): isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty* / true) */ TODO
					result.declarations = prop.declarations
					result.links.nameType = getSymbolLinks(prop).nameType
					result.links.syntheticOrigin = prop
					members.set(prop.escapedName, result)
				}
			}
			spread := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
			spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return spread
		}
	}
	getSpreadType := func(left Type, right Type, symbol *Symbol, objectFlags ObjectFlags, readonly bool) Type {
		if left.flags&TypeFlagsAny || right.flags&TypeFlagsAny {
			return anyType
		}
		if left.flags&TypeFlagsUnknown || right.flags&TypeFlagsUnknown {
			return unknownType
		}
		if left.flags & TypeFlagsNever {
			return right
		}
		if right.flags & TypeFlagsNever {
			return left
		}
		left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly)
		if left.flags & TypeFlagsUnion {
			// converted from conditional expression
			switch {
			case checkCrossProductUnion([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{left, right}):
				return mapType(left, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getSpreadType(t, right, symbol, objectFlags, readonly)
				})
			default:
				return errorType
			}
		}
		right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly)
		if right.flags & TypeFlagsUnion {
			// converted from conditional expression
			switch {
			case checkCrossProductUnion([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{left, right}):
				return mapType(right, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getSpreadType(left, t, symbol, objectFlags, readonly)
				})
			default:
				return errorType
			}
		}
		if right.flags & (TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex) {
			return left
		}
		if isGenericObjectType(left) || isGenericObjectType(right) {
			if isEmptyObjectType(left) {
				return right
			}
			if left.flags & TypeFlagsIntersection {
				types := (left).types
				lastLeft := types[types.length-1]
				if isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right) {
					return getIntersectionType(concatenate(types.slice(0, types.length-1), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getSpreadType(lastLeft, right, symbol, objectFlags, readonly)}))
				}
			}
			return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{left, right})
		}
		members := createSymbolTable()
		skippedPrivateMembers := make(map[__String]struct{})
		indexInfos := /* TODO(Node ConditionalExpression): left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]) */ TODO
		for _, rightProp := range getPropertiesOfType(right) {
			if getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				skippedPrivateMembers.add(rightProp.escapedName)
			} else if isSpreadableProperty(rightProp) {
				members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly))
			}
		}
		for _, leftProp := range getPropertiesOfType(left) {
			if skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp) {
				continue
			}
			if members.has(leftProp.escapedName) {
				rightProp := members.get(leftProp.escapedName)
				rightType := getTypeOfSymbol(rightProp)
				if rightProp.flags & SymbolFlagsOptional {
					declarations := concatenate(leftProp.declarations, rightProp.declarations)
					flags := SymbolFlagsProperty | (leftProp.flags & SymbolFlagsOptional)
					result := createSymbol(flags, leftProp.escapedName)
					leftType := getTypeOfSymbol(leftProp)
					leftTypeWithoutUndefined := removeMissingOrUndefinedType(leftType)
					rightTypeWithoutUndefined := removeMissingOrUndefinedType(rightType)
					result.links.type_ = /* TODO(Node ConditionalExpression): leftTypeWithoutUndefined === rightTypeWithoutUndefined ? leftType : getUnionType([leftType, rightTypeWithoutUndefined], UnionReduction.Subtype) */ TODO
					result.links.leftSpread = leftProp
					result.links.rightSpread = rightProp
					result.declarations = declarations
					result.links.nameType = getSymbolLinks(leftProp).nameType
					members.set(leftProp.escapedName, result)
				}
			} else {
				members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly))
			}
		}
		spread := createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any {
			return getIndexInfoWithReadonly(info, readonly)
		}))
		spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral | ObjectFlagsContainsSpread | objectFlags
		return spread
	}
	isSpreadableProperty := func(prop Symbol) bool {
		return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) && (!(prop.flags & (SymbolFlagsMethod | SymbolFlagsGetAccessor | SymbolFlagsSetAccessor)) || !prop.declarations. /*?*/ some(func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
			return isClassLike(decl.parent)
		}))
	}
	getSpreadSymbol := func(prop Symbol, readonly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
		if !isSetonlyAccessor && readonly == isReadonlySymbol(prop) {
			return prop
		}
		flags := SymbolFlagsProperty | (prop.flags & SymbolFlagsOptional)
		result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|( /* TODO(Node ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO))
		result.links.type_ = /* TODO(Node ConditionalExpression): isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop) */ TODO
		result.declarations = prop.declarations
		result.links.nameType = getSymbolLinks(prop).nameType
		result.links.syntheticOrigin = prop
		return result
	}
	getIndexInfoWithReadonly := func(info IndexInfo, readonly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any {
		// converted from conditional expression
		switch {
		case info.isReadonly != readonly:
			return createIndexInfo(info.keyType, info.type_, readonly, info.declaration)
		default:
			return info
		}
	}
	createLiteralType := func(flags TypeFlags, value /* TODO(TypeNode UnionType): string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType */ any {
		type_ := createTypeWithSymbol(flags, symbol)
		type_.value = value
		type_.regularType = regularType || type_
		return type_
	}
	getFreshTypeOfLiteralType := func(type_ Type) Type {
		if type_.flags & TypeFlagsFreshable {
			if !(type_).freshType {
				freshType := createLiteralType(type_.flags, (type_).value, (type_).symbol, type_)
				freshType.freshType = freshType
				(type_).freshType = freshType
			}
			return (type_).freshType
		}
		return type_
	}
	getRegularTypeOfLiteralType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsFreshable:
			return (type_).regularType
		case type_.flags & TypeFlagsUnion:
			return ((type_).regularType || ( /* TODO(Node BinaryExpression): (type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType */ TODO))
		default:
			return type_
		}
	}
	isFreshLiteralType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.flags & TypeFlagsFreshable) && (type_).freshType == type_
	}
	getStringLiteralType := func(value string) StringLiteralType {
		var type_ TODO
		return stringLiteralTypes.get(value) || ( /* TODO(Node BinaryExpression): stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type */ TODO)
	}
	getNumberLiteralType := func(value number) NumberLiteralType {
		var type_ TODO
		return numberLiteralTypes.get(value) || ( /* TODO(Node BinaryExpression): numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type */ TODO)
	}
	getBigIntLiteralType := func(value PseudoBigInt) BigIntLiteralType {
		var type_ TODO
		key := pseudoBigIntToString(value)
		return bigIntLiteralTypes.get(key) || ( /* TODO(Node BinaryExpression): bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type */ TODO)
	}
	getEnumLiteralType := func(value /* TODO(TypeNode UnionType): string | number */ any, enumId number, symbol Symbol) LiteralType {
		var type_ TODO
		key := /* TODO(Node TemplateExpression): `${enumId}${typeof value === "string" ? "@" : "#"}${value}` */ TODO
		flags := TypeFlagsEnumLiteral | ( /* TODO(Node ConditionalExpression): typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral */ TODO)
		return enumLiteralTypes.get(key) || ( /* TODO(Node BinaryExpression): enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type */ TODO)
	}
	getTypeFromLiteralTypeNode := func(node LiteralTypeNode) Type {
		if node.literal.kind == SyntaxKindNullKeyword {
			return nullType
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal))
		}
		return links.resolvedType
	}
	createUniqueESSymbolType := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").UniqueESSymbolType */ any {
		type_ := createTypeWithSymbol(TypeFlagsUniqueESSymbol, symbol)
		type_.escapedName = /* TODO(Node TemplateExpression): `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}` */ TODO
		return type_
	}
	getESSymbolLikeTypeForNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if isInJSFile(node) && isJSDocTypeExpression(node) {
			host := getJSDocHost(node)
			if host {
				node = getSingleVariableOfVariableStatement(host) || host
			}
		}
		if isValidESSymbolDeclaration(node) {
			symbol := /* TODO(Node ConditionalExpression): isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode((node as BinaryExpression).left) : getSymbolOfNode(node) */ TODO
			if symbol {
				links := getSymbolLinks(symbol)
				return links.uniqueESSymbolType || ( /* TODO(Node BinaryExpression): links.uniqueESSymbolType = createUniqueESSymbolType(symbol) */ TODO)
			}
		}
		return esSymbolType
	}
	getThisType := func(node Node) Type {
		container := getThisContainer(node, false, false)
		parent := container && container.parent
		if parent && (isClassLike(parent) || parent.kind == SyntaxKindInterfaceDeclaration) {
			if !isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) {
				return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent)).thisType
			}
		}
		if parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) == AssignmentDeclarationKindPrototype {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left).parent).thisType
		}
		host := /* TODO(Node ConditionalExpression): node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined */ TODO
		if host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) == AssignmentDeclarationKindPrototypeProperty {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left).parent).thisType
		}
		if isJSConstructor(container) && isNodeDescendantOf(node, container.body) {
			return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType
		}
		error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface)
		return errorType
	}
	getTypeFromThisTypeNode := func(node /* TODO(TypeNode UnionType): ThisExpression | ThisTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getThisType(node)
		}
		return links.resolvedType
	}
	getTypeFromRestTypeNode := func(node /* TODO(TypeNode UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getTypeFromTypeNode(getArrayElementTypeNode(node.type_) || node.type_)
	}
	getArrayElementTypeNode := func(node TypeNode) *TypeNode {
		switch node.kind {
		case SyntaxKindParenthesizedType:
			return getArrayElementTypeNode((node).type_)
		case SyntaxKindTupleType:
			if (node).elements.length == 1 {
				node = (node).elements[0]
				if node.kind == SyntaxKindRestType || node.kind == SyntaxKindNamedTupleMember && (node).dotDotDotToken {
					return getArrayElementTypeNode((node).type_)
				}
			}
			break
		case SyntaxKindArrayType:
			return (node).elementType
		}
		return nil
	}
	getTypeFromNamedTupleTypeNode := func(node NamedTupleMember) Type {
		links := getNodeLinks(node)
		return links.resolvedType || ( /* TODO(Node BinaryExpression): links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) : addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken) */ TODO)
	}
	getTypeFromTypeNode := func(node TypeNode) Type {
		return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node)
	}
	getTypeFromTypeNodeWorker := func(node TypeNode) Type {
		switch node.kind {
		case SyntaxKindAnyKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocAllType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocUnknownType:
			return anyType
		case SyntaxKindUnknownKeyword:
			return unknownType
		case SyntaxKindStringKeyword:
			return stringType
		case SyntaxKindNumberKeyword:
			return numberType
		case SyntaxKindBigIntKeyword:
			return bigintType
		case SyntaxKindBooleanKeyword:
			return booleanType
		case SyntaxKindSymbolKeyword:
			return esSymbolType
		case SyntaxKindVoidKeyword:
			return voidType
		case SyntaxKindUndefinedKeyword:
			return undefinedType
		case SyntaxKindNullKeyword:
			return nullType
		case SyntaxKindNeverKeyword:
			return neverType
		case SyntaxKindObjectKeyword:
			// converted from conditional expression
			switch {
			case node.flags&NodeFlagsJavaScriptFile && !noImplicitAny:
				return anyType
			default:
				return nonPrimitiveType
			}
		case SyntaxKindIntrinsicKeyword:
			return intrinsicMarkerType
		case SyntaxKindThisType:
			fallthrough // TODO: merge cases
		case SyntaxKindThisKeyword:
			return getTypeFromThisTypeNode(node)
		case SyntaxKindLiteralType:
			return getTypeFromLiteralTypeNode(node)
		case SyntaxKindTypeReference:
			return getTypeFromTypeReference(node)
		case SyntaxKindTypePredicate:
			// converted from conditional expression
			switch {
			case (node).assertsModifier:
				return voidType
			default:
				return booleanType
			}
		case SyntaxKindExpressionWithTypeArguments:
			return getTypeFromTypeReference(node)
		case SyntaxKindTypeQuery:
			return getTypeFromTypeQueryNode(node)
		case SyntaxKindArrayType:
			fallthrough // TODO: merge cases
		case SyntaxKindTupleType:
			return getTypeFromArrayOrTupleTypeNode(node)
		case SyntaxKindOptionalType:
			return getTypeFromOptionalTypeNode(node)
		case SyntaxKindUnionType:
			return getTypeFromUnionTypeNode(node)
		case SyntaxKindIntersectionType:
			return getTypeFromIntersectionTypeNode(node)
		case SyntaxKindJSDocNullableType:
			return getTypeFromJSDocNullableTypeNode(node)
		case SyntaxKindJSDocOptionalType:
			return addOptionality(getTypeFromTypeNode((node).type_))
		case SyntaxKindNamedTupleMember:
			return getTypeFromNamedTupleTypeNode(node)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeExpression:
			return getTypeFromTypeNode((node).type_)
		case SyntaxKindRestType:
			return getTypeFromRestTypeNode(node)
		case SyntaxKindJSDocVariadicType:
			return getTypeFromJSDocVariadicType(node)
		case SyntaxKindFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindConstructorType:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocSignature:
			return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
		case SyntaxKindTypeOperator:
			return getTypeFromTypeOperatorNode(node)
		case SyntaxKindIndexedAccessType:
			return getTypeFromIndexedAccessTypeNode(node)
		case SyntaxKindMappedType:
			return getTypeFromMappedTypeNode(node)
		case SyntaxKindConditionalType:
			return getTypeFromConditionalTypeNode(node)
		case SyntaxKindInferType:
			return getTypeFromInferTypeNode(node)
		case SyntaxKindTemplateLiteralType:
			return getTypeFromTemplateTypeNode(node)
		case SyntaxKindImportType:
			return getTypeFromImportTypeNode(node)
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindQualifiedName:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			symbol := getSymbolAtLocation(node)
			// converted from conditional expression
			switch {
			case symbol:
				return getDeclaredTypeOfSymbol(symbol)
			default:
				return errorType
			}
		default:
			return errorType
		}
	}
	/* OVERLOAD: function instantiateList<T>(items: readonly T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[]; */
	/* OVERLOAD: function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined; */
	instantiateList := func(items *[]T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) *[]T {
		if items && items.length {
			for i := 0; i < items.length; i++ {
				item := items[i]
				mapped := instantiator(item, mapper)
				if item != mapped {
					result := /* TODO(Node ConditionalExpression): i === 0 ? [] : items.slice(0, i) */ TODO
					result.push(mapped)
					for i++; i < items.length; i++ {
						result.push(instantiator(items[i], mapper))
					}
					return result
				}
			}
		}
		return items
	}
	/* OVERLOAD: function instantiateTypes(types: readonly Type[], mapper: TypeMapper): readonly Type[]; */
	/* OVERLOAD: function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined; */
	instantiateTypes := func(types *[]Type, mapper TypeMapper) *[]Type {
		return instantiateList(types, mapper, instantiateType)
	}
	instantiateSignatures := func(signatures []Signature, mapper TypeMapper) []Signature {
		return instantiateList(signatures, mapper, instantiateSignature)
	}
	instantiateIndexInfos := func(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
		return instantiateList(indexInfos, mapper, instantiateIndexInfo)
	}
	createTypeMapper := func(sources []TypeParameter, targets *[]Type) TypeMapper {
		// converted from conditional expression
		switch {
		case sources.length == 1:
			return makeUnaryTypeMapper(sources[0] /* TODO(Node ConditionalExpression): targets ? targets[0] : anyType */, TODO)
		default:
			return makeArrayTypeMapper(sources, targets)
		}
	}
	getMappedType := func(type_ Type, mapper TypeMapper) Type {
		switch mapper.kind {
		case TypeMapKindSimple:
			// converted from conditional expression
			switch {
			case type_ == mapper.source:
				return mapper.target
			default:
				return type_
			}
		case TypeMapKindArray:
			sources := mapper.sources
			targets := mapper.targets
			for i := 0; i < sources.length; i++ {
				if type_ == sources[i] {
					// converted from conditional expression
					switch {
					case targets:
						return targets[i]
					default:
						return anyType
					}
				}
			}
			return type_
			fallthrough
		case TypeMapKindDeferred:
			sources := mapper.sources
			targets := mapper.targets
			for i := 0; i < sources.length; i++ {
				if type_ == sources[i] {
					return targets[i]()
				}
			}
			return type_
			fallthrough
		case TypeMapKindFunction:
			return mapper.func_(type_)
		case TypeMapKindComposite:
			fallthrough // TODO: merge cases
		case TypeMapKindMerged:
			t1 := getMappedType(type_, mapper.mapper1)
			// converted from conditional expression
			switch {
			case t1 != type_ && mapper.kind == TypeMapKindComposite:
				return instantiateType(t1, mapper.mapper2)
			default:
				return getMappedType(t1, mapper.mapper2)
			}
		}
	}
	makeUnaryTypeMapper := func(source Type, target Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(Node ObjectLiteralExpression): { kind: TypeMapKind.Simple, source, target } */ TODO)
	}
	makeArrayTypeMapper := func(sources []TypeParameter, targets *[]Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(Node ObjectLiteralExpression): { kind: TypeMapKind.Array, sources, targets } */ TODO)
	}
	makeFunctionTypeMapper := func(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(Node ObjectLiteralExpression): { kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined } */ TODO)
	}
	makeDeferredTypeMapper := func(sources []TypeParameter, targets []func() Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ any {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(Node ObjectLiteralExpression): { kind: TypeMapKind.Deferred, sources, targets } */ TODO)
	}
	makeCompositeTypeMapper := func(kind /* TODO(TypeNode UnionType): TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(Node ObjectLiteralExpression): { kind, mapper1, mapper2 } */ TODO)
	}
	createTypeEraser := func(sources []TypeParameter) TypeMapper {
		return createTypeMapper(sources, nil)
	}
	createBackreferenceMapper := func(context InferenceContext, index number) TypeMapper {
		forwardInferences := context.inferences.slice(index)
		return createTypeMapper(map_(forwardInferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
			return i.typeParameter
		}), map_(forwardInferences, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
			return unknownType
		}))
	}
	combineTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		// converted from conditional expression
		switch {
		case mapper1:
			return makeCompositeTypeMapper(TypeMapKindComposite, mapper1, mapper2)
		default:
			return mapper2
		}
	}
	mergeTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		// converted from conditional expression
		switch {
		case mapper1:
			return makeCompositeTypeMapper(TypeMapKindMerged, mapper1, mapper2)
		default:
			return mapper2
		}
	}
	prependTypeMapping := func(source Type, target Type, mapper *TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ any {
		// converted from conditional expression
		switch {
		case !mapper:
			return makeUnaryTypeMapper(source, target)
		default:
			return makeCompositeTypeMapper(TypeMapKindMerged, makeUnaryTypeMapper(source, target), mapper)
		}
	}
	appendTypeMapping := func(mapper *TypeMapper, source Type, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ any {
		// converted from conditional expression
		switch {
		case !mapper:
			return makeUnaryTypeMapper(source, target)
		default:
			return makeCompositeTypeMapper(TypeMapKindMerged, mapper, makeUnaryTypeMapper(source, target))
		}
	}
	getRestrictiveTypeParameter := func(tp TypeParameter) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint == noConstraintType:
			return tp
		default:
			return tp.restrictiveInstantiation || ( /* TODO(Node BinaryExpression): tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation */ TODO)
		}
	}
	cloneTypeParameter := func(typeParameter TypeParameter) TypeParameter {
		result := createTypeParameter(typeParameter.symbol)
		result.target = typeParameter
		return result
	}
	instantiateTypePredicate := func(predicate TypePredicate, mapper TypeMapper) TypePredicate {
		return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type_, mapper))
	}
	instantiateSignature := func(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
		var freshTypeParameters *[]TypeParameter
		if signature.typeParameters && !eraseTypeParameters {
			freshTypeParameters = map_(signature.typeParameters, cloneTypeParameter)
			mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper)
			for _, tp := range freshTypeParameters {
				tp.mapper = mapper
			}
		}
		result := createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), nil, nil, signature.minArgumentCount, signature.flags&SignatureFlagsPropagatingFlags)
		result.target = signature
		result.mapper = mapper
		return result
	}
	instantiateSymbol := func(symbol Symbol, mapper TypeMapper) Symbol {
		links := getSymbolLinks(symbol)
		if links.type_ && !couldContainTypeVariables(links.type_) {
			if !(symbol.flags & SymbolFlagsSetAccessor) {
				return symbol
			}
			if links.writeType && !couldContainTypeVariables(links.writeType) {
				return symbol
			}
		}
		if getCheckFlags(symbol) & CheckFlagsInstantiated {
			symbol = links.target
			mapper = combineTypeMappers(links.mapper, mapper)
		}
		result := createSymbol(symbol.flags, symbol.escapedName, CheckFlagsInstantiated|getCheckFlags(symbol)&(CheckFlagsReadonly|CheckFlagsLate|CheckFlagsOptionalParameter|CheckFlagsRestParameter))
		result.declarations = symbol.declarations
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.mapper = mapper
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if links.nameType {
			result.links.nameType = links.nameType
		}
		return result
	}
	getObjectTypeInstantiation := func(type_ /* TODO(TypeNode UnionType): AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		declaration := /* TODO(Node ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! : type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node : type.symbol.declarations![0] */ TODO
		links := getNodeLinks(declaration)
		target := /* TODO(Node ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference : type.objectFlags & ObjectFlags.Instantiated ? type.target! : type */ TODO
		typeParameters := /* TODO(Node ConditionalExpression): type.objectFlags & ObjectFlags.SingleSignatureType ? (type as SingleSignatureType).outerTypeParameters : links.outerTypeParameters */ TODO
		if !typeParameters {
			outerTypeParameters := getOuterTypeParameters(declaration, true)
			if isJSConstructor(declaration) {
				templateTagParameters := getTypeParametersFromDeclaration(declaration)
				outerTypeParameters = addRange(outerTypeParameters, templateTagParameters)
			}
			typeParameters = outerTypeParameters || emptyArray
			allDeclarations := /* TODO(Node ConditionalExpression): type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations! */ TODO
			typeParameters = /* TODO(Node ConditionalExpression): (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ? filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) : typeParameters */ TODO
			links.outerTypeParameters = typeParameters
		}
		if typeParameters.length {
			combinedMapper := combineTypeMappers(type_.mapper, mapper)
			typeArguments := map_(typeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getMappedType(t, combinedMapper)
			})
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(Node ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			id := ( /* TODO(Node ConditionalExpression): type.objectFlags & ObjectFlags.SingleSignatureType ? "S" : "" */ TODO) + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments)
			if !target.instantiations {
				target.instantiations = make(map[string]Type)
				target.instantiations.set(getTypeListId(typeParameters)+getAliasId(target.aliasSymbol, target.aliasTypeArguments), target)
			}
			result := target.instantiations.get(id)
			if !result {
				if type_.objectFlags & ObjectFlagsSingleSignatureType {
					result = instantiateAnonymousType(type_, mapper)
					target.instantiations.set(id, result)
					return result
				}
				newMapper := createTypeMapper(typeParameters, typeArguments)
				result = /* TODO(Node ConditionalExpression): target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) : target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) : instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments) */ TODO
				target.instantiations.set(id, result)
				resultObjectFlags := getObjectFlags(result)
				if result.flags&TypeFlagsObjectFlagsType && !(resultObjectFlags & ObjectFlagsCouldContainTypeVariablesComputed) {
					resultCouldContainTypeVariables := some(typeArguments, couldContainTypeVariables)
					if !(getObjectFlags(result) & ObjectFlagsCouldContainTypeVariablesComputed) {
						if resultObjectFlags & (ObjectFlagsMapped | ObjectFlagsAnonymous | ObjectFlagsReference) {
							(result).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | ( /* TODO(Node ConditionalExpression): resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0 */ TODO)
						} else {
							(result).objectFlags |= /* TODO(Node ConditionalExpression): !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0 */ TODO
						}
					}
				}
			}
			return result
		}
		return type_
	}
	maybeTypeParameterReference := func(node Node) /* TODO inferred type boolean */ any {
		return !(node.parent.kind == SyntaxKindTypeReference && (node.parent).typeArguments && node == (node.parent).typeName || node.parent.kind == SyntaxKindImportType && (node.parent).typeArguments && node == (node.parent).qualifier)
	}
	isTypeParameterPossiblyReferenced := func(tp TypeParameter, node Node) /* TODO inferred type boolean */ any {
		if tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length == 1 {
			container := tp.symbol.declarations[0].parent
			for n := node; n != container; n = n.parent {
				if !n || n.kind == SyntaxKindBlock || n.kind == SyntaxKindConditionalType && forEachChild((n).extendsType, containsReference) {
					return true
				}
			}
			return containsReference(node)
		}
		return true
		containsReference := func(node Node) bool {
			switch node.kind {
			case SyntaxKindThisType:
				return !!tp.isThisType
			case SyntaxKindIdentifier:
				return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) && getTypeFromTypeNodeWorker(node) == tp
			case SyntaxKindTypeQuery:
				entityName := (node).exprName
				firstIdentifier := getFirstIdentifier(entityName)
				if !isThisIdentifier(firstIdentifier) {
					firstIdentifierSymbol := getResolvedSymbol(firstIdentifier)
					tpDeclaration := tp.symbol.declarations[0]
					tpScope := /* TODO(Node ConditionalExpression): tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T> tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration. undefined */ TODO
					if firstIdentifierSymbol.declarations && tpScope {
						return some(firstIdentifierSymbol.declarations, func(idDecl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
							return isNodeDescendantOf(idDecl, tpScope)
						}) || some((node).typeArguments, containsReference)
					}
				}
				return true
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodSignature:
				return !(node).type_ && !!(node).body || some((node).typeParameters, containsReference) || some((node).parameters, containsReference) || !!(node).type_ && containsReference((node).type_)
			}
			return !!forEachChild(node, containsReference)
		}
	}
	getHomomorphicTypeVariable := func(type_ MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter | undefined */ any {
		constraintType := getConstraintTypeFromMappedType(type_)
		if constraintType.flags & TypeFlagsIndex {
			typeVariable := getActualTypeVariable((constraintType).type_)
			if typeVariable.flags & TypeFlagsTypeParameter {
				return typeVariable
			}
		}
		return nil
	}
	instantiateMappedType := func(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeVariable := getHomomorphicTypeVariable(type_)
		if typeVariable {
			mappedTypeVariable := instantiateType(typeVariable, mapper)
			if typeVariable != mappedTypeVariable {
				return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
			}
		}
		// converted from conditional expression
		switch {
		case instantiateType(getConstraintTypeFromMappedType(type_), mapper) == wildcardType:
			return wildcardType
		default:
			return instantiateAnonymousType(type_, mapper, aliasSymbol, aliasTypeArguments)
		}
		instantiateConstituent := func(t Type) Type {
			if t.flags&(TypeFlagsAnyOrUnknown|TypeFlagsInstantiableNonPrimitive|TypeFlagsObject|TypeFlagsIntersection) && t != wildcardType && !isErrorType(t) {
				if !type_.declaration.nameType {
					var constraint TODO
					if isArrayType(t) || t.flags&TypeFlagsAny && findResolutionCycleStartIndex(typeVariable, TypeSystemPropertyNameImmediateBaseConstraint) < 0 && ( /* TODO(Node BinaryExpression): constraint = getConstraintOfTypeParameter(typeVariable!) */ TODO) && everyType(constraint, isArrayOrTupleType) {
						return instantiateMappedArrayType(t, type_, prependTypeMapping(typeVariable, t, mapper))
					}
					if isTupleType(t) {
						return instantiateMappedTupleType(t, type_, typeVariable, mapper)
					}
					if isArrayOrTupleOrIntersection(t) {
						return getIntersectionType(map_((t).types, instantiateConstituent))
					}
				}
				return instantiateAnonymousType(type_, prependTypeMapping(typeVariable, t, mapper))
			}
			return t
		}
	}
	getModifiedReadonlyState := func(state bool, modifiers MappedTypeModifiers) /* TODO inferred type boolean */ any {
		// converted from conditional expression
		switch {
		case modifiers & MappedTypeModifiersIncludeReadonly:
			return true
		case modifiers & MappedTypeModifiersExcludeReadonly:
			return false
		default:
			return state
		}
	}
	instantiateMappedTupleType := func(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		elementFlags := tupleType.target.elementFlags
		fixedLength := tupleType.target.fixedLength
		fixedMapper := /* TODO(Node ConditionalExpression): fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper */ TODO
		newElementTypes := map_(getElementTypes(tupleType), func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			flags := elementFlags[i]
			// converted from conditional expression
			switch {
			case i < fixedLength:
				return instantiateMappedTypeTemplate(mappedType, getStringLiteralType(""+i), !!(flags & ElementFlagsOptional), fixedMapper)
			case flags & ElementFlagsVariadic:
				return instantiateType(mappedType, prependTypeMapping(typeVariable, type_, mapper))
			default:
				return /* TODO(Node BinaryExpression): getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType */ TODO
			}
		})
		modifiers := getMappedTypeModifiers(mappedType)
		newElementFlags := /* TODO(Node ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) : modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) : elementFlags */ TODO
		newReadonly := getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType))
		// converted from conditional expression
		switch {
		case contains(newElementTypes, errorType):
			return errorType
		default:
			return createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations)
		}
	}
	instantiateMappedArrayType := func(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
		elementType := instantiateMappedTypeTemplate(mappedType, numberType, true, mapper)
		// converted from conditional expression
		switch {
		case isErrorType(elementType):
			return errorType
		default:
			return createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)))
		}
	}
	instantiateMappedTypeTemplate := func(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		templateMapper := appendTypeMapping(mapper, getTypeParameterFromMappedType(type_), key)
		propType := instantiateType(getTemplateTypeFromMappedType(type_.target || type_), templateMapper)
		modifiers := getMappedTypeModifiers(type_)
		// converted from conditional expression
		switch {
		case strictNullChecks && modifiers&MappedTypeModifiersIncludeOptional && !maybeTypeOfKind(propType, TypeFlagsUndefined|TypeFlagsVoid):
			return getOptionalType(propType, true)
		case strictNullChecks && modifiers&MappedTypeModifiersExcludeOptional && isOptional:
			return getTypeWithFacts(propType, TypeFactsNEUndefined)
		default:
			return propType
		}
	}
	instantiateAnonymousType := func(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
		Debug.assert(type_.symbol, "anonymous type must have symbol to be instantiated")
		result := createObjectType(type_.objectFlags&~(ObjectFlagsCouldContainTypeVariablesComputed|ObjectFlagsCouldContainTypeVariables)|ObjectFlagsInstantiated, type_.symbol)
		if type_.objectFlags & ObjectFlagsMapped {
			(result).declaration = (type_).declaration
			origTypeParameter := getTypeParameterFromMappedType(type_)
			freshTypeParameter := cloneTypeParameter(origTypeParameter)
			(result).typeParameter = freshTypeParameter
			mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper)
			freshTypeParameter.mapper = mapper
		}
		if type_.objectFlags & ObjectFlagsInstantiationExpressionType {
			(result).node = (type_).node
		}
		if type_.objectFlags & ObjectFlagsSingleSignatureType {
			(result).outerTypeParameters = (type_).outerTypeParameters
		}
		result.target = type_
		result.mapper = mapper
		result.aliasSymbol = aliasSymbol || type_.aliasSymbol
		result.aliasTypeArguments = /* TODO(Node ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
		result.objectFlags |= /* TODO(Node ConditionalExpression): result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0 */ TODO
		return result
	}
	getConditionalTypeInstantiation := func(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		root := type_.root
		if root.outerTypeParameters {
			typeArguments := map_(root.outerTypeParameters, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getMappedType(t, mapper)
			})
			id := ( /* TODO(Node ConditionalExpression): forConstraint ? "C" : "" */ TODO) + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments)
			result := root.instantiations.get(id)
			if !result {
				newMapper := createTypeMapper(root.outerTypeParameters, typeArguments)
				checkType := root.checkType
				distributionType := /* TODO(Node ConditionalExpression): root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined */ TODO
				result = /* TODO(Node ConditionalExpression): distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ? mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) : getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments) */ TODO
				root.instantiations.set(id, result)
			}
			return result
		}
		return type_
	}
	/* OVERLOAD: function instantiateType(type: Type, mapper: TypeMapper | undefined): Type; */
	/* OVERLOAD: function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined; */
	instantiateType := func(type_ *Type, mapper *TypeMapper) *Type {
		// converted from conditional expression
		switch {
		case type_ && mapper:
			return instantiateTypeWithAlias(type_, mapper, nil, nil)
		default:
			return type_
		}
	}
	instantiateTypeWithAlias := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments *[]Type) Type {
		if !couldContainTypeVariables(type_) {
			return type_
		}
		if instantiationDepth == 100 || instantiationCount >= 5000000 {
			tracing. /*?*/ instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit" /* TODO(Node ObjectLiteralExpression): { typeId: type.id, instantiationDepth, instantiationCount } */, TODO)
			error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
			return errorType
		}
		totalInstantiationCount++
		instantiationCount++
		instantiationDepth++
		result := instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
		instantiationDepth--
		return result
	}
	instantiateTypeWorker := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments *[]Type) Type {
		flags := type_.flags
		if flags & TypeFlagsTypeParameter {
			return getMappedType(type_, mapper)
		}
		if flags & TypeFlagsObject {
			objectFlags := (type_).objectFlags
			if objectFlags & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped) {
				if objectFlags&ObjectFlagsReference && !(type_).node {
					resolvedTypeArguments := (type_).resolvedTypeArguments
					newTypeArguments := instantiateTypes(resolvedTypeArguments, mapper)
					// converted from conditional expression
					switch {
					case newTypeArguments != resolvedTypeArguments:
						return createNormalizedTypeReference((type_).target, newTypeArguments)
					default:
						return type_
					}
				}
				if objectFlags & ObjectFlagsReverseMapped {
					return instantiateReverseMappedType(type_, mapper)
				}
				return getObjectTypeInstantiation(type_, mapper, aliasSymbol, aliasTypeArguments)
			}
			return type_
		}
		if flags & TypeFlagsUnionOrIntersection {
			origin := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined */ TODO
			types := /* TODO(Node ConditionalExpression): origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types */ TODO
			newTypes := instantiateTypes(types, mapper)
			if newTypes == types && aliasSymbol == type_.aliasSymbol {
				return type_
			}
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(Node ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			// converted from conditional expression
			switch {
			case flags&TypeFlagsIntersection || origin && origin.flags&TypeFlagsIntersection:
				return getIntersectionType(newTypes, IntersectionFlagsNone, newAliasSymbol, newAliasTypeArguments)
			default:
				return getUnionType(newTypes, UnionReductionLiteral, newAliasSymbol, newAliasTypeArguments)
			}
		}
		if flags & TypeFlagsIndex {
			return getIndexType(instantiateType((type_).type_, mapper))
		}
		if flags & TypeFlagsTemplateLiteral {
			return getTemplateLiteralType((type_).texts, instantiateTypes((type_).types, mapper))
		}
		if flags & TypeFlagsStringMapping {
			return getStringMappingType((type_).symbol, instantiateType((type_).type_, mapper))
		}
		if flags & TypeFlagsIndexedAccess {
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(Node ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return getIndexedAccessType(instantiateType((type_).objectType, mapper), instantiateType((type_).indexType, mapper), (type_).accessFlags, nil, newAliasSymbol, newAliasTypeArguments)
		}
		if flags & TypeFlagsConditional {
			return getConditionalTypeInstantiation(type_, combineTypeMappers((type_).mapper, mapper), false, aliasSymbol, aliasTypeArguments)
		}
		if flags & TypeFlagsSubstitution {
			newBaseType := instantiateType((type_).baseType, mapper)
			if isNoInferType(type_) {
				return getNoInferType(newBaseType)
			}
			newConstraint := instantiateType((type_).constraint, mapper)
			if newBaseType.flags&TypeFlagsTypeVariable && isGenericType(newConstraint) {
				return getSubstitutionType(newBaseType, newConstraint)
			}
			if newConstraint.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint)) {
				return newBaseType
			}
			// converted from conditional expression
			switch {
			case newBaseType.flags & TypeFlagsTypeVariable:
				return getSubstitutionType(newBaseType, newConstraint)
			default:
				return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{newConstraint, newBaseType})
			}
		}
		return type_
	}
	instantiateReverseMappedType := func(type_ ReverseMappedType, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		innerMappedType := instantiateType(type_.mappedType, mapper)
		if !(getObjectFlags(innerMappedType) & ObjectFlagsMapped) {
			return type_
		}
		innerIndexType := instantiateType(type_.constraintType, mapper)
		if !(innerIndexType.flags & TypeFlagsIndex) {
			return type_
		}
		instantiated := inferTypeForHomomorphicMappedType(instantiateType(type_.source, mapper), innerMappedType, innerIndexType)
		if instantiated {
			return instantiated
		}
		return type_
	}
	getPermissiveInstantiation := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever):
			return type_
		default:
			return type_.permissiveInstantiation || ( /* TODO(Node BinaryExpression): type.permissiveInstantiation = instantiateType(type, permissiveMapper) */ TODO)
		}
	}
	getRestrictiveInstantiation := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever) {
			return type_
		}
		if type_.restrictiveInstantiation {
			return type_.restrictiveInstantiation
		}
		type_.restrictiveInstantiation = instantiateType(type_, restrictiveMapper)
		type_.restrictiveInstantiation.restrictiveInstantiation = type_.restrictiveInstantiation
		return type_.restrictiveInstantiation
	}
	instantiateIndexInfo := func(info IndexInfo, mapper TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any {
		return createIndexInfo(info.keyType, instantiateType(info.type_, mapper), info.isReadonly, info.declaration)
	}
	isContextSensitive := func(node /* TODO(TypeNode UnionType): Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		switch node.kind {
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			return isContextSensitiveFunctionLikeDeclaration(node)
		case SyntaxKindObjectLiteralExpression:
			return some((node).properties, isContextSensitive)
		case SyntaxKindArrayLiteralExpression:
			return some((node).elements, isContextSensitive)
		case SyntaxKindConditionalExpression:
			return isContextSensitive((node).whenTrue) || isContextSensitive((node).whenFalse)
		case SyntaxKindBinaryExpression:
			return ((node).operatorToken.kind == SyntaxKindBarBarToken || (node).operatorToken.kind == SyntaxKindQuestionQuestionToken) && (isContextSensitive((node).left) || isContextSensitive((node).right))
		case SyntaxKindPropertyAssignment:
			return isContextSensitive((node).initializer)
		case SyntaxKindParenthesizedExpression:
			return isContextSensitive((node).expression)
		case SyntaxKindJsxAttributes:
			return some((node).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive)
		case SyntaxKindJsxAttribute:
			TODO_IDENTIFIER := node
			return !!initializer && isContextSensitive(initializer)
			fallthrough
		case SyntaxKindJsxExpression:
			TODO_IDENTIFIER := node
			return !!expression && isContextSensitive(expression)
		}
		return false
	}
	isContextSensitiveFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node)
	}
	hasContextSensitiveReturnExpression := func(node FunctionLikeDeclaration) /* TODO inferred type boolean */ any {
		if node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body {
			return false
		}
		if node.body.kind != SyntaxKindBlock {
			return isContextSensitive(node.body)
		}
		return !!forEachReturnStatement(node.body, func(statement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ any) /* TODO inferred type boolean */ any {
			return !!statement.expression && isContextSensitive(statement.expression)
		})
	}
	isContextSensitiveFunctionOrObjectLiteralMethod := func(func_ Node) /* TODO(TypeNode TypePredicate): func is FunctionExpression | ArrowFunction | MethodDeclaration */ any {
		return (isFunctionExpressionOrArrowFunction(func_) || isObjectLiteralMethod(func_)) && isContextSensitiveFunctionLikeDeclaration(func_)
	}
	getTypeWithoutSignatures := func(type_ Type) Type {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			if resolved.constructSignatures.length || resolved.callSignatures.length {
				result := createObjectType(ObjectFlagsAnonymous, type_.symbol)
				result.members = resolved.members
				result.properties = resolved.properties
				result.callSignatures = emptyArray
				result.constructSignatures = emptyArray
				result.indexInfos = emptyArray
				return result
			}
		} else if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_).types, getTypeWithoutSignatures))
		}
		return type_
	}
	isTypeIdenticalTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, identityRelation)
	}
	compareTypesIdentical := func(source Type, target Type) Ternary {
		// converted from conditional expression
		switch {
		case isTypeRelatedTo(source, target, identityRelation):
			return TernaryTrue
		default:
			return TernaryFalse
		}
	}
	compareTypesAssignable := func(source Type, target Type) Ternary {
		// converted from conditional expression
		switch {
		case isTypeRelatedTo(source, target, assignableRelation):
			return TernaryTrue
		default:
			return TernaryFalse
		}
	}
	compareTypesSubtypeOf := func(source Type, target Type) Ternary {
		// converted from conditional expression
		switch {
		case isTypeRelatedTo(source, target, subtypeRelation):
			return TernaryTrue
		default:
			return TernaryFalse
		}
	}
	isTypeSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, subtypeRelation)
	}
	isTypeStrictSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, strictSubtypeRelation)
	}
	isTypeAssignableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, assignableRelation)
	}
	isTypeDerivedFrom := func(source Type, target Type) bool {
		// converted from conditional expression
		switch {
		case source.flags & TypeFlagsUnion:
			return every((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isTypeDerivedFrom(t, target)
			})
		case target.flags & TypeFlagsUnion:
			return some((target).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isTypeDerivedFrom(source, t)
			})
		case source.flags & TypeFlagsIntersection:
			return some((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isTypeDerivedFrom(t, target)
			})
		case source.flags & TypeFlagsInstantiableNonPrimitive:
			return isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target)
		case isEmptyAnonymousObjectType(target):
			return !!(source.flags & (TypeFlagsObject | TypeFlagsNonPrimitive))
		case target == globalObjectType:
			return !!(source.flags & (TypeFlagsObject | TypeFlagsNonPrimitive)) && !isEmptyAnonymousObjectType(source)
		case target == globalFunctionType:
			return !!(source.flags & TypeFlagsObject) && isFunctionObjectType(source)
		default:
			return hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType))
		}
	}
	isTypeComparableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, comparableRelation)
	}
	areTypesComparable := func(type1 Type, type2 Type) bool {
		return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1)
	}
	checkTypeAssignableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; } */ any) bool {
		return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
	}
	checkTypeAssignableToAndOptionallyElaborate := func(source Type, target Type, errorNode Node, expr *Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, nil)
	}
	checkTypeRelatedToAndOptionallyElaborate := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr *Expression, headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isTypeRelatedTo(source, target, relation) {
			return true
		}
		if !errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	isOrHasGenericConditional := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsConditional || (type_.flags&TypeFlagsIntersection && some((type_).types, isOrHasGenericConditional)))
	}
	elaborateError := func(node *Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if !node || isOrHasGenericConditional(target) {
			return false
		}
		if !checkTypeRelatedTo(source, target, relation, nil) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return true
		}
		switch node.kind {
		case SyntaxKindAsExpression:
			if !isConstAssertion(node) {
				break
			}
			fallthrough
		case SyntaxKindJsxExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return elaborateError((node).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
		case SyntaxKindBinaryExpression:
			switch (node).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindCommaToken:
				return elaborateError((node).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
			}
			break
		case SyntaxKindObjectLiteralExpression:
			return elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindArrayLiteralExpression:
			return elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindJsxAttributes:
			return elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer)
		case SyntaxKindArrowFunction:
			return elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	elaborateDidYouMeanToCallOrConstruct := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		callSignatures := getSignaturesOfType(source, SignatureKindCall)
		constructSignatures := getSignaturesOfType(source, SignatureKindConstruct)
		for _, signatures := range [] /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ any{constructSignatures, callSignatures} {
			if some(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
				returnType := getReturnTypeOfSignature(s)
				return !(returnType.flags & (TypeFlagsAny | TypeFlagsNever)) && checkTypeRelatedTo(returnType, target, relation, nil)
			}) {
				var resultObj /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(Node ObjectLiteralExpression): {} */ TODO
				checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj)
				diagnostic := resultObj.errors[resultObj.errors.length-1]
				addRelatedInfo(diagnostic, createDiagnosticForNode(node /* TODO(Node ConditionalExpression): signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression */, TODO))
				return true
			}
		}
		return false
	}
	elaborateArrowFunction := func(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isBlock(node.body) {
			return false
		}
		if some(node.parameters, hasType) {
			return false
		}
		sourceSig := getSingleCallSignature(source)
		if !sourceSig {
			return false
		}
		targetSignatures := getSignaturesOfType(target, SignatureKindCall)
		if !length(targetSignatures) {
			return false
		}
		returnExpression := node.body
		sourceReturn := getReturnTypeOfSignature(sourceSig)
		targetReturn := getUnionType(map_(targetSignatures, getReturnTypeOfSignature))
		if !checkTypeRelatedTo(sourceReturn, targetReturn, relation, nil) {
			elaborated := returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, nil, containingMessageChain, errorOutputContainer)
			if elaborated {
				return elaborated
			}
			var resultObj /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(Node ObjectLiteralExpression): {} */ TODO
			checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, nil, containingMessageChain, resultObj)
			if resultObj.errors {
				if target.symbol && length(target.symbol.declarations) {
					addRelatedInfo(resultObj.errors[resultObj.errors.length-1], createDiagnosticForNode(target.symbol.declarations[0], Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature))
				}
				if (getFunctionFlags(node)&FunctionFlagsAsync) == 0 && !getTypeOfPropertyOfType(sourceReturn, "then") && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, nil) {
					addRelatedInfo(resultObj.errors[resultObj.errors.length-1], createDiagnosticForNode(node, Diagnostics.Did_you_mean_to_mark_this_function_as_async))
				}
				return true
			}
		}
		return false
	}
	getBestMatchIndexedAccessTypeOrUndefined := func(source Type, target Type, nameType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		idx := getIndexedAccessTypeOrUndefined(target, nameType)
		if idx {
			return idx
		}
		if target.flags & TypeFlagsUnion {
			best := getBestMatchingType(source, target)
			if best {
				return getIndexedAccessTypeOrUndefined(best, nameType)
			}
		}
	}
	checkExpressionForMutableLocationWithContextualType := func(next Expression, sourcePropType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		pushContextualType(next, sourcePropType, false)
		result := checkExpressionForMutableLocation(next, CheckModeContextual)
		popContextualType()
		return result
	}
	type ElaborationIterator IterableIterator[ /* TODO(TypeNode TypeLiteral): { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ any]
	elaborateElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ any {
		reportedError := false
		for _, value := range iterator {
			TODO_IDENTIFIER := value
			targetPropType := getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType)
			if !targetPropType || targetPropType.flags&TypeFlagsIndexedAccess {
				continue
			}
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
				continue
			}
			propName := getPropertyNameFromIndex(nameType, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation, nil, containingMessageChain, errorOutputContainer)
				reportedError = true
				if !elaborated {
					var resultObj /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(Node ObjectLiteralExpression): {} */ TODO
					specificSource := /* TODO(Node ConditionalExpression): next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType */ TODO
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType))
						diagnostics.add(diag)
						resultObj.errors = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any{diag}
					} else {
						targetIsOptional := !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						sourceIsOptional := !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						targetPropType = removeMissingType(targetPropType, targetIsOptional)
						sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && specificSource != sourcePropType {
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
					if resultObj.errors {
						reportedDiag := resultObj.errors[resultObj.errors.length-1]
						propertyName := /* TODO(Node ConditionalExpression): isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
						targetProp := /* TODO(Node ConditionalExpression): propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined */ TODO
						issuedElaboration := false
						if !targetProp {
							indexInfo := getApplicableIndexInfo(target, nameType)
							if indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib {
								issuedElaboration = true
								addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature))
							}
						}
						if !issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations)) {
							targetNode := /* TODO(Node ConditionalExpression): targetProp && length(targetProp.declarations) ? targetProp.declarations![0] : target.symbol.declarations![0] */ TODO
							if !getSourceFileOfNode(targetNode).hasNoDefaultLib {
								addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode, Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1 /* TODO(Node ConditionalExpression): propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType) */, TODO, typeToString(target)))
							}
						}
					}
				}
			}
		}
		return reportedError
	}
	elaborateIterableOrArrayLikeTargetElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ any {
		tupleOrArrayLikeTargetParts := filterType(target, isArrayOrTupleLikeType)
		nonTupleOrArrayLikeTargetParts := filterType(target, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !isArrayOrTupleLikeType(t)
		})
		iterationType := /* TODO(Node ConditionalExpression): nonTupleOrArrayLikeTargetParts !== neverType ? getIterationTypeOfIterable(IterationUse.ForOf, IterationTypeKind.Yield, nonTupleOrArrayLikeTargetParts, /*errorNode* / undefined) : undefined */ TODO
		reportedError := false
		for status := iterator.next(); !status.done; status = iterator.next() {
			TODO_IDENTIFIER := status.value
			targetPropType := iterationType
			targetIndexedPropType := /* TODO(Node ConditionalExpression): tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : undefined */ TODO
			if targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlagsIndexedAccess) {
				targetPropType = /* TODO(Node ConditionalExpression): iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType */ TODO
			}
			if !targetPropType {
				continue
			}
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
				continue
			}
			propName := getPropertyNameFromIndex(nameType, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation, nil, containingMessageChain, errorOutputContainer)
				reportedError = true
				if !elaborated {
					var resultObj /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; } */ any = errorOutputContainer || /* TODO(Node ObjectLiteralExpression): {} */ TODO
					specificSource := /* TODO(Node ConditionalExpression): next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType */ TODO
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType))
						diagnostics.add(diag)
						resultObj.errors = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any{diag}
					} else {
						targetIsOptional := !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						sourceIsOptional := !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						targetPropType = removeMissingType(targetPropType, targetIsOptional)
						sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && specificSource != sourcePropType {
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
				}
			}
		}
		return reportedError
	}
	// TODO: was generator
	generateJsxAttributes := func(node JsxAttributes) ElaborationIterator {
		if !length(node.properties) {
			return
		}
		for _, prop := range node.properties {
			if isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name)) {
				continue
			}
			yield( /* TODO(Node ObjectLiteralExpression): { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) } */ TODO)
		}
	}
	// TODO: was generator
	generateJsxChildren := func(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
		if !length(node.children) {
			return
		}
		memberOffset := 0
		for i := 0; i < node.children.length; i++ {
			child := node.children[i]
			nameType := getNumberLiteralType(i - memberOffset)
			elem := getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic)
			if elem {
				yield(elem)
			} else {
				memberOffset++
			}
		}
	}
	getElaborationElementForJsxChild := func(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) /* TODO inferred type { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxExpression; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxText; innerExpression: undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | undefined */ any {
		switch child.kind {
		case SyntaxKindJsxExpression:
			return /* TODO(Node ObjectLiteralExpression): { errorNode: child, innerExpression: child.expression, nameType } */ TODO
		case SyntaxKindJsxText:
			if child.containsOnlyTriviaWhiteSpaces {
				break
			}
			return /* TODO(Node ObjectLiteralExpression): { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() } */ TODO
		case SyntaxKindJsxElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxFragment:
			return /* TODO(Node ObjectLiteralExpression): { errorNode: child, innerExpression: child, nameType } */ TODO
		default:
			return Debug.assertNever(child, "Found invalid jsx child")
		}
	}
	elaborateJsxComponents := func(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ any {
		result := elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
		var invalidTextDiagnostic *DiagnosticMessage
		if isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent) {
			containingElement := node.parent.parent
			childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
			childrenPropName := /* TODO(Node ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
			childrenNameType := getStringLiteralType(childrenPropName)
			childrenTargetType := getIndexedAccessType(target, childrenNameType)
			validChildren := getSemanticJsxChildren(containingElement.children)
			if !length(validChildren) {
				return result
			}
			moreThanOneRealChildren := length(validChildren) > 1
			var arrayLikeTargetParts Type
			var nonArrayLikeTargetParts Type
			iterableType := getGlobalIterableType(false)
			if iterableType != emptyGenericType {
				anyIterable := createIterableType(anyType)
				arrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isTypeAssignableTo(t, anyIterable)
				})
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !isTypeAssignableTo(t, anyIterable)
				})
			} else {
				arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType)
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !isArrayOrTupleLikeType(t)
				})
			}
			if moreThanOneRealChildren {
				if arrayLikeTargetParts != neverType {
					realSource := createTupleType(checkJsxChildren(containingElement, CheckModeNormal))
					children := generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
					result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(Node BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			} else {
				if nonArrayLikeTargetParts != neverType {
					child := validChildren[0]
					elem := getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
					if elem {
						result = elaborateElementwise(( /* TODO(Node FunctionExpression): function* () { yield elem; } */ TODO)(), source, target, relation, containingMessageChain, errorOutputContainer) || result
					}
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(Node BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			}
		}
		return result
		getInvalidTextualChildDiagnostic := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ any {
			if !invalidTextDiagnostic {
				tagNameText := getTextOfNode(node.parent.tagName)
				childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
				childrenPropName := /* TODO(Node ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
				childrenTargetType := getIndexedAccessType(target, getStringLiteralType(childrenPropName))
				diagnostic := Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2
				invalidTextDiagnostic = /* TODO(Node ObjectLiteralExpression): { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) } */ TODO
			}
			return invalidTextDiagnostic
		}
	}
	// TODO: was generator
	generateLimitedTupleElements := func(node ArrayLiteralExpression, target Type) ElaborationIterator {
		len := length(node.elements)
		if !len {
			return
		}
		for i := 0; i < len; i++ {
			if isTupleLikeType(target) && !getPropertyOfType(target, (""+i)) {
				continue
			}
			elem := node.elements[i]
			if isOmittedExpression(elem) {
				continue
			}
			nameType := getNumberLiteralType(i)
			checkNode := getEffectiveCheckNode(elem)
			yield( /* TODO(Node ObjectLiteralExpression): { errorNode: checkNode, innerExpression: checkNode, nameType } */ TODO)
		}
	}
	elaborateArrayLiteral := func(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ any {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			return false
		}
		if isTupleLikeType(source) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
		}
		pushContextualType(node, target, false)
		tupleizedType := checkArrayLiteral(node, CheckModeContextual, true)
		popContextualType()
		if isTupleLikeType(tupleizedType) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	// TODO: was generator
	generateObjectLiteralElements := func(node ObjectLiteralExpression) ElaborationIterator {
		if !length(node.properties) {
			return
		}
		for _, prop := range node.properties {
			if isSpreadAssignment(prop) {
				continue
			}
			type_ := getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), TypeFlagsStringOrNumberLiteralOrUnique)
			if !type_ || (type_.flags & TypeFlagsNever) {
				continue
			}
			switch prop.kind {
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindShorthandPropertyAssignment:
				yield( /* TODO(Node ObjectLiteralExpression): { errorNode: prop.name, innerExpression: undefined, nameType: type } */ TODO)
				break
			case SyntaxKindPropertyAssignment:
				yield( /* TODO(Node ObjectLiteralExpression): { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined } */ TODO)
				break
			default:
				Debug.assertNever(prop)
			}
		}
	}
	elaborateObjectLiteral := func(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ any {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			return false
		}
		return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
	}
	checkTypeComparableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain)
	}
	isSignatureAssignableTo := func(source Signature, target Signature, ignoreReturnTypes bool) bool {
		return compareSignaturesRelated(source, target /* TODO(Node ConditionalExpression): ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None */, TODO, false, nil, nil, compareTypesAssignable, nil) != TernaryFalse
	}
	type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments)
	isTopSignature := func(s Signature) /* TODO inferred type boolean */ any {
		if !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length == 1 && signatureHasRestParameter(s) {
			paramType := getTypeOfParameter(s.parameters[0])
			restType := /* TODO(Node ConditionalExpression): isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType */ TODO
			return !!(restType.flags&(TypeFlagsAny|TypeFlagsNever) && getReturnTypeOfSignature(s).flags&TypeFlagsAnyOrUnknown)
		}
		return false
	}
	compareSignaturesRelated := func(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter *func(source Type, target Type), compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
		if source == target {
			return TernaryTrue
		}
		if !(checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source)) && isTopSignature(target) {
			return TernaryTrue
		}
		if checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source) && !isTopSignature(target) {
			return TernaryFalse
		}
		targetCount := getParameterCount(target)
		sourceHasMoreParameters := !hasEffectiveRestParameter(target) && ( /* TODO(Node ConditionalExpression): checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount */ TODO)
		if sourceHasMoreParameters {
			if reportErrors && !(checkMode & SignatureCheckModeStrictArity) {
				errorReporter(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount)
			}
			return TernaryFalse
		}
		if source.typeParameters && source.typeParameters != target.typeParameters {
			target = getCanonicalSignature(target)
			source = instantiateSignatureInContextOf(source, target, nil, compareTypes)
		}
		sourceCount := getParameterCount(source)
		sourceRestType := getNonArrayRestType(source)
		targetRestType := getNonArrayRestType(target)
		if sourceRestType || targetRestType {
			instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers)
		}
		kind := /* TODO(Node ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
		strictVariance := !(checkMode & SignatureCheckModeCallback) && strictFunctionTypes && kind != SyntaxKindMethodDeclaration && kind != SyntaxKindMethodSignature && kind != SyntaxKindConstructor
		result := TernaryTrue
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType && sourceThisType != voidType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				related := !strictVariance && compareTypes(sourceThisType, targetThisType, false) || compareTypes(targetThisType, sourceThisType, reportErrors)
				if !related {
					if reportErrors {
						errorReporter(Diagnostics.The_this_types_of_each_signature_are_incompatible)
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		paramCount := /* TODO(Node ConditionalExpression): sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount) */ TODO
		restIndex := /* TODO(Node ConditionalExpression): sourceRestType || targetRestType ? paramCount - 1 : -1 */ TODO
		for i := 0; i < paramCount; i++ {
			sourceType := /* TODO(Node ConditionalExpression): i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i) */ TODO
			targetType := /* TODO(Node ConditionalExpression): i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i) */ TODO
			if sourceType && targetType && (sourceType != targetType || checkMode&SignatureCheckModeStrictArity) {
				sourceSig := /* TODO(Node ConditionalExpression): checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType)) */ TODO
				targetSig := /* TODO(Node ConditionalExpression): checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType)) */ TODO
				callbacks := sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) && getTypeFacts(sourceType, TypeFactsIsUndefinedOrNull) == getTypeFacts(targetType, TypeFactsIsUndefinedOrNull)
				related := /* TODO(Node ConditionalExpression): callbacks ? compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) : !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors* / false) || compareTypes(targetType, sourceType, reportErrors) */ TODO
				if related && checkMode&SignatureCheckModeStrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, false) {
					related = TernaryFalse
				}
				if !related {
					if reportErrors {
						errorReporter(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)))
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		if !(checkMode & SignatureCheckModeIgnoreReturnTypes) {
			targetReturnType := /* TODO(Node ConditionalExpression): isResolvingReturnTypeOfSignature(target) ? anyType : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol)) : getReturnTypeOfSignature(target) */ TODO
			if targetReturnType == voidType || targetReturnType == anyType {
				return result
			}
			sourceReturnType := /* TODO(Node ConditionalExpression): isResolvingReturnTypeOfSignature(source) ? anyType : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol)) : getReturnTypeOfSignature(source) */ TODO
			targetTypePredicate := getTypePredicateOfSignature(target)
			if targetTypePredicate {
				sourceTypePredicate := getTypePredicateOfSignature(source)
				if sourceTypePredicate {
					result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes)
				} else if isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) {
					if reportErrors {
						errorReporter(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source))
					}
					return TernaryFalse
				}
			} else {
				result &= checkMode&SignatureCheckModeBivariantCallback && compareTypes(targetReturnType, sourceReturnType, false) || compareTypes(sourceReturnType, targetReturnType, reportErrors)
				if !result && reportErrors && incompatibleErrorReporter {
					incompatibleErrorReporter(sourceReturnType, targetReturnType)
				}
			}
		}
		return result
	}
	compareTypePredicateRelatedTo := func(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
		if source.kind != target.kind {
			if reportErrors {
				errorReporter(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard)
				errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
			}
			return TernaryFalse
		}
		if source.kind == TypePredicateKindIdentifier || source.kind == TypePredicateKindAssertsIdentifier {
			if source.parameterIndex != (target).parameterIndex {
				if reportErrors {
					errorReporter(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target).parameterName)
					errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
				}
				return TernaryFalse
			}
		}
		related := /* TODO(Node ConditionalExpression): source.type === target.type ? Ternary.True : source.type && target.type ? compareTypes(source.type, target.type, reportErrors) : Ternary.False */ TODO
		if related == TernaryFalse && reportErrors {
			errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
		}
		return related
	}
	isImplementationCompatibleWithOverload := func(implementation Signature, overload Signature) bool {
		erasedSource := getErasedSignature(implementation)
		erasedTarget := getErasedSignature(overload)
		sourceReturnType := getReturnTypeOfSignature(erasedSource)
		targetReturnType := getReturnTypeOfSignature(erasedTarget)
		if targetReturnType == voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation) {
			return isSignatureAssignableTo(erasedSource, erasedTarget, true)
		}
		return false
	}
	isEmptyResolvedType := func(t ResolvedType) /* TODO inferred type boolean */ any {
		return t != anyFunctionType && t.properties.length == 0 && t.callSignatures.length == 0 && t.constructSignatures.length == 0 && t.indexInfos.length == 0
	}
	isEmptyObjectType := func(type_ Type) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsObject:
			return !isGenericMappedType(type_) && isEmptyResolvedType(resolveStructuredTypeMembers(type_))
		case type_.flags & TypeFlagsNonPrimitive:
			return true
		case type_.flags & TypeFlagsUnion:
			return some((type_).types, isEmptyObjectType)
		case type_.flags & TypeFlagsIntersection:
			return every((type_).types, isEmptyObjectType)
		default:
			return false
		}
	}
	isEmptyAnonymousObjectType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(getObjectFlags(type_)&ObjectFlagsAnonymous && ((type_).members && isEmptyResolvedType(type_) || type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && getMembersOfSymbol(type_.symbol).size == 0))
	}
	isUnknownLikeUnionType := func(type_ Type) /* TODO inferred type boolean */ any {
		if strictNullChecks && type_.flags&TypeFlagsUnion {
			if !((type_).objectFlags & ObjectFlagsIsUnknownLikeUnionComputed) {
				types := (type_).types
				(type_).objectFlags |= ObjectFlagsIsUnknownLikeUnionComputed | ( /* TODO(Node ConditionalExpression): types.length >= 3 && types[0].flags & TypeFlags.Undefined && types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0 */ TODO)
			}
			return !!((type_).objectFlags & ObjectFlagsIsUnknownLikeUnion)
		}
		return false
	}
	containsUndefinedType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(( /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO).flags & TypeFlagsUndefined)
	}
	containsNonMissingUndefinedType := func(type_ Type) /* TODO inferred type boolean */ any {
		candidate := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO
		return !!(candidate.flags & TypeFlagsUndefined) && candidate != missingType
	}
	isStringIndexSignatureOnlyType := func(type_ Type) bool {
		return type_.flags&TypeFlagsObject && !isGenericMappedType(type_) && getPropertiesOfType(type_).length == 0 && getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, stringType) || type_.flags&TypeFlagsUnionOrIntersection && every((type_).types, isStringIndexSignatureOnlyType) || false
	}
	isEnumTypeRelatedTo := func(source Symbol, target Symbol, errorReporter ErrorReporter) /* TODO inferred type boolean */ any {
		sourceSymbol := /* TODO(Node ConditionalExpression): source.flags & SymbolFlags.EnumMember ? getParentOfSymbol(source)! : source */ TODO
		targetSymbol := /* TODO(Node ConditionalExpression): target.flags & SymbolFlags.EnumMember ? getParentOfSymbol(target)! : target */ TODO
		if sourceSymbol == targetSymbol {
			return true
		}
		if sourceSymbol.escapedName != targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlagsRegularEnum) || !(targetSymbol.flags & SymbolFlagsRegularEnum) {
			return false
		}
		id := getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol)
		entry := enumRelation.get(id)
		if entry != nil && !(entry&RelationComparisonResultFailed && errorReporter) {
			return !!(entry & RelationComparisonResultSucceeded)
		}
		targetEnumType := getTypeOfSymbol(targetSymbol)
		for _, sourceProperty := range getPropertiesOfType(getTypeOfSymbol(sourceSymbol)) {
			if sourceProperty.flags & SymbolFlagsEnumMember {
				targetProperty := getPropertyOfType(targetEnumType, sourceProperty.escapedName)
				if !targetProperty || !(targetProperty.flags & SymbolFlagsEnumMember) {
					if errorReporter {
						errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol), nil, TypeFormatFlagsUseFullyQualifiedType))
					}
					enumRelation.set(id, RelationComparisonResultFailed)
					return false
				}
				sourceValue := getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKindEnumMember)).value
				targetValue := getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKindEnumMember)).value
				if sourceValue != targetValue {
					sourceIsString := /* TODO(Node TypeOfExpression): typeof sourceValue */ TODO == "string"
					targetIsString := /* TODO(Node TypeOfExpression): typeof targetValue */ TODO == "string"
					if sourceValue != nil && targetValue != nil {
						if errorReporter {
							escapedSource := /* TODO(Node ConditionalExpression): sourceIsString ? `"${escapeString(sourceValue)}"` : sourceValue */ TODO
							escapedTarget := /* TODO(Node ConditionalExpression): targetIsString ? `"${escapeString(targetValue)}"` : targetValue */ TODO
							errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
					if sourceIsString || targetIsString {
						if errorReporter {
							knownStringValue := /* TODO(Node BinaryExpression): sourceValue ?? targetValue */ TODO
							Debug.assert( /* TODO(Node TypeOfExpression): typeof knownStringValue */ TODO == "string")
							escapedValue := /* TODO(Node TemplateExpression): `"${escapeString(knownStringValue)}"` */ TODO
							errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
				}
			}
		}
		enumRelation.set(id, RelationComparisonResultSucceeded)
		return true
	}
	isSimpleTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) /* TODO inferred type boolean */ any {
		s := source.flags
		t := target.flags
		if t&TypeFlagsAny || s&TypeFlagsNever || source == wildcardType {
			return true
		}
		if t&TypeFlagsUnknown && !(relation == strictSubtypeRelation && s&TypeFlagsAny) {
			return true
		}
		if t & TypeFlagsNever {
			return false
		}
		if s&TypeFlagsStringLike && t&TypeFlagsString {
			return true
		}
		if s&TypeFlagsStringLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsStringLiteral && !(t & TypeFlagsEnumLiteral) && (source).value == (target).value {
			return true
		}
		if s&TypeFlagsNumberLike && t&TypeFlagsNumber {
			return true
		}
		if s&TypeFlagsNumberLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsNumberLiteral && !(t & TypeFlagsEnumLiteral) && (source).value == (target).value {
			return true
		}
		if s&TypeFlagsBigIntLike && t&TypeFlagsBigInt {
			return true
		}
		if s&TypeFlagsBooleanLike && t&TypeFlagsBoolean {
			return true
		}
		if s&TypeFlagsESSymbolLike && t&TypeFlagsESSymbol {
			return true
		}
		if s&TypeFlagsEnum && t&TypeFlagsEnum && source.symbol.escapedName == target.symbol.escapedName && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
			return true
		}
		if s&TypeFlagsEnumLiteral && t&TypeFlagsEnumLiteral {
			if s&TypeFlagsUnion && t&TypeFlagsUnion && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				return true
			}
			if s&TypeFlagsLiteral && t&TypeFlagsLiteral && (source).value == (target).value && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				return true
			}
		}
		if s&TypeFlagsUndefined && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&(TypeFlagsUndefined|TypeFlagsVoid)) {
			return true
		}
		if s&TypeFlagsNull && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&TypeFlagsNull) {
			return true
		}
		if s&TypeFlagsObject && t&TypeFlagsNonPrimitive && !(relation == strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlagsFreshLiteral)) {
			return true
		}
		if relation == assignableRelation || relation == comparableRelation {
			if s & TypeFlagsAny {
				return true
			}
			if s&TypeFlagsNumber && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral) {
				return true
			}
			if s&TypeFlagsNumberLiteral && !(s & TypeFlagsEnumLiteral) && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral && (source).value == (target).value) {
				return true
			}
			if isUnknownLikeUnionType(target) {
				return true
			}
		}
		return false
	}
	isTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult]) /* TODO inferred type boolean */ any {
		if isFreshLiteralType(source) {
			source = (source).regularType
		}
		if isFreshLiteralType(target) {
			target = (target).regularType
		}
		if source == target {
			return true
		}
		if relation != identityRelation {
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation) {
				return true
			}
		} else if !((source.flags | target.flags) & (TypeFlagsUnionOrIntersection | TypeFlagsIndexedAccess | TypeFlagsConditional | TypeFlagsSubstitution)) {
			if source.flags != target.flags {
				return false
			}
			if source.flags & TypeFlagsSingleton {
				return true
			}
		}
		if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
			related := relation.get(getRelationKey(source, target, IntersectionStateNone, relation, false))
			if related != nil {
				return !!(related & RelationComparisonResultSucceeded)
			}
		}
		if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
			return checkTypeRelatedTo(source, target, relation, nil)
		}
		return false
	}
	isIgnoredJsxProperty := func(source Type, sourceProp Symbol) /* TODO inferred type boolean | 0 */ any {
		return getObjectFlags(source)&ObjectFlagsJsxAttributes && isHyphenatedJsxName(sourceProp.escapedName)
	}
	getNormalizedType := func(type_ Type, writing bool) Type {
		for true {
			t := /* TODO(Node ConditionalExpression): isFreshLiteralType(type) ? (type as FreshableType).regularType : isGenericTupleType(type) ? getNormalizedTupleType(type, writing) : getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type : type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) : type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) : type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) : type */ TODO
			if t == type_ {
				return t
			}
			type_ = t
		}
	}
	getNormalizedUnionOrIntersectionType := func(type_ UnionOrIntersectionType, writing bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		reduced := getReducedType(type_)
		if reduced != type_ {
			return reduced
		}
		if type_.flags&TypeFlagsIntersection && shouldNormalizeIntersection(type_) {
			normalizedTypes := sameMap(type_.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getNormalizedType(t, writing)
			})
			if normalizedTypes != type_.types {
				return getIntersectionType(normalizedTypes)
			}
		}
		return type_
	}
	shouldNormalizeIntersection := func(type_ IntersectionType) /* TODO inferred type boolean */ any {
		hasInstantiable := false
		hasNullableOrEmpty := false
		for _, t := range type_.types {
			/* TODO(Node BinaryExpression): hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable) */ TODO
			/* TODO(Node BinaryExpression): hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t) */ TODO
			if hasInstantiable && hasNullableOrEmpty {
				return true
			}
		}
		return false
	}
	getNormalizedTupleType := func(type_ TupleTypeReference, writing bool) Type {
		elements := getElementTypes(type_)
		normalizedElements := sameMap(elements, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Simplifiable ? getSimplifiedType(t, writing) : t */ TODO
		})
		// converted from conditional expression
		switch {
		case elements != normalizedElements:
			return createNormalizedTupleType(type_.target, normalizedElements)
		default:
			return type_
		}
	}
	checkTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo * /* TODO(TypeNode TupleType): [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
		var maybeKeys []string
		var maybeKeysSet Set[string]
		var sourceStack []Type
		var targetStack []Type
		maybeCount := 0
		sourceDepth := 0
		targetDepth := 0
		expandingFlags := ExpandingFlagsNone
		overflow := false
		overrideNextErrorInfo := 0
		skipParentCounter := 0
		var lastSkippedInfo * /* TODO(TypeNode TupleType): [Type, Type] */ any
		var incompatibleStack *[]DiagnosticAndArguments
		relationCount := /* TODO(Node BinaryExpression): (16_000_000 - relation.size) >> 3 */ TODO
		Debug.assert(relation != identityRelation || !errorNode, "no error reporting in identity checking")
		result := isRelatedTo(source, target, RecursionFlagsBoth, !!errorNode, headMessage)
		if incompatibleStack {
			reportIncompatibleStack()
		}
		if overflow {
			id := getRelationKey(source, target, IntersectionStateNone, relation, false)
			relation.set(id, RelationComparisonResultFailed|( /* TODO(Node ConditionalExpression): relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow */ TODO))
			tracing. /*?*/ instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit" /* TODO(Node ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth } */, TODO)
			message := /* TODO(Node ConditionalExpression): relationCount <= 0 ? Diagnostics.Excessive_complexity_comparing_types_0_and_1 : Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
			diag := error(errorNode || currentNode, message, typeToString(source), typeToString(target))
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(Node BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
		} else if errorInfo {
			if containingMessageChain {
				chain := containingMessageChain()
				if chain {
					concatenateDiagnosticMessageChains(chain, errorInfo)
					errorInfo = chain
				}
			}
			var relatedInformation *[]DiagnosticRelatedInformation
			if headMessage && errorNode && !result && source.symbol {
				links := getSymbolLinks(source.symbol)
				if links.originatingImport && !isImportCall(links.originatingImport) {
					helpfulRetry := checkTypeRelatedTo(getTypeOfSymbol(links.target), target, relation, nil)
					if helpfulRetry {
						diag := createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead)
						relatedInformation = append(relatedInformation, diag)
					}
				}
			}
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, errorInfo, relatedInformation)
			if relatedInfo {
				addRelatedInfo(diag, relatedInfo...)
			}
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(Node BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
			if !errorOutputContainer || !errorOutputContainer.skipLogging {
				diagnostics.add(diag)
			}
		}
		if errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result == TernaryFalse {
			Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.")
		}
		return result != TernaryFalse
		resetErrorInfo := func(saved ReturnType[ /* TODO(TypeNode TypeQuery): typeof captureErrorCalculationState */ any]) {
			errorInfo = saved.errorInfo
			lastSkippedInfo = saved.lastSkippedInfo
			incompatibleStack = saved.incompatibleStack
			overrideNextErrorInfo = saved.overrideNextErrorInfo
			skipParentCounter = saved.skipParentCounter
			relatedInfo = saved.relatedInfo
		}
		captureErrorCalculationState := func() /* TODO inferred type { errorInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined; lastSkippedInfo: [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").Type] | undefined; incompatibleStack: [message: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ any {
			return /* TODO(Node ObjectLiteralExpression): { errorInfo, lastSkippedInfo, incompatibleStack: incompatibleStack?.slice(), overrideNextErrorInfo, skipParentCounter, relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined, } */ TODO
		}
		reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
			overrideNextErrorInfo++
			lastSkippedInfo = nil
			( /* TODO(Node BinaryExpression): incompatibleStack ||= [] */ TODO).push([]TODO{message /* TODO(Node SpreadElement): ...args */})
		}
		reportIncompatibleStack := func() /* TODO inferred type undefined */ any {
			stack := incompatibleStack || [] /* TODO inferred type never */ any{}
			incompatibleStack = nil
			info := lastSkippedInfo
			lastSkippedInfo = nil
			if stack.length == 1 {
				reportError(stack[0]...)
				if info {
					reportRelationError(nil, info...)
				}
				return
			}
			path := ""
			var secondaryRootErrors []DiagnosticAndArguments = [] /* TODO inferred type never */ any{}
			for stack.length {
				TODO_IDENTIFIER := stack.pop()
				switch msg.code {
				case Diagnostics.Types_of_property_0_are_incompatible.code:
					if path.indexOf("new ") == 0 {
						path = /* TODO(Node TemplateExpression): `(${path})` */ TODO
					}
					str := "" + args[0]
					if path.length == 0 {
						path = /* TODO(Node TemplateExpression): `${str}` */ TODO
					} else if isIdentifierText(str, getEmitScriptTarget(compilerOptions)) {
						path = /* TODO(Node TemplateExpression): `${path}.${str}` */ TODO
					} else if str[0] == "[" && str[str.length-1] == "]" {
						path = /* TODO(Node TemplateExpression): `${path}${str}` */ TODO
					} else {
						path = /* TODO(Node TemplateExpression): `${path}[${str}]` */ TODO
					}
					break
					fallthrough
				case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:
					fallthrough // TODO: merge cases
				case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:
					fallthrough // TODO: merge cases
				case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
					fallthrough // TODO: merge cases
				case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
					if path.length == 0 {
						mappedMsg := msg
						if msg.code == Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
							mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible
						} else if msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
							mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible
						}
						secondaryRootErrors.unshift([]TODO{mappedMsg, args[0], args[1]})
					} else {
						prefix := /* TODO(Node ConditionalExpression): (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code || msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) ? "new " : "" */ TODO
						params := /* TODO(Node ConditionalExpression): (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code || msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) ? "" : "..." */ TODO
						path = /* TODO(Node TemplateExpression): `${prefix}${path}(${params})` */ TODO
					}
					break
					fallthrough
				case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code:
					secondaryRootErrors.unshift([]TODO{Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]})
					break
					fallthrough
				case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code:
					secondaryRootErrors.unshift([]TODO{Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]})
					break
					fallthrough
				default:
					return Debug.fail( /* TODO(Node TemplateExpression): `Unhandled Diagnostic: ${msg.code}` */ TODO)
				}
			}
			if path {
				reportError( /* TODO(Node ConditionalExpression): path[path.length - 1] === ")" ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types : Diagnostics.The_types_of_0_are_incompatible_between_these_types */ TODO, path)
			} else {
				secondaryRootErrors.shift()
			}
			for _, TODO_IDENTIFIER := range secondaryRootErrors {
				originalValue := msg.elidedInCompatabilityPyramid
				msg.elidedInCompatabilityPyramid = false
				reportError(msg, args...)
				msg.elidedInCompatabilityPyramid = originalValue
			}
			if info {
				reportRelationError(nil, info...)
			}
		}
		reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
			Debug.assert(!!errorNode)
			if incompatibleStack {
				reportIncompatibleStack()
			}
			if message.elidedInCompatabilityPyramid {
				return
			}
			if skipParentCounter == 0 {
				errorInfo = chainDiagnosticMessages(errorInfo, message, args...)
			} else {
				skipParentCounter--
			}
		}
		reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
			reportError(message, args...)
			skipParentCounter++
		}
		associateRelatedInfo := func(info DiagnosticRelatedInformation) {
			Debug.assert(!!errorInfo)
			if !relatedInfo {
				relatedInfo = []TODO{info}
			} else {
				relatedInfo.push(info)
			}
		}
		reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
			if incompatibleStack {
				reportIncompatibleStack()
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(source, target)
			generalizedSource := source
			generalizedSourceType := sourceType
			if isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target) {
				generalizedSource = getBaseTypeOfLiteralType(source)
				Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable")
				generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource)
			}
			targetFlags := /* TODO(Node ConditionalExpression): target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ? (target as IndexedAccessType).objectType.flags : target.flags */ TODO
			if targetFlags&TypeFlagsTypeParameter && target != markerSuperTypeForCheck && target != markerSubTypeForCheck {
				constraint := getBaseConstraintOfType(target)
				var needsOriginalSource TODO
				if constraint && (isTypeAssignableTo(generalizedSource, constraint) || ( /* TODO(Node BinaryExpression): needsOriginalSource = isTypeAssignableTo(source, constraint) */ TODO)) {
					reportError(Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2 /* TODO(Node ConditionalExpression): needsOriginalSource ? sourceType : generalizedSourceType */, TODO, targetType, typeToString(constraint))
				} else {
					errorInfo = nil
					reportError(Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType)
				}
			}
			if !message {
				if relation == comparableRelation {
					message = Diagnostics.Type_0_is_not_comparable_to_type_1
				} else if sourceType == targetType {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated
				} else if exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
				} else {
					if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsUnion {
						suggestedType := getSuggestedTypeForNonexistentStringLiteralType(source, target)
						if suggestedType {
							reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType))
							return
						}
					}
					message = Diagnostics.Type_0_is_not_assignable_to_type_1
				}
			} else if message == Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 && exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
				message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
			}
			reportError(message, generalizedSourceType, targetType)
		}
		tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
			sourceType := /* TODO(Node ConditionalExpression): symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source) */ TODO
			targetType := /* TODO(Node ConditionalExpression): symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target) */ TODO
			if (globalStringType == source && stringType == target) || (globalNumberType == source && numberType == target) || (globalBooleanType == source && booleanType == target) || (getGlobalESSymbolType() == source && esSymbolType == target) {
				reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType)
			}
		}
		tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
			if isTupleType(source) {
				if source.target.readonly && isMutableArrayOrTuple(target) {
					if reportErrors {
						reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
					}
					return false
				}
				return isArrayOrTupleType(target)
			}
			if isReadonlyArrayType(source) && isMutableArrayOrTuple(target) {
				if reportErrors {
					reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
				}
				return false
			}
			if isTupleType(target) {
				return isArrayType(source)
			}
			return true
		}
		isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ any {
			return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors)
		}
		isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /*  = RecursionFlags.Both */, reportErrors /* TODO inferred type boolean */ any /*  = false */, headMessage DiagnosticMessage, intersectionState /* TODO inferred type IntersectionState */ any /*  = IntersectionState.None */) Ternary {
			if originalSource == originalTarget {
				return TernaryTrue
			}
			if originalSource.flags&TypeFlagsObject && originalTarget.flags&TypeFlagsPrimitive {
				if relation == comparableRelation && !(originalTarget.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) || isSimpleTypeRelatedTo(originalSource, originalTarget, relation /* TODO(Node ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
					return TernaryTrue
				}
				if reportErrors {
					reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage)
				}
				return TernaryFalse
			}
			source := getNormalizedType(originalSource, false)
			target := getNormalizedType(originalTarget, true)
			if source == target {
				return TernaryTrue
			}
			if relation == identityRelation {
				if source.flags != target.flags {
					return TernaryFalse
				}
				if source.flags & TypeFlagsSingleton {
					return TernaryTrue
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				return recursiveTypeRelatedTo(source, target, false, IntersectionStateNone, recursionFlags)
			}
			if source.flags&TypeFlagsTypeParameter && getConstraintOfType(source) == target {
				return TernaryTrue
			}
			if source.flags&TypeFlagsDefinitelyNonNullable && target.flags&TypeFlagsUnion {
				types := (target).types
				candidate := /* TODO(Node ConditionalExpression): types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] : types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] : undefined */ TODO
				if candidate && !(candidate.flags & TypeFlagsNullable) {
					target = getNormalizedType(candidate, true)
					if source == target {
						return TernaryTrue
					}
				}
			}
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation /* TODO(Node ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
				return TernaryTrue
			}
			if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
				isPerformingExcessPropertyChecks := !(intersectionState & IntersectionStateTarget) && (isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral)
				if isPerformingExcessPropertyChecks {
					if hasExcessProperties(source, target, reportErrors) {
						if reportErrors {
							reportRelationError(headMessage, source /* TODO(Node ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */, TODO)
						}
						return TernaryFalse
					}
				}
				isPerformingCommonPropertyChecks := (relation != comparableRelation || isUnitType(source)) && !(intersectionState & IntersectionStateTarget) && source.flags&(TypeFlagsPrimitive|TypeFlagsObject|TypeFlagsIntersection) && source != globalObjectType && target.flags&(TypeFlagsObject|TypeFlagsIntersection) && isWeakType(target) && (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source))
				isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
				if isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes) {
					if reportErrors {
						sourceString := typeToString( /* TODO(Node ConditionalExpression): originalSource.aliasSymbol ? originalSource : source */ TODO)
						targetString := typeToString( /* TODO(Node ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */ TODO)
						calls := getSignaturesOfType(source, SignatureKindCall)
						constructs := getSignaturesOfType(source, SignatureKindConstruct)
						if calls.length > 0 && isRelatedTo(getReturnTypeOfSignature(calls[0]), target, RecursionFlagsSource, false) || constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature(constructs[0]), target, RecursionFlagsSource, false) {
							reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString)
						} else {
							reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString)
						}
					}
					return TernaryFalse
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				skipCaching := source.flags&TypeFlagsUnion && (source).types.length < 4 && !(target.flags&TypeFlagsUnion) || target.flags&TypeFlagsUnion && (target).types.length < 4 && !(source.flags&TypeFlagsStructuredOrInstantiable)
				result := /* TODO(Node ConditionalExpression): skipCaching ? unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) : recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) */ TODO
				if result {
					return result
				}
			}
			if reportErrors {
				reportErrorResults(originalSource, originalTarget, source, target, headMessage)
			}
			return TernaryFalse
		}
		reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
			sourceHasBase := !!getSingleBaseForNonAugmentingSubtype(originalSource)
			targetHasBase := !!getSingleBaseForNonAugmentingSubtype(originalTarget)
			source = /* TODO(Node ConditionalExpression): (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source */ TODO
			target = /* TODO(Node ConditionalExpression): (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target */ TODO
			maybeSuppress := overrideNextErrorInfo > 0
			if maybeSuppress {
				overrideNextErrorInfo--
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
				currentError := errorInfo
				tryElaborateArrayLikeErrors(source, target, true)
				if errorInfo != currentError {
					maybeSuppress = !!errorInfo
				}
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsPrimitive {
				tryElaborateErrorsForPrimitivesAndObjects(source, target)
			} else if source.symbol && source.flags&TypeFlagsObject && globalObjectType == source {
				reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead)
			} else if getObjectFlags(source)&ObjectFlagsJsxAttributes && target.flags&TypeFlagsIntersection {
				targetTypes := (target).types
				intrinsicAttributes := getJsxType(JsxNames.IntrinsicAttributes, errorNode)
				intrinsicClassAttributes := getJsxType(JsxNames.IntrinsicClassAttributes, errorNode)
				if !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) && (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) {
					return
				}
			} else {
				errorInfo = elaborateNeverIntersection(errorInfo, originalTarget)
			}
			if !headMessage && maybeSuppress {
				savedErrorState := captureErrorCalculationState()
				reportRelationError(headMessage, source, target)
				var canonical TODO
				if errorInfo && errorInfo != savedErrorState.errorInfo {
					canonical = /* TODO(Node ObjectLiteralExpression): { code: errorInfo.code, messageText: errorInfo.messageText } */ TODO
				}
				resetErrorInfo(savedErrorState)
				if canonical && errorInfo {
					errorInfo.canonicalHead = canonical
				}
				lastSkippedInfo = []TODO{source, target}
				return
			}
			reportRelationError(headMessage, source, target)
			if source.flags&TypeFlagsTypeParameter && source.symbol. /*?*/ declarations[0] && !getConstraintOfType(source) {
				syntheticParam := cloneTypeParameter(source)
				syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam))
				if hasNonCircularBaseConstraint(syntheticParam) {
					targetConstraintString := typeToString(target, source.symbol.declarations[0])
					associateRelatedInfo(createDiagnosticForNode(source.symbol.declarations[0], Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString))
				}
			}
		}
		traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
			if !tracing {
				return
			}
			if (source.flags & TypeFlagsUnionOrIntersection) && (target.flags & TypeFlagsUnionOrIntersection) {
				sourceUnionOrIntersection := source
				targetUnionOrIntersection := target
				if sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlagsPrimitiveUnion {
					return
				}
				sourceSize := sourceUnionOrIntersection.types.length
				targetSize := targetUnionOrIntersection.types.length
				if sourceSize*targetSize > 1e6 {
					tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit" /* TODO(Node ObjectLiteralExpression): { sourceId: source.id, sourceSize, targetId: target.id, targetSize, pos: errorNode?.pos, end: errorNode?.end, } */, TODO)
				}
			}
		}
		getTypeOfPropertyInTypes := func(types []Type, name __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			appendPropType := func(propTypes *[]Type, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ any {
				type_ = getApparentType(type_)
				prop := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name) */ TODO
				propType := prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type_, name). /*?*/ type_ || undefinedType
				return append(propTypes, propType)
			}
			return getUnionType(reduceLeft(types, appendPropType, nil) || emptyArray)
		}
		hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
			if !isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target)&ObjectFlagsJSLiteral {
				return false
			}
			isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
			if (relation == assignableRelation || relation == comparableRelation) && (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target))) {
				return false
			}
			reducedTarget := target
			var checkTypes *[]Type
			if target.flags & TypeFlagsUnion {
				reducedTarget = findMatchingDiscriminantType(source, target, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target)
				checkTypes = /* TODO(Node ConditionalExpression): reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget] */ TODO
			}
			for _, prop := range getPropertiesOfType(source) {
				if shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop) {
					if !isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes) {
						if reportErrors {
							errorTarget := filterType(reducedTarget, isExcessPropertyCheckTarget)
							if !errorNode {
								return Debug.fail()
							}
							if isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent) {
								if prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) == getSourceFileOfNode(prop.valueDeclaration.name) {
									errorNode = prop.valueDeclaration.name
								}
								propName := symbolToString(prop)
								suggestionSymbol := getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget)
								suggestion := /* TODO(Node ConditionalExpression): suggestionSymbol ? symbolToString(suggestionSymbol) : undefined */ TODO
								if suggestion {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion)
								} else {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget))
								}
							} else {
								objectLiteralDeclaration := source.symbol. /*?*/ declarations && firstOrUndefined(source.symbol.declarations)
								var suggestion *string
								if prop.valueDeclaration && findAncestor(prop.valueDeclaration, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
									return d == objectLiteralDeclaration
								}) && getSourceFileOfNode(objectLiteralDeclaration) == getSourceFileOfNode(errorNode) {
									propDeclaration := prop.valueDeclaration
									Debug.assertNode(propDeclaration, isObjectLiteralElementLike)
									name := propDeclaration.name
									errorNode = name
									if isIdentifier(name) {
										suggestion = getSuggestionForNonexistentProperty(name, errorTarget)
									}
								}
								if suggestion != nil {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion)
								} else {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget))
								}
							}
						}
						return true
					}
					if checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlagsBoth, reportErrors) {
						if reportErrors {
							reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop))
						}
						return true
					}
				}
			}
			return false
		}
		shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) /* TODO inferred type boolean | undefined */ any {
			return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent == container.valueDeclaration
		}
		unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			if source.flags & TypeFlagsUnion {
				if target.flags & TypeFlagsUnion {
					sourceOrigin := (source).origin
					if sourceOrigin && sourceOrigin.flags&TypeFlagsIntersection && target.aliasSymbol && contains((sourceOrigin).types, target) {
						return TernaryTrue
					}
					targetOrigin := (target).origin
					if targetOrigin && targetOrigin.flags&TypeFlagsUnion && source.aliasSymbol && contains((targetOrigin).types, source) {
						return TernaryTrue
					}
				}
				// converted from conditional expression
				switch {
				case relation == comparableRelation:
					return someTypeRelatedToType(source, target, reportErrors && !(source.flags&TypeFlagsPrimitive), intersectionState)
				default:
					return eachTypeRelatedToType(source, target, reportErrors && !(source.flags&TypeFlagsPrimitive), intersectionState)
				}
			}
			if target.flags & TypeFlagsUnion {
				return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target, reportErrors && !(source.flags&TypeFlagsPrimitive) && !(target.flags&TypeFlagsPrimitive), intersectionState)
			}
			if target.flags & TypeFlagsIntersection {
				return typeRelatedToEachType(source, target, reportErrors, IntersectionStateTarget)
			}
			if relation == comparableRelation && target.flags&TypeFlagsPrimitive {
				constraints := sameMap((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(t) || unknownType : t */ TODO
				})
				if constraints != (source).types {
					source = getIntersectionType(constraints)
					if source.flags & TypeFlagsNever {
						return TernaryFalse
					}
					if !(source.flags & TypeFlagsIntersection) {
						return isRelatedTo(source, target, RecursionFlagsSource, false) || isRelatedTo(target, source, RecursionFlagsSource, false)
					}
				}
			}
			return someTypeRelatedToType(source, target, false, IntersectionStateSource)
		}
		eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			for _, sourceType := range sourceTypes {
				related := typeRelatedToSomeType(sourceType, target, false, IntersectionStateNone)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetTypes := target.types
			if target.flags & TypeFlagsUnion {
				if containsType(targetTypes, source) {
					return TernaryTrue
				}
				if relation != comparableRelation && getObjectFlags(target)&ObjectFlagsPrimitiveUnion && !(source.flags & TypeFlagsEnumLiteral) && (source.flags&(TypeFlagsStringLiteral|TypeFlagsBooleanLiteral|TypeFlagsBigIntLiteral) || (relation == subtypeRelation || relation == strictSubtypeRelation) && source.flags&TypeFlagsNumberLiteral) {
					alternateForm := /* TODO(Node ConditionalExpression): source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType */ TODO
					primitive := /* TODO(Node ConditionalExpression): source.flags & TypeFlags.StringLiteral ? stringType : source.flags & TypeFlags.NumberLiteral ? numberType : source.flags & TypeFlags.BigIntLiteral ? bigintType : undefined */ TODO
					// converted from conditional expression
					switch {
					case primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm):
						return TernaryTrue
					default:
						return TernaryFalse
					}
				}
				match := getMatchingUnionConstituentForType(target, source)
				if match {
					related := isRelatedTo(source, match, RecursionFlagsTarget, false, nil, intersectionState)
					if related {
						return related
					}
				}
			}
			for _, type_ := range targetTypes {
				related := isRelatedTo(source, type_, RecursionFlagsTarget, false, nil, intersectionState)
				if related {
					return related
				}
			}
			if reportErrors {
				bestMatchingType := getBestMatchingType(source, target, isRelatedTo)
				if bestMatchingType {
					isRelatedTo(source, bestMatchingType, RecursionFlagsTarget, true, nil, intersectionState)
				}
			}
			return TernaryFalse
		}
		typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			targetTypes := target.types
			for _, targetType := range targetTypes {
				related := isRelatedTo(source, targetType, RecursionFlagsTarget, reportErrors, nil, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceTypes := source.types
			if source.flags&TypeFlagsUnion && containsType(sourceTypes, target) {
				return TernaryTrue
			}
			len := sourceTypes.length
			for i := 0; i < len; i++ {
				related := isRelatedTo(sourceTypes[i], target, RecursionFlagsSource, reportErrors && i == len-1, nil, intersectionState)
				if related {
					return related
				}
			}
			return TernaryFalse
		}
		getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			if source.flags&TypeFlagsUnion && target.flags&TypeFlagsUnion && !((source).types[0].flags & TypeFlagsUndefined) && (target).types[0].flags&TypeFlagsUndefined {
				return extractTypesOfKind(target, ~TypeFlagsUndefined)
			}
			return target
		}
		eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target)
			for i := 0; i < sourceTypes.length; i++ {
				sourceType := sourceTypes[i]
				if undefinedStrippedTarget.flags&TypeFlagsUnion && sourceTypes.length >= (undefinedStrippedTarget).types.length && /* TODO(Node BinaryExpression): sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length */ TODO == 0 {
					related := isRelatedTo(sourceType, (undefinedStrippedTarget).types[ /* TODO(Node BinaryExpression): i % (undefinedStrippedTarget as UnionType).types.length */ TODO], RecursionFlagsBoth, false, nil, intersectionState)
					if related {
						result &= related
						continue
					}
				}
				related := isRelatedTo(sourceType, target, RecursionFlagsSource, reportErrors, nil, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeArgumentsRelatedTo := func(sources []Type /*  = emptyArray */, targets []Type /*  = emptyArray */, variances []VarianceFlags /*  = emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
			if sources.length != targets.length && relation == identityRelation {
				return TernaryFalse
			}
			length := /* TODO(Node ConditionalExpression): sources.length <= targets.length ? sources.length : targets.length */ TODO
			result := TernaryTrue
			for i := 0; i < length; i++ {
				varianceFlags := /* TODO(Node ConditionalExpression): i < variances.length ? variances[i] : VarianceFlags.Covariant */ TODO
				variance := varianceFlags & VarianceFlagsVarianceMask
				if variance != VarianceFlagsIndependent {
					s := sources[i]
					t := targets[i]
					related := TernaryTrue
					if varianceFlags & VarianceFlagsUnmeasurable {
						related = /* TODO(Node ConditionalExpression): relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors* / false) : compareTypesIdentical(s, t) */ TODO
					} else if variance == VarianceFlagsCovariant {
						related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors, nil, intersectionState)
					} else if variance == VarianceFlagsContravariant {
						related = isRelatedTo(t, s, RecursionFlagsBoth, reportErrors, nil, intersectionState)
					} else if variance == VarianceFlagsBivariant {
						related = isRelatedTo(t, s, RecursionFlagsBoth, false)
						if !related {
							related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors, nil, intersectionState)
						}
					} else {
						related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors, nil, intersectionState)
						if related {
							related &= isRelatedTo(t, s, RecursionFlagsBoth, reportErrors, nil, intersectionState)
						}
					}
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
			return result
		}
		recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
			if overflow {
				return TernaryFalse
			}
			id := getRelationKey(source, target, intersectionState, relation, false)
			entry := relation.get(id)
			if entry != nil {
				if reportErrors && entry&RelationComparisonResultFailed && !(entry & RelationComparisonResultOverflow) {
				} else {
					if outofbandVarianceMarkerHandler {
						saved := entry & RelationComparisonResultReportsMask
						if saved & RelationComparisonResultReportsUnmeasurable {
							instantiateType(source, reportUnmeasurableMapper)
						}
						if saved & RelationComparisonResultReportsUnreliable {
							instantiateType(source, reportUnreliableMapper)
						}
					}
					if reportErrors && entry&RelationComparisonResultOverflow {
						message := /* TODO(Node ConditionalExpression): entry & RelationComparisonResult.ComplexityOverflow ? Diagnostics.Excessive_complexity_comparing_types_0_and_1 : Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
						reportError(message, typeToString(source), typeToString(target))
						overrideNextErrorInfo++
					}
					// converted from conditional expression
					switch {
					case entry & RelationComparisonResultSucceeded:
						return TernaryTrue
					default:
						return TernaryFalse
					}
				}
			}
			if relationCount <= 0 {
				overflow = true
				return TernaryFalse
			}
			if !maybeKeys {
				maybeKeys = [] /* TODO inferred type never */ any{}
				maybeKeysSet = /* TODO(Node NewExpression): new Set() */ make(map[any]struct{})
				sourceStack = [] /* TODO inferred type never */ any{}
				targetStack = [] /* TODO inferred type never */ any{}
			} else {
				if maybeKeysSet.has(id) {
					return TernaryMaybe
				}
				broadestEquivalentId := /* TODO(Node ConditionalExpression): id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints* / true) : undefined */ TODO
				if broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId) {
					return TernaryMaybe
				}
				if sourceDepth == 100 || targetDepth == 100 {
					overflow = true
					return TernaryFalse
				}
			}
			maybeStart := maybeCount
			maybeKeys[maybeCount] = id
			maybeKeysSet.add(id)
			maybeCount++
			saveExpandingFlags := expandingFlags
			if recursionFlags & RecursionFlagsSource {
				sourceStack[sourceDepth] = source
				sourceDepth++
				if !(expandingFlags & ExpandingFlagsSource) && isDeeplyNestedType(source, sourceStack, sourceDepth) {
					expandingFlags |= ExpandingFlagsSource
				}
			}
			if recursionFlags & RecursionFlagsTarget {
				targetStack[targetDepth] = target
				targetDepth++
				if !(expandingFlags & ExpandingFlagsTarget) && isDeeplyNestedType(target, targetStack, targetDepth) {
					expandingFlags |= ExpandingFlagsTarget
				}
			}
			var originalHandler /* TODO(TypeNode TypeQuery): typeof outofbandVarianceMarkerHandler */ any
			propagatingVarianceFlags := 0
			if outofbandVarianceMarkerHandler {
				originalHandler = outofbandVarianceMarkerHandler
				outofbandVarianceMarkerHandler = func(onlyUnreliable /* TODO inferred type boolean */ any) {
					propagatingVarianceFlags |= /* TODO(Node ConditionalExpression): onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable */ TODO
					return originalHandler(onlyUnreliable)
				}
			}
			var result Ternary
			if expandingFlags == ExpandingFlagsBoth {
				tracing. /*?*/ instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit" /* TODO(Node ObjectLiteralExpression): { sourceId: source.id, sourceIdStack: sourceStack.map(t => t.id), targetId: target.id, targetIdStack: targetStack.map(t => t.id), depth: sourceDepth, targetDepth, } */, TODO)
				result = TernaryMaybe
			} else {
				tracing. /*?*/ push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo" /* TODO(Node ObjectLiteralExpression): { sourceId: source.id, targetId: target.id } */, TODO)
				result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState)
				tracing. /*?*/ pop()
			}
			if outofbandVarianceMarkerHandler {
				outofbandVarianceMarkerHandler = originalHandler
			}
			if recursionFlags & RecursionFlagsSource {
				sourceDepth--
			}
			if recursionFlags & RecursionFlagsTarget {
				targetDepth--
			}
			expandingFlags = saveExpandingFlags
			if result {
				if result == TernaryTrue || (sourceDepth == 0 && targetDepth == 0) {
					if result == TernaryTrue || result == TernaryMaybe {
						resetMaybeStack(true)
					} else {
						resetMaybeStack(false)
					}
				}
			} else {
				relation.set(id, RelationComparisonResultFailed|propagatingVarianceFlags)
				relationCount--
				resetMaybeStack(false)
			}
			return result
			resetMaybeStack := func(markAllAsSucceeded bool) {
				for i := maybeStart; i < maybeCount; i++ {
					maybeKeysSet.delete(maybeKeys[i])
					if markAllAsSucceeded {
						relation.set(maybeKeys[i], RelationComparisonResultSucceeded|propagatingVarianceFlags)
						relationCount--
					}
				}
				maybeCount = maybeStart
			}
		}
		structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			saveErrorInfo := captureErrorCalculationState()
			result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
			if relation != identityRelation {
				if !result && (source.flags&TypeFlagsIntersection || source.flags&TypeFlagsTypeParameter && target.flags&TypeFlagsUnion) {
					constraint := getEffectiveConstraintOfIntersection( /* TODO(Node ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, !!(target.flags & TypeFlagsUnion))
					if constraint && everyType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return c != source
					}) {
						result = isRelatedTo(constraint, target, RecursionFlagsSource, false, nil, intersectionState)
					}
				}
				if result && !(intersectionState & IntersectionStateTarget) && target.flags&TypeFlagsIntersection && !isGenericObjectType(target) && source.flags&(TypeFlagsObject|TypeFlagsIntersection) {
					result &= propertiesRelatedTo(source, target, reportErrors, nil, false, IntersectionStateNone)
					if result && isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral {
						result &= indexSignaturesRelatedTo(source, target, false, reportErrors, IntersectionStateNone)
					}
				} else if result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) && source.flags&TypeFlagsIntersection && getApparentType(source).flags&TypeFlagsStructuredType && !some((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return t == target || !!(getObjectFlags(t) & ObjectFlagsNonInferrableType)
				}) {
					result &= propertiesRelatedTo(source, target, reportErrors, nil, true, intersectionState)
				}
			}
			if result {
				resetErrorInfo(saveErrorInfo)
			}
			return result
		}
		getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(targetType))
			var mappedKeys []Type = [] /* TODO inferred type never */ any{}
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, false, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type undefined */ any {
				return mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t)))
			})
			return getUnionType(mappedKeys)
		}
		structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[ /* TODO(TypeNode TypeQuery): typeof captureErrorCalculationState */ any]) Ternary {
			var result Ternary
			var originalErrorInfo *DiagnosticMessageChain
			varianceCheckFailed := false
			sourceFlags := source.flags
			targetFlags := target.flags
			if relation == identityRelation {
				if sourceFlags & TypeFlagsUnionOrIntersection {
					result := eachTypeRelatedToSomeType(source, target)
					if result {
						result &= eachTypeRelatedToSomeType(target, source)
					}
					return result
				}
				if sourceFlags & TypeFlagsIndex {
					return isRelatedTo((source).type_, (target).type_, RecursionFlagsBoth, false)
				}
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(Node BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(Node BinaryExpression): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if sourceFlags & TypeFlagsConditional {
					if (source).root.isDistributive == (target).root.isDistributive {
						if /* TODO(Node BinaryExpression): result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							if /* TODO(Node BinaryExpression): result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
								if /* TODO(Node BinaryExpression): result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
									if /* TODO(Node BinaryExpression): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
										return result
									}
								}
							}
						}
					}
				}
				if sourceFlags & TypeFlagsSubstitution {
					if /* TODO(Node BinaryExpression): result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(Node BinaryExpression): result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if !(sourceFlags & TypeFlagsObject) {
					return TernaryFalse
				}
			} else if sourceFlags&TypeFlagsUnionOrIntersection || targetFlags&TypeFlagsUnionOrIntersection {
				if /* TODO(Node BinaryExpression): result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
					return result
				}
				if !(sourceFlags&TypeFlagsInstantiable || sourceFlags&TypeFlagsObject && targetFlags&TypeFlagsUnion || sourceFlags&TypeFlagsIntersection && targetFlags&(TypeFlagsObject|TypeFlagsUnion|TypeFlagsInstantiable)) {
					return TernaryFalse
				}
			}
			if sourceFlags&(TypeFlagsObject|TypeFlagsConditional) && source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol == target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target)) {
				variances := getAliasVariances(source.aliasSymbol)
				if variances == emptyArray {
					return TernaryUnknown
				}
				params := getSymbolLinks(source.aliasSymbol).typeParameters
				minParams := getMinTypeArgumentCount(params)
				sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
				if varianceResult != nil {
					return varianceResult
				}
			}
			if isSingleElementGenericTupleType(source) && !source.target.readonly && ( /* TODO(Node BinaryExpression): result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source) */ TODO) || isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && ( /* TODO(Node BinaryExpression): result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target) */ TODO) {
				return result
			}
			if targetFlags & TypeFlagsTypeParameter {
				if getObjectFlags(source)&ObjectFlagsMapped && !(source).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source), RecursionFlagsBoth) {
					if !(getMappedTypeModifiers(source) & MappedTypeModifiersIncludeOptional) {
						templateType := getTemplateTypeFromMappedType(source)
						indexedAccessType := getIndexedAccessType(target, getTypeParameterFromMappedType(source))
						if /* TODO(Node BinaryExpression): result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
							return result
						}
					}
				}
				if relation == comparableRelation && sourceFlags&TypeFlagsTypeParameter {
					constraint := getConstraintOfTypeParameter(source)
					if constraint {
						for constraint && someType(constraint, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
							return !!(c.flags & TypeFlagsTypeParameter)
						}) {
							if /* TODO(Node BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false) */ TODO {
								return result
							}
							constraint = getConstraintOfTypeParameter(constraint)
						}
					}
					return TernaryFalse
				}
			} else if targetFlags & TypeFlagsIndex {
				targetType := (target).type_
				if sourceFlags & TypeFlagsIndex {
					if /* TODO(Node BinaryExpression): result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
				if isTupleType(targetType) {
					if /* TODO(Node BinaryExpression): result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getSimplifiedTypeOrConstraint(targetType)
					if constraint {
						if isRelatedTo(source, getIndexType(constraint, (target).indexFlags|IndexFlagsNoReducibleCheck), RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					} else if isGenericMappedType(targetType) {
						nameType := getNameTypeFromMappedType(targetType)
						constraintType := getConstraintTypeFromMappedType(targetType)
						var targetKeys TODO
						if nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType) {
							mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
							targetKeys = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{mappedKeys, nameType})
						} else {
							targetKeys = nameType || constraintType
						}
						if isRelatedTo(source, targetKeys, RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					}
				}
			} else if targetFlags & TypeFlagsIndexedAccess {
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(Node BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
						result &= isRelatedTo((source).indexType, (target).indexType, RecursionFlagsBoth, reportErrors)
					}
					if result {
						return result
					}
					if reportErrors {
						originalErrorInfo = errorInfo
					}
				}
				if relation == assignableRelation || relation == comparableRelation {
					objectType := (target).objectType
					indexType := (target).indexType
					baseObjectType := getBaseConstraintOfType(objectType) || objectType
					baseIndexType := getBaseConstraintOfType(indexType) || indexType
					if !isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType) {
						accessFlags := AccessFlagsWriting | ( /* TODO(Node ConditionalExpression): baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0 */ TODO)
						constraint := getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
						if constraint {
							if reportErrors && originalErrorInfo {
								resetErrorInfo(saveErrorInfo)
							}
							if /* TODO(Node BinaryExpression): result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
								return result
							}
							if reportErrors && originalErrorInfo && errorInfo {
								errorInfo = /* TODO(Node ConditionalExpression): countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo */ TODO
							}
						}
					}
				}
				if reportErrors {
					originalErrorInfo = nil
				}
			} else if isGenericMappedType(target) && relation != identityRelation {
				keysRemapped := !!target.declaration.nameType
				templateType := getTemplateTypeFromMappedType(target)
				modifiers := getMappedTypeModifiers(target)
				if !(modifiers & MappedTypeModifiersExcludeOptional) {
					if !keysRemapped && templateType.flags&TypeFlagsIndexedAccess && (templateType).objectType == source && (templateType).indexType == getTypeParameterFromMappedType(target) {
						return TernaryTrue
					}
					if !isGenericMappedType(source) {
						targetKeys := /* TODO(Node ConditionalExpression): keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target) */ TODO
						sourceKeys := getIndexType(source, IndexFlagsNoIndexSignatures)
						includeOptional := modifiers & MappedTypeModifiersIncludeOptional
						filteredByApplicability := /* TODO(Node ConditionalExpression): includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined */ TODO
						if /* TODO(Node ConditionalExpression): includeOptional ? !(filteredByApplicability!.flags & TypeFlags.Never) : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both) */ TODO {
							templateType := getTemplateTypeFromMappedType(target)
							typeParameter := getTypeParameterFromMappedType(target)
							nonNullComponent := extractTypesOfKind(templateType, ~TypeFlagsNullable)
							if !keysRemapped && nonNullComponent.flags&TypeFlagsIndexedAccess && (nonNullComponent).indexType == typeParameter {
								if /* TODO(Node BinaryExpression): result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
									return result
								}
							} else {
								indexingType := /* TODO(Node ConditionalExpression): keysRemapped ? (filteredByApplicability || targetKeys) : filteredByApplicability ? getIntersectionType([filteredByApplicability, typeParameter]) : typeParameter */ TODO
								indexedAccessType := getIndexedAccessType(source, indexingType)
								if /* TODO(Node BinaryExpression): result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
									return result
								}
							}
						}
						originalErrorInfo = errorInfo
						resetErrorInfo(saveErrorInfo)
					}
				}
			} else if targetFlags & TypeFlagsConditional {
				if isDeeplyNestedType(target, targetStack, targetDepth, 10) {
					return TernaryMaybe
				}
				c := target
				if !c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags&TypeFlagsConditional && (source).root == c.root) {
					skipTrue := !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType))
					skipFalse := !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType))
					if /* TODO(Node BinaryExpression): result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						result &= /* TODO(Node ConditionalExpression): skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO
						if result {
							return result
						}
					}
				}
			} else if targetFlags & TypeFlagsTemplateLiteral {
				if sourceFlags & TypeFlagsTemplateLiteral {
					if relation == comparableRelation {
						// converted from conditional expression
						switch {
						case templateLiteralTypesDefinitelyUnrelated(source, target):
							return TernaryFalse
						default:
							return TernaryTrue
						}
					}
					instantiateType(source, reportUnreliableMapper)
				}
				if isTypeMatchedByTemplateLiteralType(source, target) {
					return TernaryTrue
				}
			} else if target.flags & TypeFlagsStringMapping {
				if !(source.flags & TypeFlagsStringMapping) {
					if isMemberOfStringMapping(source, target) {
						return TernaryTrue
					}
				}
			}
			if sourceFlags & TypeFlagsTypeVariable {
				if !(sourceFlags&TypeFlagsIndexedAccess && targetFlags&TypeFlagsIndexedAccess) {
					constraint := getConstraintOfType(source) || unknownType
					if /* TODO(Node BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					} else if /* TODO(Node BinaryExpression): result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					}
					if isMappedTypeGenericIndexedAccess(source) {
						indexConstraint := getConstraintOfType((source).indexType)
						if indexConstraint {
							if /* TODO(Node BinaryExpression): result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
								return result
							}
						}
					}
				}
			} else if sourceFlags & TypeFlagsIndex {
				isDeferredMappedIndex := shouldDeferIndexType((source).type_, (source).indexFlags) && getObjectFlags((source).type_)&ObjectFlagsMapped
				if /* TODO(Node BinaryExpression): result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
					return result
				}
				if isDeferredMappedIndex {
					mappedType := (source).type_
					nameType := getNameTypeFromMappedType(mappedType)
					sourceMappedKeys := /* TODO(Node ConditionalExpression): nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) : (nameType || getConstraintTypeFromMappedType(mappedType)) */ TODO
					if /* TODO(Node BinaryExpression): result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else if sourceFlags&TypeFlagsTemplateLiteral && !(targetFlags & TypeFlagsObject) {
				if !(targetFlags & TypeFlagsTemplateLiteral) {
					constraint := getBaseConstraintOfType(source)
					if constraint && constraint != source && ( /* TODO(Node BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsStringMapping {
				if targetFlags & TypeFlagsStringMapping {
					if (source).symbol != (target).symbol {
						return TernaryFalse
					}
					if /* TODO(Node BinaryExpression): result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getBaseConstraintOfType(source)
					if constraint && ( /* TODO(Node BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsConditional {
				if isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
					return TernaryMaybe
				}
				if targetFlags & TypeFlagsConditional {
					sourceParams := (source).root.inferTypeParameters
					sourceExtends := (source).extendsType
					var mapper *TypeMapper
					if sourceParams {
						ctx := createInferenceContext(sourceParams, nil, InferenceFlagsNone, isRelatedToWorker)
						inferTypes(ctx.inferences, (target).extendsType, sourceExtends, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
						sourceExtends = instantiateType(sourceExtends, ctx.mapper)
						mapper = ctx.mapper
					}
					if isTypeIdenticalTo(sourceExtends, (target).extendsType) && (isRelatedTo((source).checkType, (target).checkType, RecursionFlagsBoth) || isRelatedTo((target).checkType, (source).checkType, RecursionFlagsBoth)) {
						if /* TODO(Node BinaryExpression): result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
							result &= isRelatedTo(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target), RecursionFlagsBoth, reportErrors)
						}
						if result {
							return result
						}
					}
				}
				defaultConstraint := getDefaultConstraintOfConditionalType(source)
				if defaultConstraint {
					if /* TODO(Node BinaryExpression): result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
				distributiveConstraint := /* TODO(Node ConditionalExpression): !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined */ TODO
				if distributiveConstraint {
					resetErrorInfo(saveErrorInfo)
					if /* TODO(Node BinaryExpression): result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else {
				if relation != subtypeRelation && relation != strictSubtypeRelation && isPartialMappedType(target) && isEmptyObjectType(source) {
					return TernaryTrue
				}
				if isGenericMappedType(target) {
					if isGenericMappedType(source) {
						if /* TODO(Node BinaryExpression): result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
							return result
						}
					}
					return TernaryFalse
				}
				sourceIsPrimitive := !!(sourceFlags & TypeFlagsPrimitive)
				if relation != identityRelation {
					source = getApparentType(source)
					sourceFlags = source.flags
				} else if isGenericMappedType(source) {
					return TernaryFalse
				}
				if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && (source).target == (target).target && !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target)) {
					if isEmptyArrayLiteralType(source) {
						return TernaryTrue
					}
					variances := getVariances((source).target)
					if variances == emptyArray {
						return TernaryUnknown
					}
					varianceResult := relateVariances(getTypeArguments(source), getTypeArguments(target), variances, intersectionState)
					if varianceResult != nil {
						return varianceResult
					}
				} else if /* TODO(Node ConditionalExpression): isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly) */ TODO {
					if relation != identityRelation {
						return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, RecursionFlagsBoth, reportErrors)
					} else {
						return TernaryFalse
					}
				} else if isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target) {
					constraint := getBaseConstraintOrType(source)
					if constraint != source {
						return isRelatedTo(constraint, target, RecursionFlagsSource, reportErrors)
					}
				} else if (relation == subtypeRelation || relation == strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target)&ObjectFlagsFreshLiteral && !isEmptyObjectType(source) {
					return TernaryFalse
				}
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsObject {
					reportStructuralErrors := reportErrors && errorInfo == saveErrorInfo.errorInfo && !sourceIsPrimitive
					result = propertiesRelatedTo(source, target, reportStructuralErrors, nil, false, intersectionState)
					if result {
						result &= signaturesRelatedTo(source, target, SignatureKindCall, reportStructuralErrors, intersectionState)
						if result {
							result &= signaturesRelatedTo(source, target, SignatureKindConstruct, reportStructuralErrors, intersectionState)
							if result {
								result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState)
							}
						}
					}
					if varianceCheckFailed && result {
						errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo
					} else if result {
						return result
					}
				}
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsUnion {
					objectOnlyTarget := extractTypesOfKind(target, TypeFlagsObject|TypeFlagsIntersection|TypeFlagsSubstitution)
					if objectOnlyTarget.flags & TypeFlagsUnion {
						result := typeRelatedToDiscriminatedType(source, objectOnlyTarget)
						if result {
							return result
						}
					}
				}
			}
			return TernaryFalse
			countMessageChainBreadth := func(info *[]DiagnosticMessageChain) number {
				if !info {
					return 0
				}
				return reduceLeft(info, func(value /* TODO inferred type number */ any, chain /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ any) /* TODO inferred type number */ any {
					return value + 1 + countMessageChainBreadth(chain.next)
				}, 0)
			}
			relateVariances := func(sourceTypeArguments *[]Type, targetTypeArguments *[]Type, variances []VarianceFlags, intersectionState IntersectionState) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary | undefined */ any {
				if /* TODO(Node BinaryExpression): result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
					return result
				}
				if some(variances, func(v /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ any) /* TODO inferred type boolean */ any {
					return !!(v & VarianceFlagsAllowsStructuralFallback)
				}) {
					originalErrorInfo = nil
					resetErrorInfo(saveErrorInfo)
					return nil
				}
				allowStructuralFallback := targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances)
				varianceCheckFailed = !allowStructuralFallback
				if variances != emptyArray && !allowStructuralFallback {
					if varianceCheckFailed && !(reportErrors && some(variances, func(v /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ any) /* TODO inferred type boolean */ any {
						return (v & VarianceFlagsVarianceMask) == VarianceFlagsInvariant
					})) {
						return TernaryFalse
					}
					originalErrorInfo = errorInfo
					resetErrorInfo(saveErrorInfo)
				}
			}
		}
		mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
			modifiersRelated := relation == comparableRelation || ( /* TODO(Node ConditionalExpression): relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) : getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target) */ TODO)
			if modifiersRelated {
				var result Ternary
				targetConstraint := getConstraintTypeFromMappedType(target)
				sourceConstraint := instantiateType(getConstraintTypeFromMappedType(source) /* TODO(Node ConditionalExpression): getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper */, TODO)
				if /* TODO(Node BinaryExpression): result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
					mapper := createTypeMapper([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{getTypeParameterFromMappedType(source)}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{getTypeParameterFromMappedType(target)})
					if instantiateType(getNameTypeFromMappedType(source), mapper) == instantiateType(getNameTypeFromMappedType(target), mapper) {
						return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlagsBoth, reportErrors)
					}
				}
			}
			return TernaryFalse
		}
		typeRelatedToDiscriminatedType := func(source Type, target UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ any {
			sourceProperties := getPropertiesOfType(source)
			sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
			if !sourcePropertiesFiltered {
				return TernaryFalse
			}
			numCombinations := 1
			for _, sourceProperty := range sourcePropertiesFiltered {
				numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty))
				if numCombinations > 25 {
					tracing. /*?*/ instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit" /* TODO(Node ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, numCombinations } */, TODO)
					return TernaryFalse
				}
			}
			var sourceDiscriminantTypes [][]Type = /* TODO(Node NewExpression): new Array<Type[]>(sourcePropertiesFiltered.length) */ TODO
			excludedProperties := make(map[__String]struct{})
			for i := 0; i < sourcePropertiesFiltered.length; i++ {
				sourceProperty := sourcePropertiesFiltered[i]
				sourcePropertyType := getNonMissingTypeOfSymbol(sourceProperty)
				sourceDiscriminantTypes[i] = /* TODO(Node ConditionalExpression): sourcePropertyType.flags & TypeFlags.Union ? (sourcePropertyType as UnionType).types : [sourcePropertyType] */ TODO
				excludedProperties.add(sourceProperty.escapedName)
			}
			discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
			var matchingTypes []Type = [] /* TODO inferred type never */ any{}
			for _, combination := range discriminantCombinations {
				hasMatch := false
				/* TODO(Node LabeledStatement): outer: for (const type of target.types) { for (let i = 0; i < sourcePropertiesFiltered.length; i++) { const sourceProperty = sourcePropertiesFiltered[i]; const targetProperty = getPropertyOfType(type, sourceProperty.escapedName); if (!targetProperty) continue outer; if (sourceProperty === targetProperty) continue; // We compare the source property to the target in the context of a single discriminant type. const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors* / false, IntersectionState.None, /*skipOptional* / strictNullChecks || relation === comparableRelation); // If the target property could not be found, or if the properties were not related, // then this constituent is not a match. if (!related) { continue outer; } } pushIfUnique(matchingTypes, type, equateValues); hasMatch = true; } */
				if !hasMatch {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			for _, type_ := range matchingTypes {
				result &= propertiesRelatedTo(source, type_, false, excludedProperties, false, IntersectionStateNone)
				if result {
					result &= signaturesRelatedTo(source, type_, SignatureKindCall, false, IntersectionStateNone)
					if result {
						result &= signaturesRelatedTo(source, type_, SignatureKindConstruct, false, IntersectionStateNone)
						if result && !(isTupleType(source) && isTupleType(type_)) {
							result &= indexSignaturesRelatedTo(source, type_, false, false, IntersectionStateNone)
						}
					}
				}
				if !result {
					return result
				}
			}
			return result
		}
		excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
			if !excludedProperties || properties.length == 0 {
				return properties
			}
			var result *[]Symbol
			for i := 0; i < properties.length; i++ {
				if !excludedProperties.has(properties[i].escapedName) {
					if result {
						result.push(properties[i])
					}
				} else if !result {
					result = properties.slice(0, i)
				}
			}
			return result || properties
		}
		isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetIsOptional := strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlagsPartial)
			effectiveTarget := addOptionality(getNonMissingTypeOfSymbol(targetProp), false, targetIsOptional)
			effectiveSource := getTypeOfSourceProperty(sourceProp)
			return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlagsBoth, reportErrors, nil, intersectionState)
		}
		propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
			sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
			targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
			if sourcePropFlags&ModifierFlagsPrivate || targetPropFlags&ModifierFlagsPrivate {
				if sourceProp.valueDeclaration != targetProp.valueDeclaration {
					if reportErrors {
						if sourcePropFlags&ModifierFlagsPrivate && targetPropFlags&ModifierFlagsPrivate {
							reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp))
						} else {
							reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString( /* TODO(Node ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? source : target */ TODO), typeToString( /* TODO(Node ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? target : source */ TODO))
						}
					}
					return TernaryFalse
				}
			} else if targetPropFlags & ModifierFlagsProtected {
				if !isValidOverrideOf(sourceProp, targetProp) {
					if reportErrors {
						reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target))
					}
					return TernaryFalse
				}
			} else if sourcePropFlags & ModifierFlagsProtected {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			if relation == strictSubtypeRelation && isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp) {
				return TernaryFalse
			}
			related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
			if !related {
				if reportErrors {
					reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp))
				}
				return TernaryFalse
			}
			if !skipOptional && sourceProp.flags&SymbolFlagsOptional && targetProp.flags&SymbolFlagsClassMember && !(targetProp.flags & SymbolFlagsOptional) {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			return related
		}
		reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
			shouldSkipElaboration := false
			if unmatchedProperty.valueDeclaration && isNamedDeclaration(unmatchedProperty.valueDeclaration) && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name) && source.symbol && source.symbol.flags&SymbolFlagsClass {
				privateIdentifierDescription := unmatchedProperty.valueDeclaration.name.escapedText
				symbolTableKey := getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription)
				if symbolTableKey && getPropertyOfType(source, symbolTableKey) {
					sourceName := factory.getDeclarationName(source.symbol.valueDeclaration)
					targetName := factory.getDeclarationName(target.symbol.valueDeclaration)
					reportError(Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2, diagnosticName(privateIdentifierDescription), diagnosticName( /* TODO(Node ConditionalExpression): sourceName.escapedText === "" ? anon : sourceName */ TODO), diagnosticName( /* TODO(Node ConditionalExpression): targetName.escapedText === "" ? anon : targetName */ TODO))
					return
				}
			}
			props := arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, false))
			if !headMessage || (headMessage.code != Diagnostics.Class_0_incorrectly_implements_interface_1.code && headMessage.code != Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code) {
				shouldSkipElaboration = true
			}
			if props.length == 1 {
				propName := symbolToString(unmatchedProperty, nil, SymbolFlagsNone, SymbolFormatFlagsAllowAnyNodeKind|SymbolFormatFlagsWriteComputedProps)
				reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, getTypeNamesForErrorDisplay(source, target)...)
				if length(unmatchedProperty.declarations) {
					associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations[0], Diagnostics._0_is_declared_here, propName))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			} else if tryElaborateArrayLikeErrors(source, target, false) {
				if props.length > 5 {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map_(props.slice(0, 4), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type string */ any {
						return symbolToString(p)
					}).join(", "), props.length-4)
				} else {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map_(props, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type string */ any {
						return symbolToString(p)
					}).join(", "))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			}
		}
		propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return propertiesIdenticalTo(source, target, excludedProperties)
			}
			result := TernaryTrue
			if isTupleType(target) {
				if isArrayOrTupleType(source) {
					if !target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly) {
						return TernaryFalse
					}
					sourceArity := getTypeReferenceArity(source)
					targetArity := getTypeReferenceArity(target)
					sourceRestFlag := /* TODO(Node ConditionalExpression): isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest */ TODO
					targetHasRestElement := !!(target.target.combinedFlags & ElementFlagsVariable)
					sourceMinLength := /* TODO(Node ConditionalExpression): isTupleType(source) ? source.target.minLength : 0 */ TODO
					targetMinLength := target.target.minLength
					if !sourceRestFlag && sourceArity < targetMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && targetArity < sourceMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && (sourceRestFlag || targetArity < sourceArity) {
						if reportErrors {
							if sourceMinLength < targetMinLength {
								reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength)
							} else {
								reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity)
							}
						}
						return TernaryFalse
					}
					sourceTypeArguments := getTypeArguments(source)
					targetTypeArguments := getTypeArguments(target)
					targetStartCount := getStartElementCount(target.target, ElementFlagsNonRest)
					targetEndCount := getEndElementCount(target.target, ElementFlagsNonRest)
					canExcludeDiscriminants := !!excludedProperties
					for sourcePosition := 0; sourcePosition < sourceArity; sourcePosition++ {
						sourceFlags := /* TODO(Node ConditionalExpression): isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest */ TODO
						sourcePositionFromEnd := sourceArity - 1 - sourcePosition
						targetPosition := /* TODO(Node ConditionalExpression): targetHasRestElement && sourcePosition >= targetStartCount ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount) : sourcePosition */ TODO
						targetFlags := target.target.elementFlags[targetPosition]
						if targetFlags&ElementFlagsVariadic && !(sourceFlags & ElementFlagsVariadic) {
							if reportErrors {
								reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition)
							}
							return TernaryFalse
						}
						if sourceFlags&ElementFlagsVariadic && !(targetFlags & ElementFlagsVariable) {
							if reportErrors {
								reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition)
							}
							return TernaryFalse
						}
						if targetFlags&ElementFlagsRequired && !(sourceFlags & ElementFlagsRequired) {
							if reportErrors {
								reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition)
							}
							return TernaryFalse
						}
						if canExcludeDiscriminants {
							if sourceFlags&ElementFlagsVariable || targetFlags&ElementFlagsVariable {
								canExcludeDiscriminants = false
							}
							if canExcludeDiscriminants && excludedProperties. /*?*/ has(("" + sourcePosition)) {
								continue
							}
						}
						sourceType := removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlagsOptional))
						targetType := targetTypeArguments[targetPosition]
						targetCheckType := /* TODO(Node ConditionalExpression): sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) : removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional)) */ TODO
						related := isRelatedTo(sourceType, targetCheckType, RecursionFlagsBoth, reportErrors, nil, intersectionState)
						if !related {
							if reportErrors && (targetArity > 1 || sourceArity > 1) {
								if targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount != sourceArity-targetEndCount-1 {
									reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity-targetEndCount-1, targetPosition)
								} else {
									reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition)
								}
							}
							return TernaryFalse
						}
						result &= related
					}
					return result
				}
				if target.target.combinedFlags & ElementFlagsVariable {
					return TernaryFalse
				}
			}
			requireOptionalProperties := (relation == subtypeRelation || relation == strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source)
			unmatchedProperty := getUnmatchedProperty(source, target, requireOptionalProperties, false)
			if unmatchedProperty {
				if reportErrors && shouldReportUnmatchedPropertyError(source, target) {
					reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties)
				}
				return TernaryFalse
			}
			if isObjectLiteralType(target) {
				for _, sourceProp := range excludeProperties(getPropertiesOfType(source), excludedProperties) {
					if !getPropertyOfObjectType(target, sourceProp.escapedName) {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags & TypeFlagsUndefined) {
							if reportErrors {
								reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target))
							}
							return TernaryFalse
						}
					}
				}
			}
			properties := getPropertiesOfType(target)
			numericNamesOnly := isTupleType(source) && isTupleType(target)
			for _, targetProp := range excludeProperties(properties, excludedProperties) {
				name := targetProp.escapedName
				if !(targetProp.flags & SymbolFlagsPrototype) && (!numericNamesOnly || isNumericLiteralName(name) || name == "length") && (!optionalsOnly || targetProp.flags&SymbolFlagsOptional) {
					sourceProp := getPropertyOfType(source, name)
					if sourceProp && sourceProp != targetProp {
						related := propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation == comparableRelation)
						if !related {
							return TernaryFalse
						}
						result &= related
					}
				}
			}
			return result
		}
		propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
			if !(source.flags&TypeFlagsObject && target.flags&TypeFlagsObject) {
				return TernaryFalse
			}
			sourceProperties := excludeProperties(getPropertiesOfObjectType(source), excludedProperties)
			targetProperties := excludeProperties(getPropertiesOfObjectType(target), excludedProperties)
			if sourceProperties.length != targetProperties.length {
				return TernaryFalse
			}
			result := TernaryTrue
			for _, sourceProp := range sourceProperties {
				targetProp := getPropertyOfObjectType(target, sourceProp.escapedName)
				if !targetProp {
					return TernaryFalse
				}
				related := compareProperties(sourceProp, targetProp, isRelatedTo)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return signaturesIdenticalTo(source, target, kind)
			}
			if target == anyFunctionType || source == anyFunctionType {
				return TernaryTrue
			}
			sourceIsJSConstructor := source.symbol && isJSConstructor(source.symbol.valueDeclaration)
			targetIsJSConstructor := target.symbol && isJSConstructor(target.symbol.valueDeclaration)
			sourceSignatures := getSignaturesOfType(source /* TODO(Node ConditionalExpression): (sourceIsJSConstructor && kind === SignatureKind.Construct) ? SignatureKind.Call : kind */, TODO)
			targetSignatures := getSignaturesOfType(target /* TODO(Node ConditionalExpression): (targetIsJSConstructor && kind === SignatureKind.Construct) ? SignatureKind.Call : kind */, TODO)
			if kind == SignatureKindConstruct && sourceSignatures.length && targetSignatures.length {
				sourceIsAbstract := !!(sourceSignatures[0].flags & SignatureFlagsAbstract)
				targetIsAbstract := !!(targetSignatures[0].flags & SignatureFlagsAbstract)
				if sourceIsAbstract && !targetIsAbstract {
					if reportErrors {
						reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type)
					}
					return TernaryFalse
				}
				if !constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors) {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			incompatibleReporter := /* TODO(Node ConditionalExpression): kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn */ TODO
			sourceObjectFlags := getObjectFlags(source)
			targetObjectFlags := getObjectFlags(target)
			if sourceObjectFlags&ObjectFlagsInstantiated && targetObjectFlags&ObjectFlagsInstantiated && source.symbol == target.symbol || sourceObjectFlags&ObjectFlagsReference && targetObjectFlags&ObjectFlagsReference && (source).target == (target).target {
				Debug.assertEqual(sourceSignatures.length, targetSignatures.length)
				for i := 0; i < targetSignatures.length; i++ {
					related := signatureRelatedTo(sourceSignatures[i], targetSignatures[i], true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]))
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			} else if sourceSignatures.length == 1 && targetSignatures.length == 1 {
				eraseGenerics := relation == comparableRelation
				sourceSignature := first(sourceSignatures)
				targetSignature := first(targetSignatures)
				result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature))
				if !result && reportErrors && kind == SignatureKindConstruct && (sourceObjectFlags & targetObjectFlags) && (targetSignature.declaration. /*?*/ kind == SyntaxKindConstructor || sourceSignature.declaration. /*?*/ kind == SyntaxKindConstructor) {
					constructSignatureToString := func(signature Signature) /* TODO inferred type string */ any {
						return signatureToString(signature, nil, TypeFormatFlagsWriteArrowStyleSignature, kind)
					}
					reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature))
					reportError(Diagnostics.Types_of_construct_signatures_are_incompatible)
					return result
				}
			} else {
				/* TODO(Node LabeledStatement): outer: for (const t of targetSignatures) { const saveErrorInfo = captureErrorCalculationState(); // Only elaborate errors from the first failure let shouldElaborateErrors = reportErrors; for (const s of sourceSignatures) { const related = signatureRelatedTo(s, t, /*erase* / true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t)); if (related) { result &= related; resetErrorInfo(saveErrorInfo); continue outer; } shouldElaborateErrors = false; } if (shouldElaborateErrors) { reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration* / undefined, /*flags* / undefined, kind)); } return Ternary.False; } */
			}
			return result
		}
		shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
			typeCallSignatures := getSignaturesOfStructuredType(source, SignatureKindCall)
			typeConstructSignatures := getSignaturesOfStructuredType(source, SignatureKindConstruct)
			typeProperties := getPropertiesOfObjectType(source)
			if (typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length {
				if (getSignaturesOfType(target, SignatureKindCall).length && typeCallSignatures.length) || (getSignaturesOfType(target, SignatureKindConstruct).length && typeConstructSignatures.length) {
					return true
				}
				return false
			}
			return true
		}
		reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO inferred type (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ any {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					return reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target))
				}
			}
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target))
			}
		}
		reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO inferred type (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ any {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					return reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, typeToString(source), typeToString(target))
				}
			}
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, typeToString(source), typeToString(target))
			}
		}
		signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type)) Ternary {
			checkMode := /* TODO(Node ConditionalExpression): relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature : relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity : SignatureCheckMode.None */ TODO
			return compareSignaturesRelated( /* TODO(Node ConditionalExpression): erase ? getErasedSignature(source) : source */ TODO /* TODO(Node ConditionalExpression): erase ? getErasedSignature(target) : target */, TODO, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper)
			isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ any {
				return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors, nil, intersectionState)
			}
		}
		signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
			sourceSignatures := getSignaturesOfType(source, kind)
			targetSignatures := getSignaturesOfType(target, kind)
			if sourceSignatures.length != targetSignatures.length {
				return TernaryFalse
			}
			result := TernaryTrue
			for i := 0; i < sourceSignatures.length; i++ {
				related := compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], false, false, false, isRelatedTo)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			keyType := targetInfo.keyType
			props := /* TODO(Node ConditionalExpression): source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source) */ TODO
			for _, prop := range props {
				if isIgnoredJsxProperty(source, prop) {
					continue
				}
				if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), keyType) {
					propType := getNonMissingTypeOfSymbol(prop)
					type_ := /* TODO(Node ConditionalExpression): exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional) ? propType : getTypeWithFacts(propType, TypeFacts.NEUndefined) */ TODO
					related := isRelatedTo(type_, targetInfo.type_, RecursionFlagsBoth, reportErrors, nil, intersectionState)
					if !related {
						if reportErrors {
							reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop))
						}
						return TernaryFalse
					}
					result &= related
				}
			}
			for _, info := range getIndexInfosOfType(source) {
				if isApplicableIndexType(info.keyType, keyType) {
					related := indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
			return result
		}
		indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ any {
			related := isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth, reportErrors, nil, intersectionState)
			if !related && reportErrors {
				if sourceInfo.keyType == targetInfo.keyType {
					reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType))
				} else {
					reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType))
				}
			}
			return related
		}
		indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return indexSignaturesIdenticalTo(source, target)
			}
			indexInfos := getIndexInfosOfType(target)
			targetHasStringIndex := some(indexInfos, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type boolean */ any {
				return info.keyType == stringType
			})
			result := TernaryTrue
			for _, targetInfo := range indexInfos {
				related := /* TODO(Node ConditionalExpression): relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True : isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) : typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState) */ TODO
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
			if sourceInfo {
				return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
			}
			if !(intersectionState & IntersectionStateSource) && (relation != strictSubtypeRelation || getObjectFlags(source)&ObjectFlagsFreshLiteral) && isObjectTypeWithInferableIndex(source) {
				return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
			}
			if reportErrors {
				reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source))
			}
			return TernaryFalse
		}
		indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
			sourceInfos := getIndexInfosOfType(source)
			targetInfos := getIndexInfosOfType(target)
			if sourceInfos.length != targetInfos.length {
				return TernaryFalse
			}
			for _, targetInfo := range targetInfos {
				sourceInfo := getIndexInfoOfType(source, targetInfo.keyType)
				if !(sourceInfo && isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth) && sourceInfo.isReadonly == targetInfo.isReadonly) {
					return TernaryFalse
				}
			}
			return TernaryTrue
		}
		constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) /* TODO inferred type boolean */ any {
			if !sourceSignature.declaration || !targetSignature.declaration {
				return true
			}
			sourceAccessibility := getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			targetAccessibility := getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			if targetAccessibility == ModifierFlagsPrivate {
				return true
			}
			if targetAccessibility == ModifierFlagsProtected && sourceAccessibility != ModifierFlagsPrivate {
				return true
			}
			if targetAccessibility != ModifierFlagsProtected && !sourceAccessibility {
				return true
			}
			if reportErrors {
				reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility))
			}
			return false
		}
	}
	typeCouldHaveTopLevelSingletonTypes := func(type_ Type) bool {
		if type_.flags & TypeFlagsBoolean {
			return false
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			return !!forEach((type_).types, typeCouldHaveTopLevelSingletonTypes)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getConstraintOfType(type_)
			if constraint && constraint != type_ {
				return typeCouldHaveTopLevelSingletonTypes(constraint)
			}
		}
		return isUnitType(type_) || !!(type_.flags & TypeFlagsTemplateLiteral) || !!(type_.flags & TypeFlagsStringMapping)
	}
	getExactOptionalUnassignableProperties := func(source Type, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
		if isTupleType(source) && isTupleType(target) {
			return emptyArray
		}
		return getPropertiesOfType(target).filter(func(targetProp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return isExactOptionalPropertyMismatch(getTypeOfPropertyOfType(source, targetProp.escapedName), getTypeOfSymbol(targetProp))
		})
	}
	isExactOptionalPropertyMismatch := func(source *Type, target *Type) /* TODO inferred type boolean */ any {
		return !!source && !!target && maybeTypeOfKind(source, TypeFlagsUndefined) && !!containsMissingType(target)
	}
	getExactOptionalProperties := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
		return getPropertiesOfType(type_).filter(func(targetProp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return containsMissingType(getTypeOfSymbol(targetProp))
		})
	}
	getBestMatchingType := func(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO inferred type (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ any /*  = compareTypesAssignable */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		return findMatchingDiscriminantType(source, target, isRelatedTo) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target) || findBestTypeForInvokable(source, target) || findMostOverlappyType(source, target)
	}
	discriminateTypeByDiscriminableItems := func(target UnionType, discriminators [] /* TODO(TypeNode TupleType): [() => Type, __String] */ any, related func(source Type, target Type) /* TODO(TypeNode UnionType): boolean | Ternary */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		types := target.types
		var include []Ternary = types.map_(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.False | import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.True */ any {
			return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Primitive ? Ternary.False : Ternary.True */ TODO
		})
		for _, TODO_IDENTIFIER := range discriminators {
			matched := false
			for i := 0; i < types.length; i++ {
				if include[i] {
					targetType := getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName)
					if targetType && someType(getDiscriminatingType(), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return !!related(t, targetType)
					}) {
						matched = true
					} else {
						include[i] = TernaryMaybe
					}
				}
			}
			for i := 0; i < types.length; i++ {
				if include[i] == TernaryMaybe {
					include[i] = /* TODO(Node ConditionalExpression): matched ? Ternary.False : Ternary.True */ TODO
				}
			}
		}
		filtered := /* TODO(Node ConditionalExpression): contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target */ TODO
		// converted from conditional expression
		switch {
		case filtered.flags & TypeFlagsNever:
			return target
		default:
			return filtered
		}
	}
	isWeakType := func(type_ Type) bool {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			return resolved.callSignatures.length == 0 && resolved.constructSignatures.length == 0 && resolved.indexInfos.length == 0 && resolved.properties.length > 0 && every(resolved.properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
				return !!(p.flags & SymbolFlagsOptional)
			})
		}
		if type_.flags & TypeFlagsSubstitution {
			return isWeakType((type_).baseType)
		}
		if type_.flags & TypeFlagsIntersection {
			return every((type_).types, isWeakType)
		}
		return false
	}
	hasCommonProperties := func(source Type, target Type, isComparingJsxAttributes bool) /* TODO inferred type boolean */ any {
		for _, prop := range getPropertiesOfType(source) {
			if isKnownProperty(target, prop.escapedName, isComparingJsxAttributes) {
				return true
			}
		}
		return false
	}
	getVariances := func(type_ GenericType) []VarianceFlags {
		// converted from conditional expression
		switch {
		case type_ == globalArrayType || type_ == globalReadonlyArrayType || type_.objectFlags&ObjectFlagsTuple:
			return arrayVariances
		default:
			return getVariancesWorker(type_.symbol, type_.typeParameters)
		}
	}
	getAliasVariances := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags[] */ any {
		return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters)
	}
	getVariancesWorker := func(symbol Symbol, typeParameters []TypeParameter /*  = emptyArray */) []VarianceFlags {
		links := getSymbolLinks(symbol)
		if !links.variances {
			tracing. /*?*/ push(tracing.Phase.CheckTypes, "getVariancesWorker" /* TODO(Node ObjectLiteralExpression): { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) } */, TODO)
			oldVarianceComputation := inVarianceComputation
			saveResolutionStart := resolutionStart
			if !inVarianceComputation {
				inVarianceComputation = true
				resolutionStart = resolutionTargets.length
			}
			links.variances = emptyArray
			variances := [] /* TODO inferred type never */ any{}
			for _, tp := range typeParameters {
				modifiers := getTypeParameterModifiers(tp)
				variance := /* TODO(Node ConditionalExpression): modifiers & ModifierFlags.Out ? modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant : modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined */ TODO
				if variance == nil {
					unmeasurable := false
					unreliable := false
					oldHandler := outofbandVarianceMarkerHandler
					outofbandVarianceMarkerHandler = func(onlyUnreliable /* TODO inferred type boolean */ any) /* TODO inferred type boolean */ any {
						return /* TODO(Node ConditionalExpression): onlyUnreliable ? unreliable = true : unmeasurable = true */ TODO
					}
					typeWithSuper := createMarkerType(symbol, tp, markerSuperType)
					typeWithSub := createMarkerType(symbol, tp, markerSubType)
					variance = ( /* TODO(Node ConditionalExpression): isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0 */ TODO)
					if variance == VarianceFlagsBivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper) {
						variance = VarianceFlagsIndependent
					}
					outofbandVarianceMarkerHandler = oldHandler
					if unmeasurable || unreliable {
						if unmeasurable {
							variance |= VarianceFlagsUnmeasurable
						}
						if unreliable {
							variance |= VarianceFlagsUnreliable
						}
					}
				}
				variances.push(variance)
			}
			if !oldVarianceComputation {
				inVarianceComputation = false
				resolutionStart = saveResolutionStart
			}
			links.variances = variances
			tracing. /*?*/ pop( /* TODO(Node ObjectLiteralExpression): { variances: variances.map(Debug.formatVariance) } */ TODO)
		}
		return links.variances
	}
	createMarkerType := func(symbol Symbol, source TypeParameter, target Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		mapper := makeUnaryTypeMapper(source, target)
		type_ := getDeclaredTypeOfSymbol(symbol)
		if isErrorType(type_) {
			return type_
		}
		result := /* TODO(Node ConditionalExpression): symbol.flags & SymbolFlags.TypeAlias ? getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) : createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper)) */ TODO
		markerTypes.add(getTypeId(result))
		return result
	}
	isMarkerType := func(type_ Type) /* TODO inferred type boolean */ any {
		return markerTypes.has(getTypeId(type_))
	}
	getTypeParameterModifiers := func(tp TypeParameter) ModifierFlags {
		return reduceLeft(tp.symbol. /*?*/ declarations, func(modifiers /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ any, d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type number */ any {
			return modifiers | getEffectiveModifierFlags(d)
		}, ModifierFlagsNone) & (ModifierFlagsIn | ModifierFlagsOut | ModifierFlagsConst)
	}
	hasCovariantVoidArgument := func(typeArguments []Type, variances []VarianceFlags) bool {
		for i := 0; i < variances.length; i++ {
			if (variances[i]&VarianceFlagsVarianceMask) == VarianceFlagsCovariant && typeArguments[i].flags&TypeFlagsVoid {
				return true
			}
		}
		return false
	}
	isUnconstrainedTypeParameter := func(type_ Type) /* TODO inferred type boolean | 0 */ any {
		return type_.flags&TypeFlagsTypeParameter && !getConstraintOfTypeParameter(type_)
	}
	isNonDeferredTypeReference := func(type_ Type) /* TODO(TypeNode TypePredicate): type is TypeReference */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && !(type_).node
	}
	isTypeReferenceWithGenericArguments := func(type_ Type) bool {
		return isNonDeferredTypeReference(type_) && some(getTypeArguments(type_), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & TypeFlagsTypeParameter) || isTypeReferenceWithGenericArguments(t)
		})
	}
	getGenericTypeReferenceRelationKey := func(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) /* TODO inferred type string */ any {
		var typeParameters []Type = [] /* TODO inferred type never */ any{}
		constraintMarker := ""
		sourceId := getTypeReferenceId(source, 0)
		targetId := getTypeReferenceId(target, 0)
		return /* TODO(Node TemplateExpression): `${constraintMarker}${sourceId},${targetId}${postFix}` */ TODO
		getTypeReferenceId := func(type_ TypeReference, depth /* TODO inferred type number */ any /*  = 0 */) /* TODO inferred type string */ any {
			result := "" + type_.target.id
			for _, t := range getTypeArguments(type_) {
				if t.flags & TypeFlagsTypeParameter {
					if ignoreConstraints || isUnconstrainedTypeParameter(t) {
						index := typeParameters.indexOf(t)
						if index < 0 {
							index = typeParameters.length
							typeParameters.push(t)
						}
						result += "=" + index
						continue
					}
					constraintMarker = "*"
				} else if depth < 4 && isTypeReferenceWithGenericArguments(t) {
					result += "<" + getTypeReferenceId(t, depth+1) + ">"
					continue
				}
				result += "-" + t.id
			}
			return result
		}
	}
	getRelationKey := func(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) /* TODO inferred type string */ any {
		if relation == identityRelation && source.id > target.id {
			temp := source
			source = target
			target = temp
		}
		postFix := /* TODO(Node ConditionalExpression): intersectionState ? ":" + intersectionState : "" */ TODO
		// converted from conditional expression
		switch {
		case isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target):
			return getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints)
		default:
			return /* TODO(Node TemplateExpression): `${source.id},${target.id}${postFix}` */ TODO
		}
	}
	forEachProperty := func(prop Symbol, callback func(p Symbol) T) *T {
		if getCheckFlags(prop) & CheckFlagsSynthetic {
			for _, t := range (prop).links.containingType.types {
				p := getPropertyOfType(t, prop.escapedName)
				result := p && forEachProperty(p, callback)
				if result {
					return result
				}
			}
			return nil
		}
		return callback(prop)
	}
	getDeclaringClass := func(prop Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ any {
		// converted from conditional expression
		switch {
		case prop.parent && prop.parent.flags&SymbolFlagsClass:
			return getDeclaredTypeOfSymbol(getParentOfSymbol(prop))
		default:
			return nil
		}
	}
	getTypeOfPropertyInBaseClass := func(property Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		classType := getDeclaringClass(property)
		baseClassType := classType && getBaseTypes(classType)[0]
		return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName)
	}
	isPropertyInClassDerivedFrom := func(prop Symbol, baseClass *Type) /* TODO inferred type boolean | undefined */ any {
		return forEachProperty(prop, func(sp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			sourceClass := getDeclaringClass(sp)
			// converted from conditional expression
			switch {
			case sourceClass:
				return hasBaseType(sourceClass, baseClass)
			default:
				return false
			}
		})
	}
	isValidOverrideOf := func(sourceProp Symbol, targetProp Symbol) /* TODO inferred type boolean */ any {
		return !forEachProperty(targetProp, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return /* TODO(Node ConditionalExpression): getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected ? !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false */ TODO
		})
	}
	isClassDerivedFromDeclaringClasses := func(checkClass T, prop Symbol, writing bool) /* TODO inferred type T | undefined */ any {
		// converted from conditional expression
		switch {
		case forEachProperty(prop, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return /* TODO(Node ConditionalExpression): getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ? !hasBaseType(checkClass, getDeclaringClass(p)) : false */ TODO
		}):
			return nil
		default:
			return checkClass
		}
	}
	isDeeplyNestedType := func(type_ Type, stack []Type, depth number, maxDepth /* TODO inferred type number */ any /*  = 3 */) bool {
		if depth >= maxDepth {
			if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
				type_ = getMappedTargetWithSymbol(type_)
			}
			if type_.flags & TypeFlagsIntersection {
				return some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isDeeplyNestedType(t, stack, depth, maxDepth)
				})
			}
			identity := getRecursionIdentity(type_)
			count := 0
			lastTypeId := 0
			for i := 0; i < depth; i++ {
				t := stack[i]
				if hasMatchingRecursionIdentity(t, identity) {
					if t.id >= lastTypeId {
						count++
						if count >= maxDepth {
							return true
						}
					}
					lastTypeId = t.id
				}
			}
		}
		return false
	}
	getMappedTargetWithSymbol := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		var target TODO
		for (getObjectFlags(type_)&ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped && ( /* TODO(Node BinaryExpression): target = getModifiersTypeFromMappedType(type as MappedType) */ TODO) && (target.symbol || target.flags&TypeFlagsIntersection && some((target).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type true */ any {
			return !!t.symbol
		})) {
			type_ = target
		}
		return type_
	}
	hasMatchingRecursionIdentity := func(type_ Type, identity /* TODO(Node ObjectKeyword): object */ any) bool {
		if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
			type_ = getMappedTargetWithSymbol(type_)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return hasMatchingRecursionIdentity(t, identity)
			})
		}
		return getRecursionIdentity(type_) == identity
	}
	getRecursionIdentity := func(type_ Type) /* TODO(Node ObjectKeyword): object */ any {
		if type_.flags&TypeFlagsObject && !isObjectOrArrayLiteralType(type_) {
			if getObjectFlags(type_)&ObjectFlagsReference && (type_).node {
				return (type_).node
			}
			if type_.symbol && !(getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol.flags&SymbolFlagsClass) {
				return type_.symbol
			}
			if isTupleType(type_) {
				return type_.target
			}
		}
		if type_.flags & TypeFlagsTypeParameter {
			return type_.symbol
		}
		if type_.flags & TypeFlagsIndexedAccess {
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = type_.flags & TypeFlagsIndexedAccess {
				type_ = (type_).objectType
			}
			return type_
		}
		if type_.flags & TypeFlagsConditional {
			return (type_).root
		}
		return type_
	}
	isPropertyIdenticalTo := func(sourceProp Symbol, targetProp Symbol) bool {
		return compareProperties(sourceProp, targetProp, compareTypesIdentical) != TernaryFalse
	}
	compareProperties := func(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
		if sourceProp == targetProp {
			return TernaryTrue
		}
		sourcePropAccessibility := getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlagsNonPublicAccessibilityModifier
		targetPropAccessibility := getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlagsNonPublicAccessibilityModifier
		if sourcePropAccessibility != targetPropAccessibility {
			return TernaryFalse
		}
		if sourcePropAccessibility {
			if getTargetSymbol(sourceProp) != getTargetSymbol(targetProp) {
				return TernaryFalse
			}
		} else {
			if (sourceProp.flags & SymbolFlagsOptional) != (targetProp.flags & SymbolFlagsOptional) {
				return TernaryFalse
			}
		}
		if isReadonlySymbol(sourceProp) != isReadonlySymbol(targetProp) {
			return TernaryFalse
		}
		return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp))
	}
	isMatchingSignature := func(source Signature, target Signature, partialMatch bool) /* TODO inferred type boolean */ any {
		sourceParameterCount := getParameterCount(source)
		targetParameterCount := getParameterCount(target)
		sourceMinArgumentCount := getMinArgumentCount(source)
		targetMinArgumentCount := getMinArgumentCount(target)
		sourceHasRestParameter := hasEffectiveRestParameter(source)
		targetHasRestParameter := hasEffectiveRestParameter(target)
		if sourceParameterCount == targetParameterCount && sourceMinArgumentCount == targetMinArgumentCount && sourceHasRestParameter == targetHasRestParameter {
			return true
		}
		if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
			return true
		}
		return false
	}
	compareSignaturesIdentical := func(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
		if source == target {
			return TernaryTrue
		}
		if !(isMatchingSignature(source, target, partialMatch)) {
			return TernaryFalse
		}
		if length(source.typeParameters) != length(target.typeParameters) {
			return TernaryFalse
		}
		if target.typeParameters {
			mapper := createTypeMapper(source.typeParameters, target.typeParameters)
			for i := 0; i < target.typeParameters.length; i++ {
				s := source.typeParameters[i]
				t := target.typeParameters[i]
				if !(s == t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) && compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType)) {
					return TernaryFalse
				}
			}
			source = instantiateSignature(source, mapper, true)
		}
		result := TernaryTrue
		if !ignoreThisTypes {
			sourceThisType := getThisTypeOfSignature(source)
			if sourceThisType {
				targetThisType := getThisTypeOfSignature(target)
				if targetThisType {
					related := compareTypes(sourceThisType, targetThisType)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
		}
		targetLen := getParameterCount(target)
		for i := 0; i < targetLen; i++ {
			s := getTypeAtPosition(source, i)
			t := getTypeAtPosition(target, i)
			related := compareTypes(t, s)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		if !ignoreReturnTypes {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			targetTypePredicate := getTypePredicateOfSignature(target)
			result &= /* TODO(Node ConditionalExpression): sourceTypePredicate || targetTypePredicate ? compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) : compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target)) */ TODO
		}
		return result
	}
	compareTypePredicatesIdentical := func(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
		// converted from conditional expression
		switch {
		case !(source && target && typePredicateKindsMatch(source, target)):
			return TernaryFalse
		case source.type_ == target.type_:
			return TernaryTrue
		case source.type_ && target.type_:
			return compareTypes(source.type_, target.type_)
		default:
			return TernaryFalse
		}
	}
	literalTypesWithSameBaseType := func(types []Type) bool {
		var commonBaseType *Type
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				baseType := getBaseTypeOfLiteralType(t)
				/* TODO(Node BinaryExpression): commonBaseType ??= baseType */ TODO
				if baseType == t || baseType != commonBaseType {
					return false
				}
			}
		}
		return true
	}
	getCombinedTypeFlags := func(types []Type) TypeFlags {
		return reduceLeft(types, func(flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
			return flags | ( /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags */ TODO)
		}, 0)
	}
	getCommonSupertype := func(types []Type) Type {
		if types.length == 1 {
			return types[0]
		}
		primaryTypes := /* TODO(Node ConditionalExpression): strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types */ TODO
		superTypeOrUnion := /* TODO(Node ConditionalExpression): literalTypesWithSameBaseType(primaryTypes) ? getUnionType(primaryTypes) : reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s)! */ TODO
		// converted from conditional expression
		switch {
		case primaryTypes == types:
			return superTypeOrUnion
		default:
			return getNullableType(superTypeOrUnion, getCombinedTypeFlags(types)&TypeFlagsNullable)
		}
	}
	getCommonSubtype := func(types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return reduceLeft(types, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): isTypeSubtypeOf(t, s) ? t : s */ TODO
		})
	}
	isArrayType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is TypeReference */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && ((type_).target == globalArrayType || (type_).target == globalReadonlyArrayType)
	}
	isReadonlyArrayType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && (type_).target == globalReadonlyArrayType
	}
	isArrayOrTupleType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is TypeReference */ any {
		return isArrayType(type_) || isTupleType(type_)
	}
	isMutableArrayOrTuple := func(type_ Type) bool {
		return isArrayType(type_) && !isReadonlyArrayType(type_) || isTupleType(type_) && !type_.target.readonly
	}
	getElementTypeOfArrayType := func(type_ Type) *Type {
		// converted from conditional expression
		switch {
		case isArrayType(type_):
			return getTypeArguments(type_)[0]
		default:
			return nil
		}
	}
	isArrayLikeType := func(type_ Type) bool {
		return isArrayType(type_) || !(type_.flags&TypeFlagsNullable) && isTypeAssignableTo(type_, anyReadonlyArrayType)
	}
	isMutableArrayLikeType := func(type_ Type) bool {
		return isMutableArrayOrTuple(type_) || !(type_.flags&(TypeFlagsAny|TypeFlagsNullable)) && isTypeAssignableTo(type_, anyArrayType)
	}
	getSingleBaseForNonAugmentingSubtype := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if !(getObjectFlags(type_) & ObjectFlagsReference) || !(getObjectFlags((type_).target) & ObjectFlagsClassOrInterface) {
			return nil
		}
		if getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeCalculated {
			// converted from conditional expression
			switch {
			case getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeExists:
				return (type_).cachedEquivalentBaseType
			default:
				return nil
			}
		}
		(type_).objectFlags |= ObjectFlagsIdenticalBaseTypeCalculated
		target := (type_).target
		if getObjectFlags(target) & ObjectFlagsClass {
			baseTypeNode := getBaseTypeNodeOfClass(target)
			if baseTypeNode && baseTypeNode.expression.kind != SyntaxKindIdentifier && baseTypeNode.expression.kind != SyntaxKindPropertyAccessExpression {
				return nil
			}
		}
		bases := getBaseTypes(target)
		if bases.length != 1 {
			return nil
		}
		if getMembersOfSymbol(type_.symbol).size {
			return nil
		}
		instantiatedBase := /* TODO(Node ConditionalExpression): !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length))) */ TODO
		if length(getTypeArguments(type_)) > length(target.typeParameters) {
			instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type_)))
		}
		(type_).objectFlags |= ObjectFlagsIdenticalBaseTypeExists
		(type_).cachedEquivalentBaseType = instantiatedBase
		return (type_).cachedEquivalentBaseType
	}
	isEmptyLiteralType := func(type_ Type) bool {
		// converted from conditional expression
		switch {
		case strictNullChecks:
			return type_ == implicitNeverType
		default:
			return type_ == undefinedWideningType
		}
	}
	isEmptyArrayLiteralType := func(type_ Type) bool {
		elementType := getElementTypeOfArrayType(type_)
		return !!elementType && isEmptyLiteralType(elementType)
	}
	isTupleLikeType := func(type_ Type) bool {
		var lengthType TODO
		return isTupleType(type_) || !!getPropertyOfType(type_, "0") || isArrayLikeType(type_) && !!( /* TODO(Node BinaryExpression): lengthType = getTypeOfPropertyOfType(type, "length" as __String) */ TODO) && everyType(lengthType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & TypeFlagsNumberLiteral)
		})
	}
	isArrayOrTupleLikeType := func(type_ Type) bool {
		return isArrayLikeType(type_) || isTupleLikeType(type_)
	}
	getTupleElementType := func(type_ Type, index number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		propType := getTypeOfPropertyOfType(type_, ""+index)
		if propType {
			return propType
		}
		if everyType(type_, isTupleType) {
			return getTupleElementTypeOutOfStartCount(type_, index /* TODO(Node ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined */, TODO)
		}
		return nil
	}
	isNeitherUnitTypeNorNever := func(type_ Type) bool {
		return !(type_.flags & (TypeFlagsUnit | TypeFlagsNever))
	}
	isUnitType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsUnit)
	}
	isUnitLikeType := func(type_ Type) bool {
		t := getBaseConstraintOrType(type_)
		// converted from conditional expression
		switch {
		case t.flags & TypeFlagsIntersection:
			return some((t).types, isUnitType)
		default:
			return isUnitType(t)
		}
	}
	extractUnitType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return find((type_).types, isUnitType) || type_
		default:
			return type_
		}
	}
	isLiteralType := func(type_ Type) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsBoolean:
			return true
		case type_.flags & TypeFlagsUnion:
			// converted from conditional expression
			switch {
			case type_.flags & TypeFlagsEnumLiteral:
				return true
			default:
				return every((type_).types, isUnitType)
			}
		default:
			return isUnitType(type_)
		}
	}
	getBaseTypeOfLiteralType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsEnumLike:
			return getBaseTypeOfEnumLikeType(type_)
		case type_.flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral | TypeFlagsStringMapping):
			return stringType
		case type_.flags & TypeFlagsNumberLiteral:
			return numberType
		case type_.flags & TypeFlagsBigIntLiteral:
			return bigintType
		case type_.flags & TypeFlagsBooleanLiteral:
			return booleanType
		case type_.flags & TypeFlagsUnion:
			return getBaseTypeOfLiteralTypeUnion(type_)
		default:
			return type_
		}
	}
	getBaseTypeOfLiteralTypeUnion := func(type_ UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		key := /* TODO(Node TemplateExpression): `B${getTypeId(type)}` */ TODO
		return /* TODO(Node BinaryExpression): getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
	}
	getBaseTypeOfLiteralTypeForComparison := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral | TypeFlagsStringMapping):
			return stringType
		case type_.flags & (TypeFlagsNumberLiteral | TypeFlagsEnum):
			return numberType
		case type_.flags & TypeFlagsBigIntLiteral:
			return bigintType
		case type_.flags & TypeFlagsBooleanLiteral:
			return booleanType
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, getBaseTypeOfLiteralTypeForComparison)
		default:
			return type_
		}
	}
	getWidenedLiteralType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags&TypeFlagsEnumLike && isFreshLiteralType(type_):
			return getBaseTypeOfEnumLikeType(type_)
		case type_.flags&TypeFlagsStringLiteral && isFreshLiteralType(type_):
			return stringType
		case type_.flags&TypeFlagsNumberLiteral && isFreshLiteralType(type_):
			return numberType
		case type_.flags&TypeFlagsBigIntLiteral && isFreshLiteralType(type_):
			return bigintType
		case type_.flags&TypeFlagsBooleanLiteral && isFreshLiteralType(type_):
			return booleanType
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, getWidenedLiteralType)
		default:
			return type_
		}
	}
	getWidenedUniqueESSymbolType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUniqueESSymbol:
			return esSymbolType
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, getWidenedUniqueESSymbolType)
		default:
			return type_
		}
	}
	getWidenedLiteralLikeTypeForContextualType := func(type_ Type, contextualType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !isLiteralOfContextualType(type_, contextualType) {
			type_ = getWidenedUniqueESSymbolType(getWidenedLiteralType(type_))
		}
		return getRegularTypeOfLiteralType(type_)
	}
	getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, isAsync bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(Node ConditionalExpression): !contextualSignatureReturnType ? undefined : isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) : contextualSignatureReturnType */ TODO
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, kind IterationTypeKind, isAsyncGenerator bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(Node ConditionalExpression): !contextualSignatureReturnType ? undefined : getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator) */ TODO
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	isTupleType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is TupleTypeReference */ any {
		return !!(getObjectFlags(type_)&ObjectFlagsReference && (type_).target.objectFlags&ObjectFlagsTuple)
	}
	isGenericTupleType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is TupleTypeReference */ any {
		return isTupleType(type_) && !!(type_.target.combinedFlags & ElementFlagsVariadic)
	}
	isSingleElementGenericTupleType := func(type_ Type) /* TODO(TypeNode TypePredicate): type is TupleTypeReference */ any {
		return isGenericTupleType(type_) && type_.target.elementFlags.length == 1
	}
	getRestTypeOfTupleType := func(type_ TupleTypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		return getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength)
	}
	getTupleElementTypeOutOfStartCount := func(type_ Type, index number, undefinedOrMissingType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			tupleType := t
			restType := getRestTypeOfTupleType(tupleType)
			if !restType {
				return undefinedType
			}
			if undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target) {
				return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{restType, undefinedOrMissingType})
			}
			return restType
		})
	}
	getRestArrayTypeOfTupleType := func(type_ TupleTypeReference) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | undefined */ any {
		restType := getRestTypeOfTupleType(type_)
		return restType && createArrayType(restType)
	}
	getElementTypeOfSliceOfTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO inferred type number */ any /*  = 0 */, writing /* TODO inferred type boolean */ any /*  = false */, noReductions /* TODO inferred type boolean */ any /*  = false */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		length := getTypeReferenceArity(type_) - endSkipCount
		if index < length {
			typeArguments := getTypeArguments(type_)
			var elementTypes []Type = [] /* TODO inferred type never */ any{}
			for i := index; i < length; i++ {
				t := typeArguments[i]
				elementTypes.push( /* TODO(Node ConditionalExpression): type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t */ TODO)
			}
			// converted from conditional expression
			switch {
			case writing:
				return getIntersectionType(elementTypes)
			default:
				return getUnionType(elementTypes /* TODO(Node ConditionalExpression): noReductions ? UnionReduction.None : UnionReduction.Literal */, TODO)
			}
		}
		return nil
	}
	isTupleTypeStructureMatching := func(t1 TupleTypeReference, t2 TupleTypeReference) /* TODO inferred type boolean */ any {
		return getTypeReferenceArity(t1) == getTypeReferenceArity(t2) && every(t1.target.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any, i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
			return (f & ElementFlagsVariable) == (t2.target.elementFlags[i] & ElementFlagsVariable)
		})
	}
	isZeroBigInt := func(TODO_IDENTIFIER BigIntLiteralType) /* TODO inferred type boolean */ any {
		return value.base10Value == "0"
	}
	removeDefinitelyFalsyTypes := func(type_ Type) Type {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return hasTypeFacts(t, TypeFactsTruthy)
		})
	}
	extractDefinitelyFalsyTypes := func(type_ Type) Type {
		return mapType(type_, getDefinitelyFalsyPartOfType)
	}
	getDefinitelyFalsyPartOfType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsString:
			return emptyStringType
		case type_.flags & TypeFlagsNumber:
			return zeroType
		case type_.flags & TypeFlagsBigInt:
			return zeroBigIntType
		case type_ == regularFalseType || type_ == falseType || type_.flags&(TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull|TypeFlagsAnyOrUnknown) || type_.flags&TypeFlagsStringLiteral && (type_).value == "" || type_.flags&TypeFlagsNumberLiteral && (type_).value == 0 || type_.flags&TypeFlagsBigIntLiteral && isZeroBigInt(type_):
			return type_
		default:
			return neverType
		}
	}
	getNullableType := func(type_ Type, flags TypeFlags) Type {
		missing := (flags & ~type_.flags) & (TypeFlagsUndefined | TypeFlagsNull)
		// converted from conditional expression
		switch {
		case missing == 0:
			return type_
		case missing == TypeFlagsUndefined:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, undefinedType})
		case missing == TypeFlagsNull:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, nullType})
		default:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, undefinedType, nullType})
		}
	}
	getOptionalType := func(type_ Type, isProperty /* TODO inferred type boolean */ any /*  = false */) Type {
		Debug.assert(strictNullChecks)
		missingOrUndefined := /* TODO(Node ConditionalExpression): isProperty ? undefinedOrMissingType : undefinedType */ TODO
		// converted from conditional expression
		switch {
		case type_ == missingOrUndefined || type_.flags&TypeFlagsUnion && (type_).types[0] == missingOrUndefined:
			return type_
		default:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, missingOrUndefined})
		}
	}
	getGlobalNonNullableTypeInstantiation := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !deferredGlobalNonNullableTypeAlias {
			deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable", SymbolFlagsTypeAlias, nil) || unknownSymbol
		}
		// converted from conditional expression
		switch {
		case deferredGlobalNonNullableTypeAlias != unknownSymbol:
			return getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_})
		default:
			return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, emptyObjectType})
		}
	}
	getNonNullableType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case strictNullChecks:
			return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
		default:
			return type_
		}
	}
	addOptionalTypeMarker := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case strictNullChecks:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, optionalType})
		default:
			return type_
		}
	}
	removeOptionalTypeMarker := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case strictNullChecks:
			return removeType(type_, optionalType)
		default:
			return type_
		}
	}
	propagateOptionalTypeMarker := func(type_ Type, node OptionalChain, wasOptional bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case wasOptional:
			// converted from conditional expression
			switch {
			case isOutermostOptionalChain(node):
				return getOptionalType(type_)
			default:
				return addOptionalTypeMarker(type_)
			}
		default:
			return type_
		}
	}
	getOptionalExpressionType := func(exprType Type, expression Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case isExpressionOfOptionalChainRoot(expression):
			return getNonNullableType(exprType)
		case isOptionalChain(expression):
			return removeOptionalTypeMarker(exprType)
		default:
			return exprType
		}
	}
	removeMissingType := func(type_ Type, isOptional bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case exactOptionalPropertyTypes && isOptional:
			return removeType(type_, missingType)
		default:
			return type_
		}
	}
	containsMissingType := func(type_ Type) /* TODO inferred type boolean */ any {
		return type_ == missingType || !!(type_.flags&TypeFlagsUnion) && (type_).types[0] == missingType
	}
	removeMissingOrUndefinedType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case exactOptionalPropertyTypes:
			return removeType(type_, missingType)
		default:
			return getTypeWithFacts(type_, TypeFactsNEUndefined)
		}
	}
	isCoercibleUnderDoubleEquals := func(source Type, target Type) bool {
		return ((source.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBooleanLiteral)) != 0) && ((target.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBoolean)) != 0)
	}
	isObjectTypeWithInferableIndex := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return every((type_).types, isObjectTypeWithInferableIndex)
		default:
			return !!(type_.symbol && (type_.symbol.flags&(SymbolFlagsObjectLiteral|SymbolFlagsTypeLiteral|SymbolFlagsEnum|SymbolFlagsValueModule)) != 0 && !(type_.symbol.flags & SymbolFlagsClass) && !typeHasCallOrConstructSignatures(type_)) || !!(objectFlags & ObjectFlagsObjectRestType) || !!(objectFlags&ObjectFlagsReverseMapped && isObjectTypeWithInferableIndex((type_).source))
		}
	}
	createSymbolWithType := func(source Symbol, type_ *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any {
		symbol := createSymbol(source.flags, source.escapedName, getCheckFlags(source)&CheckFlagsReadonly)
		symbol.declarations = source.declarations
		symbol.parent = source.parent
		symbol.links.type_ = type_
		symbol.links.target = source
		if source.valueDeclaration {
			symbol.valueDeclaration = source.valueDeclaration
		}
		nameType := getSymbolLinks(source).nameType
		if nameType {
			symbol.links.nameType = nameType
		}
		return symbol
	}
	transformTypeOfMembers := func(type_ Type, f func(propertyType Type) Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ any {
		members := createSymbolTable()
		for _, property := range getPropertiesOfObjectType(type_) {
			original := getTypeOfSymbol(property)
			updated := f(original)
			members.set(property.escapedName /* TODO(Node ConditionalExpression): updated === original ? property : createSymbolWithType(property, updated) */, TODO)
		}
		return members
	}
	getRegularTypeOfObjectLiteral := func(type_ Type) Type {
		if !(isObjectLiteralType(type_) && getObjectFlags(type_)&ObjectFlagsFreshLiteral) {
			return type_
		}
		regularType := (type_).regularType
		if regularType {
			return regularType
		}
		resolved := type_
		members := transformTypeOfMembers(type_, getRegularTypeOfObjectLiteral)
		regularNew := createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos)
		regularNew.flags = resolved.flags
		regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlagsFreshLiteral
		(type_).regularType = regularNew
		return regularNew
	}
	createWideningContext := func(parent *WideningContext, propertyName *__String, siblings *[]Type) WideningContext {
		return /* TODO(Node ObjectLiteralExpression): { parent, propertyName, siblings, resolvedProperties: undefined } */ TODO
	}
	getSiblingsOfContext := func(context WideningContext) []Type {
		if !context.siblings {
			var siblings []Type = [] /* TODO inferred type never */ any{}
			for _, type_ := range getSiblingsOfContext(context.parent) {
				if isObjectLiteralType(type_) {
					prop := getPropertyOfObjectType(type_, context.propertyName)
					if prop {
						forEachType(getTypeOfSymbol(prop), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
							siblings.push(t)
						})
					}
				}
			}
			context.siblings = siblings
		}
		return context.siblings
	}
	getPropertiesOfContext := func(context WideningContext) []Symbol {
		if !context.resolvedProperties {
			names := make(map[__String]Symbol)
			for _, t := range getSiblingsOfContext(context) {
				if isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlagsContainsSpread) {
					for _, prop := range getPropertiesOfType(t) {
						names.set(prop.escapedName, prop)
					}
				}
			}
			context.resolvedProperties = arrayFrom(names.values())
		}
		return context.resolvedProperties
	}
	getWidenedProperty := func(prop Symbol, context *WideningContext) Symbol {
		if !(prop.flags & SymbolFlagsProperty) {
			return prop
		}
		original := getTypeOfSymbol(prop)
		propContext := context && createWideningContext(context, prop.escapedName, nil)
		widened := getWidenedTypeWithContext(original, propContext)
		// converted from conditional expression
		switch {
		case widened == original:
			return prop
		default:
			return createSymbolWithType(prop, widened)
		}
	}
	getUndefinedProperty := func(prop Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		cached := undefinedProperties.get(prop.escapedName)
		if cached {
			return cached
		}
		result := createSymbolWithType(prop, undefinedOrMissingType)
		result.flags |= SymbolFlagsOptional
		undefinedProperties.set(prop.escapedName, result)
		return result
	}
	getWidenedTypeOfObjectLiteral := func(type_ Type, context *WideningContext) Type {
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, getWidenedProperty(prop, context))
		}
		if context {
			for _, prop := range getPropertiesOfContext(context) {
				if !members.has(prop.escapedName) {
					members.set(prop.escapedName, getUndefinedProperty(prop))
				}
			}
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type_), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any {
			return createIndexInfo(info.keyType, getWidenedType(info.type_), info.isReadonly)
		}))
		result.objectFlags |= getObjectFlags(type_) & (ObjectFlagsJSLiteral | ObjectFlagsNonInferrableType)
		return result
	}
	getWidenedType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getWidenedTypeWithContext(type_, nil)
	}
	getWidenedTypeWithContext := func(type_ Type, context *WideningContext) Type {
		if getObjectFlags(type_) & ObjectFlagsRequiresWidening {
			if context == nil && type_.widened {
				return type_.widened
			}
			var result *Type
			if type_.flags & (TypeFlagsAny | TypeFlagsNullable) {
				result = anyType
			} else if isObjectLiteralType(type_) {
				result = getWidenedTypeOfObjectLiteral(type_, context)
			} else if type_.flags & TypeFlagsUnion {
				unionContext := context || createWideningContext(nil, nil, (type_).types)
				widenedTypes := sameMap((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Nullable ? t : getWidenedTypeWithContext(t, unionContext) */ TODO
				})
				result = getUnionType(widenedTypes /* TODO(Node ConditionalExpression): some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			} else if type_.flags & TypeFlagsIntersection {
				result = getIntersectionType(sameMap((type_).types, getWidenedType))
			} else if isArrayOrTupleType(type_) {
				result = createTypeReference(type_.target, sameMap(getTypeArguments(type_), getWidenedType))
			}
			if result && context == nil {
				type_.widened = result
			}
			return result || type_
		}
		return type_
	}
	reportWideningErrorsInType := func(type_ Type) bool {
		errorReported := false
		if getObjectFlags(type_) & ObjectFlagsContainsWideningType {
			if type_.flags & TypeFlagsUnion {
				if some((type_).types, isEmptyObjectType) {
					errorReported = true
				} else {
					for _, t := range (type_).types {
						/* TODO(Node BinaryExpression): errorReported ||= reportWideningErrorsInType(t) */ TODO
					}
				}
			} else if isArrayOrTupleType(type_) {
				for _, t := range getTypeArguments(type_) {
					/* TODO(Node BinaryExpression): errorReported ||= reportWideningErrorsInType(t) */ TODO
				}
			} else if isObjectLiteralType(type_) {
				for _, p := range getPropertiesOfObjectType(type_) {
					t := getTypeOfSymbol(p)
					if getObjectFlags(t) & ObjectFlagsContainsWideningType {
						errorReported = reportWideningErrorsInType(t)
						if !errorReported {
							valueDeclaration := p.declarations. /*?*/ find(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
								return d.symbol.valueDeclaration. /*?*/ parent == type_.symbol.valueDeclaration
							})
							if valueDeclaration {
								error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)))
								errorReported = true
							}
						}
					}
				}
			}
		}
		return errorReported
	}
	reportImplicitAny := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		typeAsString := typeToString(getWidenedType(type_))
		if isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions) {
			return
		}
		var diagnostic DiagnosticMessage
		switch declaration.kind {
		case SyntaxKindBinaryExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertySignature:
			diagnostic = /* TODO(Node ConditionalExpression): noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage */ TODO
			break
		case SyntaxKindParameter:
			param := declaration
			if isIdentifier(param.name) {
				originalKeywordKind := identifierToKeywordKind(param.name)
				if (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) && param.parent.parameters.includes(param) && (resolveName(param, param.name.escapedText, SymbolFlagsType, nil, true) || originalKeywordKind && isTypeNodeKind(originalKeywordKind)) {
					newName := "arg" + param.parent.parameters.indexOf(param)
					typeName := declarationNameToString(param.name) + ( /* TODO(Node ConditionalExpression): param.dotDotDotToken ? "[]" : "" */ TODO)
					errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName)
					return
				}
			}
			diagnostic = /* TODO(Node ConditionalExpression): (declaration as ParameterDeclaration).dotDotDotToken ? noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage : noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage */ TODO
			break
		case SyntaxKindBindingElement:
			diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type
			if !noImplicitAny {
				return
			}
			break
		case SyntaxKindJSDocFunctionType:
			error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
			return
		case SyntaxKindJSDocSignature:
			if noImplicitAny && isJSDocOverloadTag(declaration.parent) {
				error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString)
			}
			return
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			if noImplicitAny && !(declaration).name {
				if wideningKind == WideningKindGeneratorYield {
					error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString)
				} else {
					error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
				}
				return
			}
			diagnostic = /* TODO(Node ConditionalExpression): !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage : wideningKind === WideningKind.GeneratorYield ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type : Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type */ TODO
			break
		case SyntaxKindMappedType:
			if noImplicitAny {
				error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type)
			}
			return
		default:
			diagnostic = /* TODO(Node ConditionalExpression): noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage */ TODO
		}
		errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString)
	}
	reportErrorsFromWidening := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		addLazyDiagnostic(func() {
			if noImplicitAny && getObjectFlags(type_)&ObjectFlagsContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration)) {
				if !reportWideningErrorsInType(type_) {
					reportImplicitAny(declaration, type_, wideningKind)
				}
			}
		})
	}
	applyToParameterTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		sourceCount := getParameterCount(source)
		targetCount := getParameterCount(target)
		sourceRestType := getEffectiveRestType(source)
		targetRestType := getEffectiveRestType(target)
		targetNonRestCount := /* TODO(Node ConditionalExpression): targetRestType ? targetCount - 1 : targetCount */ TODO
		paramCount := /* TODO(Node ConditionalExpression): sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount) */ TODO
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				callback(sourceThisType, targetThisType)
			}
		}
		for i := 0; i < paramCount; i++ {
			callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i))
		}
		if targetRestType {
			callback(getRestTypeAtPosition(source, paramCount, isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType)
		}
	}
	applyToReturnTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		targetTypePredicate := getTypePredicateOfSignature(target)
		if targetTypePredicate {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			if sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type_ && targetTypePredicate.type_ {
				callback(sourceTypePredicate.type_, targetTypePredicate.type_)
				return
			}
		}
		targetReturnType := getReturnTypeOfSignature(target)
		if couldContainTypeVariables(targetReturnType) {
			callback(getReturnTypeOfSignature(source), targetReturnType)
		}
	}
	createInferenceContext := func(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		return createInferenceContextWorker(typeParameters.map_(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable)
	}
	cloneInferenceContext := func(context T, extraFlags InferenceFlags /*  = 0 */) /* TODO(TypeNode UnionType): InferenceContext | T & undefined */ any {
		return context && createInferenceContextWorker(map_(context.inferences, cloneInferenceInfo), context.signature, context.flags|extraFlags, context.compareTypes)
	}
	createInferenceContextWorker := func(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		var context InferenceContext = /* TODO(Node ObjectLiteralExpression): { inferences, signature, flags, compareTypes, mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction nonFixingMapper: reportUnmeasurableMapper, } */ TODO
		context.mapper = makeFixingMapperForContext(context)
		context.nonFixingMapper = makeNonFixingMapperForContext(context)
		return context
	}
	makeFixingMapperForContext := func(context InferenceContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ any {
		return makeDeferredTypeMapper(map_(context.inferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
			return i.typeParameter
		}), map_(context.inferences, func(inference /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any, i /* TODO inferred type number */ any) /* TODO inferred type () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				if !inference.isFixed {
					inferFromIntraExpressionSites(context)
					clearCachedInferences(context.inferences)
					inference.isFixed = true
				}
				return getInferredType(context, i)
			}
		}))
	}
	makeNonFixingMapperForContext := func(context InferenceContext) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ any {
		return makeDeferredTypeMapper(map_(context.inferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
			return i.typeParameter
		}), map_(context.inferences, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any, i /* TODO inferred type number */ any) /* TODO inferred type () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getInferredType(context, i)
			}
		}))
	}
	clearCachedInferences := func(inferences []InferenceInfo) {
		for _, inference := range inferences {
			if !inference.isFixed {
				inference.inferredType = nil
			}
		}
	}
	addIntraExpressionInferenceSite := func(context InferenceContext, node /* TODO(TypeNode UnionType): Expression | MethodDeclaration */ any, type_ Type) {
		( /* TODO(Node BinaryExpression): context.intraExpressionInferenceSites ??= [] */ TODO).push( /* TODO(Node ObjectLiteralExpression): { node, type } */ TODO)
	}
	inferFromIntraExpressionSites := func(context InferenceContext) {
		if context.intraExpressionInferenceSites {
			for _, TODO_IDENTIFIER := range context.intraExpressionInferenceSites {
				contextualType := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.MethodDeclaration ? getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) : getContextualType(node, ContextFlags.NoConstraints) */ TODO
				if contextualType {
					inferTypes(context.inferences, type_, contextualType)
				}
			}
			context.intraExpressionInferenceSites = nil
		}
	}
	createInferenceInfo := func(typeParameter TypeParameter) InferenceInfo {
		return /* TODO(Node ObjectLiteralExpression): { typeParameter, candidates: undefined, contraCandidates: undefined, inferredType: undefined, priority: undefined, topLevel: true, isFixed: false, impliedArity: undefined, } */ TODO
	}
	cloneInferenceInfo := func(inference InferenceInfo) InferenceInfo {
		return /* TODO(Node ObjectLiteralExpression): { typeParameter: inference.typeParameter, candidates: inference.candidates && inference.candidates.slice(), contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(), inferredType: inference.inferredType, priority: inference.priority, topLevel: inference.topLevel, isFixed: inference.isFixed, impliedArity: inference.impliedArity, } */ TODO
	}
	cloneInferredPartOfContext := func(context InferenceContext) *InferenceContext {
		inferences := filter(context.inferences, hasInferenceCandidates)
		// converted from conditional expression
		switch {
		case inferences.length:
			return createInferenceContextWorker(map_(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes)
		default:
			return nil
		}
	}
	getMapperFromContext := func(context T) /* TODO(TypeNode UnionType): TypeMapper | T & undefined */ any {
		return context && context.mapper
	}
	couldContainTypeVariables := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		if objectFlags & ObjectFlagsCouldContainTypeVariablesComputed {
			return !!(objectFlags & ObjectFlagsCouldContainTypeVariables)
		}
		result := !!(type_.flags&TypeFlagsInstantiable || type_.flags&TypeFlagsObject && !isNonGenericTopLevelType(type_) && (objectFlags&ObjectFlagsReference && ((type_).node || some(getTypeArguments(type_), couldContainTypeVariables)) || objectFlags&ObjectFlagsSingleSignatureType && !!length((type_).outerTypeParameters) || objectFlags&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod|SymbolFlagsClass|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) && type_.symbol.declarations || objectFlags&(ObjectFlagsMapped|ObjectFlagsReverseMapped|ObjectFlagsObjectRestType|ObjectFlagsInstantiationExpressionType)) || type_.flags&TypeFlagsUnionOrIntersection && !(type_.flags&TypeFlagsEnumLiteral) && !isNonGenericTopLevelType(type_) && some((type_).types, couldContainTypeVariables))
		if type_.flags & TypeFlagsObjectFlagsType {
			(type_).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | ( /* TODO(Node ConditionalExpression): result ? ObjectFlags.CouldContainTypeVariables : 0 */ TODO)
		}
		return result
	}
	isNonGenericTopLevelType := func(type_ Type) /* TODO inferred type boolean */ any {
		if type_.aliasSymbol && !type_.aliasTypeArguments {
			declaration := getDeclarationOfKind(type_.aliasSymbol, SyntaxKindTypeAliasDeclaration)
			return !!(declaration && findAncestor(declaration.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
				return /* TODO(Node ConditionalExpression): n.kind === SyntaxKind.SourceFile ? true : n.kind === SyntaxKind.ModuleDeclaration ? false : "quit" */ TODO
			}))
		}
		return false
	}
	isTypeParameterAtTopLevel := func(type_ Type, tp TypeParameter, depth /* TODO inferred type number */ any /*  = 0 */) bool {
		return !!(type_ == tp || type_.flags&TypeFlagsUnionOrIntersection && some((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return isTypeParameterAtTopLevel(t, tp, depth)
		}) || depth < 3 && type_.flags&TypeFlagsConditional && (isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type_), tp, depth+1) || isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type_), tp, depth+1)))
	}
	isTypeParameterAtTopLevelInReturnType := func(signature Signature, typeParameter TypeParameter) /* TODO inferred type boolean */ any {
		typePredicate := getTypePredicateOfSignature(signature)
		// converted from conditional expression
		switch {
		case typePredicate:
			return !!typePredicate.type_ && isTypeParameterAtTopLevel(typePredicate.type_, typeParameter)
		default:
			return isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter)
		}
	}
	createEmptyObjectTypeFromStringLiteral := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ any {
		members := createSymbolTable()
		forEachType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
			if !(t.flags & TypeFlagsStringLiteral) {
				return
			}
			name := escapeLeadingUnderscores((t).value)
			literalProp := createSymbol(SymbolFlagsProperty, name)
			literalProp.links.type_ = anyType
			if t.symbol {
				literalProp.declarations = t.symbol.declarations
				literalProp.valueDeclaration = t.symbol.valueDeclaration
			}
			members.set(name, literalProp)
		})
		indexInfos := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly* / false)] : emptyArray */ TODO
		return createAnonymousType(nil, members, emptyArray, emptyArray, indexInfos)
	}
	inferTypeForHomomorphicMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := source.id + "," + target.id + "," + constraint.id
		if reverseHomomorphicMappedCache.has(cacheKey) {
			return reverseHomomorphicMappedCache.get(cacheKey)
		}
		type_ := createReverseMappedType(source, target, constraint)
		reverseHomomorphicMappedCache.set(cacheKey, type_)
		return type_
	}
	isPartiallyInferableType := func(type_ Type) bool {
		return !(getObjectFlags(type_) & ObjectFlagsNonInferrableType) || isObjectLiteralType(type_) && some(getPropertiesOfType(type_), func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return isPartiallyInferableType(getTypeOfSymbol(prop))
		}) || isTupleType(type_) && some(getElementTypes(type_), isPartiallyInferableType)
	}
	createReverseMappedType := func(source Type, target MappedType, constraint IndexType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if !(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length != 0 && isPartiallyInferableType(source)) {
			return nil
		}
		if isArrayType(source) {
			elementType := inferReverseMappedType(getTypeArguments(source)[0], target, constraint)
			if !elementType {
				return nil
			}
			return createArrayType(elementType, isReadonlyArrayType(source))
		}
		if isTupleType(source) {
			elementTypes := map_(getElementTypes(source), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
				return inferReverseMappedType(t, target, constraint)
			})
			if !every(elementTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any) /* TODO(TypeNode TypePredicate): t is Type */ any {
				return !!t
			}) {
				return nil
			}
			elementFlags := /* TODO(Node ConditionalExpression): getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ? sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) : source.target.elementFlags */ TODO
			return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations)
		}
		reversed := createObjectType(ObjectFlagsReverseMapped|ObjectFlagsAnonymous, nil)
		reversed.source = source
		reversed.mappedType = target
		reversed.constraintType = constraint
		return reversed
	}
	getTypeOfReverseMappedSymbol := func(symbol ReverseMappedSymbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			links.type_ = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType
		}
		return links.type_
	}
	inferReverseMappedTypeWorker := func(sourceType Type, target MappedType, constraint IndexType) Type {
		typeParameter := getIndexedAccessType(constraint.type_, getTypeParameterFromMappedType(target))
		templateType := getTemplateTypeFromMappedType(target)
		inference := createInferenceInfo(typeParameter)
		inferTypes([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any{inference}, sourceType, templateType)
		return getTypeFromInference(inference) || unknownType
	}
	inferReverseMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := source.id + "," + target.id + "," + constraint.id
		if reverseMappedCache.has(cacheKey) {
			return reverseMappedCache.get(cacheKey) || unknownType
		}
		reverseMappedSourceStack.push(source)
		reverseMappedTargetStack.push(target)
		saveExpandingFlags := reverseExpandingFlags
		if isDeeplyNestedType(source, reverseMappedSourceStack, reverseMappedSourceStack.length, 2) {
			reverseExpandingFlags |= ExpandingFlagsSource
		}
		if isDeeplyNestedType(target, reverseMappedTargetStack, reverseMappedTargetStack.length, 2) {
			reverseExpandingFlags |= ExpandingFlagsTarget
		}
		var type_ TODO
		if reverseExpandingFlags != ExpandingFlagsBoth {
			type_ = inferReverseMappedTypeWorker(source, target, constraint)
		}
		reverseMappedSourceStack.pop()
		reverseMappedTargetStack.pop()
		reverseExpandingFlags = saveExpandingFlags
		reverseMappedCache.set(cacheKey, type_)
		return type_
	}
	// TODO: was generator
	getUnmatchedProperties := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
		properties := getPropertiesOfType(target)
		for _, targetProp := range properties {
			if isStaticPrivateIdentifierProperty(targetProp) {
				continue
			}
			if requireOptionalProperties || !(targetProp.flags&SymbolFlagsOptional || getCheckFlags(targetProp)&CheckFlagsPartial) {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if !sourceProp {
					yield(targetProp)
				} else if matchDiscriminantProperties {
					targetType := getTypeOfSymbol(targetProp)
					if targetType.flags & TypeFlagsUnit {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags&TypeFlagsAny || getRegularTypeOfLiteralType(sourceType) == getRegularTypeOfLiteralType(targetType)) {
							yield(targetProp)
						}
					}
				}
			}
		}
	}
	getUnmatchedProperty := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) *Symbol {
		return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
	}
	tupleTypesDefinitelyUnrelated := func(source TupleTypeReference, target TupleTypeReference) /* TODO inferred type boolean */ any {
		return !(target.target.combinedFlags&ElementFlagsVariadic) && target.target.minLength > source.target.minLength || !(target.target.combinedFlags&ElementFlagsVariable) && (!!(source.target.combinedFlags&ElementFlagsVariable) || target.target.fixedLength < source.target.fixedLength)
	}
	typesDefinitelyUnrelated := func(source Type, target Type) /* TODO inferred type boolean */ any {
		// converted from conditional expression
		switch {
		case isTupleType(source) && isTupleType(target):
			return tupleTypesDefinitelyUnrelated(source, target)
		default:
			return !!getUnmatchedProperty(source, target, false, true) && !!getUnmatchedProperty(target, source, false, false)
		}
	}
	getTypeFromInference := func(inference InferenceInfo) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		// converted from conditional expression
		switch {
		case inference.candidates:
			return getUnionType(inference.candidates, UnionReductionSubtype)
		case inference.contraCandidates:
			return getIntersectionType(inference.contraCandidates)
		default:
			return nil
		}
	}
	hasSkipDirectInferenceFlag := func(node Node) /* TODO inferred type boolean */ any {
		return !!getNodeLinks(node).skipDirectInference
	}
	isFromInferenceBlockedSource := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(type_.symbol && some(type_.symbol.declarations, hasSkipDirectInferenceFlag))
	}
	templateLiteralTypesDefinitelyUnrelated := func(source TemplateLiteralType, target TemplateLiteralType) /* TODO inferred type boolean */ any {
		sourceStart := source.texts[0]
		targetStart := target.texts[0]
		sourceEnd := source.texts[source.texts.length-1]
		targetEnd := target.texts[target.texts.length-1]
		startLen := Math.min(sourceStart.length, targetStart.length)
		endLen := Math.min(sourceEnd.length, targetEnd.length)
		return sourceStart.slice(0, startLen) != targetStart.slice(0, startLen) || sourceEnd.slice(sourceEnd.length-endLen) != targetEnd.slice(targetEnd.length-endLen)
	}
	isValidNumberString := func(s string, roundTripOnly bool) bool {
		if s == "" {
			return false
		}
		n := +s
		return isFinite(n) && (!roundTripOnly || ""+n == s)
	}
	parseBigIntLiteralType := func(text string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BigIntLiteralType */ any {
		return getBigIntLiteralType(parseValidBigInt(text))
	}
	isMemberOfStringMapping := func(source Type, target Type) bool {
		if target.flags & TypeFlagsAny {
			return true
		}
		if target.flags & (TypeFlagsString | TypeFlagsTemplateLiteral) {
			return isTypeAssignableTo(source, target)
		}
		if target.flags & TypeFlagsStringMapping {
			mappingStack := [] /* TODO inferred type never */ any{}
			for target.flags & TypeFlagsStringMapping {
				mappingStack.unshift(target.symbol)
				target = (target).type_
			}
			mappedSource := reduceLeft(mappingStack, func(memo /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, value /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return getStringMappingType(value, memo)
			}, source)
			return mappedSource == source && isMemberOfStringMapping(source, target)
		}
		return false
	}
	isValidTypeForTemplateLiteralPlaceholder := func(source Type, target Type) bool {
		if target.flags & TypeFlagsIntersection {
			return every((target).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return t == emptyTypeLiteralType || isValidTypeForTemplateLiteralPlaceholder(source, t)
			})
		}
		if target.flags&TypeFlagsString || isTypeAssignableTo(source, target) {
			return true
		}
		if source.flags & TypeFlagsStringLiteral {
			value := (source).value
			return !!(target.flags&TypeFlagsNumber && isValidNumberString(value, false) || target.flags&TypeFlagsBigInt && isValidBigIntString(value, false) || target.flags&(TypeFlagsBooleanLiteral|TypeFlagsNullable) && value == (target).intrinsicName || target.flags&TypeFlagsStringMapping && isMemberOfStringMapping(getStringLiteralType(value), target) || target.flags&TypeFlagsTemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target))
		}
		if source.flags & TypeFlagsTemplateLiteral {
			texts := (source).texts
			return texts.length == 2 && texts[0] == "" && texts[1] == "" && isTypeAssignableTo((source).types[0], target)
		}
		return false
	}
	inferTypesFromTemplateLiteralType := func(source Type, target TemplateLiteralType) *[]Type {
		// converted from conditional expression
		switch {
		case source.flags & TypeFlagsStringLiteral:
			return inferFromLiteralPartsToTemplateLiteral([] /* TODO inferred type string */ any{(source).value}, emptyArray, target)
		case source.flags & TypeFlagsTemplateLiteral:
			// converted from conditional expression
			switch {
			case arrayIsEqualTo((source).texts, target.texts):
				return map_((source).types, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					// converted from conditional expression
					switch {
					case isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])):
						return s
					default:
						return getStringLikeTypeForType(s)
					}
				})
			default:
				return inferFromLiteralPartsToTemplateLiteral((source).texts, (source).types, target)
			}
		default:
			return nil
		}
	}
	isTypeMatchedByTemplateLiteralType := func(source Type, target TemplateLiteralType) bool {
		inferences := inferTypesFromTemplateLiteralType(source, target)
		return !!inferences && every(inferences, func(r /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type boolean */ any {
			return isValidTypeForTemplateLiteralPlaceholder(r, target.types[i])
		})
	}
	getStringLikeTypeForType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags & (TypeFlagsAny | TypeFlagsStringLike):
			return type_
		default:
			return getTemplateLiteralType([] /* TODO inferred type string */ any{"", ""}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_})
		}
	}
	inferFromLiteralPartsToTemplateLiteral := func(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) *[]Type {
		lastSourceIndex := sourceTexts.length - 1
		sourceStartText := sourceTexts[0]
		sourceEndText := sourceTexts[lastSourceIndex]
		targetTexts := target.texts
		lastTargetIndex := targetTexts.length - 1
		targetStartText := targetTexts[0]
		targetEndText := targetTexts[lastTargetIndex]
		if lastSourceIndex == 0 && sourceStartText.length < targetStartText.length+targetEndText.length || !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText) {
			return nil
		}
		remainingEndText := sourceEndText.slice(0, sourceEndText.length-targetEndText.length)
		var matches []Type = [] /* TODO inferred type never */ any{}
		seg := 0
		pos := targetStartText.length
		for i := 1; i < lastTargetIndex; i++ {
			delim := targetTexts[i]
			if delim.length > 0 {
				s := seg
				p := pos
				for true {
					p = getSourceText(s).indexOf(delim, p)
					if p >= 0 {
						break
					}
					s++
					if s == sourceTexts.length {
						return nil
					}
					p = 0
				}
				addMatch(s, p)
				pos += delim.length
			} else if pos < getSourceText(seg).length {
				addMatch(seg, pos+1)
			} else if seg < lastSourceIndex {
				addMatch(seg+1, 0)
			} else {
				return nil
			}
		}
		addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length)
		return matches
		getSourceText := func(index number) /* TODO inferred type string */ any {
			// converted from conditional expression
			switch {
			case index < lastSourceIndex:
				return sourceTexts[index]
			default:
				return remainingEndText
			}
		}
		addMatch := func(s number, p number) {
			matchType := /* TODO(Node ConditionalExpression): s === seg ? getStringLiteralType(getSourceText(s).slice(pos, p)) : getTemplateLiteralType( [sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)], sourceTypes.slice(seg, s), ) */ TODO
			matches.push(matchType)
			seg = s
			pos = p
		}
	}
	isTupleOfSelf := func(typeParameter TypeParameter, type_ Type) /* TODO inferred type boolean */ any {
		return isTupleType(type_) && getTupleElementType(type_, 0) == getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type_, "1")
	}
	inferTypes := func(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferencePriority */ any /*  = InferencePriority.None */, contravariant /* TODO inferred type boolean */ any /*  = false */) {
		bivariant := false
		var propagationType Type
		var inferencePriority number = InferencePriorityMaxValue
		var visited Map[string, number]
		var sourceStack []Type
		var targetStack []Type
		expandingFlags := ExpandingFlagsNone
		inferFromTypes(originalSource, originalTarget)
		inferFromTypes := func(source Type, target Type) {
			if !couldContainTypeVariables(target) || isNoInferType(target) {
				return
			}
			if source == wildcardType || source == blockedStringType {
				savePropagationType := propagationType
				propagationType = source
				inferFromTypes(target, target)
				propagationType = savePropagationType
				return
			}
			if source.aliasSymbol && source.aliasSymbol == target.aliasSymbol {
				if source.aliasTypeArguments {
					params := getSymbolLinks(source.aliasSymbol).typeParameters
					minParams := getMinTypeArgumentCount(params)
					sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					inferFromTypeArguments(sourceTypes, targetTypes, getAliasVariances(source.aliasSymbol))
				}
				return
			}
			if source == target && source.flags&TypeFlagsUnionOrIntersection {
				for _, t := range (source).types {
					inferFromTypes(t, t)
				}
				return
			}
			if target.flags & TypeFlagsUnion {
				TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(Node ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO, (target).types, isTypeOrBaseIdenticalTo)
				TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy)
				if targets.length == 0 {
					return
				}
				target = getUnionType(targets)
				if sources.length == 0 {
					inferWithPriority(source, target, InferencePriorityNakedTypeVariable)
					return
				}
				source = getUnionType(sources)
			} else if target.flags&TypeFlagsIntersection && !every((target).types, isNonGenericObjectType) {
				if !(source.flags & TypeFlagsUnion) {
					TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(Node ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, (target).types, isTypeIdenticalTo)
					if sources.length == 0 || targets.length == 0 {
						return
					}
					source = getIntersectionType(sources)
					target = getIntersectionType(targets)
				}
			}
			if target.flags & (TypeFlagsIndexedAccess | TypeFlagsSubstitution) {
				if isNoInferType(target) {
					return
				}
				target = getActualTypeVariable(target)
			}
			if target.flags & TypeFlagsTypeVariable {
				if isFromInferenceBlockedSource(source) {
					return
				}
				inference := getInferenceInfoForType(target)
				if inference {
					if getObjectFlags(source)&ObjectFlagsNonInferrableType || source == nonInferrableAnyType {
						return
					}
					if !inference.isFixed {
						candidate := propagationType || source
						if candidate == blockedStringType {
							return
						}
						if inference.priority == nil || priority < inference.priority {
							inference.candidates = nil
							inference.contraCandidates = nil
							inference.topLevel = true
							inference.priority = priority
						}
						if priority == inference.priority {
							if isTupleOfSelf(inference.typeParameter, candidate) {
								return
							}
							if contravariant && !bivariant {
								if !contains(inference.contraCandidates, candidate) {
									inference.contraCandidates = append(inference.contraCandidates, candidate)
									clearCachedInferences(inferences)
								}
							} else if !contains(inference.candidates, candidate) {
								inference.candidates = append(inference.candidates, candidate)
								clearCachedInferences(inferences)
							}
						}
						if !(priority & InferencePriorityReturnType) && target.flags&TypeFlagsTypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target) {
							inference.topLevel = false
							clearCachedInferences(inferences)
						}
					}
					inferencePriority = Math.min(inferencePriority, priority)
					return
				}
				simplified := getSimplifiedType(target, false)
				if simplified != target {
					inferFromTypes(source, simplified)
				} else if target.flags & TypeFlagsIndexedAccess {
					indexType := getSimplifiedType((target).indexType, false)
					if indexType.flags & TypeFlagsInstantiable {
						simplified := distributeIndexOverObjectType(getSimplifiedType((target).objectType, false), indexType, false)
						if simplified && simplified != target {
							inferFromTypes(source, simplified)
						}
					}
				}
			}
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source).target == (target).target || isArrayType(source) && isArrayType(target)) && !((source).node && (target).node) {
				inferFromTypeArguments(getTypeArguments(source), getTypeArguments(target), getVariances((source).target))
			} else if source.flags&TypeFlagsIndex && target.flags&TypeFlagsIndex {
				inferFromContravariantTypes((source).type_, (target).type_)
			} else if (isLiteralType(source) || source.flags&TypeFlagsString) && target.flags&TypeFlagsIndex {
				empty := createEmptyObjectTypeFromStringLiteral(source)
				inferFromContravariantTypesWithPriority(empty, (target).type_, InferencePriorityLiteralKeyof)
			} else if source.flags&TypeFlagsIndexedAccess && target.flags&TypeFlagsIndexedAccess {
				inferFromTypes((source).objectType, (target).objectType)
				inferFromTypes((source).indexType, (target).indexType)
			} else if source.flags&TypeFlagsStringMapping && target.flags&TypeFlagsStringMapping {
				if (source).symbol == (target).symbol {
					inferFromTypes((source).type_, (target).type_)
				}
			} else if source.flags & TypeFlagsSubstitution {
				inferFromTypes((source).baseType, target)
				inferWithPriority(getSubstitutionIntersection(source), target, InferencePrioritySubstituteSource)
			} else if target.flags & TypeFlagsConditional {
				invokeOnce(source, target, inferToConditionalType)
			} else if target.flags & TypeFlagsUnionOrIntersection {
				inferToMultipleTypes(source, (target).types, target.flags)
			} else if source.flags & TypeFlagsUnion {
				sourceTypes := (source).types
				for _, sourceType := range sourceTypes {
					inferFromTypes(sourceType, target)
				}
			} else if target.flags & TypeFlagsTemplateLiteral {
				inferToTemplateLiteralType(source, target)
			} else {
				source = getReducedType(source)
				if isGenericMappedType(source) && isGenericMappedType(target) {
					invokeOnce(source, target, inferFromGenericMappedTypes)
				}
				if !(priority&InferencePriorityNoConstraints && source.flags&(TypeFlagsIntersection|TypeFlagsInstantiable)) {
					apparentSource := getApparentType(source)
					if apparentSource != source && !(apparentSource.flags & (TypeFlagsObject | TypeFlagsIntersection)) {
						return inferFromTypes(apparentSource, target)
					}
					source = apparentSource
				}
				if source.flags & (TypeFlagsObject | TypeFlagsIntersection) {
					invokeOnce(source, target, inferFromObjectTypes)
				}
			}
		}
		inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromTypes(source, target)
			priority = savePriority
		}
		inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromContravariantTypes(source, target)
			priority = savePriority
		}
		inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferToMultipleTypes(source, targets, targetFlags)
			priority = savePriority
		}
		invokeOnce := func(source Source, target Target, action func(source Source, target Target)) {
			key := source.id + "," + target.id
			status := visited && visited.get(key)
			if status != nil {
				inferencePriority = Math.min(inferencePriority, status)
				return
			}
			(visited || ( /* TODO(Node BinaryExpression): visited = new Map<string, number>() */ TODO)).set(key, InferencePriorityCircularity)
			saveInferencePriority := inferencePriority
			inferencePriority = InferencePriorityMaxValue
			saveExpandingFlags := expandingFlags
			( /* TODO(Node BinaryExpression): sourceStack ??= [] */ TODO).push(source)
			( /* TODO(Node BinaryExpression): targetStack ??= [] */ TODO).push(target)
			if isDeeplyNestedType(source, sourceStack, sourceStack.length, 2) {
				expandingFlags |= ExpandingFlagsSource
			}
			if isDeeplyNestedType(target, targetStack, targetStack.length, 2) {
				expandingFlags |= ExpandingFlagsTarget
			}
			if expandingFlags != ExpandingFlagsBoth {
				action(source, target)
			} else {
				inferencePriority = InferencePriorityCircularity
			}
			targetStack.pop()
			sourceStack.pop()
			expandingFlags = saveExpandingFlags
			visited.set(key, inferencePriority)
			inferencePriority = Math.min(inferencePriority, saveInferencePriority)
		}
		inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TypeNode TupleType): [Type[], Type[]] */ any {
			var matchedSources *[]Type
			var matchedTargets *[]Type
			for _, t := range targets {
				for _, s := range sources {
					if matches(s, t) {
						inferFromTypes(s, t)
						matchedSources = appendIfUnique(matchedSources, s)
						matchedTargets = appendIfUnique(matchedTargets, t)
					}
				}
			}
			return []TODO{ /* TODO(Node ConditionalExpression): matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources */ TODO /* TODO(Node ConditionalExpression): matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets */, TODO}
		}
		inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
			count := /* TODO(Node ConditionalExpression): sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length */ TODO
			for i := 0; i < count; i++ {
				if i < variances.length && (variances[i]&VarianceFlagsVarianceMask) == VarianceFlagsContravariant {
					inferFromContravariantTypes(sourceTypes[i], targetTypes[i])
				} else {
					inferFromTypes(sourceTypes[i], targetTypes[i])
				}
			}
		}
		inferFromContravariantTypes := func(source Type, target Type) {
			contravariant = !contravariant
			inferFromTypes(source, target)
			contravariant = !contravariant
		}
		inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
			if strictFunctionTypes || priority&InferencePriorityAlwaysStrict {
				inferFromContravariantTypes(source, target)
			} else {
				inferFromTypes(source, target)
			}
		}
		getInferenceInfoForType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo | undefined */ any {
			if type_.flags & TypeFlagsTypeVariable {
				for _, inference := range inferences {
					if type_ == inference.typeParameter {
						return inference
					}
				}
			}
			return nil
		}
		getSingleTypeVariableFromIntersectionTypes := func(types []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
			var typeVariable *Type
			for _, type_ := range types {
				t := type_.flags&TypeFlagsIntersection && find((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!getInferenceInfoForType(t)
				})
				if !t || typeVariable && t != typeVariable {
					return nil
				}
				typeVariable = t
			}
			return typeVariable
		}
		inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
			typeVariableCount := 0
			if targetFlags & TypeFlagsUnion {
				var nakedTypeVariable *Type
				sources := /* TODO(Node ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO
				matched := /* TODO(Node NewExpression): new Array<boolean>(sources.length) */ TODO
				inferenceCircularity := false
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						nakedTypeVariable = t
						typeVariableCount++
					} else {
						for i := 0; i < sources.length; i++ {
							saveInferencePriority := inferencePriority
							inferencePriority = InferencePriorityMaxValue
							inferFromTypes(sources[i], t)
							if inferencePriority == priority {
								matched[i] = true
							}
							inferenceCircularity = inferenceCircularity || inferencePriority == InferencePriorityCircularity
							inferencePriority = Math.min(inferencePriority, saveInferencePriority)
						}
					}
				}
				if typeVariableCount == 0 {
					intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
					if intersectionTypeVariable {
						inferWithPriority(source, intersectionTypeVariable, InferencePriorityNakedTypeVariable)
					}
					return
				}
				if typeVariableCount == 1 && !inferenceCircularity {
					unmatched := flatMap(sources, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
						return /* TODO(Node ConditionalExpression): matched[i] ? undefined : s */ TODO
					})
					if unmatched.length {
						inferFromTypes(getUnionType(unmatched), nakedTypeVariable)
						return
					}
				}
			} else {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						typeVariableCount++
					} else {
						inferFromTypes(source, t)
					}
				}
			}
			if /* TODO(Node ConditionalExpression): targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0 */ TODO {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						inferWithPriority(source, t, InferencePriorityNakedTypeVariable)
					}
				}
			}
		}
		inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
			if (constraintType.flags & TypeFlagsUnion) || (constraintType.flags & TypeFlagsIntersection) {
				result := false
				for _, type_ := range (constraintType).types {
					result = inferToMappedType(source, target, type_) || result
				}
				return result
			}
			if constraintType.flags & TypeFlagsIndex {
				inference := getInferenceInfoForType((constraintType).type_)
				if inference && !inference.isFixed && !isFromInferenceBlockedSource(source) {
					inferredType := inferTypeForHomomorphicMappedType(source, target, constraintType)
					if inferredType {
						inferWithPriority(inferredType, inference.typeParameter /* TODO(Node ConditionalExpression): getObjectFlags(source) & ObjectFlags.NonInferrableType ? InferencePriority.PartialHomomorphicMappedType : InferencePriority.HomomorphicMappedType */, TODO)
					}
				}
				return true
			}
			if constraintType.flags & TypeFlagsTypeParameter {
				inferWithPriority(getIndexType(source /* TODO(Node ConditionalExpression): !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None */, TODO), constraintType, InferencePriorityMappedTypeConstraint)
				extendedConstraint := getConstraintOfType(constraintType)
				if extendedConstraint && inferToMappedType(source, target, extendedConstraint) {
					return true
				}
				propTypes := map_(getPropertiesOfType(source), getTypeOfSymbol)
				indexTypes := map_(getIndexInfosOfType(source), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return /* TODO(Node ConditionalExpression): info !== enumNumberIndexInfo ? info.type : neverType */ TODO
				})
				inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target))
				return true
			}
			return false
		}
		inferToConditionalType := func(source Type, target ConditionalType) {
			if source.flags & TypeFlagsConditional {
				inferFromTypes((source).checkType, target.checkType)
				inferFromTypes((source).extendsType, target.extendsType)
				inferFromTypes(getTrueTypeFromConditionalType(source), getTrueTypeFromConditionalType(target))
				inferFromTypes(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target))
			} else {
				targetTypes := [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)}
				inferToMultipleTypesWithPriority(source, targetTypes, target.flags /* TODO(Node ConditionalExpression): contravariant ? InferencePriority.ContravariantConditional : 0 */, TODO)
			}
		}
		inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
			matches := inferTypesFromTemplateLiteralType(source, target)
			types := target.types
			if matches || every(target.texts, func(s /* TODO inferred type string */ any) /* TODO inferred type boolean */ any {
				return s.length == 0
			}) {
				for i := 0; i < types.length; i++ {
					source := /* TODO(Node ConditionalExpression): matches ? matches[i] : neverType */ TODO
					target := types[i]
					if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsTypeVariable {
						inferenceContext := getInferenceInfoForType(target)
						constraint := /* TODO(Node ConditionalExpression): inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : undefined */ TODO
						if constraint && !isTypeAny(constraint) {
							constraintTypes := /* TODO(Node ConditionalExpression): constraint.flags & TypeFlags.Union ? (constraint as UnionType).types : [constraint] */ TODO
							var allTypeFlags TypeFlags = reduceLeft(constraintTypes, func(flags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
								return flags | t.flags
							}, 0)
							if !(allTypeFlags & TypeFlagsString) {
								str := (source).value
								if allTypeFlags&TypeFlagsNumberLike && !isValidNumberString(str, true) {
									allTypeFlags &= ~TypeFlagsNumberLike
								}
								if allTypeFlags&TypeFlagsBigIntLike && !isValidBigIntString(str, true) {
									allTypeFlags &= ~TypeFlagsBigIntLike
								}
								matchingType := reduceLeft(constraintTypes, func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
									return /* TODO(Node ConditionalExpression): !(right.flags & allTypeFlags) ? left : left.flags & TypeFlags.String ? left : right.flags & TypeFlags.String ? source : left.flags & TypeFlags.TemplateLiteral ? left : right.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right as TemplateLiteralType) ? source : left.flags & TypeFlags.StringMapping ? left : right.flags & TypeFlags.StringMapping && str === applyStringMapping(right.symbol, str) ? source : left.flags & TypeFlags.StringLiteral ? left : right.flags & TypeFlags.StringLiteral && (right as StringLiteralType).value === str ? right : left.flags & TypeFlags.Number ? left : right.flags & TypeFlags.Number ? getNumberLiteralType(+str) : left.flags & TypeFlags.Enum ? left : right.flags & TypeFlags.Enum ? getNumberLiteralType(+str) : left.flags & TypeFlags.NumberLiteral ? left : right.flags & TypeFlags.NumberLiteral && (right as NumberLiteralType).value === +str ? right : left.flags & TypeFlags.BigInt ? left : right.flags & TypeFlags.BigInt ? parseBigIntLiteralType(str) : left.flags & TypeFlags.BigIntLiteral ? left : right.flags & TypeFlags.BigIntLiteral && pseudoBigIntToString((right as BigIntLiteralType).value) === str ? right : left.flags & TypeFlags.Boolean ? left : right.flags & TypeFlags.Boolean ? str === "true" ? trueType : str === "false" ? falseType : booleanType : left.flags & TypeFlags.BooleanLiteral ? left : right.flags & TypeFlags.BooleanLiteral && (right as IntrinsicType).intrinsicName === str ? right : left.flags & TypeFlags.Undefined ? left : right.flags & TypeFlags.Undefined && (right as IntrinsicType).intrinsicName === str ? right : left.flags & TypeFlags.Null ? left : right.flags & TypeFlags.Null && (right as IntrinsicType).intrinsicName === str ? right : left */ TODO
								}, neverType)
								if !(matchingType.flags & TypeFlagsNever) {
									inferFromTypes(matchingType, target)
									continue
								}
							}
						}
					}
					inferFromTypes(source, target)
				}
			}
		}
		inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
			inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target))
			inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target))
			sourceNameType := getNameTypeFromMappedType(source)
			targetNameType := getNameTypeFromMappedType(target)
			if sourceNameType && targetNameType {
				inferFromTypes(sourceNameType, targetNameType)
			}
		}
		inferFromObjectTypes := func(source Type, target Type) {
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source).target == (target).target || isArrayType(source) && isArrayType(target)) {
				inferFromTypeArguments(getTypeArguments(source), getTypeArguments(target), getVariances((source).target))
				return
			}
			if isGenericMappedType(source) && isGenericMappedType(target) {
				inferFromGenericMappedTypes(source, target)
			}
			if getObjectFlags(target)&ObjectFlagsMapped && !(target).declaration.nameType {
				constraintType := getConstraintTypeFromMappedType(target)
				if inferToMappedType(source, target, constraintType) {
					return
				}
			}
			if !typesDefinitelyUnrelated(source, target) {
				if isArrayOrTupleType(source) {
					if isTupleType(target) {
						sourceArity := getTypeReferenceArity(source)
						targetArity := getTypeReferenceArity(target)
						elementTypes := getTypeArguments(target)
						elementFlags := target.target.elementFlags
						if isTupleType(source) && isTupleTypeStructureMatching(source, target) {
							for i := 0; i < targetArity; i++ {
								inferFromTypes(getTypeArguments(source)[i], elementTypes[i])
							}
							return
						}
						startLength := /* TODO(Node ConditionalExpression): isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0 */ TODO
						endLength := Math.min( /* TODO(Node ConditionalExpression): isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0 */ TODO /* TODO(Node ConditionalExpression): target.target.combinedFlags & ElementFlags.Variable ? getEndElementCount(target.target, ElementFlags.Fixed) : 0 */, TODO)
						for i := 0; i < startLength; i++ {
							inferFromTypes(getTypeArguments(source)[i], elementTypes[i])
						}
						if !isTupleType(source) || sourceArity-startLength-endLength == 1 && source.target.elementFlags[startLength]&ElementFlagsRest {
							restType := getTypeArguments(source)[startLength]
							for i := startLength; i < targetArity-endLength; i++ {
								inferFromTypes( /* TODO(Node ConditionalExpression): elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType */ TODO, elementTypes[i])
							}
						} else {
							middleLength := targetArity - startLength - endLength
							if middleLength == 2 {
								if elementFlags[startLength] & elementFlags[startLength+1] & ElementFlagsVariadic {
									targetInfo := getInferenceInfoForType(elementTypes[startLength])
									if targetInfo && targetInfo.impliedArity != nil {
										inferFromTypes(sliceTupleType(source, startLength, endLength+sourceArity-targetInfo.impliedArity), elementTypes[startLength])
										inferFromTypes(sliceTupleType(source, startLength+targetInfo.impliedArity, endLength), elementTypes[startLength+1])
									}
								} else if elementFlags[startLength]&ElementFlagsVariadic && elementFlags[startLength+1]&ElementFlagsRest {
									param := getInferenceInfoForType(elementTypes[startLength]). /*?*/ typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										inferFromTypes(sliceTupleType(source, startLength, sourceArity-(startLength+impliedArity)), elementTypes[startLength])
										inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength+impliedArity, endLength), elementTypes[startLength+1])
									}
								} else if elementFlags[startLength]&ElementFlagsRest && elementFlags[startLength+1]&ElementFlagsVariadic {
									param := getInferenceInfoForType(elementTypes[startLength+1]). /*?*/ typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										endIndex := sourceArity - getEndElementCount(target.target, ElementFlagsFixed)
										startIndex := endIndex - impliedArity
										trailingSlice := createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex), false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex))
										inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength+impliedArity), elementTypes[startLength])
										inferFromTypes(trailingSlice, elementTypes[startLength+1])
									}
								}
							} else if middleLength == 1 && elementFlags[startLength]&ElementFlagsVariadic {
								endsInOptional := target.target.elementFlags[targetArity-1] & ElementFlagsOptional
								sourceSlice := sliceTupleType(source, startLength, endLength)
								inferWithPriority(sourceSlice, elementTypes[startLength] /* TODO(Node ConditionalExpression): endsInOptional ? InferencePriority.SpeculativeTuple : 0 */, TODO)
							} else if middleLength == 1 && elementFlags[startLength]&ElementFlagsRest {
								restType := getElementTypeOfSliceOfTupleType(source, startLength, endLength)
								if restType {
									inferFromTypes(restType, elementTypes[startLength])
								}
							}
						}
						for i := 0; i < endLength; i++ {
							inferFromTypes(getTypeArguments(source)[sourceArity-i-1], elementTypes[targetArity-i-1])
						}
						return
					}
					if isArrayType(target) {
						inferFromIndexTypes(source, target)
						return
					}
				}
				inferFromProperties(source, target)
				inferFromSignatures(source, target, SignatureKindCall)
				inferFromSignatures(source, target, SignatureKindConstruct)
				inferFromIndexTypes(source, target)
			}
		}
		inferFromProperties := func(source Type, target Type) {
			properties := getPropertiesOfObjectType(target)
			for _, targetProp := range properties {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag) {
					inferFromTypes(removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags&SymbolFlagsOptional)), removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags&SymbolFlagsOptional)))
				}
			}
		}
		inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
			sourceSignatures := getSignaturesOfType(source, kind)
			sourceLen := sourceSignatures.length
			if sourceLen > 0 {
				targetSignatures := getSignaturesOfType(target, kind)
				targetLen := targetSignatures.length
				for i := 0; i < targetLen; i++ {
					sourceIndex := Math.max(sourceLen-targetLen+i, 0)
					inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]))
				}
			}
		}
		inferFromSignature := func(source Signature, target Signature) {
			if !(source.flags & SignatureFlagsIsNonInferrable) {
				saveBivariant := bivariant
				kind := /* TODO(Node ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
				bivariant = bivariant || kind == SyntaxKindMethodDeclaration || kind == SyntaxKindMethodSignature || kind == SyntaxKindConstructor
				applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes)
				bivariant = saveBivariant
			}
			applyToReturnTypes(source, target, inferFromTypes)
		}
		inferFromIndexTypes := func(source Type, target Type) {
			priority := /* TODO(Node ConditionalExpression): (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0 */ TODO
			indexInfos := getIndexInfosOfType(target)
			if isObjectTypeWithInferableIndex(source) {
				for _, targetInfo := range indexInfos {
					var propTypes []Type = [] /* TODO inferred type never */ any{}
					for _, prop := range getPropertiesOfType(source) {
						if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), targetInfo.keyType) {
							propType := getTypeOfSymbol(prop)
							propTypes.push( /* TODO(Node ConditionalExpression): prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType */ TODO)
						}
					}
					for _, info := range getIndexInfosOfType(source) {
						if isApplicableIndexType(info.keyType, targetInfo.keyType) {
							propTypes.push(info.type_)
						}
					}
					if propTypes.length {
						inferWithPriority(getUnionType(propTypes), targetInfo.type_, priority)
					}
				}
			}
			for _, targetInfo := range indexInfos {
				sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
				if sourceInfo {
					inferWithPriority(sourceInfo.type_, targetInfo.type_, priority)
				}
			}
		}
	}
	isTypeOrBaseIdenticalTo := func(s Type, t Type) /* TODO inferred type boolean */ any {
		// converted from conditional expression
		switch {
		case t == missingType:
			return s == t
		default:
			return (isTypeIdenticalTo(s, t) || !!(t.flags&TypeFlagsString && s.flags&TypeFlagsStringLiteral || t.flags&TypeFlagsNumber && s.flags&TypeFlagsNumberLiteral))
		}
	}
	isTypeCloselyMatchedBy := func(s Type, t Type) /* TODO inferred type boolean */ any {
		return !!(s.flags&TypeFlagsObject && t.flags&TypeFlagsObject && s.symbol && s.symbol == t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol == t.aliasSymbol)
	}
	hasPrimitiveConstraint := func(type_ TypeParameter) bool {
		constraint := getConstraintOfTypeParameter(type_)
		return !!constraint && maybeTypeOfKind( /* TODO(Node ConditionalExpression): constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint */ TODO, TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
	}
	isObjectLiteralType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(getObjectFlags(type_) & ObjectFlagsObjectLiteral)
	}
	isObjectOrArrayLiteralType := func(type_ Type) /* TODO inferred type boolean */ any {
		return !!(getObjectFlags(type_) & (ObjectFlagsObjectLiteral | ObjectFlagsArrayLiteral))
	}
	unionObjectAndArrayLiteralCandidates := func(candidates []Type) []Type {
		if candidates.length > 1 {
			objectLiterals := filter(candidates, isObjectOrArrayLiteralType)
			if objectLiterals.length {
				literalsType := getUnionType(objectLiterals, UnionReductionSubtype)
				return concatenate(filter(candidates, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !isObjectOrArrayLiteralType(t)
				}), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{literalsType})
			}
		}
		return candidates
	}
	getContravariantInference := func(inference InferenceInfo) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case inference.priority & InferencePriorityPriorityImpliesCombination:
			return getIntersectionType(inference.contraCandidates)
		default:
			return getCommonSubtype(inference.contraCandidates)
		}
	}
	getCovariantInference := func(inference InferenceInfo, signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		candidates := unionObjectAndArrayLiteralCandidates(inference.candidates)
		primitiveConstraint := hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter)
		widenLiteralTypes := !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter))
		baseCandidates := /* TODO(Node ConditionalExpression): primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) : widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) : candidates */ TODO
		unwidenedType := /* TODO(Node ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ? getUnionType(baseCandidates, UnionReduction.Subtype) : getCommonSupertype(baseCandidates) */ TODO
		return getWidenedType(unwidenedType)
	}
	getInferredType := func(context InferenceContext, index number) Type {
		inference := context.inferences[index]
		if !inference.inferredType {
			var inferredType *Type
			var fallbackType *Type
			if context.signature {
				inferredCovariantType := /* TODO(Node ConditionalExpression): inference.candidates ? getCovariantInference(inference, context.signature) : undefined */ TODO
				inferredContravariantType := /* TODO(Node ConditionalExpression): inference.contraCandidates ? getContravariantInference(inference) : undefined */ TODO
				if inferredCovariantType || inferredContravariantType {
					preferCovariantType := inferredCovariantType && (!inferredContravariantType || !(inferredCovariantType.flags&(TypeFlagsNever|TypeFlagsAny)) && some(inference.contraCandidates, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return isTypeAssignableTo(inferredCovariantType, t)
					}) && every(context.inferences, func(other /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type boolean */ any {
						return other != inference && getConstraintOfTypeParameter(other.typeParameter) != inference.typeParameter || every(other.candidates, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
							return isTypeAssignableTo(t, inferredCovariantType)
						})
					}))
					inferredType = /* TODO(Node ConditionalExpression): preferCovariantType ? inferredCovariantType : inferredContravariantType */ TODO
					fallbackType = /* TODO(Node ConditionalExpression): preferCovariantType ? inferredContravariantType : inferredCovariantType */ TODO
				} else if context.flags & InferenceFlagsNoDefault {
					inferredType = silentNeverType
				} else {
					defaultType := getDefaultFromTypeParameter(inference.typeParameter)
					if defaultType {
						inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper))
					}
				}
			} else {
				inferredType = getTypeFromInference(inference)
			}
			inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlagsAnyDefault))
			constraint := getConstraintOfTypeParameter(inference.typeParameter)
			if constraint {
				instantiatedConstraint := instantiateType(constraint, context.nonFixingMapper)
				if !inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType)) {
					inference.inferredType = /* TODO(Node ConditionalExpression): fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint */ TODO
				}
			}
		}
		return inference.inferredType
	}
	getDefaultTypeArgumentType := func(isInJavaScriptFile bool) Type {
		// converted from conditional expression
		switch {
		case isInJavaScriptFile:
			return anyType
		default:
			return unknownType
		}
	}
	getInferredTypes := func(context InferenceContext) []Type {
		var result []Type = [] /* TODO inferred type never */ any{}
		for i := 0; i < context.inferences.length; i++ {
			result.push(getInferredType(context, i))
		}
		return result
	}
	getCannotFindNameDiagnosticForName := func(node Identifier) DiagnosticMessage {
		switch node.escapedText {
		case "document":
			fallthrough // TODO: merge cases
		case "console":
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom
		case "$":
			// converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery
			}
		case "describe":
			fallthrough // TODO: merge cases
		case "suite":
			fallthrough // TODO: merge cases
		case "it":
			fallthrough // TODO: merge cases
		case "test":
			// converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha
			}
		case "process":
			fallthrough // TODO: merge cases
		case "require":
			fallthrough // TODO: merge cases
		case "Buffer":
			fallthrough // TODO: merge cases
		case "module":
			// converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode
			}
		case "Bun":
			// converted from conditional expression
			switch {
			case compilerOptions.types:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig
			default:
				return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun
			}
		case "Map":
			fallthrough // TODO: merge cases
		case "Set":
			fallthrough // TODO: merge cases
		case "Promise":
			fallthrough // TODO: merge cases
		case "Symbol":
			fallthrough // TODO: merge cases
		case "WeakMap":
			fallthrough // TODO: merge cases
		case "WeakSet":
			fallthrough // TODO: merge cases
		case "Iterator":
			fallthrough // TODO: merge cases
		case "AsyncIterator":
			fallthrough // TODO: merge cases
		case "SharedArrayBuffer":
			fallthrough // TODO: merge cases
		case "Atomics":
			fallthrough // TODO: merge cases
		case "AsyncIterable":
			fallthrough // TODO: merge cases
		case "AsyncIterableIterator":
			fallthrough // TODO: merge cases
		case "AsyncGenerator":
			fallthrough // TODO: merge cases
		case "AsyncGeneratorFunction":
			fallthrough // TODO: merge cases
		case "BigInt":
			fallthrough // TODO: merge cases
		case "Reflect":
			fallthrough // TODO: merge cases
		case "BigInt64Array":
			fallthrough // TODO: merge cases
		case "BigUint64Array":
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later
		case "await":
			if isCallExpression(node.parent) {
				return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function
			}
			fallthrough
		default:
			if node.parent.kind == SyntaxKindShorthandPropertyAssignment {
				return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer
			} else {
				return Diagnostics.Cannot_find_name_0
			}
		}
	}
	getResolvedSymbol := func(node Identifier) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			links.resolvedSymbol = !nodeIsMissing(node) && resolveName(node, node, SymbolFlagsValue|SymbolFlagsExportValue, getCannotFindNameDiagnosticForName(node), !isWriteOnlyAccess(node), false) || unknownSymbol
		}
		return links.resolvedSymbol
	}
	isInAmbientOrTypeNode := func(node Node) bool {
		return !!(node.flags&NodeFlagsAmbient || findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n)
		}))
	}
	getFlowCacheKey := func(node Node, declaredType Type, initialType Type, flowContainer Node) *string {
		switch node.kind {
		case SyntaxKindIdentifier:
			if !isThisInTypeQuery(node) {
				symbol := getResolvedSymbol(node)
				// converted from conditional expression
				switch {
				case symbol != unknownSymbol:
					return /* TODO(Node TemplateExpression): `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` */ TODO
				default:
					return nil
				}
			}
			fallthrough
		case SyntaxKindThisKeyword:
			return /* TODO(Node TemplateExpression): `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}` */ TODO
		case SyntaxKindNonNullExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return getFlowCacheKey((node).expression, declaredType, initialType, flowContainer)
		case SyntaxKindQualifiedName:
			left := getFlowCacheKey((node).left, declaredType, initialType, flowContainer)
			return left && /* TODO(Node TemplateExpression): `${left}.${(node as QualifiedName).right.escapedText}` */ TODO
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			propName := getAccessedPropertyName(node)
			if propName != nil {
				key := getFlowCacheKey((node).expression, declaredType, initialType, flowContainer)
				return key && /* TODO(Node TemplateExpression): `${key}.${propName}` */ TODO
			}
			if isElementAccessExpression(node) && isIdentifier(node.argumentExpression) {
				symbol := getResolvedSymbol(node.argumentExpression)
				if isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol) {
					key := getFlowCacheKey((node).expression, declaredType, initialType, flowContainer)
					return key && /* TODO(Node TemplateExpression): `${key}.@${getSymbolId(symbol)}` */ TODO
				}
			}
			break
		case SyntaxKindObjectBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			return /* TODO(Node TemplateExpression): `${getNodeId(node)}#${getTypeId(declaredType)}` */ TODO
		}
		return nil
	}
	isMatchingReference := func(source Node, target Node) bool {
		switch target.kind {
		case SyntaxKindParenthesizedExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNonNullExpression:
			return isMatchingReference(source, (target).expression)
		case SyntaxKindBinaryExpression:
			return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) || (isBinaryExpression(target) && target.operatorToken.kind == SyntaxKindCommaToken && isMatchingReference(source, target.right))
		}
		switch source.kind {
		case SyntaxKindMetaProperty:
			return target.kind == SyntaxKindMetaProperty && (source).keywordToken == (target).keywordToken && (source).name.escapedText == (target).name.escapedText
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPrivateIdentifier:
			// converted from conditional expression
			switch {
			case isThisInTypeQuery(source):
				return target.kind == SyntaxKindThisKeyword
			default:
				return target.kind == SyntaxKindIdentifier && getResolvedSymbol(source) == getResolvedSymbol(target) || (isVariableDeclaration(target) || isBindingElement(target)) && getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source)) == getSymbolOfDeclaration(target)
			}
		case SyntaxKindThisKeyword:
			return target.kind == SyntaxKindThisKeyword
		case SyntaxKindSuperKeyword:
			return target.kind == SyntaxKindSuperKeyword
		case SyntaxKindNonNullExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return isMatchingReference((source).expression, target)
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			sourcePropertyName := getAccessedPropertyName(source)
			if sourcePropertyName != nil {
				targetPropertyName := /* TODO(Node ConditionalExpression): isAccessExpression(target) ? getAccessedPropertyName(target) : undefined */ TODO
				if targetPropertyName != nil {
					return targetPropertyName == sourcePropertyName && isMatchingReference((source).expression, (target).expression)
				}
			}
			if isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression) {
				symbol := getResolvedSymbol(source.argumentExpression)
				if symbol == getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {
					return isMatchingReference(source.expression, target.expression)
				}
			}
			break
		case SyntaxKindQualifiedName:
			return isAccessExpression(target) && (source).right.escapedText == getAccessedPropertyName(target) && isMatchingReference((source).left, target.expression)
		case SyntaxKindBinaryExpression:
			return (isBinaryExpression(source) && source.operatorToken.kind == SyntaxKindCommaToken && isMatchingReference(source.right, target))
		}
		return false
	}
	getAccessedPropertyName := func(access /* TODO(TypeNode UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
		if isPropertyAccessExpression(access) {
			return access.name.escapedText
		}
		if isElementAccessExpression(access) {
			return tryGetElementAccessExpressionName(access)
		}
		if isBindingElement(access) {
			name := getDestructuringPropertyName(access)
			// converted from conditional expression
			switch {
			case name:
				return escapeLeadingUnderscores(name)
			default:
				return nil
			}
		}
		if isParameter(access) {
			return ("" + access.parent.parameters.indexOf(access))
		}
		return nil
	}
	tryGetNameFromType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUniqueESSymbol:
			return (type_).escapedName
		case type_.flags & TypeFlagsStringOrNumberLiteral:
			return escapeLeadingUnderscores("" + (type_).value)
		default:
			return nil
		}
	}
	tryGetElementAccessExpressionName := func(node ElementAccessExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		// converted from conditional expression
		switch {
		case isStringOrNumericLiteralLike(node.argumentExpression):
			return escapeLeadingUnderscores(node.argumentExpression.text)
		case isEntityNameExpression(node.argumentExpression):
			return tryGetNameFromEntityNameExpression(node.argumentExpression)
		default:
			return nil
		}
	}
	tryGetNameFromEntityNameExpression := func(node EntityNameOrEntityNameExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		symbol := resolveEntityName(node, SymbolFlagsValue, true)
		if !symbol || !(isConstantVariable(symbol) || (symbol.flags & SymbolFlagsEnumMember)) {
			return nil
		}
		declaration := symbol.valueDeclaration
		if declaration == nil {
			return nil
		}
		type_ := tryGetTypeFromEffectiveTypeNode(declaration)
		if type_ {
			name := tryGetNameFromType(type_)
			if name != nil {
				return name
			}
		}
		if hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node) {
			initializer := getEffectiveInitializer(declaration)
			if initializer {
				initializerType := /* TODO(Node ConditionalExpression): isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer) */ TODO
				return initializerType && tryGetNameFromType(initializerType)
			}
			if isEnumMember(declaration) {
				return getTextOfPropertyName(declaration.name)
			}
		}
		return nil
	}
	containsMatchingReference := func(source Node, target Node) /* TODO inferred type boolean */ any {
		for isAccessExpression(source) {
			source = source.expression
			if isMatchingReference(source, target) {
				return true
			}
		}
		return false
	}
	optionalChainContainsReference := func(source Node, target Node) /* TODO inferred type boolean */ any {
		for isOptionalChain(source) {
			source = source.expression
			if isMatchingReference(source, target) {
				return true
			}
		}
		return false
	}
	isDiscriminantProperty := func(type_ *Type, name __String) /* TODO inferred type boolean */ any {
		if type_ && type_.flags&TypeFlagsUnion {
			prop := getUnionOrIntersectionProperty(type_, name)
			if prop && getCheckFlags(prop)&CheckFlagsSyntheticProperty {
				if (prop).links.isDiscriminantProperty == nil {
					(prop).links.isDiscriminantProperty = ((prop).links.checkFlags&CheckFlagsDiscriminant) == CheckFlagsDiscriminant && !isGenericType(getTypeOfSymbol(prop))
				}
				return !!(prop).links.isDiscriminantProperty
			}
		}
		return false
	}
	findDiscriminantProperties := func(sourceProperties []Symbol, target Type) *[]Symbol {
		var result *[]Symbol
		for _, sourceProperty := range sourceProperties {
			if isDiscriminantProperty(target, sourceProperty.escapedName) {
				if result {
					result.push(sourceProperty)
					continue
				}
				result = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{sourceProperty}
			}
		}
		return result
	}
	mapTypesByKeyProperty := func(types []Type, name __String) /* TODO inferred type Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").Type> | undefined */ any {
		map_ := make(map[TypeId]Type)
		count := 0
		for _, type_ := range types {
			if type_.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive) {
				discriminant := getTypeOfPropertyOfType(type_, name)
				if discriminant {
					if !isLiteralType(discriminant) {
						return nil
					}
					duplicate := false
					forEachType(discriminant, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
						id := getTypeId(getRegularTypeOfLiteralType(t))
						existing := map_.get(id)
						if !existing {
							map_.set(id, type_)
						} else if existing != unknownType {
							map_.set(id, unknownType)
							duplicate = true
						}
					})
					if !duplicate {
						count++
					}
				}
			}
		}
		// converted from conditional expression
		switch {
		case count >= 10 && count*2 >= types.length:
			return map_
		default:
			return nil
		}
	}
	getKeyPropertyName := func(unionType UnionType) *__String {
		types := unionType.types
		if types.length < 10 || getObjectFlags(unionType)&ObjectFlagsPrimitiveUnion || countWhere(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & (TypeFlagsObject | TypeFlagsInstantiableNonPrimitive))
		}) < 10 {
			return nil
		}
		if unionType.keyPropertyName == nil {
			keyPropertyName := forEach(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | import("/home/jabaile/work/TypeScript/src/compiler/types").InternalSymbolName | undefined */ any {
				return /* TODO(Node ConditionalExpression): t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) ? forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined) : undefined */ TODO
			})
			mapByKeyProperty := keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName)
			unionType.keyPropertyName = /* TODO(Node ConditionalExpression): mapByKeyProperty ? keyPropertyName : "" as __String */ TODO
			unionType.constituentMap = mapByKeyProperty
		}
		// converted from conditional expression
		switch {
		case (unionType.keyPropertyName).length:
			return unionType.keyPropertyName
		default:
			return nil
		}
	}
	getConstituentTypeForKeyType := func(unionType UnionType, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		result := unionType.constituentMap. /*?*/ get(getTypeId(getRegularTypeOfLiteralType(keyType)))
		// converted from conditional expression
		switch {
		case result != unknownType:
			return result
		default:
			return nil
		}
	}
	getMatchingUnionConstituentForType := func(unionType UnionType, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		keyPropertyName := getKeyPropertyName(unionType)
		propType := keyPropertyName && getTypeOfPropertyOfType(type_, keyPropertyName)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	getMatchingUnionConstituentForObjectLiteral := func(unionType UnionType, node ObjectLiteralExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		keyPropertyName := getKeyPropertyName(unionType)
		propNode := keyPropertyName && find(node.properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").ShorthandPropertyAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").SpreadAssignment */ any) /* TODO inferred type boolean */ any {
			return p.symbol && p.kind == SyntaxKindPropertyAssignment && p.symbol.escapedName == keyPropertyName && isPossiblyDiscriminantValue(p.initializer)
		})
		propType := propNode && getContextFreeTypeOfExpression((propNode).initializer)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	isOrContainsMatchingReference := func(source Node, target Node) /* TODO inferred type boolean */ any {
		return isMatchingReference(source, target) || containsMatchingReference(source, target)
	}
	hasMatchingArgument := func(expression /* TODO(TypeNode UnionType): CallExpression | NewExpression */ any, reference Node) /* TODO inferred type boolean */ any {
		if expression.arguments {
			for _, argument := range expression.arguments {
				if isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference) {
					return true
				}
			}
		}
		if expression.expression.kind == SyntaxKindPropertyAccessExpression && isOrContainsMatchingReference(reference, (expression.expression).expression) {
			return true
		}
		return false
	}
	getFlowNodeId := func(flow FlowNode) number {
		if flow.id <= 0 {
			flow.id = nextFlowId
			nextFlowId++
		}
		return flow.id
	}
	typeMaybeAssignableTo := func(source Type, target Type) /* TODO inferred type boolean */ any {
		if !(source.flags & TypeFlagsUnion) {
			return isTypeAssignableTo(source, target)
		}
		for _, t := range (source).types {
			if isTypeAssignableTo(t, target) {
				return true
			}
		}
		return false
	}
	getAssignmentReducedType := func(declaredType UnionType, assignedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if declaredType == assignedType {
			return declaredType
		}
		if assignedType.flags & TypeFlagsNever {
			return assignedType
		}
		key := /* TODO(Node TemplateExpression): `A${getTypeId(declaredType)},${getTypeId(assignedType)}` */ TODO
		return /* TODO(Node BinaryExpression): getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
	}
	getAssignmentReducedTypeWorker := func(declaredType UnionType, assignedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		filteredType := filterType(declaredType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return typeMaybeAssignableTo(assignedType, t)
		})
		reducedType := /* TODO(Node ConditionalExpression): assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType */ TODO
		// converted from conditional expression
		switch {
		case isTypeAssignableTo(assignedType, reducedType):
			return reducedType
		default:
			return declaredType
		}
	}
	isFunctionObjectType := func(type_ ObjectType) bool {
		if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
			return false
		}
		resolved := resolveStructuredTypeMembers(type_)
		return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get("bind") && isTypeSubtypeOf(type_, globalFunctionType))
	}
	getTypeFacts := func(type_ Type, mask TypeFacts) TypeFacts {
		return getTypeFactsWorker(type_, mask) & mask
	}
	hasTypeFacts := func(type_ Type, mask TypeFacts) bool {
		return getTypeFacts(type_, mask) != 0
	}
	getTypeFactsWorker := func(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
		if type_.flags & (TypeFlagsIntersection | TypeFlagsInstantiable) {
			type_ = getBaseConstraintOfType(type_) || unknownType
		}
		flags := type_.flags
		if flags & (TypeFlagsString | TypeFlagsStringMapping) {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsStringStrictFacts
			default:
				return TypeFactsStringFacts
			}
		}
		if flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral) {
			isEmpty := flags&TypeFlagsStringLiteral && (type_).value == ""
			// converted from conditional expression
			switch {
			case strictNullChecks:
				// converted from conditional expression
				switch {
				case isEmpty:
					return TypeFactsEmptyStringStrictFacts
				default:
					return TypeFactsNonEmptyStringStrictFacts
				}
			case isEmpty:
				return TypeFactsEmptyStringFacts
			default:
				return TypeFactsNonEmptyStringFacts
			}
		}
		if flags & (TypeFlagsNumber | TypeFlagsEnum) {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsNumberStrictFacts
			default:
				return TypeFactsNumberFacts
			}
		}
		if flags & TypeFlagsNumberLiteral {
			isZero := (type_).value == 0
			// converted from conditional expression
			switch {
			case strictNullChecks:
				// converted from conditional expression
				switch {
				case isZero:
					return TypeFactsZeroNumberStrictFacts
				default:
					return TypeFactsNonZeroNumberStrictFacts
				}
			case isZero:
				return TypeFactsZeroNumberFacts
			default:
				return TypeFactsNonZeroNumberFacts
			}
		}
		if flags & TypeFlagsBigInt {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsBigIntStrictFacts
			default:
				return TypeFactsBigIntFacts
			}
		}
		if flags & TypeFlagsBigIntLiteral {
			isZero := isZeroBigInt(type_)
			// converted from conditional expression
			switch {
			case strictNullChecks:
				// converted from conditional expression
				switch {
				case isZero:
					return TypeFactsZeroBigIntStrictFacts
				default:
					return TypeFactsNonZeroBigIntStrictFacts
				}
			case isZero:
				return TypeFactsZeroBigIntFacts
			default:
				return TypeFactsNonZeroBigIntFacts
			}
		}
		if flags & TypeFlagsBoolean {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsBooleanStrictFacts
			default:
				return TypeFactsBooleanFacts
			}
		}
		if flags & TypeFlagsBooleanLike {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				// converted from conditional expression
				switch {
				case (type_ == falseType || type_ == regularFalseType):
					return TypeFactsFalseStrictFacts
				default:
					return TypeFactsTrueStrictFacts
				}
			case (type_ == falseType || type_ == regularFalseType):
				return TypeFactsFalseFacts
			default:
				return TypeFactsTrueFacts
			}
		}
		if flags & TypeFlagsObject {
			possibleFacts := /* TODO(Node ConditionalExpression): strictNullChecks ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts */ TODO
			if (callerOnlyNeeds & possibleFacts) == 0 {
				return 0
			}
			// converted from conditional expression
			switch {
			case getObjectFlags(type_)&ObjectFlagsAnonymous && isEmptyObjectType(type_):
				// converted from conditional expression
				switch {
				case strictNullChecks:
					return TypeFactsEmptyObjectStrictFacts
				default:
					return TypeFactsEmptyObjectFacts
				}
			case isFunctionObjectType(type_):
				// converted from conditional expression
				switch {
				case strictNullChecks:
					return TypeFactsFunctionStrictFacts
				default:
					return TypeFactsFunctionFacts
				}
			case strictNullChecks:
				return TypeFactsObjectStrictFacts
			default:
				return TypeFactsObjectFacts
			}
		}
		if flags & TypeFlagsVoid {
			return TypeFactsVoidFacts
		}
		if flags & TypeFlagsUndefined {
			return TypeFactsUndefinedFacts
		}
		if flags & TypeFlagsNull {
			return TypeFactsNullFacts
		}
		if flags & TypeFlagsESSymbolLike {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsSymbolStrictFacts
			default:
				return TypeFactsSymbolFacts
			}
		}
		if flags & TypeFlagsNonPrimitive {
			// converted from conditional expression
			switch {
			case strictNullChecks:
				return TypeFactsObjectStrictFacts
			default:
				return TypeFactsObjectFacts
			}
		}
		if flags & TypeFlagsNever {
			return TypeFactsNone
		}
		if flags & TypeFlagsUnion {
			return reduceLeft((type_).types, func(facts /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/checker").TypeFacts.None */ any, t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type number */ any {
				return facts | getTypeFactsWorker(t, callerOnlyNeeds)
			}, TypeFactsNone)
		}
		if flags & TypeFlagsIntersection {
			return getIntersectionTypeFacts(type_, callerOnlyNeeds)
		}
		return TypeFactsUnknownFacts
	}
	getIntersectionTypeFacts := func(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
		ignoreObjects := maybeTypeOfKind(type_, TypeFlagsPrimitive)
		oredFacts := TypeFactsNone
		andedFacts := TypeFactsAll
		for _, t := range type_.types {
			if !(ignoreObjects && t.flags&TypeFlagsObject) {
				f := getTypeFactsWorker(t, callerOnlyNeeds)
				oredFacts |= f
				andedFacts &= f
			}
		}
		return oredFacts&TypeFactsOrFactsMask | andedFacts&TypeFactsAndFactsMask
	}
	getTypeWithFacts := func(type_ Type, include TypeFacts) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return hasTypeFacts(t, include)
		})
	}
	getAdjustedTypeWithFacts := func(type_ Type, facts TypeFacts) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		reduced := recombineUnknownType(getTypeWithFacts( /* TODO(Node ConditionalExpression): strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type */ TODO, facts))
		if strictNullChecks {
			switch facts {
			case TypeFactsNEUndefined:
				return removeNullableByIntersection(reduced, TypeFactsEQUndefined, TypeFactsEQNull, TypeFactsIsNull, nullType)
			case TypeFactsNENull:
				return removeNullableByIntersection(reduced, TypeFactsEQNull, TypeFactsEQUndefined, TypeFactsIsUndefined, undefinedType)
			case TypeFactsNEUndefinedOrNull:
				fallthrough // TODO: merge cases
			case TypeFactsTruthy:
				return mapType(reduced, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return /* TODO(Node ConditionalExpression): hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t */ TODO
				})
			}
		}
		return reduced
	}
	removeNullableByIntersection := func(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		facts := getTypeFacts(type_, TypeFactsEQUndefined|TypeFactsEQNull|TypeFactsIsUndefined|TypeFactsIsNull)
		if !(facts & targetFacts) {
			return type_
		}
		emptyAndOtherUnion := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{emptyObjectType, otherType})
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return /* TODO(Node ConditionalExpression): hasTypeFacts(t, targetFacts) ? getIntersectionType([t, !(facts & otherIncludesFacts) && hasTypeFacts(t, otherFacts) ? emptyAndOtherUnion : emptyObjectType]) : t */ TODO
		})
	}
	recombineUnknownType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_ == unknownUnionType:
			return unknownType
		default:
			return type_
		}
	}
	getTypeWithDefault := func(type_ Type, defaultExpression Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case defaultExpression:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getNonUndefinedType(type_), getTypeOfExpression(defaultExpression)})
		default:
			return type_
		}
	}
	getTypeOfDestructuredProperty := func(type_ Type, name PropertyName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		nameType := getLiteralTypeFromPropertyName(name)
		if !isTypeUsableAsPropertyName(nameType) {
			return errorType
		}
		text := getPropertyNameFromType(nameType)
		return getTypeOfPropertyOfType(type_, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type_, text). /*?*/ type_) || errorType
	}
	getTypeOfDestructuredArrayElement := func(type_ Type, index number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return everyType(type_, isTupleLikeType) && getTupleElementType(type_, index) || includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType, nil)) || errorType
	}
	includeUndefinedInIndexSignature := func(type_ *Type) *Type {
		if !type_ {
			return type_
		}
		// converted from conditional expression
		switch {
		case compilerOptions.noUncheckedIndexedAccess:
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, missingType})
		default:
			return type_
		}
	}
	getTypeOfDestructuredSpreadExpression := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return createArrayType(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType, nil) || errorType)
	}
	getAssignedTypeOfBinaryExpression := func(node BinaryExpression) Type {
		isDestructuringDefaultAssignment := node.parent.kind == SyntaxKindArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) || node.parent.kind == SyntaxKindPropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent)
		// converted from conditional expression
		switch {
		case isDestructuringDefaultAssignment:
			return getTypeWithDefault(getAssignedType(node), node.right)
		default:
			return getTypeOfExpression(node.right)
		}
	}
	isDestructuringAssignmentTarget := func(parent Node) /* TODO inferred type boolean */ any {
		return parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent).left == parent || parent.parent.kind == SyntaxKindForOfStatement && (parent.parent).initializer == parent
	}
	getAssignedTypeOfArrayLiteralElement := func(node ArrayLiteralExpression, element Expression) Type {
		return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element))
	}
	getAssignedTypeOfSpreadExpression := func(node SpreadElement) Type {
		return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent))
	}
	getAssignedTypeOfPropertyAssignment := func(node /* TODO(TypeNode UnionType): PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
		return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name)
	}
	getAssignedTypeOfShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) Type {
		return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer)
	}
	getAssignedType := func(node Expression) Type {
		TODO_IDENTIFIER := node
		switch parent.kind {
		case SyntaxKindForInStatement:
			return stringType
		case SyntaxKindForOfStatement:
			return checkRightHandSideOfForOf(parent) || errorType
		case SyntaxKindBinaryExpression:
			return getAssignedTypeOfBinaryExpression(parent)
		case SyntaxKindDeleteExpression:
			return undefinedType
		case SyntaxKindArrayLiteralExpression:
			return getAssignedTypeOfArrayLiteralElement(parent, node)
		case SyntaxKindSpreadElement:
			return getAssignedTypeOfSpreadExpression(parent)
		case SyntaxKindPropertyAssignment:
			return getAssignedTypeOfPropertyAssignment(parent)
		case SyntaxKindShorthandPropertyAssignment:
			return getAssignedTypeOfShorthandPropertyAssignment(parent)
		}
		return errorType
	}
	getInitialTypeOfBindingElement := func(node BindingElement) Type {
		pattern := node.parent
		parentType := getInitialType(pattern.parent)
		type_ := /* TODO(Node ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern ? getTypeOfDestructuredProperty(parentType, node.propertyName || node.name as Identifier) : !node.dotDotDotToken ? getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) : getTypeOfDestructuredSpreadExpression(parentType) */ TODO
		return getTypeWithDefault(type_, node.initializer)
	}
	getTypeOfInitializer := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		links := getNodeLinks(node)
		return links.resolvedType || getTypeOfExpression(node)
	}
	getInitialTypeOfVariableDeclaration := func(node VariableDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if node.initializer {
			return getTypeOfInitializer(node.initializer)
		}
		if node.parent.parent.kind == SyntaxKindForInStatement {
			return stringType
		}
		if node.parent.parent.kind == SyntaxKindForOfStatement {
			return checkRightHandSideOfForOf(node.parent.parent) || errorType
		}
		return errorType
	}
	getInitialType := func(node /* TODO(TypeNode UnionType): VariableDeclaration | BindingElement */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case node.kind == SyntaxKindVariableDeclaration:
			return getInitialTypeOfVariableDeclaration(node)
		default:
			return getInitialTypeOfBindingElement(node)
		}
	}
	isEmptyArrayAssignment := func(node /* TODO(TypeNode UnionType): VariableDeclaration | BindingElement | Expression */ any) /* TODO inferred type boolean */ any {
		return node.kind == SyntaxKindVariableDeclaration && (node).initializer && isEmptyArrayLiteral((node).initializer) || node.kind != SyntaxKindBindingElement && node.parent.kind == SyntaxKindBinaryExpression && isEmptyArrayLiteral((node.parent).right)
	}
	getReferenceCandidate := func(node Expression) Expression {
		switch node.kind {
		case SyntaxKindParenthesizedExpression:
			return getReferenceCandidate((node).expression)
		case SyntaxKindBinaryExpression:
			switch (node).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				return getReferenceCandidate((node).left)
			case SyntaxKindCommaToken:
				return getReferenceCandidate((node).right)
			}
		}
		return node
	}
	getReferenceRoot := func(node Node) Node {
		TODO_IDENTIFIER := node
		// converted from conditional expression
		switch {
		case parent.kind == SyntaxKindParenthesizedExpression || parent.kind == SyntaxKindBinaryExpression && (parent).operatorToken.kind == SyntaxKindEqualsToken && (parent).left == node || parent.kind == SyntaxKindBinaryExpression && (parent).operatorToken.kind == SyntaxKindCommaToken && (parent).right == node:
			return getReferenceRoot(parent)
		default:
			return node
		}
	}
	getTypeOfSwitchClause := func(clause /* TODO(TypeNode UnionType): CaseClause | DefaultClause */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if clause.kind == SyntaxKindCaseClause {
			return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression))
		}
		return neverType
	}
	getSwitchClauseTypes := func(switchStatement SwitchStatement) []Type {
		links := getNodeLinks(switchStatement)
		if !links.switchTypes {
			links.switchTypes = [] /* TODO inferred type never */ any{}
			for _, clause := range switchStatement.caseBlock.clauses {
				links.switchTypes.push(getTypeOfSwitchClause(clause))
			}
		}
		return links.switchTypes
	}
	getSwitchClauseTypeOfWitnesses := func(switchStatement SwitchStatement) *[]*string {
		if some(switchStatement.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ any) /* TODO inferred type boolean */ any {
			return clause.kind == SyntaxKindCaseClause && !isStringLiteralLike(clause.expression)
		}) {
			return nil
		}
		var witnesses []*string = [] /* TODO inferred type never */ any{}
		for _, clause := range switchStatement.caseBlock.clauses {
			text := /* TODO(Node ConditionalExpression): clause.kind === SyntaxKind.CaseClause ? (clause.expression as StringLiteralLike).text : undefined */ TODO
			witnesses.push( /* TODO(Node ConditionalExpression): text && !contains(witnesses, text) ? text : undefined */ TODO)
		}
		return witnesses
	}
	eachTypeContainedIn := func(source Type, types []Type) /* TODO inferred type boolean */ any {
		// converted from conditional expression
		switch {
		case source.flags & TypeFlagsUnion:
			return !forEach((source).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !contains(types, t)
			})
		default:
			return contains(types, source)
		}
	}
	isTypeSubsetOf := func(source Type, target Type) /* TODO inferred type boolean */ any {
		return !!(source == target || source.flags&TypeFlagsNever || target.flags&TypeFlagsUnion && isTypeSubsetOfUnion(source, target))
	}
	isTypeSubsetOfUnion := func(source Type, target UnionType) /* TODO inferred type boolean */ any {
		if source.flags & TypeFlagsUnion {
			for _, t := range (source).types {
				if !containsType(target.types, t) {
					return false
				}
			}
			return true
		}
		if source.flags&TypeFlagsEnumLike && getBaseTypeOfEnumLikeType(source) == target {
			return true
		}
		return containsType(target.types, source)
	}
	forEachType := func(type_ Type, f func(t Type) *T) *T {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return forEach((type_).types, f)
		default:
			return f(type_)
		}
	}
	someType := func(type_ Type, f func(t Type) bool) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return some((type_).types, f)
		default:
			return f(type_)
		}
	}
	everyType := func(type_ Type, f func(t Type) bool) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return every((type_).types, f)
		default:
			return f(type_)
		}
	}
	everyContainedType := func(type_ Type, f func(t Type) bool) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnionOrIntersection:
			return every((type_).types, f)
		default:
			return f(type_)
		}
	}
	filterType := func(type_ Type, f func(t Type) bool) Type {
		if type_.flags & TypeFlagsUnion {
			types := (type_).types
			filtered := filter(types, f)
			if filtered == types {
				return type_
			}
			origin := (type_).origin
			var newOrigin *Type
			if origin && origin.flags&TypeFlagsUnion {
				originTypes := (origin).types
				originFiltered := filter(originTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags & TypeFlagsUnion) || f(t)
				})
				if originTypes.length-originFiltered.length == types.length-filtered.length {
					if originFiltered.length == 1 {
						return originFiltered[0]
					}
					newOrigin = createOriginUnionOrIntersectionType(TypeFlagsUnion, originFiltered)
				}
			}
			return getUnionTypeFromSortedList(filtered, (type_).objectFlags&(ObjectFlagsPrimitiveUnion|ObjectFlagsContainsIntersections), nil, nil, newOrigin)
		}
		// converted from conditional expression
		switch {
		case type_.flags&TypeFlagsNever || f(type_):
			return type_
		default:
			return neverType
		}
	}
	removeType := func(type_ Type, targetType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return t != targetType
		})
	}
	countTypes := func(type_ Type) /* TODO inferred type number */ any {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return (type_).types.length
		default:
			return 1
		}
	}
	/* OVERLOAD: function mapType(type: Type, mapper: (t: Type) => Type, noReductions?: boolean): Type; */
	/* OVERLOAD: function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined; */
	mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type {
		if type_.flags & TypeFlagsNever {
			return type_
		}
		if !(type_.flags & TypeFlagsUnion) {
			return mapper(type_)
		}
		origin := (type_).origin
		types := /* TODO(Node ConditionalExpression): origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types */ TODO
		var mappedTypes *[]Type
		changed := false
		for _, t := range types {
			mapped := /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t) */ TODO
			/* TODO(Node BinaryExpression): changed ||= t !== mapped */ TODO
			if mapped {
				if !mappedTypes {
					mappedTypes = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{mapped}
				} else {
					mappedTypes.push(mapped)
				}
			}
		}
		// converted from conditional expression
		switch {
		case changed:
			return mappedTypes && getUnionType(mappedTypes /* TODO(Node ConditionalExpression): noReductions ? UnionReduction.None : UnionReduction.Literal */, TODO)
		default:
			return type_
		}
	}
	mapTypeWithAlias := func(type_ Type, mapper func(t Type) Type, aliasSymbol *Symbol, aliasTypeArguments *[]Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags&TypeFlagsUnion && aliasSymbol:
			return getUnionType(map_((type_).types, mapper), UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
		default:
			return mapType(type_, mapper)
		}
	}
	extractTypesOfKind := func(type_ Type, kind TypeFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return (t.flags & kind) != 0
		})
	}
	replacePrimitivesWithLiterals := func(typeWithPrimitives Type, typeWithLiterals Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if maybeTypeOfKind(typeWithPrimitives, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsNumber|TypeFlagsBigInt) && maybeTypeOfKind(typeWithLiterals, TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping|TypeFlagsNumberLiteral|TypeFlagsBigIntLiteral) {
			return mapType(typeWithPrimitives, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): t.flags & TypeFlags.String ? extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) : isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) : t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral) : t.flags & TypeFlags.BigInt ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral) : t */ TODO
			})
		}
		return typeWithPrimitives
	}
	isIncomplete := func(flowType FlowType) /* TODO inferred type boolean */ any {
		return flowType.flags == 0
	}
	getTypeFromFlowType := func(flowType FlowType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case flowType.flags == 0:
			return flowType.type_
		default:
			return flowType
		}
	}
	createFlowType := func(type_ Type, incomplete bool) FlowType {
		// converted from conditional expression
		switch {
		case incomplete:
			return /* TODO(Node ObjectLiteralExpression): { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } */ TODO
		default:
			return type_
		}
	}
	createEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		result := createObjectType(ObjectFlagsEvolvingArray)
		result.elementType = elementType
		return result
	}
	getEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		return evolvingArrayTypes[elementType.id] || ( /* TODO(Node BinaryExpression): evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType) */ TODO)
	}
	addEvolvingArrayElementType := func(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
		elementType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)))
		// converted from conditional expression
		switch {
		case isTypeSubsetOf(elementType, evolvingArrayType.elementType):
			return evolvingArrayType
		default:
			return getEvolvingArrayType(getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{evolvingArrayType.elementType, elementType}))
		}
	}
	createFinalArrayType := func(elementType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case elementType.flags & TypeFlagsNever:
			return autoArrayType
		default:
			return createArrayType( /* TODO(Node ConditionalExpression): elementType.flags & TypeFlags.Union ? getUnionType((elementType as UnionType).types, UnionReduction.Subtype) : elementType */ TODO)
		}
	}
	getFinalArrayType := func(evolvingArrayType EvolvingArrayType) Type {
		return evolvingArrayType.finalArrayType || ( /* TODO(Node BinaryExpression): evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType) */ TODO)
	}
	finalizeEvolvingArrayType := func(type_ Type) Type {
		// converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsEvolvingArray:
			return getFinalArrayType(type_)
		default:
			return type_
		}
	}
	getElementTypeOfEvolvingArrayType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case getObjectFlags(type_) & ObjectFlagsEvolvingArray:
			return (type_).elementType
		default:
			return neverType
		}
	}
	isEvolvingArrayTypeList := func(types []Type) /* TODO inferred type boolean */ any {
		hasEvolvingArrayType := false
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				if !(getObjectFlags(t) & ObjectFlagsEvolvingArray) {
					return false
				}
				hasEvolvingArrayType = true
			}
		}
		return hasEvolvingArrayType
	}
	isEvolvingArrayOperationTarget := func(node Node) /* TODO inferred type boolean */ any {
		root := getReferenceRoot(node)
		parent := root.parent
		isLengthPushOrUnshift := isPropertyAccessExpression(parent) && (parent.name.escapedText == "length" || parent.parent.kind == SyntaxKindCallExpression && isIdentifier(parent.name) && isPushOrUnshiftIdentifier(parent.name))
		isElementAssignment := parent.kind == SyntaxKindElementAccessExpression && (parent).expression == root && parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent).operatorToken.kind == SyntaxKindEqualsToken && (parent.parent).left == parent && !isAssignmentTarget(parent.parent) && isTypeAssignableToKind(getTypeOfExpression((parent).argumentExpression), TypeFlagsNumberLike)
		return isLengthPushOrUnshift || isElementAssignment
	}
	isDeclarationWithExplicitTypeAnnotation := func(node Declaration) /* TODO inferred type boolean */ any {
		return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer))
	}
	getExplicitTypeOfSymbol := func(symbol Symbol, diagnostic Diagnostic) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		symbol = resolveSymbol(symbol)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsValueModule) {
			return getTypeOfSymbol(symbol)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			if getCheckFlags(symbol) & CheckFlagsMapped {
				origin := (symbol).links.syntheticOrigin
				if origin && getExplicitTypeOfSymbol(origin) {
					return getTypeOfSymbol(symbol)
				}
			}
			declaration := symbol.valueDeclaration
			if declaration {
				if isDeclarationWithExplicitTypeAnnotation(declaration) {
					return getTypeOfSymbol(symbol)
				}
				if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
					statement := declaration.parent.parent
					expressionType := getTypeOfDottedName(statement.expression, nil)
					if expressionType {
						use := /* TODO(Node ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
						return checkIteratedTypeOrElementType(use, expressionType, undefinedType, nil)
					}
				}
				if diagnostic {
					addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)))
				}
			}
		}
	}
	getTypeOfDottedName := func(node Expression, diagnostic *Diagnostic) *Type {
		if !(node.flags & NodeFlagsInWithStatement) {
			switch node.kind {
			case SyntaxKindIdentifier:
				symbol := getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node))
				return getExplicitTypeOfSymbol(symbol, diagnostic)
			case SyntaxKindThisKeyword:
				return getExplicitThisType(node)
			case SyntaxKindSuperKeyword:
				return checkSuperExpression(node)
			case SyntaxKindPropertyAccessExpression:
				type_ := getTypeOfDottedName((node).expression, diagnostic)
				if type_ {
					name := (node).name
					var prop *Symbol
					if isPrivateIdentifier(name) {
						if !type_.symbol {
							return nil
						}
						prop = getPropertyOfType(type_, getSymbolNameForPrivateIdentifier(type_.symbol, name.escapedText))
					} else {
						prop = getPropertyOfType(type_, name.escapedText)
					}
					return prop && getExplicitTypeOfSymbol(prop, diagnostic)
				}
				return nil
				fallthrough
			case SyntaxKindParenthesizedExpression:
				return getTypeOfDottedName((node).expression, diagnostic)
			}
		}
	}
	getEffectsSignature := func(node /* TODO(TypeNode UnionType): CallExpression | InstanceofExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
		links := getNodeLinks(node)
		signature := links.effectsSignature
		if signature == nil {
			var funcType *Type
			if isBinaryExpression(node) {
				rightType := checkNonNullExpression(node.right)
				funcType = getSymbolHasInstanceMethodOfObjectType(rightType)
			} else if node.parent.kind == SyntaxKindExpressionStatement {
				funcType = getTypeOfDottedName(node.expression, nil)
			} else if node.expression.kind != SyntaxKindSuperKeyword {
				if isOptionalChain(node) {
					funcType = checkNonNullType(getOptionalExpressionType(checkExpression(node.expression), node.expression), node.expression)
				} else {
					funcType = checkNonNullExpression(node.expression)
				}
			}
			signatures := getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, SignatureKindCall)
			candidate := /* TODO(Node ConditionalExpression): signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] : some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) : undefined */ TODO
			signature = /* TODO(Node BinaryExpression): links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature */ TODO
		}
		// converted from conditional expression
		switch {
		case signature == unknownSignature:
			return nil
		default:
			return signature
		}
	}
	hasTypePredicateOrNeverReturnType := func(signature Signature) /* TODO inferred type boolean */ any {
		return !!(getTypePredicateOfSignature(signature) || signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags&TypeFlagsNever)
	}
	getTypePredicateArgument := func(predicate TypePredicate, callExpression CallExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ any {
		if predicate.kind == TypePredicateKindIdentifier || predicate.kind == TypePredicateKindAssertsIdentifier {
			return callExpression.arguments[predicate.parameterIndex]
		}
		invokedExpression := skipParentheses(callExpression.expression)
		// converted from conditional expression
		switch {
		case isAccessExpression(invokedExpression):
			return skipParentheses(invokedExpression.expression)
		default:
			return nil
		}
	}
	reportFlowControlError := func(node Node) {
		block := findAncestor(node, isFunctionOrModuleBlock)
		sourceFile := getSourceFileOfNode(node)
		span := getSpanOfTokenAtPosition(sourceFile, block.statements.pos)
		diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis))
	}
	isReachableFlowNode := func(flow FlowNode) /* TODO inferred type boolean */ any {
		result := isReachableFlowNodeWorker(flow, false)
		lastFlowNode = flow
		lastFlowNodeReachable = result
		return result
	}
	isFalseExpression := func(expr Expression) bool {
		node := skipParentheses(expr, true)
		return node.kind == SyntaxKindFalseKeyword || node.kind == SyntaxKindBinaryExpression && ((node).operatorToken.kind == SyntaxKindAmpersandAmpersandToken && (isFalseExpression((node).left) || isFalseExpression((node).right)) || (node).operatorToken.kind == SyntaxKindBarBarToken && isFalseExpression((node).left) && isFalseExpression((node).right))
	}
	isReachableFlowNodeWorker := func(flow FlowNode, noCacheCheck bool) bool {
		for true {
			if flow == lastFlowNode {
				return lastFlowNodeReachable
			}
			flags := flow.flags
			if flags & FlowFlagsShared {
				if !noCacheCheck {
					id := getFlowNodeId(flow)
					reachable := flowNodeReachable[id]
					// converted from conditional expression
					switch {
					case reachable != nil:
						return reachable
					default:
						return ( /* TODO(Node BinaryExpression): flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true) */ TODO)
					}
				}
				noCacheCheck = false
			}
			if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation) {
				flow = (flow).antecedent
			} else if flags & FlowFlagsCall {
				signature := getEffectsSignature((flow).node)
				if signature {
					predicate := getTypePredicateOfSignature(signature)
					if predicate && predicate.kind == TypePredicateKindAssertsIdentifier && !predicate.type_ {
						predicateArgument := (flow).node.arguments[predicate.parameterIndex]
						if predicateArgument && isFalseExpression(predicateArgument) {
							return false
						}
					}
					if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
						return false
					}
				}
				flow = (flow).antecedent
			} else if flags & FlowFlagsBranchLabel {
				return some((flow).antecedent, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode */ any) /* TODO inferred type boolean */ any {
					return isReachableFlowNodeWorker(f, false)
				})
			} else if flags & FlowFlagsLoopLabel {
				antecedents := (flow).antecedent
				if antecedents == nil || antecedents.length == 0 {
					return false
				}
				flow = antecedents[0]
			} else if flags & FlowFlagsSwitchClause {
				data := (flow).node
				if data.clauseStart == data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement) {
					return false
				}
				flow = (flow).antecedent
			} else if flags & FlowFlagsReduceLabel {
				lastFlowNode = nil
				target := (flow).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow).node.antecedents
				result := isReachableFlowNodeWorker((flow).antecedent, false)
				target.antecedent = saveAntecedents
				return result
			} else {
				return !(flags & FlowFlagsUnreachable)
			}
		}
	}
	isPostSuperFlowNode := func(flow FlowNode, noCacheCheck bool) bool {
		for true {
			flags := flow.flags
			if flags & FlowFlagsShared {
				if !noCacheCheck {
					id := getFlowNodeId(flow)
					postSuper := flowNodePostSuper[id]
					// converted from conditional expression
					switch {
					case postSuper != nil:
						return postSuper
					default:
						return ( /* TODO(Node BinaryExpression): flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true) */ TODO)
					}
				}
				noCacheCheck = false
			}
			if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation | FlowFlagsSwitchClause) {
				flow = (flow).antecedent
			} else if flags & FlowFlagsCall {
				if (flow).node.expression.kind == SyntaxKindSuperKeyword {
					return true
				}
				flow = (flow).antecedent
			} else if flags & FlowFlagsBranchLabel {
				return every((flow).antecedent, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode */ any) /* TODO inferred type boolean */ any {
					return isPostSuperFlowNode(f, false)
				})
			} else if flags & FlowFlagsLoopLabel {
				flow = (flow).antecedent[0]
			} else if flags & FlowFlagsReduceLabel {
				target := (flow).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow).node.antecedents
				result := isPostSuperFlowNode((flow).antecedent, false)
				target.antecedent = saveAntecedents
				return result
			} else {
				return !!(flags & FlowFlagsUnreachable)
			}
		}
	}
	isConstantReference := func(node Node) bool {
		switch node.kind {
		case SyntaxKindThisKeyword:
			return true
		case SyntaxKindIdentifier:
			if !isThisInTypeQuery(node) {
				symbol := getResolvedSymbol(node)
				return isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol) || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration)
			}
			break
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			return isConstantReference((node).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol)
		case SyntaxKindObjectBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayBindingPattern:
			rootDeclaration := getRootDeclaration(node.parent)
			// converted from conditional expression
			switch {
			case isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration):
				return !isSomeSymbolAssigned(rootDeclaration)
			default:
				return isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration)
			}
		}
		return false
	}
	getFlowTypeOfReference := func(reference Node, declaredType Type, initialType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any /*  = declaredType */, flowContainer Node, flowNode /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode | undefined */ any /*  = tryCast(reference, canHaveFlowNode)?.flowNode */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		var key *string
		isKeySet := false
		flowDepth := 0
		if flowAnalysisDisabled {
			return errorType
		}
		if !flowNode {
			return declaredType
		}
		flowInvocationCount++
		sharedFlowStart := sharedFlowCount
		evolvedType := getTypeFromFlowType(getTypeAtFlowNode(flowNode))
		sharedFlowCount = sharedFlowStart
		resultType := /* TODO(Node ConditionalExpression): getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType) */ TODO
		if resultType == unreachableNeverType || reference.parent && reference.parent.kind == SyntaxKindNonNullExpression && !(resultType.flags&TypeFlagsNever) && getTypeWithFacts(resultType, TypeFactsNEUndefinedOrNull).flags&TypeFlagsNever {
			return declaredType
		}
		return resultType
		getOrSetCacheKey := func() /* TODO inferred type string | undefined */ any {
			if isKeySet {
				return key
			}
			isKeySet = true
			key = getFlowCacheKey(reference, declaredType, initialType, flowContainer)
			return key
		}
		getTypeAtFlowNode := func(flow FlowNode) FlowType {
			if flowDepth == 2000 {
				tracing. /*?*/ instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit" /* TODO(Node ObjectLiteralExpression): { flowId: flow.id } */, TODO)
				flowAnalysisDisabled = true
				reportFlowControlError(reference)
				return errorType
			}
			flowDepth++
			var sharedFlow *FlowNode
			for true {
				flags := flow.flags
				if flags & FlowFlagsShared {
					for i := sharedFlowStart; i < sharedFlowCount; i++ {
						if sharedFlowNodes[i] == flow {
							flowDepth--
							return sharedFlowTypes[i]
						}
					}
					sharedFlow = flow
				}
				var type_ *FlowType
				if flags & FlowFlagsAssignment {
					type_ = getTypeAtFlowAssignment(flow)
					if !type_ {
						flow = (flow).antecedent
						continue
					}
				} else if flags & FlowFlagsCall {
					type_ = getTypeAtFlowCall(flow)
					if !type_ {
						flow = (flow).antecedent
						continue
					}
				} else if flags & FlowFlagsCondition {
					type_ = getTypeAtFlowCondition(flow)
				} else if flags & FlowFlagsSwitchClause {
					type_ = getTypeAtSwitchClause(flow)
				} else if flags & FlowFlagsLabel {
					if (flow).antecedent.length == 1 {
						flow = (flow).antecedent[0]
						continue
					}
					type_ = /* TODO(Node ConditionalExpression): flags & FlowFlags.BranchLabel ? getTypeAtFlowBranchLabel(flow as FlowLabel) : getTypeAtFlowLoopLabel(flow as FlowLabel) */ TODO
				} else if flags & FlowFlagsArrayMutation {
					type_ = getTypeAtFlowArrayMutation(flow)
					if !type_ {
						flow = (flow).antecedent
						continue
					}
				} else if flags & FlowFlagsReduceLabel {
					target := (flow).node.target
					saveAntecedents := target.antecedent
					target.antecedent = (flow).node.antecedents
					type_ = getTypeAtFlowNode((flow).antecedent)
					target.antecedent = saveAntecedents
				} else if flags & FlowFlagsStart {
					container := (flow).node
					if container && container != flowContainer && reference.kind != SyntaxKindPropertyAccessExpression && reference.kind != SyntaxKindElementAccessExpression && !(reference.kind == SyntaxKindThisKeyword && container.kind != SyntaxKindArrowFunction) {
						flow = container.flowNode
						continue
					}
					type_ = initialType
				} else {
					type_ = convertAutoToAny(declaredType)
				}
				if sharedFlow {
					sharedFlowNodes[sharedFlowCount] = sharedFlow
					sharedFlowTypes[sharedFlowCount] = type_
					sharedFlowCount++
				}
				flowDepth--
				return type_
			}
		}
		getInitialOrAssignedType := func(flow FlowAssignment) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			node := flow.node
			return getNarrowableTypeForReference( /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ? getInitialType(node as VariableDeclaration | BindingElement) : getAssignedType(node) */ TODO, reference)
		}
		getTypeAtFlowAssignment := func(flow FlowAssignment) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").FlowType | undefined */ any {
			node := flow.node
			if isMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if getAssignmentTargetKind(node) == AssignmentKindCompound {
					flowType := getTypeAtFlowNode(flow.antecedent)
					return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType))
				}
				if declaredType == autoType || declaredType == autoArrayType {
					if isEmptyArrayAssignment(node) {
						return getEvolvingArrayType(neverType)
					}
					assignedType := getWidenedLiteralType(getInitialOrAssignedType(flow))
					// converted from conditional expression
					switch {
					case isTypeAssignableTo(assignedType, declaredType):
						return assignedType
					default:
						return anyArrayType
					}
				}
				t := /* TODO(Node ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType */ TODO
				if t.flags & TypeFlagsUnion {
					return getAssignmentReducedType(t, getInitialOrAssignedType(flow))
				}
				return t
			}
			if containsMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node)) {
					init := getDeclaredExpandoInitializer(node)
					if init && (init.kind == SyntaxKindFunctionExpression || init.kind == SyntaxKindArrowFunction) {
						return getTypeAtFlowNode(flow.antecedent)
					}
				}
				return declaredType
			}
			if isVariableDeclaration(node) && node.parent.parent.kind == SyntaxKindForInStatement && (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference)) {
				return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))))
			}
			return nil
		}
		narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
			node := skipParentheses(expr, true)
			if node.kind == SyntaxKindFalseKeyword {
				return unreachableNeverType
			}
			if node.kind == SyntaxKindBinaryExpression {
				if (node).operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
					return narrowTypeByAssertion(narrowTypeByAssertion(type_, (node).left), (node).right)
				}
				if (node).operatorToken.kind == SyntaxKindBarBarToken {
					return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{narrowTypeByAssertion(type_, (node).left), narrowTypeByAssertion(type_, (node).right)})
				}
			}
			return narrowType(type_, node, true)
		}
		getTypeAtFlowCall := func(flow FlowCall) *FlowType {
			signature := getEffectsSignature(flow.node)
			if signature {
				predicate := getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindAssertsThis || predicate.kind == TypePredicateKindAssertsIdentifier) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := finalizeEvolvingArrayType(getTypeFromFlowType(flowType))
					narrowedType := /* TODO(Node ConditionalExpression): predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue* / true) : predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) : type */ TODO
					// converted from conditional expression
					switch {
					case narrowedType == type_:
						return flowType
					default:
						return createFlowType(narrowedType, isIncomplete(flowType))
					}
				}
				if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
					return unreachableNeverType
				}
			}
			return nil
		}
		getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
			if declaredType == autoType || declaredType == autoArrayType {
				node := flow.node
				expr := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.CallExpression ? (node.expression as PropertyAccessExpression).expression : (node.left as ElementAccessExpression).expression */ TODO
				if isMatchingReference(reference, getReferenceCandidate(expr)) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := getTypeFromFlowType(flowType)
					if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
						evolvedType := type_
						if node.kind == SyntaxKindCallExpression {
							for _, arg := range node.arguments {
								evolvedType = addEvolvingArrayElementType(evolvedType, arg)
							}
						} else {
							indexType := getContextFreeTypeOfExpression((node.left).argumentExpression)
							if isTypeAssignableToKind(indexType, TypeFlagsNumberLike) {
								evolvedType = addEvolvingArrayElementType(evolvedType, node.right)
							}
						}
						// converted from conditional expression
						switch {
						case evolvedType == type_:
							return flowType
						default:
							return createFlowType(evolvedType, isIncomplete(flowType))
						}
					}
					return flowType
				}
			}
			return nil
		}
		getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if type_.flags & TypeFlagsNever {
				return flowType
			}
			assumeTrue := (flow.flags & FlowFlagsTrueCondition) != 0
			nonEvolvingType := finalizeEvolvingArrayType(type_)
			narrowedType := narrowType(nonEvolvingType, flow.node, assumeTrue)
			if narrowedType == nonEvolvingType {
				return flowType
			}
			return createFlowType(narrowedType, isIncomplete(flowType))
		}
		getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
			expr := skipParentheses(flow.node.switchStatement.expression)
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if isMatchingReference(reference, expr) {
				type_ = narrowTypeBySwitchOnDiscriminant(type_, flow.node)
			} else if expr.kind == SyntaxKindTypeOfExpression && isMatchingReference(reference, (expr).expression) {
				type_ = narrowTypeBySwitchOnTypeOf(type_, flow.node)
			} else if expr.kind == SyntaxKindTrueKeyword {
				type_ = narrowTypeBySwitchOnTrue(type_, flow.node)
			} else {
				if strictNullChecks {
					if optionalChainContainsReference(expr, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
							return !(t.flags & (TypeFlagsUndefined | TypeFlagsNever))
						})
					} else if expr.kind == SyntaxKindTypeOfExpression && optionalChainContainsReference((expr).expression, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
							return !(t.flags&TypeFlagsNever || t.flags&TypeFlagsStringLiteral && (t).value == "undefined")
						})
					}
				}
				access := getDiscriminantPropertyAccess(expr, type_)
				if access {
					type_ = narrowTypeBySwitchOnDiscriminantProperty(type_, access, flow.node)
				}
			}
			return createFlowType(type_, isIncomplete(flowType))
		}
		getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
			var antecedentTypes []Type = [] /* TODO inferred type never */ any{}
			subtypeReduction := false
			seenIncomplete := false
			var bypassFlow *FlowSwitchClause
			for _, antecedent := range flow.antecedent {
				if !bypassFlow && antecedent.flags&FlowFlagsSwitchClause && (antecedent).node.clauseStart == (antecedent).node.clauseEnd {
					bypassFlow = antecedent
					continue
				}
				flowType := getTypeAtFlowNode(antecedent)
				type_ := getTypeFromFlowType(flowType)
				if type_ == declaredType && declaredType == initialType {
					return type_
				}
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if isIncomplete(flowType) {
					seenIncomplete = true
				}
			}
			if bypassFlow {
				flowType := getTypeAtFlowNode(bypassFlow)
				type_ := getTypeFromFlowType(flowType)
				if !(type_.flags & TypeFlagsNever) && !contains(antecedentTypes, type_) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement) {
					if type_ == declaredType && declaredType == initialType {
						return type_
					}
					antecedentTypes.push(type_)
					if !isTypeSubsetOf(type_, initialType) {
						subtypeReduction = true
					}
					if isIncomplete(flowType) {
						seenIncomplete = true
					}
				}
			}
			return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes /* TODO(Node ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO), seenIncomplete)
		}
		getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
			id := getFlowNodeId(flow)
			cache := flowLoopCaches[id] || ( /* TODO(Node BinaryExpression): flowLoopCaches[id] = new Map<string, Type>() */ TODO)
			key := getOrSetCacheKey()
			if !key {
				return declaredType
			}
			cached := cache.get(key)
			if cached {
				return cached
			}
			for i := flowLoopStart; i < flowLoopCount; i++ {
				if flowLoopNodes[i] == flow && flowLoopKeys[i] == key && flowLoopTypes[i].length {
					return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReductionLiteral), true)
				}
			}
			var antecedentTypes []Type = [] /* TODO inferred type never */ any{}
			subtypeReduction := false
			var firstAntecedentType *FlowType
			for _, antecedent := range flow.antecedent {
				var flowType TODO
				if !firstAntecedentType {
					flowType = /* TODO(Node BinaryExpression): firstAntecedentType = getTypeAtFlowNode(antecedent) */ TODO
				} else {
					flowLoopNodes[flowLoopCount] = flow
					flowLoopKeys[flowLoopCount] = key
					flowLoopTypes[flowLoopCount] = antecedentTypes
					flowLoopCount++
					saveFlowTypeCache := flowTypeCache
					flowTypeCache = nil
					flowType = getTypeAtFlowNode(antecedent)
					flowTypeCache = saveFlowTypeCache
					flowLoopCount--
					cached := cache.get(key)
					if cached {
						return cached
					}
				}
				type_ := getTypeFromFlowType(flowType)
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if type_ == declaredType {
					break
				}
			}
			result := getUnionOrEvolvingArrayType(antecedentTypes /* TODO(Node ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			if isIncomplete(firstAntecedentType) {
				return createFlowType(result, true)
			}
			cache.set(key, result)
			return result
		}
		getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			if isEvolvingArrayTypeList(types) {
				return getEvolvingArrayType(getUnionType(map_(types, getElementTypeOfEvolvingArrayType)))
			}
			result := recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction))
			if result != declaredType && result.flags&declaredType.flags&TypeFlagsUnion && arrayIsEqualTo((result).types, (declaredType).types) {
				return declaredType
			}
			return result
		}
		getCandidateDiscriminantPropertyAccess := func(expr Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ any {
			if isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) {
				if isIdentifier(expr) {
					symbol := getResolvedSymbol(expr)
					declaration := symbol.valueDeclaration
					if declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference == declaration.parent && !declaration.initializer && !declaration.dotDotDotToken {
						return declaration
					}
				}
			} else if isAccessExpression(expr) {
				if isMatchingReference(reference, expr.expression) {
					return expr
				}
			} else if isIdentifier(expr) {
				symbol := getResolvedSymbol(expr)
				if isConstantVariable(symbol) {
					declaration := symbol.valueDeclaration
					if isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isAccessExpression(declaration.initializer) && isMatchingReference(reference, declaration.initializer.expression) {
						return declaration.initializer
					}
					if isBindingElement(declaration) && !declaration.initializer {
						parent := declaration.parent.parent
						if isVariableDeclaration(parent) && !parent.type_ && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) && isMatchingReference(reference, parent.initializer) {
							return declaration
						}
					}
				}
			}
			return nil
		}
		getDiscriminantPropertyAccess := func(expr Expression, computedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ any {
			if declaredType.flags&TypeFlagsUnion || computedType.flags&TypeFlagsUnion {
				access := getCandidateDiscriminantPropertyAccess(expr)
				if access {
					name := getAccessedPropertyName(access)
					if name {
						type_ := /* TODO(Node ConditionalExpression): declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType */ TODO
						if isDiscriminantProperty(type_, name) {
							return access
						}
					}
				}
			}
			return nil
		}
		narrowTypeByDiscriminant := func(type_ Type, access /* TODO(TypeNode UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
			propName := getAccessedPropertyName(access)
			if propName == nil {
				return type_
			}
			optionalChain := isOptionalChain(access)
			removeNullable := strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type_, TypeFlagsNullable)
			propType := getTypeOfPropertyOfType( /* TODO(Node ConditionalExpression): removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO, propName)
			if !propType {
				return type_
			}
			propType = /* TODO(Node ConditionalExpression): removeNullable && optionalChain ? getOptionalType(propType) : propType */ TODO
			narrowedPropType := narrowType(propType)
			return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				discriminantType := getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType
				return !(discriminantType.flags & TypeFlagsNever) && !(narrowedPropType.flags & TypeFlagsNever) && areTypesComparable(narrowedPropType, discriminantType)
			})
		}
		narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(TypeNode UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			if (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken) && type_.flags&TypeFlagsUnion {
				keyPropertyName := getKeyPropertyName(type_)
				if keyPropertyName && keyPropertyName == getAccessedPropertyName(access) {
					candidate := getConstituentTypeForKeyType(type_, getTypeOfExpression(value))
					if candidate {
						// converted from conditional expression
						switch {
						case operator == ( /* TODO(Node ConditionalExpression): assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken */ TODO):
							return candidate
						case isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType):
							return removeType(type_, candidate)
						default:
							return type_
						}
					}
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return narrowTypeByEquality(t, operator, value, assumeTrue)
			})
		}
		narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(TypeNode UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			if data.clauseStart < data.clauseEnd && type_.flags&TypeFlagsUnion && getKeyPropertyName(type_) == getAccessedPropertyName(access) {
				clauseTypes := getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd)
				candidate := getUnionType(map_(clauseTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getConstituentTypeForKeyType(type_, t) || unknownType
				}))
				if candidate != unknownType {
					return candidate
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return narrowTypeBySwitchOnDiscriminant(t, data)
			})
		}
		narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(Node ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */, TODO)
			}
			if strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference) {
				type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getTypeWithFacts(t /* TODO(Node ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */, TODO)
				})
			}
			return type_
		}
		isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) /* TODO inferred type boolean */ any {
			prop := getPropertyOfType(type_, propName)
			// converted from conditional expression
			switch {
			case prop:
				return !!(prop.flags&SymbolFlagsOptional || getCheckFlags(prop)&CheckFlagsPartial) || assumeTrue
			default:
				return !!getApplicableIndexInfoForName(type_, propName) || !assumeTrue
			}
		}
		narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(TypeNode UnionType): StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			name := getPropertyNameFromType(nameType)
			isKnownProperty := someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isTypePresencePossible(t, name, true)
			})
			if isKnownProperty {
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isTypePresencePossible(t, name, assumeTrue)
				})
			}
			if assumeTrue {
				recordSymbol := getGlobalRecordSymbol()
				if recordSymbol {
					return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, getTypeAliasInstantiation(recordSymbol, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").NumberLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").UniqueESSymbolType */ any{nameType, unknownType})})
				}
			}
			return type_
		}
		narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
			assumeTrue = (assumeTrue != (bool.kind == SyntaxKindTrueKeyword)) != (operator != SyntaxKindExclamationEqualsEqualsToken && operator != SyntaxKindExclamationEqualsToken)
			return narrowType(type_, expr, assumeTrue)
		}
		narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			switch expr.operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				return narrowTypeByTruthiness(narrowType(type_, expr.right, assumeTrue), expr.left, assumeTrue)
			case SyntaxKindEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindEqualsEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsEqualsToken:
				operator := expr.operatorToken.kind
				left := getReferenceCandidate(expr.left)
				right := getReferenceCandidate(expr.right)
				if left.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(right) {
					return narrowTypeByTypeof(type_, left, operator, right, assumeTrue)
				}
				if right.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(left) {
					return narrowTypeByTypeof(type_, right, operator, left, assumeTrue)
				}
				if isMatchingReference(reference, left) {
					return narrowTypeByEquality(type_, operator, right, assumeTrue)
				}
				if isMatchingReference(reference, right) {
					return narrowTypeByEquality(type_, operator, left, assumeTrue)
				}
				if strictNullChecks {
					if optionalChainContainsReference(left, reference) {
						type_ = narrowTypeByOptionalChainContainment(type_, operator, right, assumeTrue)
					} else if optionalChainContainsReference(right, reference) {
						type_ = narrowTypeByOptionalChainContainment(type_, operator, left, assumeTrue)
					}
				}
				leftAccess := getDiscriminantPropertyAccess(left, type_)
				if leftAccess {
					return narrowTypeByDiscriminantProperty(type_, leftAccess, operator, right, assumeTrue)
				}
				rightAccess := getDiscriminantPropertyAccess(right, type_)
				if rightAccess {
					return narrowTypeByDiscriminantProperty(type_, rightAccess, operator, left, assumeTrue)
				}
				if isMatchingConstructorReference(left) {
					return narrowTypeByConstructor(type_, operator, right, assumeTrue)
				}
				if isMatchingConstructorReference(right) {
					return narrowTypeByConstructor(type_, operator, left, assumeTrue)
				}
				if isBooleanLiteral(right) && !isAccessExpression(left) {
					return narrowTypeByBooleanComparison(type_, left, right, operator, assumeTrue)
				}
				if isBooleanLiteral(left) && !isAccessExpression(right) {
					return narrowTypeByBooleanComparison(type_, right, left, operator, assumeTrue)
				}
				break
			case SyntaxKindInstanceOfKeyword:
				return narrowTypeByInstanceof(type_, expr, assumeTrue)
			case SyntaxKindInKeyword:
				if isPrivateIdentifier(expr.left) {
					return narrowTypeByPrivateIdentifierInInExpression(type_, expr, assumeTrue)
				}
				target := getReferenceCandidate(expr.right)
				if containsMissingType(type_) && isAccessExpression(reference) && isMatchingReference(reference.expression, target) {
					leftType := getTypeOfExpression(expr.left)
					if isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) == getPropertyNameFromType(leftType) {
						return getTypeWithFacts(type_ /* TODO(Node ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */, TODO)
					}
				}
				if isMatchingReference(reference, target) {
					leftType := getTypeOfExpression(expr.left)
					if isTypeUsableAsPropertyName(leftType) {
						return narrowTypeByInKeyword(type_, leftType, assumeTrue)
					}
				}
				break
			case SyntaxKindCommaToken:
				return narrowType(type_, expr.right, assumeTrue)
			case SyntaxKindAmpersandAmpersandToken:
				// converted from conditional expression
				switch {
				case assumeTrue:
					return narrowType(narrowType(type_, expr.left, true), expr.right, true)
				default:
					return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{narrowType(type_, expr.left, false), narrowType(type_, expr.right, false)})
				}
			case SyntaxKindBarBarToken:
				// converted from conditional expression
				switch {
				case assumeTrue:
					return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{narrowType(type_, expr.left, true), narrowType(type_, expr.right, true)})
				default:
					return narrowType(narrowType(type_, expr.left, false), expr.right, false)
				}
			}
			return type_
		}
		narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			target := getReferenceCandidate(expr.right)
			if !isMatchingReference(reference, target) {
				return type_
			}
			Debug.assertNode(expr.left, isPrivateIdentifier)
			symbol := getSymbolForPrivateIdentifierExpression(expr.left)
			if symbol == nil {
				return type_
			}
			classSymbol := symbol.parent
			targetType := /* TODO(Node ConditionalExpression): hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration")) ? getTypeOfSymbol(classSymbol) as InterfaceType : getDeclaredTypeOfSymbol(classSymbol) */ TODO
			return getNarrowedType(type_, targetType, assumeTrue, true)
		}
		narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			equalsOperator := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
			nullableFlags := /* TODO(Node ConditionalExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined */ TODO
			valueType := getTypeOfExpression(value)
			removeNullable := equalsOperator != assumeTrue && everyType(valueType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !!(t.flags & nullableFlags)
			}) || equalsOperator == assumeTrue && everyType(valueType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !(t.flags & (TypeFlagsAnyOrUnknown | nullableFlags))
			})
			// converted from conditional expression
			switch {
			case removeNullable:
				return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			default:
				return type_
			}
		}
		narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			if type_.flags & TypeFlagsAny {
				return type_
			}
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			valueType := getTypeOfExpression(value)
			doubleEquals := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken
			if valueType.flags & TypeFlagsNullable {
				if !strictNullChecks {
					return type_
				}
				facts := /* TODO(Node ConditionalExpression): doubleEquals ? assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull : valueType.flags & TypeFlags.Null ? assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull : assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined */ TODO
				return getAdjustedTypeWithFacts(type_, facts)
			}
			if assumeTrue {
				if !doubleEquals && (type_.flags&TypeFlagsUnknown || someType(type_, isEmptyAnonymousObjectType)) {
					if valueType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) || isEmptyAnonymousObjectType(valueType) {
						return valueType
					}
					if valueType.flags & TypeFlagsObject {
						return nonPrimitiveType
					}
				}
				filteredType := filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType)
				})
				return replacePrimitivesWithLiterals(filteredType, valueType)
			}
			if isUnitType(valueType) {
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !(isUnitLikeType(t) && areTypesComparable(t, valueType))
				})
			}
			return type_
		}
		narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			target := getReferenceCandidate(typeOfExpr.expression)
			if !isMatchingReference(reference, target) {
				if strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue == (literal.text != "undefined") {
					type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				propertyAccess := getDiscriminantPropertyAccess(target, type_)
				if propertyAccess {
					return narrowTypeByDiscriminant(type_, propertyAccess, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return narrowTypeByLiteralExpression(t, literal, assumeTrue)
					})
				}
				return type_
			}
			return narrowTypeByLiteralExpression(type_, literal, assumeTrue)
		}
		narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			// converted from conditional expression
			switch {
			case assumeTrue:
				return narrowTypeByTypeName(type_, literal.text)
			default:
				return getAdjustedTypeWithFacts(type_, typeofNEFacts.get(literal.text) || TypeFactsTypeofNEHostObject)
			}
		}
		narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			everyClauseChecks := clauseStart != clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck)
			// converted from conditional expression
			switch {
			case everyClauseChecks:
				return getTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			default:
				return type_
			}
		}
		narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			switchTypes := getSwitchClauseTypes(switchStatement)
			if !switchTypes.length {
				return type_
			}
			clauseTypes := switchTypes.slice(clauseStart, clauseEnd)
			hasDefaultClause := clauseStart == clauseEnd || contains(clauseTypes, neverType)
			if (type_.flags & TypeFlagsUnknown) && !hasDefaultClause {
				var groundClauseTypes *[]Type
				for i := 0; i < clauseTypes.length; i += 1 {
					t := clauseTypes[i]
					if t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive) {
						if groundClauseTypes != nil {
							groundClauseTypes.push(t)
						}
					} else if t.flags & TypeFlagsObject {
						if groundClauseTypes == nil {
							groundClauseTypes = clauseTypes.slice(0, i)
						}
						groundClauseTypes.push(nonPrimitiveType)
					} else {
						return type_
					}
				}
				return getUnionType( /* TODO(Node ConditionalExpression): groundClauseTypes === undefined ? clauseTypes : groundClauseTypes */ TODO)
			}
			discriminantType := getUnionType(clauseTypes)
			caseType := /* TODO(Node ConditionalExpression): discriminantType.flags & TypeFlags.Never ? neverType : replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType) */ TODO
			if !hasDefaultClause {
				return caseType
			}
			defaultType := filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !(isUnitLikeType(t) && contains(switchTypes /* TODO(Node ConditionalExpression): t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)) */, TODO))
			})
			// converted from conditional expression
			switch {
			case caseType.flags & TypeFlagsNever:
				return defaultType
			default:
				return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{caseType, defaultType})
			}
		}
		narrowTypeByTypeName := func(type_ Type, typeName string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			switch typeName {
			case "string":
				return narrowTypeByTypeFacts(type_, stringType, TypeFactsTypeofEQString)
			case "number":
				return narrowTypeByTypeFacts(type_, numberType, TypeFactsTypeofEQNumber)
			case "bigint":
				return narrowTypeByTypeFacts(type_, bigintType, TypeFactsTypeofEQBigInt)
			case "boolean":
				return narrowTypeByTypeFacts(type_, booleanType, TypeFactsTypeofEQBoolean)
			case "symbol":
				return narrowTypeByTypeFacts(type_, esSymbolType, TypeFactsTypeofEQSymbol)
			case "object":
				// converted from conditional expression
				switch {
				case type_.flags & TypeFlagsAny:
					return type_
				default:
					return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{narrowTypeByTypeFacts(type_, nonPrimitiveType, TypeFactsTypeofEQObject), narrowTypeByTypeFacts(type_, nullType, TypeFactsEQNull)})
				}
			case "function":
				// converted from conditional expression
				switch {
				case type_.flags & TypeFlagsAny:
					return type_
				default:
					return narrowTypeByTypeFacts(type_, globalFunctionType, TypeFactsTypeofEQFunction)
				}
			case "undefined":
				return narrowTypeByTypeFacts(type_, undefinedType, TypeFactsEQUndefined)
			}
			return narrowTypeByTypeFacts(type_, nonPrimitiveType, TypeFactsTypeofEQHostObject)
		}
		narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? hasTypeFacts(t, facts) ? t : neverType : // We next check if the consituent is a supertype of the implied type. If so, we substitute the implied // type. This handles top types like `unknown` and `{}`, and supertypes like `{ toString(): string }`. isTypeSubtypeOf(impliedType, t) ? impliedType : // Neither the constituent nor the implied type is a subtype of the other, however their domains may still // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate // possible overlap, we form an intersection. Otherwise, we eliminate the constituent. hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) : neverType */ TODO
			})
		}
		narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			witnesses := getSwitchClauseTypeOfWitnesses(switchStatement)
			if !witnesses {
				return type_
			}
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ any) /* TODO inferred type boolean */ any {
				return clause.kind == SyntaxKindDefaultClause
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			if hasDefaultClause {
				notEqualFacts := getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return getTypeFacts(t, notEqualFacts) == notEqualFacts
				})
			}
			clauseWitnesses := witnesses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauseWitnesses, func(text /* TODO inferred type string | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): text ? narrowTypeByTypeName(type, text) : neverType */ TODO
			}))
		}
		narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ any) /* TODO inferred type boolean */ any {
				return clause.kind == SyntaxKindDefaultClause
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			for i := 0; i < clauseStart; i++ {
				clause := switchStatement.caseBlock.clauses[i]
				if clause.kind == SyntaxKindCaseClause {
					type_ = narrowType(type_, clause.expression, false)
				}
			}
			if hasDefaultClause {
				for i := clauseEnd; i < switchStatement.caseBlock.clauses.length; i++ {
					clause := switchStatement.caseBlock.clauses[i]
					if clause.kind == SyntaxKindCaseClause {
						type_ = narrowType(type_, clause.expression, false)
					}
				}
				return type_
			}
			clauses := switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseOrDefaultClause */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): clause.kind === SyntaxKind.CaseClause ? narrowType(type, clause.expression, /*assumeTrue* / true) : neverType */ TODO
			}))
		}
		isMatchingConstructorReference := func(expr Expression) /* TODO inferred type boolean */ any {
			return (isPropertyAccessExpression(expr) && idText(expr.name) == "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text == "constructor") && isMatchingReference(reference, expr.expression)
		}
		narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
			if /* TODO(Node ConditionalExpression): assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken) */ TODO {
				return type_
			}
			identifierType := getTypeOfExpression(identifier)
			if !isFunctionType(identifierType) && !isConstructorType(identifierType) {
				return type_
			}
			prototypeProperty := getPropertyOfType(identifierType, "prototype")
			if !prototypeProperty {
				return type_
			}
			prototypeType := getTypeOfSymbol(prototypeProperty)
			candidate := /* TODO(Node ConditionalExpression): !isTypeAny(prototypeType) ? prototypeType : undefined */ TODO
			if !candidate || candidate == globalObjectType || candidate == globalFunctionType {
				return type_
			}
			if isTypeAny(type_) {
				return candidate
			}
			return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isConstructedBy(t, candidate)
			})
			isConstructedBy := func(source Type, target Type) /* TODO inferred type boolean */ any {
				if source.flags&TypeFlagsObject && getObjectFlags(source)&ObjectFlagsClass || target.flags&TypeFlagsObject && getObjectFlags(target)&ObjectFlagsClass {
					return source.symbol == target.symbol
				}
				return isTypeSubtypeOf(source, target)
			}
		}
		narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
			left := getReferenceCandidate(expr.left)
			if !isMatchingReference(reference, left) {
				if assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference) {
					return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				return type_
			}
			right := expr.right
			rightType := getTypeOfExpression(right)
			if !isTypeDerivedFrom(rightType, globalObjectType) {
				return type_
			}
			signature := getEffectsSignature(expr)
			predicate := signature && getTypePredicateOfSignature(signature)
			if predicate && predicate.kind == TypePredicateKindIdentifier && predicate.parameterIndex == 0 {
				return getNarrowedType(type_, predicate.type_, assumeTrue, true)
			}
			if !isTypeDerivedFrom(rightType, globalFunctionType) {
				return type_
			}
			instanceType := mapType(rightType, getInstanceType)
			if isTypeAny(type_) && (instanceType == globalObjectType || instanceType == globalFunctionType) || !assumeTrue && !(instanceType.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(instanceType)) {
				return type_
			}
			return getNarrowedType(type_, instanceType, assumeTrue, true)
		}
		getInstanceType := func(constructorType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			prototypePropertyType := getTypeOfPropertyOfType(constructorType, "prototype")
			if prototypePropertyType && !isTypeAny(prototypePropertyType) {
				return prototypePropertyType
			}
			constructSignatures := getSignaturesOfType(constructorType, SignatureKindConstruct)
			if constructSignatures.length {
				return getUnionType(map_(constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getReturnTypeOfSignature(getErasedSignature(signature))
				}))
			}
			return emptyObjectType
		}
		getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
			key := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined */ TODO
			return /* TODO(Node BinaryExpression): getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
		}
		getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			if !assumeTrue {
				if type_ == candidate {
					return neverType
				}
				if checkDerived {
					return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return !isTypeDerivedFrom(t, candidate)
					})
				}
				trueType := getNarrowedType(type_, candidate, true, false)
				return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !isTypeSubsetOf(t, trueType)
				})
			}
			if type_.flags & TypeFlagsAnyOrUnknown {
				return candidate
			}
			if type_ == candidate {
				return candidate
			}
			isRelated := /* TODO(Node ConditionalExpression): checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf */ TODO
			keyPropertyName := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined */ TODO
			narrowedType := mapType(candidate, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				discriminant := keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName)
				matching := discriminant && getConstituentTypeForKeyType(type_, discriminant)
				directlyRelated := mapType(matching || type_ /* TODO(Node ConditionalExpression): checkDerived ? t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType : t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType */, TODO)
				// converted from conditional expression
				switch {
				case directlyRelated.flags & TypeFlagsNever:
					return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
						return /* TODO(Node ConditionalExpression): maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType */ TODO
					})
				default:
					return directlyRelated
				}
			})
			// converted from conditional expression
			switch {
			case !(narrowedType.flags & TypeFlagsNever):
				return narrowedType
			case isTypeSubtypeOf(candidate, type_):
				return candidate
			case isTypeAssignableTo(type_, candidate):
				return type_
			case isTypeAssignableTo(candidate, type_):
				return candidate
			default:
				return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_, candidate})
			}
		}
		narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
			if hasMatchingArgument(callExpression, reference) {
				signature := /* TODO(Node ConditionalExpression): assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined */ TODO
				predicate := signature && getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindThis || predicate.kind == TypePredicateKindIdentifier) {
					return narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
				}
			}
			if containsMissingType(type_) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression) {
				callAccess := callExpression.expression
				if isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText == "hasOwnProperty" && callExpression.arguments.length == 1 {
					argument := callExpression.arguments[0]
					if isStringLiteralLike(argument) && getAccessedPropertyName(reference) == escapeLeadingUnderscores(argument.text) {
						return getTypeWithFacts(type_ /* TODO(Node ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */, TODO)
					}
				}
			}
			return type_
		}
		narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
			if predicate.type_ && !(isTypeAny(type_) && (predicate.type_ == globalObjectType || predicate.type_ == globalFunctionType)) {
				predicateArgument := getTypePredicateArgument(predicate, callExpression)
				if predicateArgument {
					if isMatchingReference(reference, predicateArgument) {
						return getNarrowedType(type_, predicate.type_, assumeTrue, false)
					}
					if strictNullChecks && optionalChainContainsReference(predicateArgument, reference) && (assumeTrue && !(hasTypeFacts(predicate.type_, TypeFactsEQUndefined)) || !assumeTrue && everyType(predicate.type_, isNullableType)) {
						type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
					}
					access := getDiscriminantPropertyAccess(predicateArgument, type_)
					if access {
						return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
							return getNarrowedType(t, predicate.type_, assumeTrue, false)
						})
					}
				}
			}
			return type_
		}
		narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionToken || expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionEqualsToken) && expr.parent.left == expr {
				return narrowTypeByOptionality(type_, expr, assumeTrue)
			}
			switch expr.kind {
			case SyntaxKindIdentifier:
				if !isMatchingReference(reference, expr) && inlineLevel < 5 {
					symbol := getResolvedSymbol(expr)
					if isConstantVariable(symbol) {
						declaration := symbol.valueDeclaration
						if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isConstantReference(reference) {
							inlineLevel++
							result := narrowType(type_, declaration.initializer, assumeTrue)
							inlineLevel--
							return result
						}
					}
				}
				fallthrough
			case SyntaxKindThisKeyword:
				fallthrough // TODO: merge cases
			case SyntaxKindSuperKeyword:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyAccessExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindElementAccessExpression:
				return narrowTypeByTruthiness(type_, expr, assumeTrue)
			case SyntaxKindCallExpression:
				return narrowTypeByCallExpression(type_, expr, assumeTrue)
			case SyntaxKindParenthesizedExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindNonNullExpression:
				return narrowType(type_, (expr).expression, assumeTrue)
			case SyntaxKindBinaryExpression:
				return narrowTypeByBinaryExpression(type_, expr, assumeTrue)
			case SyntaxKindPrefixUnaryExpression:
				if (expr).operator == SyntaxKindExclamationToken {
					return narrowType(type_, (expr).operand, !assumeTrue)
				}
				break
			}
			return type_
		}
		narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(Node ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */, TODO)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
					return getTypeWithFacts(t /* TODO(Node ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */, TODO)
				})
			}
			return type_
		}
	}
	getTypeOfSymbolAtLocation := func(symbol Symbol, location Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		symbol = getExportSymbolOfValueSymbolIfExported(symbol)
		if location.kind == SyntaxKindIdentifier || location.kind == SyntaxKindPrivateIdentifier {
			if isRightSideOfQualifiedNameOrPropertyAccess(location) {
				location = location.parent
			}
			if isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location)) {
				type_ := removeOptionalTypeMarker( /* TODO(Node ConditionalExpression): isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ? checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true) : getTypeOfExpression(location as Expression) */ TODO)
				if getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) == symbol {
					return type_
				}
			}
		}
		if isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent) {
			return getWriteTypeOfAccessors(location.parent.symbol)
		}
		// converted from conditional expression
		switch {
		case isRightSideOfAccessExpression(location) && isWriteAccess(location.parent):
			return getWriteTypeOfSymbol(symbol)
		default:
			return getNonMissingTypeOfSymbol(symbol)
		}
	}
	getControlFlowContainer := func(node Node) Node {
		return findAncestor(node.parent, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) || node.kind == SyntaxKindModuleBlock || node.kind == SyntaxKindSourceFile || node.kind == SyntaxKindPropertyDeclaration
		})
	}
	isSymbolAssignedDefinitely := func(symbol Symbol) /* TODO inferred type boolean */ any {
		if symbol.lastAssignmentPos != nil {
			return symbol.lastAssignmentPos < 0
		}
		return isSymbolAssigned(symbol) && symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0
	}
	isSymbolAssigned := func(symbol Symbol) /* TODO inferred type boolean */ any {
		return !isPastLastAssignment(symbol, nil)
	}
	isPastLastAssignment := func(symbol Symbol, location Node) /* TODO inferred type boolean | undefined */ any {
		parent := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
		if !parent {
			return false
		}
		links := getNodeLinks(parent)
		if !(links.flags & NodeCheckFlagsAssignmentsMarked) {
			links.flags |= NodeCheckFlagsAssignmentsMarked
			if !hasParentWithAssignmentsMarked(parent) {
				markNodeAssignments(parent)
			}
		}
		return !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos
	}
	isSomeSymbolAssigned := func(rootDeclaration Node) /* TODO inferred type boolean */ any {
		Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration))
		return isSomeSymbolAssignedWorker(rootDeclaration.name)
	}
	isSomeSymbolAssignedWorker := func(node BindingName) bool {
		if node.kind == SyntaxKindIdentifier {
			return isSymbolAssigned(getSymbolOfDeclaration(node.parent))
		}
		return some(node.elements, func(e /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ any) /* TODO inferred type boolean */ any {
			return e.kind != SyntaxKindOmittedExpression && isSomeSymbolAssignedWorker(e.name)
		})
	}
	hasParentWithAssignmentsMarked := func(node Node) /* TODO inferred type boolean */ any {
		return !!findAncestor(node.parent, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return isFunctionOrSourceFile(node) && !!(getNodeLinks(node).flags & NodeCheckFlagsAssignmentsMarked)
		})
	}
	isFunctionOrSourceFile := func(node Node) /* TODO inferred type boolean */ any {
		return isFunctionLikeDeclaration(node) || isSourceFile(node)
	}
	markNodeAssignments := func(node Node) {
		switch node.kind {
		case SyntaxKindIdentifier:
			assigmentTarget := getAssignmentTargetKind(node)
			if assigmentTarget != AssignmentKindNone {
				symbol := getResolvedSymbol(node)
				hasDefiniteAssignment := assigmentTarget == AssignmentKindDefinite || (symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0)
				if isParameterOrMutableLocalVariable(symbol) {
					if symbol.lastAssignmentPos == nil || Math.abs(symbol.lastAssignmentPos) != Number.MAX_VALUE {
						referencingFunction := findAncestor(node, isFunctionOrSourceFile)
						declaringFunction := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
						symbol.lastAssignmentPos = /* TODO(Node ConditionalExpression): referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE */ TODO
					}
					if hasDefiniteAssignment && symbol.lastAssignmentPos > 0 {
						symbol.lastAssignmentPos *= -1
					}
				}
			}
			return
		case SyntaxKindExportSpecifier:
			exportDeclaration := (node).parent.parent
			name := (node).propertyName || (node).name
			if !(node).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind != SyntaxKindStringLiteral {
				symbol := resolveEntityName(name, SymbolFlagsValue, true, true)
				if symbol && isParameterOrMutableLocalVariable(symbol) {
					sign := /* TODO(Node ConditionalExpression): symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 ? -1 : 1 */ TODO
					symbol.lastAssignmentPos = sign * Number.MAX_VALUE
				}
			}
			return
		case SyntaxKindInterfaceDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAliasDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindEnumDeclaration:
			return
		}
		if isTypeNode(node) {
			return
		}
		forEachChild(node, markNodeAssignments)
	}
	extendAssignmentPosition := func(node Node, declaration Declaration) /* TODO inferred type number */ any {
		pos := node.pos
		for node && node.pos > declaration.pos {
			switch node.kind {
			case SyntaxKindVariableStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindExpressionStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindIfStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindDoStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindWhileStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForInStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForOfStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindWithStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindSwitchStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindTryStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindClassDeclaration:
				pos = node.end
			}
			node = node.parent
		}
		return pos
	}
	isConstantVariable := func(symbol Symbol) /* TODO inferred type boolean | 0 */ any {
		return symbol.flags&SymbolFlagsVariable && (getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant) != 0
	}
	isParameterOrMutableLocalVariable := func(symbol Symbol) /* TODO inferred type boolean */ any {
		declaration := symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration)
		return !!declaration && (isParameter(declaration) || isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration)))
	}
	isMutableLocalVariableDeclaration := func(declaration VariableDeclaration) /* TODO inferred type boolean */ any {
		return !!(declaration.parent.flags & NodeFlagsLet) && !(getCombinedModifierFlags(declaration)&ModifierFlagsExport || declaration.parent.parent.kind == SyntaxKindVariableStatement && isGlobalSourceFile(declaration.parent.parent.parent))
	}
	parameterInitializerContainsUndefined := func(declaration ParameterDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.parameterInitializerContainsUndefined == nil {
			if !pushTypeResolution(declaration, TypeSystemPropertyNameParameterInitializerContainsUndefined) {
				reportCircularityError(declaration.symbol)
				return true
			}
			containsUndefined := !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined))
			if !popTypeResolution() {
				reportCircularityError(declaration.symbol)
				return true
			}
			/* TODO(Node BinaryExpression): links.parameterInitializerContainsUndefined ??= containsUndefined */ TODO
		}
		return links.parameterInitializerContainsUndefined
	}
	removeOptionalityFromDeclaredType := func(declaredType Type, declaration VariableLikeDeclaration) Type {
		removeUndefined := strictNullChecks && declaration.kind == SyntaxKindParameter && declaration.initializer && hasTypeFacts(declaredType, TypeFactsIsUndefined) && !parameterInitializerContainsUndefined(declaration)
		// converted from conditional expression
		switch {
		case removeUndefined:
			return getTypeWithFacts(declaredType, TypeFactsNEUndefined)
		default:
			return declaredType
		}
	}
	isConstraintPosition := func(type_ Type, node Node) /* TODO inferred type boolean */ any {
		parent := node.parent
		return parent.kind == SyntaxKindPropertyAccessExpression || parent.kind == SyntaxKindQualifiedName || parent.kind == SyntaxKindCallExpression && (parent).expression == node || parent.kind == SyntaxKindNewExpression && (parent).expression == node || parent.kind == SyntaxKindElementAccessExpression && (parent).expression == node && !(someType(type_, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent).argumentExpression)))
	}
	isGenericTypeWithUnionConstraint := func(type_ Type) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return some((type_).types, isGenericTypeWithUnionConstraint)
		default:
			return !!(type_.flags&TypeFlagsInstantiable && getBaseConstraintOrType(type_).flags&(TypeFlagsNullable|TypeFlagsUnion))
		}
	}
	isGenericTypeWithoutNullableConstraint := func(type_ Type) bool {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsIntersection:
			return some((type_).types, isGenericTypeWithoutNullableConstraint)
		default:
			return !!(type_.flags&TypeFlagsInstantiable && !maybeTypeOfKind(getBaseConstraintOrType(type_), TypeFlagsNullable))
		}
	}
	hasContextualTypeWithNoGenericTypes := func(node Node, checkMode *CheckMode) /* TODO inferred type boolean | undefined */ any {
		contextualType := (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName == node) && ( /* TODO(Node ConditionalExpression): checkMode && checkMode & CheckMode.RestBindingElement ? getContextualType(node, ContextFlags.SkipBindingPatterns) : getContextualType(node, /*contextFlags* / undefined) */ TODO)
		return contextualType && !isGenericType(contextualType)
	}
	getNarrowableTypeForReference := func(type_ Type, reference Node, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if isNoInferType(type_) {
			type_ = (type_).baseType
		}
		substituteConstraints := !(checkMode && checkMode&CheckModeInferential) && someType(type_, isGenericTypeWithUnionConstraint) && (isConstraintPosition(type_, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode))
		// converted from conditional expression
		switch {
		case substituteConstraints:
			return mapType(type_, getBaseConstraintOrType)
		default:
			return type_
		}
	}
	isExportOrExportExpression := func(location Node) /* TODO inferred type boolean */ any {
		return !!findAncestor(location, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			parent := n.parent
			if parent == nil {
				return "quit"
			}
			if isExportAssignment(parent) {
				return parent.expression == n && isEntityNameExpression(n)
			}
			if isExportSpecifier(parent) {
				return parent.name == n || parent.propertyName == n
			}
			return false
		})
	}
	/* OVERLOAD: function markLinkedReferences(location: PropertyAccessExpression | QualifiedName, hint: ReferenceHint.Property, propSymbol: Symbol | undefined, parentType: Type): void; */
	/* OVERLOAD: function markLinkedReferences(location: Identifier, hint: ReferenceHint.Identifier): void; */
	/* OVERLOAD: function markLinkedReferences(location: ExportAssignment, hint: ReferenceHint.ExportAssignment): void; */
	/* OVERLOAD: function markLinkedReferences(location: JsxOpeningLikeElement | JsxOpeningFragment, hint: ReferenceHint.Jsx): void; */
	/* OVERLOAD: function markLinkedReferences(location: FunctionLikeDeclaration | MethodSignature, hint: ReferenceHint.AsyncFunction): void; */
	/* OVERLOAD: function markLinkedReferences(location: ImportEqualsDeclaration, hint: ReferenceHint.ExportImportEquals): void; */
	/* OVERLOAD: function markLinkedReferences(location: ExportSpecifier, hint: ReferenceHint.ExportSpecifier): void; */
	/* OVERLOAD: function markLinkedReferences(location: HasDecorators, hint: ReferenceHint.Decorator): void; */
	/* OVERLOAD: function markLinkedReferences(location: Node, hint: ReferenceHint.Unspecified, propSymbol?: Symbol, parentType?: Type): void; */
	markLinkedReferences := func(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if location.flags&NodeFlagsAmbient && !isPropertySignature(location) && !isPropertyDeclaration(location) {
			return
		}
		switch hint {
		case ReferenceHintIdentifier:
			return markIdentifierAliasReferenced(location)
		case ReferenceHintProperty:
			return markPropertyAliasReferenced(location, propSymbol, parentType)
		case ReferenceHintExportAssignment:
			return markExportAssignmentAliasReferenced(location)
		case ReferenceHintJsx:
			return markJsxAliasReferenced(location)
		case ReferenceHintAsyncFunction:
			return markAsyncFunctionAliasReferenced(location)
		case ReferenceHintExportImportEquals:
			return markImportEqualsAliasReferenced(location)
		case ReferenceHintExportSpecifier:
			return markExportSpecifierAliasReferenced(location)
		case ReferenceHintDecorator:
			return markDecoratorAliasReferenced(location)
		case ReferenceHintUnspecified:
			if isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference == location)) && shouldMarkIdentifierAliasReferenced(location) {
				if isPropertyAccessOrQualifiedName(location.parent) {
					left := /* TODO(Node ConditionalExpression): isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left */ TODO
					if left != location {
						return
					}
				}
				markIdentifierAliasReferenced(location)
				return
			}
			if isPropertyAccessOrQualifiedName(location) {
				var topProp Node = location
				for isPropertyAccessOrQualifiedName(topProp) {
					if isPartOfTypeNode(topProp) {
						return
					}
					topProp = topProp.parent
				}
				return markPropertyAliasReferenced(location)
			}
			if isExportAssignment(location) {
				return markExportAssignmentAliasReferenced(location)
			}
			if isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location) {
				return markJsxAliasReferenced(location)
			}
			if isImportEqualsDeclaration(location) {
				if isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location) {
					return markImportEqualsAliasReferenced(location)
				}
				return
			}
			if isExportSpecifier(location) {
				return markExportSpecifierAliasReferenced(location)
			}
			if isFunctionLikeDeclaration(location) || isMethodSignature(location) {
				markAsyncFunctionAliasReferenced(location)
			}
			if !compilerOptions.emitDecoratorMetadata {
				return
			}
			if !canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent) {
				return
			}
			return markDecoratorAliasReferenced(location)
			fallthrough
		default:
			Debug.assertNever(hint /* TODO(Node TemplateExpression): `Unhandled reference hint: ${hint}` */, TODO)
		}
	}
	markIdentifierAliasReferenced := func(location Identifier) {
		symbol := getResolvedSymbol(location)
		if symbol && symbol != argumentsSymbol && symbol != unknownSymbol && !isThisInTypeQuery(location) {
			markAliasReferenced(symbol, location)
		}
	}
	markPropertyAliasReferenced := func(location /* TODO(TypeNode UnionType): PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
		left := /* TODO(Node ConditionalExpression): isPropertyAccessExpression(location) ? location.expression : location.left */ TODO
		if isThisIdentifier(left) || !isIdentifier(left) {
			return
		}
		parentSymbol := getResolvedSymbol(left)
		if !parentSymbol || parentSymbol == unknownSymbol {
			return
		}
		if getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location)) {
			markAliasReferenced(parentSymbol, location)
			return
		}
		leftType := parentType || checkExpressionCached(left)
		if isTypeAny(leftType) || leftType == silentNeverType {
			markAliasReferenced(parentSymbol, location)
			return
		}
		prop := propSymbol
		if !prop && !parentType {
			right := /* TODO(Node ConditionalExpression): isPropertyAccessExpression(location) ? location.name : location.right */ TODO
			lexicallyScopedSymbol := isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			assignmentKind := getAssignmentTargetKind(location)
			apparentType := getApparentType( /* TODO(Node ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(location) ? getWidenedType(leftType) : leftType */ TODO)
			prop = /* TODO(Node ConditionalExpression): isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined : getPropertyOfType(apparentType, right.escapedText) */ TODO
		}
		if !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags&SymbolFlagsEnumMember && location.parent.kind == SyntaxKindEnumMember)) {
			markAliasReferenced(parentSymbol, location)
		}
		return
	}
	markExportAssignmentAliasReferenced := func(location ExportAssignment) {
		if isIdentifier(location.expression) {
			id := location.expression
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll, true, true, location))
			if sym {
				markAliasReferenced(sym, id)
			}
		}
	}
	markJsxAliasReferenced := func(node /* TODO(TypeNode UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		if !getJsxNamespaceContainerForImplicitImport(node) {
			jsxFactoryRefErr := /* TODO(Node ConditionalExpression): diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.Cannot_find_name_0 : undefined */ TODO
			jsxFactoryNamespace := getJsxNamespace(node)
			jsxFactoryLocation := /* TODO(Node ConditionalExpression): isJsxOpeningLikeElement(node) ? node.tagName : node */ TODO
			var jsxFactorySym *Symbol
			if !(isJsxOpeningFragment(node) && jsxFactoryNamespace == "null") {
				jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlagsValue, jsxFactoryRefErr, true)
			}
			if jsxFactorySym {
				jsxFactorySym.isReferenced = SymbolFlagsAll
				if canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags&SymbolFlagsAlias && !getTypeOnlyAliasDeclaration(jsxFactorySym) {
					markAliasSymbolAsReferenced(jsxFactorySym)
				}
			}
			if isJsxOpeningFragment(node) {
				file := getSourceFileOfNode(node)
				localJsxNamespace := getLocalJsxNamespace(file)
				if localJsxNamespace {
					resolveName(jsxFactoryLocation, localJsxNamespace, SymbolFlagsValue, jsxFactoryRefErr, true)
				}
			}
		}
		return
	}
	markAsyncFunctionAliasReferenced := func(location /* TODO(TypeNode UnionType): FunctionLikeDeclaration | MethodSignature */ any) {
		if languageVersion < ScriptTargetES2015 {
			if getFunctionFlags(location) & FunctionFlagsAsync {
				returnTypeNode := getEffectiveReturnTypeNode(location)
				markTypeNodeAsReferenced(returnTypeNode)
			}
		}
	}
	markImportEqualsAliasReferenced := func(location ImportEqualsDeclaration) {
		if hasSyntacticModifier(location, ModifierFlagsExport) {
			markExportAsReferenced(location)
		}
	}
	markExportSpecifierAliasReferenced := func(location ExportSpecifier) {
		if !location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly {
			exportedName := location.propertyName || location.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) {
			} else {
				target := symbol && ( /* TODO(Node ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO)
				if !target || getSymbolFlags(target)&SymbolFlagsValue {
					markExportAsReferenced(location)
					markIdentifierAliasReferenced(exportedName)
				}
			}
			return
		}
	}
	markDecoratorAliasReferenced := func(node HasDecorators) {
		if compilerOptions.emitDecoratorMetadata {
			firstDecorator := find(node.modifiers, isDecorator)
			if !firstDecorator {
				return
			}
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersMetadata)
			switch node.kind {
			case SyntaxKindClassDeclaration:
				constructor := getFirstConstructorWithBody(node)
				if constructor {
					for _, parameter := range constructor.parameters {
						markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
					}
				}
				break
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				otherKind := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
				otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(node), otherKind)
				markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor))
				break
			case SyntaxKindMethodDeclaration:
				for _, parameter := range node.parameters {
					markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
				}
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node))
				break
			case SyntaxKindPropertyDeclaration:
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node))
				break
			case SyntaxKindParameter:
				markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node))
				containingSignature := node.parent
				for _, parameter := range containingSignature.parameters {
					markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter))
				}
				markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature))
				break
			}
		}
	}
	markAliasReferenced := func(symbol Symbol, location Node) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if isNonLocalAlias(symbol, SymbolFlagsValue) && !isInTypeQuery(location) {
			target := resolveAlias(symbol)
			if getSymbolFlags(symbol, true) & (SymbolFlagsValue | SymbolFlagsExportValue) {
				if getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target)) {
					markAliasSymbolAsReferenced(symbol)
				}
			}
		}
	}
	markAliasSymbolAsReferenced := func(symbol Symbol) /* TODO inferred type undefined */ any {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		links := getSymbolLinks(symbol)
		if !links.referenced {
			links.referenced = true
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			if isInternalModuleImportEqualsDeclaration(node) {
				if getSymbolFlags(resolveSymbol(symbol)) & SymbolFlagsValue {
					left := getFirstIdentifier(node.moduleReference)
					markIdentifierAliasReferenced(left)
				}
			}
		}
	}
	markExportAsReferenced := func(node /* TODO(TypeNode UnionType): ImportEqualsDeclaration | ExportSpecifier */ any) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target {
			markAlias := target == unknownSymbol || ((getSymbolFlags(symbol, true) & SymbolFlagsValue) && !isConstEnumOrConstEnumOnlyModule(target))
			if markAlias {
				markAliasSymbolAsReferenced(symbol)
			}
		}
	}
	markEntityNameOrEntityExpressionAsReference := func(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
		if !typeName {
			return
		}
		rootName := getFirstIdentifier(typeName)
		meaning := ( /* TODO(Node ConditionalExpression): typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO) | SymbolFlagsAlias
		rootSymbol := resolveName(rootName, rootName.escapedText, meaning, nil, true)
		if rootSymbol && rootSymbol.flags&SymbolFlagsAlias {
			if canCollectSymbolAliasAccessabilityData && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol) {
				markAliasSymbolAsReferenced(rootSymbol)
			} else if forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= ModuleKindES2015 && !symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration) {
				diag := error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled)
				aliasDeclaration := find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration)
				if aliasDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)))
				}
			}
		}
	}
	markTypeNodeAsReferenced := func(node *TypeNode) {
		markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node), false)
	}
	markDecoratorMedataDataTypeNodeAsReferenced := func(node *TypeNode) {
		entityName := getEntityNameForDecoratorMetadata(node)
		if entityName && isEntityName(entityName) {
			markEntityNameOrEntityExpressionAsReference(entityName, true)
		}
	}
	getNarrowedTypeOfSymbol := func(symbol Symbol, location Identifier) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		type_ := getTypeOfSymbol(symbol)
		declaration := symbol.valueDeclaration
		if declaration {
			if isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2 {
				parent := declaration.parent.parent
				rootDeclaration := getRootDeclaration(parent)
				if rootDeclaration.kind == SyntaxKindVariableDeclaration && getCombinedNodeFlagsCached(rootDeclaration)&NodeFlagsConstant || rootDeclaration.kind == SyntaxKindParameter {
					links := getNodeLinks(parent)
					if !(links.flags & NodeCheckFlagsInCheckIdentifier) {
						links.flags |= NodeCheckFlagsInCheckIdentifier
						parentType := getTypeForBindingElementParent(parent, CheckModeNormal)
						parentTypeConstraint := parentType && mapType(parentType, getBaseConstraintOrType)
						links.flags &= ~NodeCheckFlagsInCheckIdentifier
						if parentTypeConstraint && parentTypeConstraint.flags&TypeFlagsUnion && !(rootDeclaration.kind == SyntaxKindParameter && isSomeSymbolAssigned(rootDeclaration)) {
							pattern := declaration.parent
							narrowedType := getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, nil, location.flowNode)
							if narrowedType.flags & TypeFlagsNever {
								return neverType
							}
							return getBindingElementTypeFromParentType(declaration, narrowedType, true)
						}
					}
				}
			}
			if isParameter(declaration) && !declaration.type_ && !declaration.initializer && !declaration.dotDotDotToken {
				func_ := declaration.parent
				if func_.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
					contextualSignature := getContextualSignature(func_)
					if contextualSignature && contextualSignature.parameters.length == 1 && signatureHasRestParameter(contextualSignature) {
						restType := getReducedApparentType(instantiateType(getTypeOfSymbol(contextualSignature.parameters[0]), getInferenceContext(func_). /*?*/ nonFixingMapper))
						if restType.flags&TypeFlagsUnion && everyType(restType, isTupleType) && !some(func_.parameters, isSomeSymbolAssigned) {
							narrowedType := getFlowTypeOfReference(func_, restType, restType, nil, location.flowNode)
							index := func_.parameters.indexOf(declaration) - ( /* TODO(Node ConditionalExpression): getThisParameter(func) ? 1 : 0 */ TODO)
							return getIndexedAccessType(narrowedType, getNumberLiteralType(index))
						}
					}
				}
			}
		}
		return type_
	}
	checkIdentifierCalculateNodeCheckFlags := func(node Identifier, symbol Symbol) {
		if isThisInTypeQuery(node) {
			return
		}
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers)
				return
			}
			container := getContainingFunction(node)
			if container {
				if languageVersion < ScriptTargetES2015 {
					if container.kind == SyntaxKindArrowFunction {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression)
					} else if hasSyntacticModifier(container, ModifierFlagsAsync) {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method)
					}
				}
				getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
				for container && isArrowFunction(container) {
					container = getContainingFunction(container)
					if container {
						getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
					}
				}
			}
			return
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		targetSymbol := resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
		if isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations {
			addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText)
		}
		declaration := localOrExportSymbol.valueDeclaration
		if declaration && localOrExportSymbol.flags&SymbolFlagsClass {
			if isClassLike(declaration) && declaration.name != node {
				container := getThisContainer(node, false, false)
				for container.kind != SyntaxKindSourceFile && container.parent != declaration {
					container = getThisContainer(container, false, false)
				}
				if container.kind != SyntaxKindSourceFile {
					getNodeLinks(declaration).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(container).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(node).flags |= NodeCheckFlagsConstructorReference
				}
			}
		}
		checkNestedBlockScopedBinding(node, symbol)
	}
	checkIdentifier := func(node Identifier, checkMode *CheckMode) Type {
		if isThisInTypeQuery(node) {
			return checkThisExpression(node)
		}
		symbol := getResolvedSymbol(node)
		if symbol == unknownSymbol {
			return errorType
		}
		checkIdentifierCalculateNodeCheckFlags(node, symbol)
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				return errorType
			}
			return getTypeOfSymbol(symbol)
		}
		if shouldMarkIdentifierAliasReferenced(node) {
			markLinkedReferences(node, ReferenceHintIdentifier)
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		declaration := localOrExportSymbol.valueDeclaration
		immediateDeclaration := declaration
		if declaration && declaration.kind == SyntaxKindBindingElement && contains(contextualBindingPatterns, declaration.parent) && findAncestor(node, func(parent /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return parent == declaration.parent
		}) {
			return nonInferrableAnyType
		}
		type_ := getNarrowedTypeOfSymbol(localOrExportSymbol, node)
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind {
			if !(localOrExportSymbol.flags & SymbolFlagsVariable) && !(isInJSFile(node) && localOrExportSymbol.flags&SymbolFlagsValueModule) {
				assignmentError := /* TODO(Node ConditionalExpression): localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable */ TODO
				error(node, assignmentError, symbolToString(symbol))
				return errorType
			}
			if isReadonlySymbol(localOrExportSymbol) {
				if localOrExportSymbol.flags & SymbolFlagsVariable {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol))
				} else {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol))
				}
				return errorType
			}
		}
		isAlias := localOrExportSymbol.flags & SymbolFlagsAlias
		if localOrExportSymbol.flags & SymbolFlagsVariable {
			if assignmentKind == AssignmentKindDefinite {
				// converted from conditional expression
				switch {
				case isInCompoundLikeAssignment(node):
					return getBaseTypeOfLiteralType(type_)
				default:
					return type_
				}
			}
		} else if isAlias {
			declaration = getDeclarationOfAliasSymbol(symbol)
		} else {
			return type_
		}
		if !declaration {
			return type_
		}
		type_ = getNarrowableTypeForReference(type_, node, checkMode)
		isParameter := getRootDeclaration(declaration).kind == SyntaxKindParameter
		declarationContainer := getControlFlowContainer(declaration)
		flowContainer := getControlFlowContainer(node)
		isOuterVariable := flowContainer != declarationContainer
		isSpreadDestructuringAssignmentTarget := node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent)
		isModuleExports := symbol.flags & SymbolFlagsModuleExports
		typeIsAutomatic := type_ == autoType || type_ == autoArrayType
		isAutomaticTypeInNonNull := typeIsAutomatic && node.parent.kind == SyntaxKindNonNullExpression
		for flowContainer != declarationContainer && (flowContainer.kind == SyntaxKindFunctionExpression || flowContainer.kind == SyntaxKindArrowFunction || isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)) && (isConstantVariable(localOrExportSymbol) && type_ != autoArrayType || isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)) {
			flowContainer = getControlFlowContainer(flowContainer)
		}
		isNeverInitialized := immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol)
		assumeInitialized := isParameter || isAlias || (isOuterVariable && !isNeverInitialized) || isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) || type_ != autoType && type_ != autoArrayType && (!strictNullChecks || (type_.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid)) != 0 || isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind == SyntaxKindExportSpecifier) || node.parent.kind == SyntaxKindNonNullExpression || declaration.kind == SyntaxKindVariableDeclaration && (declaration).exclamationToken || declaration.flags&NodeFlagsAmbient
		initialType := /* TODO(Node ConditionalExpression): isAutomaticTypeInNonNull ? undefinedType : assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) : typeIsAutomatic ? undefinedType : getOptionalType(type) */ TODO
		flowType := /* TODO(Node ConditionalExpression): isAutomaticTypeInNonNull ? getNonNullableType(getFlowTypeOfReference(node, type, initialType, flowContainer)) : getFlowTypeOfReference(node, type, initialType, flowContainer) */ TODO
		if !isEvolvingArrayOperationTarget(node) && (type_ == autoType || type_ == autoArrayType) {
			if flowType == autoType || flowType == autoArrayType {
				if noImplicitAny {
					error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType))
					error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
				}
				return convertAutoToAny(flowType)
			}
		} else if !assumeInitialized && !containsUndefinedType(type_) && containsUndefinedType(flowType) {
			error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol))
			return type_
		}
		// converted from conditional expression
		switch {
		case assignmentKind:
			return getBaseTypeOfLiteralType(flowType)
		default:
			return flowType
		}
	}
	isSameScopedBindingElement := func(node Identifier, declaration Declaration) /* TODO inferred type boolean | undefined */ any {
		if isBindingElement(declaration) {
			bindingElement := findAncestor(node, isBindingElement)
			return bindingElement && getRootDeclaration(bindingElement) == getRootDeclaration(declaration)
		}
	}
	shouldMarkIdentifierAliasReferenced := func(node Identifier) bool {
		parent := node.parent
		if parent {
			if isPropertyAccessExpression(parent) && parent.expression == node {
				return false
			}
			if isExportSpecifier(parent) && parent.isTypeOnly {
				return false
			}
			greatGrandparent := parent.parent. /*?*/ parent
			if greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly {
				return false
			}
		}
		return true
	}
	isInsideFunctionOrInstancePropertyInitializer := func(node Node, threshold Node) bool {
		return !!findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): n === threshold ? "quit" : isFunctionLike(n) || ( n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n ) */ TODO
		})
	}
	getPartOfForStatementContainingNode := func(node Node, container ForStatement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ any {
		return findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement */ TODO
		})
	}
	getEnclosingIterationStatement := func(node Node) Node {
		return findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): (!n || nodeStartsNewLexicalEnvironment(n)) ? "quit" : isIterationStatement(n, /*lookInLabeledStatements* / false) */ TODO
		})
	}
	checkNestedBlockScopedBinding := func(node Identifier, symbol Symbol) {
		if languageVersion >= ScriptTargetES2015 || (symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsClass)) == 0 || !symbol.valueDeclaration || isSourceFile(symbol.valueDeclaration) || symbol.valueDeclaration.parent.kind == SyntaxKindCatchClause {
			return
		}
		container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
		isCaptured := isInsideFunctionOrInstancePropertyInitializer(node, container)
		enclosingIterationStatement := getEnclosingIterationStatement(container)
		if enclosingIterationStatement {
			if isCaptured {
				capturesBlockScopeBindingInLoopBody := true
				if isForStatement(container) {
					varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					if varDeclList && varDeclList.parent == container {
						part := getPartOfForStatementContainingNode(node.parent, container)
						if part {
							links := getNodeLinks(part)
							links.flags |= NodeCheckFlagsContainsCapturedBlockScopeBinding
							capturedBindings := links.capturedBlockScopeBindings || ( /* TODO(Node BinaryExpression): links.capturedBlockScopeBindings = [] */ TODO)
							pushIfUnique(capturedBindings, symbol)
							if part == container.initializer {
								capturesBlockScopeBindingInLoopBody = false
							}
						}
					}
				}
				if capturesBlockScopeBindingInLoopBody {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
				}
			}
			if isForStatement(container) {
				varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
				if varDeclList && varDeclList.parent == container && isAssignedInBodyOfForStatement(node, container) {
					getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsNeedsLoopOutParameter
				}
			}
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsBlockScopedBindingInLoop
		}
		if isCaptured {
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsCapturedBlockScopedBinding
		}
	}
	isBindingCapturedByNode := func(node Node, decl /* TODO(TypeNode UnionType): VariableDeclaration | BindingElement */ any) /* TODO inferred type boolean */ any {
		links := getNodeLinks(node)
		return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl))
	}
	isAssignedInBodyOfForStatement := func(node Identifier, container ForStatement) bool {
		var current Node = node
		for current.parent.kind == SyntaxKindParenthesizedExpression {
			current = current.parent
		}
		isAssigned := false
		if isAssignmentTarget(current) {
			isAssigned = true
		} else if current.parent.kind == SyntaxKindPrefixUnaryExpression || current.parent.kind == SyntaxKindPostfixUnaryExpression {
			expr := current.parent
			isAssigned = expr.operator == SyntaxKindPlusPlusToken || expr.operator == SyntaxKindMinusMinusToken
		}
		if !isAssigned {
			return false
		}
		return !!findAncestor(current, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): n === container ? "quit" : n === container.statement */ TODO
		})
	}
	captureLexicalThis := func(node Node, container Node) {
		getNodeLinks(node).flags |= NodeCheckFlagsLexicalThis
		if container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindConstructor {
			classNode := container.parent
			getNodeLinks(classNode).flags |= NodeCheckFlagsCaptureThis
		} else {
			getNodeLinks(container).flags |= NodeCheckFlagsCaptureThis
		}
	}
	findFirstSuperCall := func(node Node) *SuperCall {
		// converted from conditional expression
		switch {
		case isSuperCall(node):
			return node
		case isFunctionLike(node):
			return nil
		default:
			return forEachChild(node, findFirstSuperCall)
		}
	}
	classDeclarationExtendsNull := func(classDecl ClassLikeDeclaration) bool {
		classSymbol := getSymbolOfDeclaration(classDecl)
		classInstanceType := getDeclaredTypeOfSymbol(classSymbol)
		baseConstructorType := getBaseConstructorTypeOfClass(classInstanceType)
		return baseConstructorType == nullWideningType
	}
	checkThisBeforeSuper := func(node Node, container Node, diagnosticMessage DiagnosticMessage) {
		containingClassDecl := container.parent
		baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)
		if baseTypeNode && !classDeclarationExtendsNull(containingClassDecl) {
			if canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode, false) {
				error(node, diagnosticMessage)
			}
		}
	}
	checkThisInStaticClassFieldInitializerInDecoratedClass := func(thisExpression Node, container Node) {
		if isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators && container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent) {
			error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class)
		}
	}
	checkThisExpression := func(node Node) Type {
		isNodeInTypeQuery := isInTypeQuery(node)
		container := getThisContainer(node, true, true)
		capturedByArrowFunction := false
		thisInComputedPropertyName := false
		if container.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class)
		}
		for true {
			if container.kind == SyntaxKindArrowFunction {
				container = getThisContainer(container, false, !thisInComputedPropertyName)
				capturedByArrowFunction = true
			}
			if container.kind == SyntaxKindComputedPropertyName {
				container = getThisContainer(container, !capturedByArrowFunction, false)
				thisInComputedPropertyName = true
				continue
			}
			break
		}
		checkThisInStaticClassFieldInitializerInDecoratedClass(node, container)
		if thisInComputedPropertyName {
			error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name)
		} else {
			switch container.kind {
			case SyntaxKindModuleDeclaration:
				error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body)
				break
			case SyntaxKindEnumDeclaration:
				error(node, Diagnostics.this_cannot_be_referenced_in_current_location)
				break
			}
		}
		if !isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTargetES2015 {
			captureLexicalThis(node, container)
		}
		type_ := tryGetThisTypeAt(node, true, container)
		if noImplicitThis {
			globalThisType := getTypeOfSymbol(globalThisSymbol)
			if type_ == globalThisType && capturedByArrowFunction {
				error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this)
			} else if !type_ {
				diag := error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation)
				if !isSourceFile(container) {
					outsideThis := tryGetThisTypeAt(container)
					if outsideThis && outsideThis != globalThisType {
						addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container))
					}
				}
			}
		}
		return type_ || anyType
	}
	tryGetThisTypeAt := func(node Node, includeGlobalThis /* TODO inferred type boolean */ any /*  = true */, container /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/utilities").ThisContainer */ any /*  = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) *Type {
		isInJS := isInJSFile(node)
		if isFunctionLike(container) && (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) {
			thisType := getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container)
			if !thisType {
				className := getClassNameFromPrototypeMethod(container)
				if isInJS && className {
					classSymbol := checkExpression(className).symbol
					if classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlagsFunction) {
						thisType = (getDeclaredTypeOfSymbol(classSymbol)).thisType
					}
				} else if isJSConstructor(container) {
					thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol))).thisType
				}
				/* TODO(Node BinaryExpression): thisType ||= getContextualThisParameterType(container) */ TODO
			}
			if thisType {
				return getFlowTypeOfReference(node, thisType)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			type_ := /* TODO(Node ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
			return getFlowTypeOfReference(node, type_)
		}
		if isSourceFile(container) {
			if container.commonJsModuleIndicator {
				fileSymbol := getSymbolOfDeclaration(container)
				return fileSymbol && getTypeOfSymbol(fileSymbol)
			} else if container.externalModuleIndicator {
				return undefinedType
			} else if includeGlobalThis {
				return getTypeOfSymbol(globalThisSymbol)
			}
		}
	}
	getExplicitThisType := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		container := getThisContainer(node, false, false)
		if isFunctionLike(container) {
			signature := getSignatureFromDeclaration(container)
			if signature.thisParameter {
				return getExplicitTypeOfSymbol(signature.thisParameter)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			// converted from conditional expression
			switch {
			case isStatic(container):
				return getTypeOfSymbol(symbol)
			default:
				return (getDeclaredTypeOfSymbol(symbol)).thisType
			}
		}
	}
	getClassNameFromPrototypeMethod := func(container Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").LeftHandSideExpression | undefined */ any {
		if container.kind == SyntaxKindFunctionExpression && isBinaryExpression(container.parent) && getAssignmentDeclarationKind(container.parent) == AssignmentDeclarationKindPrototypeProperty {
			return ((container.parent.left).expression).expression
		} else if container.kind == SyntaxKindMethodDeclaration && container.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent) && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.left).expression
		} else if container.kind == SyntaxKindFunctionExpression && container.parent.kind == SyntaxKindPropertyAssignment && container.parent.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent.parent) && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.parent.left).expression
		} else if container.kind == SyntaxKindFunctionExpression && isPropertyAssignment(container.parent) && isIdentifier(container.parent.name) && (container.parent.name.escapedText == "value" || container.parent.name.escapedText == "get" || container.parent.name.escapedText == "set") && isObjectLiteralExpression(container.parent.parent) && isCallExpression(container.parent.parent.parent) && container.parent.parent.parent.arguments[2] == container.parent.parent && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return (container.parent.parent.parent.arguments[0]).expression
		} else if isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText == "value" || container.name.escapedText == "get" || container.name.escapedText == "set") && isObjectLiteralExpression(container.parent) && isCallExpression(container.parent.parent) && container.parent.parent.arguments[2] == container.parent && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return (container.parent.parent.arguments[0]).expression
		}
	}
	getTypeForThisExpressionFromJSDoc := func(node SignatureDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		thisTag := getJSDocThisTag(node)
		if thisTag && thisTag.typeExpression {
			return getTypeFromTypeNode(thisTag.typeExpression)
		}
		signature := getSignatureOfTypeTag(node)
		if signature {
			return getThisTypeOfSignature(signature)
		}
	}
	isInConstructorArgumentInitializer := func(node Node, constructorDecl Node) bool {
		return !!findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			return /* TODO(Node ConditionalExpression): isFunctionLikeDeclaration(n) ? "quit" : n.kind === SyntaxKind.Parameter && n.parent === constructorDecl */ TODO
		})
	}
	checkSuperExpression := func(node Node) Type {
		isCallExpression := node.parent.kind == SyntaxKindCallExpression && (node.parent).expression == node
		immediateContainer := getSuperContainer(node, true)
		container := immediateContainer
		needToCaptureLexicalThis := false
		inAsyncFunction := false
		if !isCallExpression {
			for container && container.kind == SyntaxKindArrowFunction {
				if hasSyntacticModifier(container, ModifierFlagsAsync) {
					inAsyncFunction = true
				}
				container = getSuperContainer(container, true)
				needToCaptureLexicalThis = languageVersion < ScriptTargetES2015
			}
			if container && hasSyntacticModifier(container, ModifierFlagsAsync) {
				inAsyncFunction = true
			}
		}
		var nodeCheckFlag NodeCheckFlags = 0
		if !container || !isLegalUsageOfSuperExpression(container) {
			current := findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
				return /* TODO(Node ConditionalExpression): n === container ? "quit" : n.kind === SyntaxKind.ComputedPropertyName */ TODO
			})
			if current && current.kind == SyntaxKindComputedPropertyName {
				error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name)
			} else if isCallExpression {
				error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors)
			} else if !container || !container.parent || !(isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression) {
				error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions)
			} else {
				error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class)
			}
			return errorType
		}
		if !isCallExpression && immediateContainer.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class)
		}
		if isStatic(container) || isCallExpression {
			nodeCheckFlag = NodeCheckFlagsSuperStatic
			if !isCallExpression && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) {
				forEachEnclosingBlockScopeContainer(node.parent, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) {
					if !isSourceFile(current) || isExternalOrCommonJsModule(current) {
						getNodeLinks(current).flags |= NodeCheckFlagsContainsSuperPropertyInStaticInitializer
					}
				})
			}
		} else {
			nodeCheckFlag = NodeCheckFlagsSuperInstance
		}
		getNodeLinks(node).flags |= nodeCheckFlag
		if container.kind == SyntaxKindMethodDeclaration && inAsyncFunction {
			if isSuperProperty(node.parent) && isAssignmentTarget(node.parent) {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync
			} else {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync
			}
		}
		if needToCaptureLexicalThis {
			captureLexicalThis(node.parent, container)
		}
		if container.parent.kind == SyntaxKindObjectLiteralExpression {
			if languageVersion < ScriptTargetES2015 {
				error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher)
				return errorType
			} else {
				return anyType
			}
		}
		classLikeDeclaration := container.parent
		if !getClassExtendsHeritageElement(classLikeDeclaration) {
			error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class)
			return errorType
		}
		if classDeclarationExtendsNull(classLikeDeclaration) {
			// converted from conditional expression
			switch {
			case isCallExpression:
				return errorType
			default:
				return nullWideningType
			}
		}
		classType := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration))
		baseClassType := classType && getBaseTypes(classType)[0]
		if !baseClassType {
			return errorType
		}
		if container.kind == SyntaxKindConstructor && isInConstructorArgumentInitializer(node, container) {
			error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments)
			return errorType
		}
		// converted from conditional expression
		switch {
		case nodeCheckFlag == NodeCheckFlagsSuperStatic:
			return getBaseConstructorTypeOfClass(classType)
		default:
			return getTypeWithThisArgument(baseClassType, classType.thisType)
		}
		isLegalUsageOfSuperExpression := func(container Node) bool {
			if isCallExpression {
				return container.kind == SyntaxKindConstructor
			} else {
				if isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression {
					if isStatic(container) {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindClassStaticBlockDeclaration
					} else {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindPropertySignature || container.kind == SyntaxKindConstructor
					}
				}
			}
			return false
		}
	}
	getContainingObjectLiteral := func(func_ SignatureDeclaration) *ObjectLiteralExpression {
		// converted from conditional expression
		switch {
		case (func_.kind == SyntaxKindMethodDeclaration || func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor) && func_.parent.kind == SyntaxKindObjectLiteralExpression:
			return func_.parent
		case func_.kind == SyntaxKindFunctionExpression && func_.parent.kind == SyntaxKindPropertyAssignment:
			return func_.parent.parent
		default:
			return nil
		}
	}
	getThisTypeArgument := func(type_ Type) *Type {
		// converted from conditional expression
		switch {
		case getObjectFlags(type_)&ObjectFlagsReference && (type_).target == globalThisType:
			return getTypeArguments(type_)[0]
		default:
			return nil
		}
	}
	getThisTypeFromContextualType := func(type_ Type) *Type {
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
			// converted from conditional expression
			switch {
			case t.flags & TypeFlagsIntersection:
				return forEach((t).types, getThisTypeArgument)
			default:
				return getThisTypeArgument(t)
			}
		})
	}
	getThisTypeOfObjectLiteralFromContextualType := func(containingLiteral ObjectLiteralExpression, contextualType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		literal := containingLiteral
		type_ := contextualType
		for type_ {
			thisType := getThisTypeFromContextualType(type_)
			if thisType {
				return thisType
			}
			if literal.parent.kind != SyntaxKindPropertyAssignment {
				break
			}
			literal = literal.parent.parent
			type_ = getApparentTypeOfContextualType(literal, nil)
		}
	}
	getContextualThisParameterType := func(func_ SignatureDeclaration) *Type {
		if func_.kind == SyntaxKindArrowFunction {
			return nil
		}
		if isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			contextualSignature := getContextualSignature(func_)
			if contextualSignature {
				thisParameter := contextualSignature.thisParameter
				if thisParameter {
					return getTypeOfSymbol(thisParameter)
				}
			}
		}
		inJs := isInJSFile(func_)
		if noImplicitThis || inJs {
			containingLiteral := getContainingObjectLiteral(func_)
			if containingLiteral {
				contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
				thisType := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
				if thisType {
					return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)))
				}
				return getWidenedType( /* TODO(Node ConditionalExpression): contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral) */ TODO)
			}
			parent := walkUpParenthesizedExpressions(func_.parent)
			if isAssignmentExpression(parent) {
				target := parent.left
				if isAccessExpression(target) {
					TODO_IDENTIFIER := target
					if inJs && isIdentifier(expression) {
						sourceFile := getSourceFileOfNode(parent)
						if sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) == sourceFile.symbol {
							return nil
						}
					}
					return getWidenedType(checkExpressionCached(expression))
				}
			}
		}
		return nil
	}
	getContextuallyTypedParameterType := func(parameter ParameterDeclaration) *Type {
		func_ := parameter.parent
		if !isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			return nil
		}
		iife := getImmediatelyInvokedFunctionExpression(func_)
		if iife && iife.arguments {
			args := getEffectiveCallArguments(iife)
			indexOfParameter := func_.parameters.indexOf(parameter)
			if parameter.dotDotDotToken {
				return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, nil, CheckModeNormal)
			}
			links := getNodeLinks(iife)
			cached := links.resolvedSignature
			links.resolvedSignature = anySignature
			type_ := /* TODO(Node ConditionalExpression): indexOfParameter < args.length ? getWidenedLiteralType(checkExpression(args[indexOfParameter])) : parameter.initializer ? undefined : undefinedWideningType */ TODO
			links.resolvedSignature = cached
			return type_
		}
		contextualSignature := getContextualSignature(func_)
		if contextualSignature {
			index := func_.parameters.indexOf(parameter) - ( /* TODO(Node ConditionalExpression): getThisParameter(func) ? 1 : 0 */ TODO)
			// converted from conditional expression
			switch {
			case parameter.dotDotDotToken && lastOrUndefined(func_.parameters) == parameter:
				return getRestTypeAtPosition(contextualSignature, index)
			default:
				return tryGetTypeAtPosition(contextualSignature, index)
			}
		}
	}
	getContextualTypeForVariableLikeDeclaration := func(declaration VariableLikeDeclaration, contextFlags *ContextFlags) *Type {
		typeNode := getEffectiveTypeAnnotationNode(declaration) || ( /* TODO(Node ConditionalExpression): isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined */ TODO)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		switch declaration.kind {
		case SyntaxKindParameter:
			return getContextuallyTypedParameterType(declaration)
		case SyntaxKindBindingElement:
			return getContextualTypeForBindingElement(declaration, contextFlags)
		case SyntaxKindPropertyDeclaration:
			if isStatic(declaration) {
				return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags)
			}
		}
	}
	getContextualTypeForBindingElement := func(declaration BindingElement, contextFlags *ContextFlags) *Type {
		parent := declaration.parent.parent
		name := declaration.propertyName || declaration.name
		parentType := getContextualTypeForVariableLikeDeclaration(parent, contextFlags) || parent.kind != SyntaxKindBindingElement && parent.initializer && checkDeclarationInitializer(parent /* TODO(Node ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */, TODO)
		if !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) {
			return nil
		}
		if parent.name.kind == SyntaxKindArrayBindingPattern {
			index := indexOfNode(declaration.parent.elements, declaration)
			if index < 0 {
				return nil
			}
			return getContextualTypeForElementExpression(parentType, index)
		}
		nameType := getLiteralTypeFromPropertyName(name)
		if isTypeUsableAsPropertyName(nameType) {
			text := getPropertyNameFromType(nameType)
			return getTypeOfPropertyOfType(parentType, text)
		}
	}
	getContextualTypeForStaticPropertyDeclaration := func(declaration PropertyDeclaration, contextFlags *ContextFlags) *Type {
		parentType := isExpression(declaration.parent) && getContextualType(declaration.parent, contextFlags)
		if !parentType {
			return nil
		}
		return getTypeOfPropertyOfContextualType(parentType, getSymbolOfDeclaration(declaration).escapedName)
	}
	getContextualTypeForInitializerExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		declaration := node.parent
		if hasInitializer(declaration) && node == declaration.initializer {
			result := getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
			if result {
				return result
			}
			if !(contextFlags & ContextFlagsSkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0 {
				return getTypeFromBindingPattern(declaration.name, true, false)
			}
		}
		return nil
	}
	getContextualTypeForReturnExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				functionFlags := getFunctionFlags(func_)
				if functionFlags & FunctionFlagsGenerator {
					isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
					if contextualReturnType.flags & TypeFlagsUnion {
						contextualReturnType = filterType(contextualReturnType, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
							return !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
						})
					}
					iterationReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, contextualReturnType, (functionFlags&FunctionFlagsAsync) != 0)
					if !iterationReturnType {
						return nil
					}
					contextualReturnType = iterationReturnType
				}
				if functionFlags & FunctionFlagsAsync {
					contextualAwaitedType := mapType(contextualReturnType, getAwaitedTypeNoAlias)
					return contextualAwaitedType && getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)})
				}
				return contextualReturnType
			}
		}
		return nil
	}
	getContextualTypeForAwaitOperand := func(node AwaitExpression, contextFlags *ContextFlags) *Type {
		contextualType := getContextualType(node, contextFlags)
		if contextualType {
			contextualAwaitedType := getAwaitedTypeNoAlias(contextualType)
			return contextualAwaitedType && getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)})
		}
		return nil
	}
	getContextualTypeForYieldOperand := func(node YieldExpression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			functionFlags := getFunctionFlags(func_)
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
				if !node.asteriskToken && contextualReturnType.flags&TypeFlagsUnion {
					contextualReturnType = filterType(contextualReturnType, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return !!getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
					})
				}
				if node.asteriskToken {
					iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
					yieldType := /* TODO(Node BinaryExpression): iterationTypes?.yieldType ?? silentNeverType */ TODO
					returnType := /* TODO(Node BinaryExpression): getContextualType(node, contextFlags) ?? silentNeverType */ TODO
					nextType := /* TODO(Node BinaryExpression): iterationTypes?.nextType ?? unknownType */ TODO
					generatorType := createGeneratorType(yieldType, returnType, nextType, false)
					if isAsyncGenerator {
						asyncGeneratorType := createGeneratorType(yieldType, returnType, nextType, true)
						return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any{generatorType, asyncGeneratorType})
					}
					return generatorType
				}
				return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, contextualReturnType, isAsyncGenerator)
			}
		}
		return nil
	}
	isInParameterInitializerBeforeContainingFunction := func(node Node) /* TODO inferred type boolean */ any {
		inBindingInitializer := false
		for node.parent && !isFunctionLike(node.parent) {
			if isParameter(node.parent) && (inBindingInitializer || node.parent.initializer == node) {
				return true
			}
			if isBindingElement(node.parent) && node.parent.initializer == node {
				inBindingInitializer = true
			}
			node = node.parent
		}
		return false
	}
	getContextualIterationType := func(kind IterationTypeKind, functionDecl SignatureDeclaration) *Type {
		isAsync := !!(getFunctionFlags(functionDecl) & FunctionFlagsAsync)
		contextualReturnType := getContextualReturnType(functionDecl, nil)
		if contextualReturnType {
			return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || nil
		}
		return nil
	}
	getContextualReturnType := func(functionDecl SignatureDeclaration, contextFlags *ContextFlags) *Type {
		returnType := getReturnTypeFromAnnotation(functionDecl)
		if returnType {
			return returnType
		}
		signature := getContextualSignatureForFunctionLikeDeclaration(functionDecl)
		if signature && !isResolvingReturnTypeOfSignature(signature) {
			returnType := getReturnTypeOfSignature(signature)
			functionFlags := getFunctionFlags(functionDecl)
			if functionFlags & FunctionFlagsGenerator {
				return filterType(returnType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, nil)
				})
			}
			if functionFlags & FunctionFlagsAsync {
				return filterType(returnType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t)
				})
			}
			return returnType
		}
		iife := getImmediatelyInvokedFunctionExpression(functionDecl)
		if iife {
			return getContextualType(iife, contextFlags)
		}
		return nil
	}
	getContextualTypeForArgument := func(callTarget CallLikeExpression, arg Expression) *Type {
		args := getEffectiveCallArguments(callTarget)
		argIndex := args.indexOf(arg)
		// converted from conditional expression
		switch {
		case argIndex == -1:
			return nil
		default:
			return getContextualTypeForArgumentAtIndex(callTarget, argIndex)
		}
	}
	getContextualTypeForArgumentAtIndex := func(callTarget CallLikeExpression, argIndex number) Type {
		if isImportCall(callTarget) {
			// converted from conditional expression
			switch {
			case argIndex == 0:
				return stringType
			case argIndex == 1:
				return getGlobalImportCallOptionsType(false)
			default:
				return anyType
			}
		}
		signature := /* TODO(Node ConditionalExpression): getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget) */ TODO
		if isJsxOpeningLikeElement(callTarget) && argIndex == 0 {
			return getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
		}
		restIndex := signature.parameters.length - 1
		// converted from conditional expression
		switch {
		case signatureHasRestParameter(signature) && argIndex >= restIndex:
			return getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex-restIndex), AccessFlagsContextual)
		default:
			return getTypeAtPosition(signature, argIndex)
		}
	}
	getContextualTypeForDecorator := func(decorator Decorator) *Type {
		signature := getDecoratorCallSignature(decorator)
		// converted from conditional expression
		switch {
		case signature:
			return getOrCreateTypeFromSignature(signature)
		default:
			return nil
		}
	}
	getContextualTypeForSubstitutionExpression := func(template TemplateExpression, substitutionExpression Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if template.parent.kind == SyntaxKindTaggedTemplateExpression {
			return getContextualTypeForArgument(template.parent, substitutionExpression)
		}
		return nil
	}
	getContextualTypeForBinaryOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		binaryExpression := node.parent
		TODO_IDENTIFIER := binaryExpression
		switch operatorToken.kind {
		case SyntaxKindEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandAmpersandEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarBarEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindQuestionQuestionEqualsToken:
			// converted from conditional expression
			switch {
			case node == right:
				return getContextualTypeForAssignmentDeclaration(binaryExpression)
			default:
				return nil
			}
		case SyntaxKindBarBarToken:
			fallthrough // TODO: merge cases
		case SyntaxKindQuestionQuestionToken:
			type_ := getContextualType(binaryExpression, contextFlags)
			// converted from conditional expression
			switch {
			case node == right && (type_ && type_.pattern || !type_ && !isDefaultedExpandoInitializer(binaryExpression)):
				return getTypeOfExpression(left)
			default:
				return type_
			}
		case SyntaxKindAmpersandAmpersandToken:
			fallthrough // TODO: merge cases
		case SyntaxKindCommaToken:
			// converted from conditional expression
			switch {
			case node == right:
				return getContextualType(binaryExpression, contextFlags)
			default:
				return nil
			}
		default:
			return nil
		}
	}
	getSymbolForExpression := func(e Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		if canHaveSymbol(e) && e.symbol {
			return e.symbol
		}
		if isIdentifier(e) {
			return getResolvedSymbol(e)
		}
		if isPropertyAccessExpression(e) {
			lhsType := getTypeOfExpression(e.expression)
			// converted from conditional expression
			switch {
			case isPrivateIdentifier(e.name):
				return tryGetPrivateIdentifierPropertyOfType(lhsType, e.name)
			default:
				return getPropertyOfType(lhsType, e.name.escapedText)
			}
		}
		if isElementAccessExpression(e) {
			propType := checkExpressionCached(e.argumentExpression)
			if !isTypeUsableAsPropertyName(propType) {
				return nil
			}
			lhsType := getTypeOfExpression(e.expression)
			return getPropertyOfType(lhsType, getPropertyNameFromType(propType))
		}
		return nil
		tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id)
			return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type_, lexicallyScopedSymbol)
		}
	}
	getContextualTypeForAssignmentDeclaration := func(binaryExpression BinaryExpression) *Type {
		kind := getAssignmentDeclarationKind(binaryExpression)
		switch kind {
		case AssignmentDeclarationKindNone:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindThisProperty:
			lhsSymbol := getSymbolForExpression(binaryExpression.left)
			decl := lhsSymbol && lhsSymbol.valueDeclaration
			if decl && (isPropertyDeclaration(decl) || isPropertySignature(decl)) {
				overallAnnotation := getEffectiveTypeAnnotationNode(decl)
				return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) || ( /* TODO(Node ConditionalExpression): isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined */ TODO)
			}
			if kind == AssignmentDeclarationKindNone {
				return getTypeOfExpression(binaryExpression.left)
			}
			return getContextualTypeForThisPropertyAssignment(binaryExpression)
		case AssignmentDeclarationKindProperty:
			if isPossiblyAliasedThisProperty(binaryExpression, kind) {
				return getContextualTypeForThisPropertyAssignment(binaryExpression)
			} else if !canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol {
				return getTypeOfExpression(binaryExpression.left)
			} else {
				decl := binaryExpression.left.symbol.valueDeclaration
				if !decl {
					return nil
				}
				lhs := cast(binaryExpression.left, isAccessExpression)
				overallAnnotation := getEffectiveTypeAnnotationNode(decl)
				if overallAnnotation {
					return getTypeFromTypeNode(overallAnnotation)
				} else if isIdentifier(lhs.expression) {
					id := lhs.expression
					parentSymbol := resolveName(id, id.escapedText, SymbolFlagsValue, nil, true)
					if parentSymbol {
						annotated := parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration)
						if annotated {
							nameStr := getElementOrPropertyAccessName(lhs)
							if nameStr != nil {
								return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr)
							}
						}
						return nil
					}
				}
				// converted from conditional expression
				switch {
				case isInJSFile(decl) || decl == binaryExpression.left:
					return nil
				default:
					return getTypeOfExpression(binaryExpression.left)
				}
			}
			fallthrough
		case AssignmentDeclarationKindExportsProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindPrototype:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindPrototypeProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindModuleExports:
			var valueDeclaration Declaration
			if kind != AssignmentDeclarationKindModuleExports {
				valueDeclaration = /* TODO(Node ConditionalExpression): canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined */ TODO
			}
			/* TODO(Node BinaryExpression): valueDeclaration ||= binaryExpression.symbol?.valueDeclaration */ TODO
			annotated := valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration)
			// converted from conditional expression
			switch {
			case annotated:
				return getTypeFromTypeNode(annotated)
			default:
				return nil
			}
		case AssignmentDeclarationKindObjectDefinePropertyValue:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindObjectDefinePropertyExports:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindObjectDefinePrototypeProperty:
			return Debug.fail("Does not apply")
		default:
			return Debug.assertNever(kind)
		}
	}
	isPossiblyAliasedThisProperty := func(declaration BinaryExpression, kind /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").AssignmentDeclarationKind */ any /*  = getAssignmentDeclarationKind(declaration) */) /* TODO inferred type boolean */ any {
		if kind == AssignmentDeclarationKindThisProperty {
			return true
		}
		if !isInJSFile(declaration) || kind != AssignmentDeclarationKindProperty || !isIdentifier((declaration.left).expression) {
			return false
		}
		name := ((declaration.left).expression).escapedText
		symbol := resolveName(declaration.left, name, SymbolFlagsValue, nil, true, true)
		return isThisInitializedDeclaration(symbol. /*?*/ valueDeclaration)
	}
	getContextualTypeForThisPropertyAssignment := func(binaryExpression BinaryExpression) *Type {
		if !binaryExpression.symbol {
			return getTypeOfExpression(binaryExpression.left)
		}
		if binaryExpression.symbol.valueDeclaration {
			annotated := getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration)
			if annotated {
				type_ := getTypeFromTypeNode(annotated)
				if type_ {
					return type_
				}
			}
		}
		thisAccess := cast(binaryExpression.left, isAccessExpression)
		if !isObjectLiteralMethod(getThisContainer(thisAccess.expression, false, false)) {
			return nil
		}
		thisType := checkThisExpression(thisAccess.expression)
		nameStr := getElementOrPropertyAccessName(thisAccess)
		return nameStr != nil && getTypeOfPropertyOfContextualType(thisType, nameStr) || nil
	}
	isCircularMappedProperty := func(symbol Symbol) /* TODO inferred type boolean */ any {
		return !!(getCheckFlags(symbol)&CheckFlagsMapped && !(symbol).links.type_ && findResolutionCycleStartIndex(symbol, TypeSystemPropertyNameType) >= 0)
	}
	isExcludedMappedPropertyName := func(constraint Type, propertyNameType Type) bool {
		if constraint.flags & TypeFlagsConditional {
			type_ := constraint
			return !!(getReducedType(getTrueTypeFromConditionalType(type_)).flags & TypeFlagsNever) && getActualTypeVariable(getFalseTypeFromConditionalType(type_)) == getActualTypeVariable(type_.checkType) && isTypeAssignableTo(propertyNameType, type_.extendsType)
		}
		if constraint.flags & TypeFlagsIntersection {
			return some((constraint).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return isExcludedMappedPropertyName(t, propertyNameType)
			})
		}
		return false
	}
	getTypeOfPropertyOfContextualType := func(type_ Type, name __String, nameType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
			if t.flags & TypeFlagsIntersection {
				var types *[]Type
				var indexInfoCandidates *[]Type
				ignoreIndexInfos := false
				for _, constituentType := range (t).types {
					if !(constituentType.flags & TypeFlagsObject) {
						continue
					}
					if isGenericMappedType(constituentType) && getMappedTypeNameTypeKind(constituentType) != MappedTypeNameTypeKindRemapping {
						substitutedType := getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, substitutedType)
						continue
					}
					propertyType := getTypeOfConcretePropertyOfContextualType(constituentType, name)
					if !propertyType {
						if !ignoreIndexInfos {
							indexInfoCandidates = append(indexInfoCandidates, constituentType)
						}
						continue
					}
					ignoreIndexInfos = true
					indexInfoCandidates = nil
					types = appendContextualPropertyTypeConstituent(types, propertyType)
				}
				if indexInfoCandidates {
					for _, candidate := range indexInfoCandidates {
						indexInfoType := getTypeFromIndexInfosOfContextualType(candidate, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, indexInfoType)
					}
				}
				if !types {
					return
				}
				if types.length == 1 {
					return types[0]
				}
				return getIntersectionType(types)
			}
			if !(t.flags & TypeFlagsObject) {
				return
			}
			// converted from conditional expression
			switch {
			case isGenericMappedType(t) && getMappedTypeNameTypeKind(t) != MappedTypeNameTypeKindRemapping:
				return getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)
			default:
				return /* TODO(Node BinaryExpression): getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType) */ TODO
			}
		}, true)
	}
	appendContextualPropertyTypeConstituent := func(types *[]Type, type_ *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ any {
		// converted from conditional expression
		switch {
		case type_:
			return append(types /* TODO(Node ConditionalExpression): type.flags & TypeFlags.Any ? unknownType : type */, TODO)
		default:
			return types
		}
	}
	getIndexedMappedTypeSubstitutedTypeOfContextualType := func(type_ MappedType, name __String, nameType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		propertyNameType := nameType || getStringLiteralType(unescapeLeadingUnderscores(name))
		constraint := getConstraintTypeFromMappedType(type_)
		if type_.nameType && isExcludedMappedPropertyName(type_.nameType, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType) {
			return
		}
		constraintOfConstraint := getBaseConstraintOfType(constraint) || constraint
		if !isTypeAssignableTo(propertyNameType, constraintOfConstraint) {
			return
		}
		return substituteIndexedMappedType(type_, propertyNameType)
	}
	getTypeOfConcretePropertyOfContextualType := func(type_ Type, name __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		prop := getPropertyOfType(type_, name)
		if !prop || isCircularMappedProperty(prop) {
			return
		}
		return removeMissingType(getTypeOfSymbol(prop), !!(prop.flags & SymbolFlagsOptional))
	}
	getTypeFromIndexInfosOfContextualType := func(type_ Type, name __String, nameType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if isTupleType(type_) && isNumericLiteralName(name) && +name >= 0 {
			restType := getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength, 0, false, true)
			if restType {
				return restType
			}
		}
		return findApplicableIndexInfo(getIndexInfosOfStructuredType(type_), nameType || getStringLiteralType(unescapeLeadingUnderscores(name))). /*?*/ type_
	}
	getContextualTypeForObjectLiteralMethod := func(node MethodDeclaration, contextFlags *ContextFlags) *Type {
		Debug.assert(isObjectLiteralMethod(node))
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		return getContextualTypeForObjectLiteralElement(node, contextFlags)
	}
	getContextualTypeForObjectLiteralElement := func(element ObjectLiteralElementLike, contextFlags *ContextFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		objectLiteral := element.parent
		propertyAssignmentType := isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags)
		if propertyAssignmentType {
			return propertyAssignmentType
		}
		type_ := getApparentTypeOfContextualType(objectLiteral, contextFlags)
		if type_ {
			if hasBindableName(element) {
				symbol := getSymbolOfDeclaration(element)
				return getTypeOfPropertyOfContextualType(type_, symbol.escapedName, getSymbolLinks(symbol).nameType)
			}
			if hasDynamicName(element) {
				name := getNameOfDeclaration(element)
				if name && isComputedPropertyName(name) {
					exprType := checkExpression(name.expression)
					propType := isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type_, getPropertyNameFromType(exprType))
					if propType {
						return propType
					}
				}
			}
			if element.name {
				nameType := getLiteralTypeFromPropertyName(element.name)
				return mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
					return findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType). /*?*/ type_
				}, true)
			}
		}
		return nil
	}
	getSpreadIndices := func(elements []Node) /* TODO inferred type { first: number | undefined; last: number | undefined; } */ any {
		var first TODO
		var last TODO
		for i := 0; i < elements.length; i++ {
			if isSpreadElement(elements[i]) {
				/* TODO(Node BinaryExpression): first ??= i */ TODO
				last = i
			}
		}
		return /* TODO(Node ObjectLiteralExpression): { first, last } */ TODO
	}
	getContextualTypeForElementExpression := func(type_ *Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) *Type {
		return type_ && mapType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
			if isTupleType(t) {
				if (firstSpreadIndex == nil || index < firstSpreadIndex) && index < t.target.fixedLength {
					return removeMissingType(getTypeArguments(t)[index], !!(t.target.elementFlags[index] && ElementFlagsOptional))
				}
				offset := /* TODO(Node ConditionalExpression): length !== undefined && (lastSpreadIndex === undefined || index > lastSpreadIndex) ? length - index : 0 */ TODO
				fixedEndLength := /* TODO(Node ConditionalExpression): offset > 0 && (t.target.combinedFlags & ElementFlags.Variable) ? getEndElementCount(t.target, ElementFlags.Fixed) : 0 */ TODO
				if offset > 0 && offset <= fixedEndLength {
					return getTypeArguments(t)[getTypeReferenceArity(t)-offset]
				}
				return getElementTypeOfSliceOfTupleType(t /* TODO(Node ConditionalExpression): firstSpreadIndex === undefined ? t.target.fixedLength : Math.min(t.target.fixedLength, firstSpreadIndex) */, TODO /* TODO(Node ConditionalExpression): length === undefined || lastSpreadIndex === undefined ? fixedEndLength : Math.min(fixedEndLength, length - lastSpreadIndex) */, TODO, false, true)
			}
			return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t, ""+index) || getIteratedTypeOrElementType(IterationUseElement, t, undefinedType, nil, false)
		}, true)
	}
	getContextualTypeForConditionalOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		conditional := node.parent
		// converted from conditional expression
		switch {
		case node == conditional.whenTrue || node == conditional.whenFalse:
			return getContextualType(conditional, contextFlags)
		default:
			return nil
		}
	}
	getContextualTypeForChildJsxExpression := func(node JsxElement, child JsxChild, contextFlags *ContextFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		attributesType := getApparentTypeOfContextualType(node.openingElement.attributes, contextFlags)
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		if !(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName != "") {
			return nil
		}
		realChildren := getSemanticJsxChildren(node.children)
		childIndex := realChildren.indexOf(child)
		childFieldType := getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
		return childFieldType && ( /* TODO(Node ConditionalExpression): realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => { if (isArrayLikeType(t)) { return getIndexedAccessType(t, getNumberLiteralType(childIndex)); } else { return t; } }, /*noReductions* / true) */ TODO)
	}
	getContextualTypeForJsxExpression := func(node JsxExpression, contextFlags *ContextFlags) *Type {
		exprParent := node.parent
		// converted from conditional expression
		switch {
		case isJsxAttributeLike(exprParent):
			return getContextualType(node, contextFlags)
		case isJsxElement(exprParent):
			return getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)
		default:
			return nil
		}
	}
	getContextualTypeForJsxAttribute := func(attribute /* TODO(TypeNode UnionType): JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) *Type {
		if isJsxAttribute(attribute) {
			attributesType := getApparentTypeOfContextualType(attribute.parent, contextFlags)
			if !attributesType || isTypeAny(attributesType) {
				return nil
			}
			return getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(attribute.name))
		} else {
			return getContextualType(attribute.parent, contextFlags)
		}
	}
	isPossiblyDiscriminantValue := func(node Expression) bool {
		switch node.kind {
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNullKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindUndefinedKeyword:
			return true
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			return isPossiblyDiscriminantValue((node).expression)
		case SyntaxKindJsxExpression:
			return !(node).expression || isPossiblyDiscriminantValue((node).expression)
		}
		return false
	}
	discriminateContextualTypeByObjectMembers := func(node ObjectLiteralExpression, contextualType UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		key := /* TODO(Node TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		return /* TODO(Node BinaryExpression): getCachedType(key) ?? setCachedType( key, getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems( contextualType, concatenate( map( filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => { if (!p.symbol) { return false; } if (p.kind === SyntaxKind.PropertyAssignment) { return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName); } if (p.kind === SyntaxKind.ShorthandPropertyAssignment) { return isDiscriminantProperty(contextualType, p.symbol.escapedName); } return false; }), prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const), ), map( filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)), s => [() => undefinedType, s.escapedName] as const, ), ), isTypeAssignableTo, ), ) */ TODO
	}
	discriminateContextualTypeByJSXAttributes := func(node JsxAttributes, contextualType UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		key := /* TODO(Node TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		cached := getCachedType(key)
		if cached {
			return cached
		}
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		return setCachedType(key, discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter(node.properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttribute | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSpreadAttribute */ any) /* TODO inferred type boolean */ any {
			return !!p.symbol && p.kind == SyntaxKindJsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer))
		}), func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttribute | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSpreadAttribute */ any) /* TODO inferred type readonly [() => import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ any {
			return ([]TODO{ /* TODO(Node ConditionalExpression): !(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)) */ TODO, prop.symbol.escapedName})
		}), map_(filter(getPropertiesOfType(contextualType), func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			if !(s.flags & SymbolFlagsOptional) || !node. /*?*/ symbol. /*?*/ members {
				return false
			}
			element := node.parent.parent
			if s.escapedName == jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length {
				return false
			}
			return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)
		}), func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type readonly [() => import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ any {
			return []TODO{func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
				return undefinedType
			}, s.escapedName}
		})), isTypeAssignableTo))
	}
	getApparentTypeOfContextualType := func(node /* TODO(TypeNode UnionType): Expression | MethodDeclaration */ any, contextFlags *ContextFlags) *Type {
		contextualType := /* TODO(Node ConditionalExpression): isObjectLiteralMethod(node) ? getContextualTypeForObjectLiteralMethod(node, contextFlags) : getContextualType(node, contextFlags) */ TODO
		instantiatedType := instantiateContextualType(contextualType, node, contextFlags)
		if instantiatedType && !(contextFlags && contextFlags&ContextFlagsNoConstraints && instantiatedType.flags&TypeFlagsTypeVariable) {
			apparentType := mapType(instantiatedType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): getObjectFlags(t) & ObjectFlags.Mapped ? t : getApparentType(t) */ TODO
			}, true)
			// converted from conditional expression
			switch {
			case apparentType.flags&TypeFlagsUnion && isObjectLiteralExpression(node):
				return discriminateContextualTypeByObjectMembers(node, apparentType)
			case apparentType.flags&TypeFlagsUnion && isJsxAttributes(node):
				return discriminateContextualTypeByJSXAttributes(node, apparentType)
			default:
				return apparentType
			}
		}
	}
	instantiateContextualType := func(contextualType *Type, node Node, contextFlags *ContextFlags) *Type {
		if contextualType && maybeTypeOfKind(contextualType, TypeFlagsInstantiable) {
			inferenceContext := getInferenceContext(node)
			if inferenceContext && contextFlags&ContextFlagsSignature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault) {
				return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper)
			}
			if inferenceContext. /*?*/ returnMapper {
				type_ := instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper)
				// converted from conditional expression
				switch {
				case type_.flags&TypeFlagsUnion && containsType((type_).types, regularFalseType) && containsType((type_).types, regularTrueType):
					return filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
						return t != regularFalseType && t != regularTrueType
					})
				default:
					return type_
				}
			}
		}
		return contextualType
	}
	instantiateInstantiableTypes := func(type_ Type, mapper TypeMapper) Type {
		if type_.flags & TypeFlagsInstantiable {
			return instantiateType(type_, mapper)
		}
		if type_.flags & TypeFlagsUnion {
			return getUnionType(map_((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return instantiateInstantiableTypes(t, mapper)
			}), UnionReductionNone)
		}
		if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return instantiateInstantiableTypes(t, mapper)
			}))
		}
		return type_
	}
	getContextualType := func(node Expression, contextFlags *ContextFlags) *Type {
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		index := findContextualNode(node, !contextFlags)
		if index >= 0 {
			return contextualTypes[index]
		}
		TODO_IDENTIFIER := node
		switch parent.kind {
		case SyntaxKindVariableDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindParameter:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertySignature:
			fallthrough // TODO: merge cases
		case SyntaxKindBindingElement:
			return getContextualTypeForInitializerExpression(node, contextFlags)
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindReturnStatement:
			return getContextualTypeForReturnExpression(node, contextFlags)
		case SyntaxKindYieldExpression:
			return getContextualTypeForYieldOperand(parent, contextFlags)
		case SyntaxKindAwaitExpression:
			return getContextualTypeForAwaitOperand(parent, contextFlags)
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			return getContextualTypeForArgument(parent, node)
		case SyntaxKindDecorator:
			return getContextualTypeForDecorator(parent)
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			// converted from conditional expression
			switch {
			case isConstTypeReference((parent).type_):
				return getContextualType(parent, contextFlags)
			default:
				return getTypeFromTypeNode((parent).type_)
			}
		case SyntaxKindBinaryExpression:
			return getContextualTypeForBinaryOperand(node, contextFlags)
		case SyntaxKindPropertyAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindShorthandPropertyAssignment:
			return getContextualTypeForObjectLiteralElement(parent, contextFlags)
		case SyntaxKindSpreadAssignment:
			return getContextualType(parent.parent, contextFlags)
		case SyntaxKindArrayLiteralExpression:
			arrayLiteral := parent
			type_ := getApparentTypeOfContextualType(arrayLiteral, contextFlags)
			elementIndex := indexOfNode(arrayLiteral.elements, node)
			spreadIndices := /* TODO(Node BinaryExpression): getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements) */ TODO
			return getContextualTypeForElementExpression(type_, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last)
			fallthrough
		case SyntaxKindConditionalExpression:
			return getContextualTypeForConditionalOperand(node, contextFlags)
		case SyntaxKindTemplateSpan:
			Debug.assert(parent.parent.kind == SyntaxKindTemplateExpression)
			return getContextualTypeForSubstitutionExpression(parent.parent, node)
		case SyntaxKindParenthesizedExpression:
			if isInJSFile(parent) {
				if isJSDocSatisfiesExpression(parent) {
					return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent))
				}
				typeTag := getJSDocTypeTag(parent)
				if typeTag && !isConstTypeReference(typeTag.typeExpression.type_) {
					return getTypeFromTypeNode(typeTag.typeExpression.type_)
				}
			}
			return getContextualType(parent, contextFlags)
			fallthrough
		case SyntaxKindNonNullExpression:
			return getContextualType(parent, contextFlags)
		case SyntaxKindSatisfiesExpression:
			return getTypeFromTypeNode((parent).type_)
		case SyntaxKindExportAssignment:
			return tryGetTypeFromEffectiveTypeNode(parent)
		case SyntaxKindJsxExpression:
			return getContextualTypeForJsxExpression(parent, contextFlags)
		case SyntaxKindJsxAttribute:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSpreadAttribute:
			return getContextualTypeForJsxAttribute(parent, contextFlags)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			return getContextualJsxElementAttributesType(parent, contextFlags)
		case SyntaxKindImportAttribute:
			return getContextualImportAttributeType(parent)
		}
		return nil
	}
	pushCachedContextualType := func(node Expression) {
		pushContextualType(node, getContextualType(node, nil), true)
	}
	pushContextualType := func(node Expression, type_ *Type, isCache bool) {
		contextualTypeNodes[contextualTypeCount] = node
		contextualTypes[contextualTypeCount] = type_
		contextualIsCache[contextualTypeCount] = isCache
		contextualTypeCount++
	}
	popContextualType := func() {
		contextualTypeCount--
	}
	findContextualNode := func(node Node, includeCaches bool) /* TODO inferred type number */ any {
		for i := contextualTypeCount - 1; i >= 0; i-- {
			if node == contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i]) {
				return i
			}
		}
		return -1
	}
	pushInferenceContext := func(node Node, inferenceContext *InferenceContext) {
		inferenceContextNodes[inferenceContextCount] = node
		inferenceContexts[inferenceContextCount] = inferenceContext
		inferenceContextCount++
	}
	popInferenceContext := func() {
		inferenceContextCount--
	}
	getInferenceContext := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ any {
		for i := inferenceContextCount - 1; i >= 0; i-- {
			if isNodeDescendantOf(node, inferenceContextNodes[i]) {
				return inferenceContexts[i]
			}
		}
	}
	getContextualImportAttributeType := func(node ImportAttribute) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		return getTypeOfPropertyOfContextualType(getGlobalImportAttributesType(false), getNameFromImportAttribute(node))
	}
	getContextualJsxElementAttributesType := func(node JsxOpeningLikeElement, contextFlags *ContextFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if isJsxOpeningElement(node) && contextFlags != ContextFlagsCompletions {
			index := findContextualNode(node.parent, !contextFlags)
			if index >= 0 {
				return contextualTypes[index]
			}
		}
		return getContextualTypeForArgumentAtIndex(node, 0)
	}
	getEffectiveFirstArgumentForJsxSignature := func(signature Signature, node JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case getJsxReferenceKind(node) != JsxReferenceKindComponent:
			return getJsxPropsTypeFromCallSignature(signature, node)
		default:
			return getJsxPropsTypeFromClassType(signature, node)
		}
	}
	getJsxPropsTypeFromCallSignature := func(sig Signature, context JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		propsType := getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
		propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType)
		intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
		if !isErrorType(intrinsicAttribs) {
			propsType = intersectTypes(intrinsicAttribs, propsType)
		}
		return propsType
	}
	getJsxPropsTypeForSignatureFromMember := func(sig Signature, forcedLookupLocation __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if sig.compositeSignatures {
			var results []Type = [] /* TODO inferred type never */ any{}
			for _, signature := range sig.compositeSignatures {
				instance := getReturnTypeOfSignature(signature)
				if isTypeAny(instance) {
					return instance
				}
				propType := getTypeOfPropertyOfType(instance, forcedLookupLocation)
				if !propType {
					return
				}
				results.push(propType)
			}
			return getIntersectionType(results)
		}
		instanceType := getReturnTypeOfSignature(sig)
		// converted from conditional expression
		switch {
		case isTypeAny(instanceType):
			return instanceType
		default:
			return getTypeOfPropertyOfType(instanceType, forcedLookupLocation)
		}
	}
	getStaticTypeOfReferencedJsxConstructor := func(context JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if isJsxIntrinsicTagName(context.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		tagType := checkExpressionCached(context.tagName)
		if tagType.flags & TypeFlagsStringLiteral {
			result := getIntrinsicAttributesTypeFromStringLiteralType(tagType, context)
			if !result {
				return errorType
			}
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		return tagType
	}
	getJsxManagedAttributesFromLocatedAttributes := func(context JsxOpeningLikeElement, ns Symbol, attributesType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		managedSym := getJsxLibraryManagedAttributes(ns)
		if managedSym {
			ctorType := getStaticTypeOfReferencedJsxConstructor(context)
			result := instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
			if result {
				return result
			}
		}
		return attributesType
	}
	getJsxPropsTypeFromClassType := func(sig Signature, context JsxOpeningLikeElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		ns := getJsxNamespaceAt(context)
		forcedLookupLocation := getJsxElementPropertiesName(ns)
		attributesType := /* TODO(Node ConditionalExpression): forcedLookupLocation === undefined // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType) : forcedLookupLocation === "" // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead ? getReturnTypeOfSignature(sig) // Otherwise get the type of the property on the signature return type : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) */ TODO
		if !attributesType {
			if !!forcedLookupLocation && !!length(context.attributes.properties) {
				error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation))
			}
			return unknownType
		}
		attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType)
		if isTypeAny(attributesType) {
			return attributesType
		} else {
			apparentAttributesType := attributesType
			intrinsicClassAttribs := getJsxType(JsxNames.IntrinsicClassAttributes, context)
			if !isErrorType(intrinsicClassAttribs) {
				typeParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol)
				hostClassType := getReturnTypeOfSignature(sig)
				var libraryManagedAttributeType Type
				if typeParams {
					inferredArgs := fillMissingTypeArguments([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{hostClassType}, typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context))
					libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs))
				} else {
					libraryManagedAttributeType = intrinsicClassAttribs
				}
				apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType)
			}
			intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
			if !isErrorType(intrinsicAttribs) {
				apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType)
			}
			return apparentAttributesType
		}
	}
	getIntersectedSignatures := func(signatures []Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
		// converted from conditional expression
		switch {
		case getStrictOptionValue(compilerOptions, "noImplicitAny"):
			return reduceLeft(signatures, func(left *Signature, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
				return /* TODO(Node ConditionalExpression): left === right || !left ? left : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!) : undefined */ TODO
			})
		default:
			return nil
		}
	}
	combineIntersectionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)})
		return createSymbolWithType(left, thisType)
	}
	combineIntersectionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(Node ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(Node ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(Node ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(Node NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		for i := 0; i < longestCount; i++ {
			longestParamType := tryGetTypeAtPosition(longest, i)
			if longest == right {
				longestParamType = instantiateType(longestParamType, mapper)
			}
			shorterParamType := tryGetTypeAtPosition(shorter, i) || unknownType
			if shorter == right {
				shorterParamType = instantiateType(shorterParamType, mapper)
			}
			unionParamType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{longestParamType, shorterParamType})
			isRestParam := eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount-1)
			isOptional := i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter)
			leftName := /* TODO(Node ConditionalExpression): i >= leftCount ? undefined : getParameterNameAtPosition(left, i) */ TODO
			rightName := /* TODO(Node ConditionalExpression): i >= rightCount ? undefined : getParameterNameAtPosition(right, i) */ TODO
			paramName := /* TODO(Node ConditionalExpression): leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : undefined */ TODO
			paramSymbol := createSymbol(SymbolFlagsFunctionScopedVariable|( /* TODO(Node ConditionalExpression): isOptional && !isRestParam ? SymbolFlags.Optional : 0 */ TODO), paramName || /* TODO(Node TemplateExpression): `arg${i}` */ TODO)
			paramSymbol.links.type_ = /* TODO(Node ConditionalExpression): isRestParam ? createArrayType(unionParamType) : unionParamType */ TODO
			params[i] = paramSymbol
		}
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args")
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			params[longestCount] = restParamSymbol
		}
		return params
	}
	combineSignaturesOfIntersectionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
		}
		declaration := left.declaration
		params := combineIntersectionParameters(left, right, paramMapper)
		thisParam := combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsIntersection
		result.compositeSignatures = concatenate(left.compositeKind == TypeFlagsIntersection && left.compositeSignatures || [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{left}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{right})
		if paramMapper {
			result.mapper = /* TODO(Node ConditionalExpression): left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper */ TODO
		}
		return result
	}
	getContextualCallSignature := func(type_ Type, node SignatureDeclaration) *Signature {
		signatures := getSignaturesOfType(type_, SignatureKindCall)
		applicableByArity := filter(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
			return !isAritySmaller(s, node)
		})
		// converted from conditional expression
		switch {
		case applicableByArity.length == 1:
			return applicableByArity[0]
		default:
			return getIntersectedSignatures(applicableByArity)
		}
	}
	isAritySmaller := func(signature Signature, target SignatureDeclaration) /* TODO inferred type boolean */ any {
		targetParameterCount := 0
		for ; targetParameterCount < target.parameters.length; targetParameterCount++ {
			param := target.parameters[targetParameterCount]
			if param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param) {
				break
			}
		}
		if target.parameters.length && parameterIsThisKeyword(target.parameters[0]) {
			targetParameterCount--
		}
		return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount
	}
	getContextualSignatureForFunctionLikeDeclaration := func(node FunctionLikeDeclaration) *Signature {
		// converted from conditional expression
		switch {
		case isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node):
			return getContextualSignature(node)
		default:
			return nil
		}
	}
	getContextualSignature := func(node /* TODO(TypeNode UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		typeTagSignature := getSignatureOfTypeTag(node)
		if typeTagSignature {
			return typeTagSignature
		}
		type_ := getApparentTypeOfContextualType(node, ContextFlagsSignature)
		if !type_ {
			return nil
		}
		if !(type_.flags & TypeFlagsUnion) {
			return getContextualCallSignature(type_, node)
		}
		var signatureList *[]Signature
		types := (type_).types
		for _, current := range types {
			signature := getContextualCallSignature(current, node)
			if signature {
				if !signatureList {
					signatureList = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{signature}
				} else if !compareSignaturesIdentical(signatureList[0], signature, false, true, true, compareTypesIdentical) {
					return nil
				} else {
					signatureList.push(signature)
				}
			}
		}
		if signatureList {
			// converted from conditional expression
			switch {
			case signatureList.length == 1:
				return signatureList[0]
			default:
				return createUnionSignature(signatureList[0], signatureList)
			}
		}
	}
	checkGrammarRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO inferred type boolean */ any {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) && !node.isUnterminated {
			var lastError *DiagnosticWithLocation
			/* TODO(Node BinaryExpression): scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true) */ TODO
			scanner.setScriptTarget(sourceFile.languageVersion)
			scanner.setLanguageVariant(sourceFile.languageVariant)
			scanner.setOnError(func(message /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ any, length /* TODO inferred type number */ any, arg0 /* TODO inferred type any */ any) {
				start := scanner.getTokenEnd()
				if message.category == DiagnosticCategoryMessage && lastError && start == lastError.start && length == lastError.length {
					error := createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0)
					addRelatedInfo(lastError, error)
				} else if !lastError || start != lastError.start {
					lastError = createFileDiagnostic(sourceFile, start, length, message, arg0)
					diagnostics.add(lastError)
				}
			})
			scanner.setText(sourceFile.text, node.pos, node.end-node.pos)
			/* TODO(Node TryStatement): try { scanner.scan(); Debug.assert(scanner.reScanSlashToken(/*reportErrors* / true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral"); return !!lastError; } finally { scanner.setText(""); scanner.setOnError(/*onError* / undefined); } */
		}
		return false
	}
	checkRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsTypeChecked) {
			nodeLinks.flags |= NodeCheckFlagsTypeChecked
			addLazyDiagnostic(func() /* TODO inferred type boolean */ any {
				return checkGrammarRegularExpressionLiteral(node)
			})
		}
		return globalRegExpType
	}
	checkSpreadExpression := func(node SpreadElement, checkMode CheckMode) Type {
		if languageVersion < LanguageFeatureMinimumTargetSpreadElements {
			checkExternalEmitHelpers(node /* TODO(Node ConditionalExpression): compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray */, TODO)
		}
		arrayOrIterableType := checkExpression(node.expression, checkMode)
		return checkIteratedTypeOrElementType(IterationUseSpread, arrayOrIterableType, undefinedType, node.expression)
	}
	checkSyntheticExpression := func(node SyntheticExpression) Type {
		// converted from conditional expression
		switch {
		case node.isSpread:
			return getIndexedAccessType(node.type_, numberType)
		default:
			return node.type_
		}
	}
	hasDefaultValue := func(node /* TODO(TypeNode UnionType): BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
		return node.kind == SyntaxKindBindingElement && !!(node).initializer || node.kind == SyntaxKindPropertyAssignment && hasDefaultValue((node).initializer) || node.kind == SyntaxKindShorthandPropertyAssignment && !!(node).objectAssignmentInitializer || node.kind == SyntaxKindBinaryExpression && (node).operatorToken.kind == SyntaxKindEqualsToken
	}
	isSpreadIntoCallOrNew := func(node ArrayLiteralExpression) /* TODO inferred type boolean */ any {
		parent := walkUpParenthesizedExpressions(node.parent)
		return isSpreadElement(parent) && isCallOrNewExpression(parent.parent)
	}
	checkArrayLiteral := func(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple *bool) Type {
		elements := node.elements
		elementCount := elements.length
		var elementTypes []Type = [] /* TODO inferred type never */ any{}
		var elementFlags []ElementFlags = [] /* TODO inferred type never */ any{}
		pushCachedContextualType(node)
		inDestructuringPattern := isAssignmentTarget(node)
		inConstContext := isConstContext(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		inTupleContext := isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return isTupleLikeType(t) || isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target || t)
		})
		hasOmittedExpression := false
		for i := 0; i < elementCount; i++ {
			e := elements[i]
			if e.kind == SyntaxKindSpreadElement {
				if languageVersion < LanguageFeatureMinimumTargetSpreadElements {
					checkExternalEmitHelpers(e /* TODO(Node ConditionalExpression): compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray */, TODO)
				}
				spreadType := checkExpression((e).expression, checkMode, forceTuple)
				if isArrayLikeType(spreadType) {
					elementTypes.push(spreadType)
					elementFlags.push(ElementFlagsVariadic)
				} else if inDestructuringPattern {
					restElementType := getIndexTypeOfType(spreadType, numberType) || getIteratedTypeOrElementType(IterationUseDestructuring, spreadType, undefinedType, nil, false) || unknownType
					elementTypes.push(restElementType)
					elementFlags.push(ElementFlagsRest)
				} else {
					elementTypes.push(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType, (e).expression))
					elementFlags.push(ElementFlagsRest)
				}
			} else if exactOptionalPropertyTypes && e.kind == SyntaxKindOmittedExpression {
				hasOmittedExpression = true
				elementTypes.push(undefinedOrMissingType)
				elementFlags.push(ElementFlagsOptional)
			} else {
				type_ := checkExpressionForMutableLocation(e, checkMode, forceTuple)
				elementTypes.push(addOptionality(type_, true, hasOmittedExpression))
				elementFlags.push( /* TODO(Node ConditionalExpression): hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required */ TODO)
				if inTupleContext && checkMode && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && isContextSensitive(e) {
					inferenceContext := getInferenceContext(node)
					Debug.assert(inferenceContext)
					addIntraExpressionInferenceSite(inferenceContext, e, type_)
				}
			}
		}
		popContextualType()
		if inDestructuringPattern {
			return createTupleType(elementTypes, elementFlags)
		}
		if forceTuple || inConstContext || inTupleContext {
			return createArrayLiteralType(createTupleType(elementTypes, elementFlags, inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType))))
		}
		return createArrayLiteralType(createArrayType( /* TODO(Node ConditionalExpression): elementTypes.length ? getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) : strictNullChecks ? implicitNeverType : undefinedWideningType */ TODO, inConstContext))
	}
	createArrayLiteralType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !(getObjectFlags(type_) & ObjectFlagsReference) {
			return type_
		}
		literalType := (type_).literalType
		if !literalType {
			literalType = /* TODO(Node BinaryExpression): (type as TypeReference).literalType = cloneTypeReference(type as TypeReference) */ TODO
			literalType.objectFlags |= ObjectFlagsArrayLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		}
		return literalType
	}
	isNumericName := func(name DeclarationName) bool {
		switch name.kind {
		case SyntaxKindComputedPropertyName:
			return isNumericComputedName(name)
		case SyntaxKindIdentifier:
			return isNumericLiteralName(name.escapedText)
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			return isNumericLiteralName(name.text)
		default:
			return false
		}
	}
	isNumericComputedName := func(name ComputedPropertyName) bool {
		return isTypeAssignableToKind(checkComputedPropertyName(name), TypeFlagsNumberLike)
	}
	checkComputedPropertyName := func(node ComputedPropertyName) Type {
		links := getNodeLinks(node.expression)
		if !links.resolvedType {
			if (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind == SyntaxKindInKeyword && node.parent.kind != SyntaxKindGetAccessor && node.parent.kind != SyntaxKindSetAccessor {
				links.resolvedType = errorType
				return links.resolvedType
			}
			links.resolvedType = checkExpression(node.expression)
			if isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent) {
				container := getEnclosingBlockScopeContainer(node.parent.parent)
				enclosingIterationStatement := getEnclosingIterationStatement(container)
				if enclosingIterationStatement {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					getNodeLinks(node).flags |= NodeCheckFlagsBlockScopedBindingInLoop
					getNodeLinks(node.parent.parent).flags |= NodeCheckFlagsBlockScopedBindingInLoop
				}
			}
			if links.resolvedType.flags&TypeFlagsNullable || !isTypeAssignableToKind(links.resolvedType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType) {
				error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any)
			}
		}
		return links.resolvedType
	}
	isSymbolWithNumericName := func(symbol Symbol) /* TODO inferred type boolean | undefined */ any {
		firstDecl := symbol.declarations[0]
		return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name))
	}
	isSymbolWithSymbolName := func(symbol Symbol) /* TODO inferred type boolean | undefined */ any {
		firstDecl := symbol.declarations[0]
		return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) && isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlagsESSymbol))
	}
	getObjectLiteralIndexInfo := func(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
		var propTypes []Type = [] /* TODO inferred type never */ any{}
		for i := offset; i < properties.length; i++ {
			prop := properties[i]
			if keyType == stringType && !isSymbolWithSymbolName(prop) || keyType == numberType && isSymbolWithNumericName(prop) || keyType == esSymbolType && isSymbolWithSymbolName(prop) {
				propTypes.push(getTypeOfSymbol(properties[i]))
			}
		}
		unionType := /* TODO(Node ConditionalExpression): propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType */ TODO
		return createIndexInfo(keyType, unionType, isConstContext(node))
	}
	getImmediateAliasedSymbol := func(symbol Symbol) *Symbol {
		Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.immediateTarget {
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			links.immediateTarget = getTargetOfAliasDeclaration(node, true)
		}
		return links.immediateTarget
	}
	checkObjectLiteral := func(node ObjectLiteralExpression, checkMode CheckMode /*  = CheckMode.Normal */) Type {
		inDestructuringPattern := isAssignmentTarget(node)
		checkGrammarObjectLiteralExpression(node, inDestructuringPattern)
		allPropertiesTable := /* TODO(Node ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		propertiesTable := createSymbolTable()
		var propertiesArray []Symbol = [] /* TODO inferred type never */ any{}
		var spread Type = emptyObjectType
		pushCachedContextualType(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		contextualTypeHasPattern := contextualType && contextualType.pattern && (contextualType.pattern.kind == SyntaxKindObjectBindingPattern || contextualType.pattern.kind == SyntaxKindObjectLiteralExpression)
		inConstContext := isConstContext(node)
		checkFlags := /* TODO(Node ConditionalExpression): inConstContext ? CheckFlags.Readonly : 0 */ TODO
		isInJavascript := isInJSFile(node) && !isInJsonFile(node)
		enumTag := /* TODO(Node ConditionalExpression): isInJavascript ? getJSDocEnumTag(node) : undefined */ TODO
		isJSObjectLiteral := !contextualType && isInJavascript && !enumTag
		var objectFlags ObjectFlags = ObjectFlagsFreshLiteral
		patternWithComputedProperties := false
		hasComputedStringProperty := false
		hasComputedNumberProperty := false
		hasComputedSymbolProperty := false
		for _, elem := range node.properties {
			if elem.name && isComputedPropertyName(elem.name) {
				checkComputedPropertyName(elem.name)
			}
		}
		offset := 0
		for _, memberDecl := range node.properties {
			member := getSymbolOfDeclaration(memberDecl)
			computedNameType := /* TODO(Node ConditionalExpression): memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ? checkComputedPropertyName(memberDecl.name) : undefined */ TODO
			if memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindShorthandPropertyAssignment || isObjectLiteralMethod(memberDecl) {
				type_ := /* TODO(Node ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) : // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`. // we don't want to say "could not find 'a'". memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) : checkObjectLiteralMethod(memberDecl, checkMode) */ TODO
				if isInJavascript {
					jsDocType := getTypeForDeclarationFromJSDocComment(memberDecl)
					if jsDocType {
						checkTypeAssignableTo(type_, jsDocType, memberDecl)
						type_ = jsDocType
					} else if enumTag && enumTag.typeExpression {
						checkTypeAssignableTo(type_, getTypeFromTypeNode(enumTag.typeExpression), memberDecl)
					}
				}
				objectFlags |= getObjectFlags(type_) & ObjectFlagsPropagatingFlags
				nameType := /* TODO(Node ConditionalExpression): computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined */ TODO
				prop := /* TODO(Node ConditionalExpression): nameType ? createSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late) : createSymbol(SymbolFlags.Property | member.flags, member.escapedName, checkFlags) */ TODO
				if nameType {
					prop.links.nameType = nameType
				}
				if inDestructuringPattern && hasDefaultValue(memberDecl) {
					prop.flags |= SymbolFlagsOptional
				} else if contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlagsObjectLiteralPatternWithComputedProperties) {
					impliedProp := getPropertyOfType(contextualType, member.escapedName)
					if impliedProp {
						prop.flags |= impliedProp.flags & SymbolFlagsOptional
					} else if !getIndexInfoOfType(contextualType, stringType) {
						error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType))
					}
				}
				prop.declarations = member.declarations
				prop.parent = member.parent
				if member.valueDeclaration {
					prop.valueDeclaration = member.valueDeclaration
				}
				prop.links.type_ = type_
				prop.links.target = member
				member = prop
				allPropertiesTable. /*?*/ set(prop.escapedName, prop)
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && (memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindMethodDeclaration) && isContextSensitive(memberDecl) {
					inferenceContext := getInferenceContext(node)
					Debug.assert(inferenceContext)
					inferenceNode := /* TODO(Node ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl */ TODO
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type_)
				}
			} else if memberDecl.kind == SyntaxKindSpreadAssignment {
				if languageVersion < LanguageFeatureMinimumTargetObjectAssign {
					checkExternalEmitHelpers(memberDecl, ExternalEmitHelpersAssign)
				}
				if propertiesArray.length > 0 {
					spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
					propertiesArray = [] /* TODO inferred type never */ any{}
					propertiesTable = createSymbolTable()
					hasComputedStringProperty = false
					hasComputedNumberProperty = false
					hasComputedSymbolProperty = false
				}
				type_ := getReducedType(checkExpression(memberDecl.expression, checkMode&CheckModeInferential))
				if isValidSpreadType(type_) {
					mergedType := tryMergeUnionOfObjectTypeAndEmptyObject(type_, inConstContext)
					if allPropertiesTable {
						checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl)
					}
					offset = propertiesArray.length
					if isErrorType(spread) {
						continue
					}
					spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext)
				} else {
					error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					spread = errorType
				}
				continue
			} else {
				Debug.assert(memberDecl.kind == SyntaxKindGetAccessor || memberDecl.kind == SyntaxKindSetAccessor)
				checkNodeDeferred(memberDecl)
			}
			if computedNameType && !(computedNameType.flags & TypeFlagsStringOrNumberLiteralOrUnique) {
				if isTypeAssignableTo(computedNameType, stringNumberSymbolType) {
					if isTypeAssignableTo(computedNameType, numberType) {
						hasComputedNumberProperty = true
					} else if isTypeAssignableTo(computedNameType, esSymbolType) {
						hasComputedSymbolProperty = true
					} else {
						hasComputedStringProperty = true
					}
					if inDestructuringPattern {
						patternWithComputedProperties = true
					}
				}
			} else {
				propertiesTable.set(member.escapedName, member)
			}
			propertiesArray.push(member)
		}
		popContextualType()
		if isErrorType(spread) {
			return errorType
		}
		if spread != emptyObjectType {
			if propertiesArray.length > 0 {
				spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
				propertiesArray = [] /* TODO inferred type never */ any{}
				propertiesTable = createSymbolTable()
				hasComputedStringProperty = false
				hasComputedNumberProperty = false
			}
			return mapType(spread, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
				return /* TODO(Node ConditionalExpression): t === emptyObjectType ? createObjectLiteralType() : t */ TODO
			})
		}
		return createObjectLiteralType()
		createObjectLiteralType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ any {
			indexInfos := [] /* TODO inferred type never */ any{}
			if hasComputedStringProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType))
			}
			if hasComputedNumberProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType))
			}
			if hasComputedSymbolProperty {
				indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType))
			}
			result := createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			if isJSObjectLiteral {
				result.objectFlags |= ObjectFlagsJSLiteral
			}
			if patternWithComputedProperties {
				result.objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
			}
			if inDestructuringPattern {
				result.pattern = node
			}
			return result
		}
	}
	isValidSpreadType := func(type_ Type) bool {
		t := removeDefinitelyFalsyTypes(mapType(type_, getBaseConstraintOrType))
		return !!(t.flags&(TypeFlagsAny|TypeFlagsNonPrimitive|TypeFlagsObject|TypeFlagsInstantiableNonPrimitive) || t.flags&TypeFlagsUnionOrIntersection && every((t).types, isValidSpreadType))
	}
	checkJsxSelfClosingElementDeferred := func(node JsxSelfClosingElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node)
	}
	checkJsxSelfClosingElement := func(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxElementDeferred := func(node JsxElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement)
		if isJsxIntrinsicTagName(node.closingElement.tagName) {
			getIntrinsicTagSymbol(node.closingElement)
		} else {
			checkExpression(node.closingElement.tagName)
		}
		checkJsxChildren(node)
	}
	checkJsxElement := func(node JsxElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxFragment := func(node JsxFragment) Type {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment)
		nodeSourceFile := getSourceFileOfNode(node)
		if getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag") {
			error(node /* TODO(Node ConditionalExpression): compilerOptions.jsxFactory ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments */, TODO)
		}
		checkJsxChildren(node)
		return getJsxElementTypeAt(node) || anyType
	}
	isHyphenatedJsxName := func(name /* TODO(TypeNode UnionType): string | __String */ any) /* TODO inferred type boolean */ any {
		return (name).includes("-")
	}
	isJsxIntrinsicTagName := func(tagName Node) /* TODO(TypeNode TypePredicate): tagName is Identifier | JsxNamespacedName */ any {
		return isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName)
	}
	checkJsxAttribute := func(node JsxAttribute, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case node.initializer:
			return checkExpressionForMutableLocation(node.initializer, checkMode)
		default:
			return trueType
		}
	}
	createJsxAttributesTypeFromAttributesProperty := func(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /*  = CheckMode.Normal */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		attributes := openingLikeElement.attributes
		contextualType := getContextualType(attributes, ContextFlagsNone)
		allAttributesTable := /* TODO(Node ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		attributesTable := createSymbolTable()
		var spread Type = emptyJsxObjectType
		hasSpreadAnyType := false
		var typeToIntersect *Type
		explicitlySpecifyChildrenAttribute := false
		var objectFlags ObjectFlags = ObjectFlagsJsxAttributes
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement))
		for _, attributeDecl := range attributes.properties {
			member := attributeDecl.symbol
			if isJsxAttribute(attributeDecl) {
				exprType := checkJsxAttribute(attributeDecl, checkMode)
				objectFlags |= getObjectFlags(exprType) & ObjectFlagsPropagatingFlags
				attributeSymbol := createSymbol(SymbolFlagsProperty|member.flags, member.escapedName)
				attributeSymbol.declarations = member.declarations
				attributeSymbol.parent = member.parent
				if member.valueDeclaration {
					attributeSymbol.valueDeclaration = member.valueDeclaration
				}
				attributeSymbol.links.type_ = exprType
				attributeSymbol.links.target = member
				attributesTable.set(attributeSymbol.escapedName, attributeSymbol)
				allAttributesTable. /*?*/ set(attributeSymbol.escapedName, attributeSymbol)
				if getEscapedTextOfJsxAttributeName(attributeDecl.name) == jsxChildrenPropertyName {
					explicitlySpecifyChildrenAttribute = true
				}
				if contextualType {
					prop := getPropertyOfType(contextualType, member.escapedName)
					if prop && prop.declarations && isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name) {
						addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText)
					}
				}
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && isContextSensitive(attributeDecl) {
					inferenceContext := getInferenceContext(attributes)
					Debug.assert(inferenceContext)
					inferenceNode := (attributeDecl.initializer).expression
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType)
				}
			} else {
				Debug.assert(attributeDecl.kind == SyntaxKindJsxSpreadAttribute)
				if attributesTable.size > 0 {
					spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false)
					attributesTable = createSymbolTable()
				}
				exprType := getReducedType(checkExpression(attributeDecl.expression, checkMode&CheckModeInferential))
				if isTypeAny(exprType) {
					hasSpreadAnyType = true
				}
				if isValidSpreadType(exprType) {
					spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, false)
					if allAttributesTable {
						checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl)
					}
				} else {
					error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					typeToIntersect = /* TODO(Node ConditionalExpression): typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType */ TODO
				}
			}
		}
		if !hasSpreadAnyType {
			if attributesTable.size > 0 {
				spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false)
			}
		}
		parent := /* TODO(Node ConditionalExpression): openingLikeElement.parent.kind === SyntaxKind.JsxElement ? openingLikeElement.parent as JsxElement : undefined */ TODO
		if parent && parent.openingElement == openingLikeElement && getSemanticJsxChildren(parent.children).length > 0 {
			var childrenTypes []Type = checkJsxChildren(parent, checkMode)
			if !hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName != "" {
				if explicitlySpecifyChildrenAttribute {
					error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName))
				}
				contextualType := getApparentTypeOfContextualType(openingLikeElement.attributes, nil)
				childrenContextualType := contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName)
				childrenPropSymbol := createSymbol(SymbolFlagsProperty, jsxChildrenPropertyName)
				childrenPropSymbol.links.type_ = /* TODO(Node ConditionalExpression): childrenTypes.length === 1 ? childrenTypes[0] : childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) : createArrayType(getUnionType(childrenTypes)) */ TODO
				childrenPropSymbol.valueDeclaration = factory.createPropertySignature(nil, unescapeLeadingUnderscores(jsxChildrenPropertyName), nil, nil)
				setParent(childrenPropSymbol.valueDeclaration, attributes)
				childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol
				childPropMap := createSymbolTable()
				childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol)
				spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags, false)
			}
		}
		if hasSpreadAnyType {
			return anyType
		}
		if typeToIntersect && spread != emptyJsxObjectType {
			return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{typeToIntersect, spread})
		}
		return typeToIntersect || ( /* TODO(Node ConditionalExpression): spread === emptyJsxObjectType ? createJsxAttributesType() : spread */ TODO)
		createJsxAttributesType := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ any {
			objectFlags |= ObjectFlagsFreshLiteral
			result := createAnonymousType(attributes.symbol, attributesTable, emptyArray, emptyArray, emptyArray)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return result
		}
	}
	checkJsxChildren := func(node /* TODO(TypeNode UnionType): JsxElement | JsxFragment */ any, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ any {
		var childrenTypes []Type = [] /* TODO inferred type never */ any{}
		for _, child := range node.children {
			if child.kind == SyntaxKindJsxText {
				if !child.containsOnlyTriviaWhiteSpaces {
					childrenTypes.push(stringType)
				}
			} else if child.kind == SyntaxKindJsxExpression && !child.expression {
				continue
			} else {
				childrenTypes.push(checkExpressionForMutableLocation(child, checkMode))
			}
		}
		return childrenTypes
	}
	checkSpreadPropOverrides := func(type_ Type, props SymbolTable, spread /* TODO(TypeNode UnionType): SpreadAssignment | JsxSpreadAttribute */ any) {
		for _, right := range getPropertiesOfType(type_) {
			if !(right.flags & SymbolFlagsOptional) {
				left := props.get(right.escapedName)
				if left {
					diagnostic := error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName))
					addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property))
				}
			}
		}
	}
	checkJsxAttributes := func(node JsxAttributes, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode)
	}
	getJsxType := func(name __String, location Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		namespace := getJsxNamespaceAt(location)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, name, SymbolFlagsType)
		// converted from conditional expression
		switch {
		case typeSymbol:
			return getDeclaredTypeOfSymbol(typeSymbol)
		default:
			return errorType
		}
	}
	getIntrinsicTagSymbol := func(node /* TODO(TypeNode UnionType): JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, node)
			if !isErrorType(intrinsicElementsType) {
				if !isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName) {
					return Debug.fail()
				}
				propName := /* TODO(Node ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				intrinsicProp := getPropertyOfType(intrinsicElementsType, propName)
				if intrinsicProp {
					links.jsxFlags |= JsxFlagsIntrinsicNamedElement
					links.resolvedSymbol = intrinsicProp
					return links.resolvedSymbol
				}
				indexSymbol := getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)))
				if indexSymbol {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					links.resolvedSymbol = indexSymbol
					return links.resolvedSymbol
				}
				if getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					links.resolvedSymbol = intrinsicElementsType.symbol
					return links.resolvedSymbol
				}
				error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName), "JSX."+JsxNames.IntrinsicElements)
				links.resolvedSymbol = unknownSymbol
				return links.resolvedSymbol
			} else {
				if noImplicitAny {
					error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements))
				}
				links.resolvedSymbol = unknownSymbol
				return links.resolvedSymbol
			}
		}
		return links.resolvedSymbol
	}
	getJsxNamespaceContainerForImplicitImport := func(location Node) *Symbol {
		file := location && getSourceFileOfNode(location)
		links := file && getNodeLinks(file)
		if links && links.jsxImplicitImportContainer == false {
			return nil
		}
		if links && links.jsxImplicitImportContainer {
			return links.jsxImplicitImportContainer
		}
		runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions)
		if !runtimeImportSpecifier {
			return nil
		}
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		errorMessage := /* TODO(Node ConditionalExpression): isClassic ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		specifier := getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
		mod := resolveExternalModule(specifier || location, runtimeImportSpecifier, errorMessage, location)
		result := /* TODO(Node ConditionalExpression): mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined */ TODO
		if links {
			links.jsxImplicitImportContainer = result || false
		}
		return result
	}
	getJsxNamespaceAt := func(location Node) Symbol {
		links := location && getNodeLinks(location)
		if links && links.jsxNamespace {
			return links.jsxNamespace
		}
		if !links || links.jsxNamespace != false {
			resolvedNamespace := getJsxNamespaceContainerForImplicitImport(location)
			if !resolvedNamespace || resolvedNamespace == unknownSymbol {
				namespaceName := getJsxNamespace(location)
				resolvedNamespace = resolveName(location, namespaceName, SymbolFlagsNamespace, nil, false)
			}
			if resolvedNamespace {
				candidate := resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, SymbolFlagsNamespace))
				if candidate && candidate != unknownSymbol {
					if links {
						links.jsxNamespace = candidate
					}
					return candidate
				}
			}
			if links {
				links.jsxNamespace = false
			}
		}
		s := resolveSymbol(getGlobalSymbol(JsxNames.JSX, SymbolFlagsNamespace, nil))
		if s == unknownSymbol {
			return nil
		}
		return s
	}
	getNameFromJsxElementAttributesContainer := func(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
		jsxElementAttribPropInterfaceSym := jsxNamespace && getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, SymbolFlagsType)
		jsxElementAttribPropInterfaceType := jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym)
		propertiesOfJsxElementAttribPropInterface := jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType)
		if propertiesOfJsxElementAttribPropInterface {
			if propertiesOfJsxElementAttribPropInterface.length == 0 {
				return ""
			} else if propertiesOfJsxElementAttribPropInterface.length == 1 {
				return propertiesOfJsxElementAttribPropInterface[0].escapedName
			} else if propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations {
				error(jsxElementAttribPropInterfaceSym.declarations[0], Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer))
			}
		}
		return nil
	}
	getJsxLibraryManagedAttributes := func(jsxNamespace Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.LibraryManagedAttributes, SymbolFlagsType)
	}
	getJsxElementTypeSymbol := func(jsxNamespace Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		return jsxNamespace && getSymbol(jsxNamespace.exports, JsxNames.ElementType, SymbolFlagsType)
	}
	getJsxElementPropertiesName := func(jsxNamespace Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace)
	}
	getJsxElementChildrenPropertyName := func(jsxNamespace Symbol) *__String {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace)
	}
	getUninstantiatedJsxSignaturesOfType := func(elementType Type, caller JsxOpeningLikeElement) []Signature {
		if elementType.flags & TypeFlagsString {
			return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{anySignature}
		} else if elementType.flags & TypeFlagsStringLiteral {
			intrinsicType := getIntrinsicAttributesTypeFromStringLiteralType(elementType, caller)
			if !intrinsicType {
				error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType).value, "JSX."+JsxNames.IntrinsicElements)
				return emptyArray
			} else {
				fakeSignature := createSignatureForJSXIntrinsic(caller, intrinsicType)
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{fakeSignature}
			}
		}
		apparentElemType := getApparentType(elementType)
		signatures := getSignaturesOfType(apparentElemType, SignatureKindConstruct)
		if signatures.length == 0 {
			signatures = getSignaturesOfType(apparentElemType, SignatureKindCall)
		}
		if signatures.length == 0 && apparentElemType.flags&TypeFlagsUnion {
			signatures = getUnionSignatures(map_((apparentElemType).types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ any {
				return getUninstantiatedJsxSignaturesOfType(t, caller)
			}))
		}
		return signatures
	}
	getIntrinsicAttributesTypeFromStringLiteralType := func(type_ StringLiteralType, location Node) *Type {
		intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, location)
		if !isErrorType(intrinsicElementsType) {
			stringLiteralTypeName := type_.value
			intrinsicProp := getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
			if intrinsicProp {
				return getTypeOfSymbol(intrinsicProp)
			}
			indexSignatureType := getIndexTypeOfType(intrinsicElementsType, stringType)
			if indexSignatureType {
				return indexSignatureType
			}
			return nil
		}
		return anyType
	}
	checkJsxReturnAssignableToAppropriateBound := func(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
		if refKind == JsxReferenceKindFunction {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			if sfcReturnConstraint {
				checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else if refKind == JsxReferenceKindComponent {
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if classConstraint {
				checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if !sfcReturnConstraint || !classConstraint {
				return
			}
			combined := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{sfcReturnConstraint, classConstraint})
			checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
		}
		generateInitialErrorChain := func() DiagnosticMessageChain {
			componentName := getTextOfNode(openingLikeElement.tagName)
			return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
		}
	}
	getIntrinsicAttributesTypeFromJsxOpeningLikeElement := func(node JsxOpeningLikeElement) Type {
		Debug.assert(isJsxIntrinsicTagName(node.tagName))
		links := getNodeLinks(node)
		if !links.resolvedJsxElementAttributesType {
			symbol := getIntrinsicTagSymbol(node)
			if links.jsxFlags & JsxFlagsIntrinsicNamedElement {
				links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType
				return links.resolvedJsxElementAttributesType
			} else if links.jsxFlags & JsxFlagsIntrinsicIndexedElement {
				propName := /* TODO(Node ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName). /*?*/ type_ || errorType
				return links.resolvedJsxElementAttributesType
			} else {
				links.resolvedJsxElementAttributesType = errorType
				return links.resolvedJsxElementAttributesType
			}
		}
		return links.resolvedJsxElementAttributesType
	}
	getJsxElementClassTypeAt := func(location Node) *Type {
		type_ := getJsxType(JsxNames.ElementClass, location)
		if isErrorType(type_) {
			return nil
		}
		return type_
	}
	getJsxElementTypeAt := func(location Node) Type {
		return getJsxType(JsxNames.Element, location)
	}
	getJsxStatelessElementTypeAt := func(location Node) *Type {
		jsxElementType := getJsxElementTypeAt(location)
		if jsxElementType {
			return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{jsxElementType, nullType})
		}
	}
	getJsxElementTypeTypeAt := func(location Node) *Type {
		ns := getJsxNamespaceAt(location)
		if !ns {
			return nil
		}
		sym := getJsxElementTypeSymbol(ns)
		if !sym {
			return nil
		}
		type_ := instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
		if !type_ || isErrorType(type_) {
			return nil
		}
		return type_
	}
	instantiateAliasOrInterfaceWithDefaults := func(managedSym Symbol, inJs bool, typeArguments []Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		declaredManagedType := getDeclaredTypeOfSymbol(managedSym)
		if managedSym.flags & SymbolFlagsTypeAlias {
			params := getSymbolLinks(managedSym).typeParameters
			if length(params) >= typeArguments.length {
				args := fillMissingTypeArguments(typeArguments, params, typeArguments.length, inJs)
				// converted from conditional expression
				switch {
				case length(args) == 0:
					return declaredManagedType
				default:
					return getTypeAliasInstantiation(managedSym, args)
				}
			}
		}
		if length((declaredManagedType).typeParameters) >= typeArguments.length {
			args := fillMissingTypeArguments(typeArguments, (declaredManagedType).typeParameters, typeArguments.length, inJs)
			return createTypeReference(declaredManagedType, args)
		}
		return nil
	}
	getJsxIntrinsicTagNamesAt := func(location Node) []Symbol {
		intrinsics := getJsxType(JsxNames.IntrinsicElements, location)
		// converted from conditional expression
		switch {
		case intrinsics:
			return getPropertiesOfType(intrinsics)
		default:
			return emptyArray
		}
	}
	checkJsxPreconditions := func(errorNode Node) {
		if (compilerOptions.jsx || JsxEmitNone) == JsxEmitNone {
			error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided)
		}
		if getJsxElementTypeAt(errorNode) == nil {
			if noImplicitAny {
				error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist)
			}
		}
	}
	checkJsxOpeningLikeElementOrOpeningFragment := func(node /* TODO(TypeNode UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)
		if isNodeOpeningLikeElement {
			checkGrammarJsxElement(node)
		}
		checkJsxPreconditions(node)
		markJsxAliasReferenced(node)
		if isNodeOpeningLikeElement {
			jsxOpeningLikeNode := node
			sig := getResolvedSignature(jsxOpeningLikeNode)
			checkDeprecatedSignature(sig, node)
			elementTypeConstraint := getJsxElementTypeTypeAt(jsxOpeningLikeNode)
			if elementTypeConstraint != nil {
				tagName := jsxOpeningLikeNode.tagName
				tagType := /* TODO(Node ConditionalExpression): isJsxIntrinsicTagName(tagName) ? getStringLiteralType(intrinsicTagNameToString(tagName)) : checkExpression(tagName) */ TODO
				checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ any {
					componentName := getTextOfNode(tagName)
					return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
				})
			} else {
				checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode)
			}
		}
	}
	isKnownProperty := func(targetType Type, name __String, isComparingJsxAttributes bool) bool {
		if targetType.flags & TypeFlagsObject {
			if getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(targetType, name) || isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) || isComparingJsxAttributes && isHyphenatedJsxName(name) {
				return true
			}
		}
		if targetType.flags & TypeFlagsSubstitution {
			return isKnownProperty((targetType).baseType, name, isComparingJsxAttributes)
		}
		if targetType.flags&TypeFlagsUnionOrIntersection && isExcessPropertyCheckTarget(targetType) {
			for _, t := range (targetType).types {
				if isKnownProperty(t, name, isComparingJsxAttributes) {
					return true
				}
			}
		}
		return false
	}
	isExcessPropertyCheckTarget := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsObject && !(getObjectFlags(type_)&ObjectFlagsObjectLiteralPatternWithComputedProperties) || type_.flags&TypeFlagsNonPrimitive || type_.flags&TypeFlagsSubstitution && isExcessPropertyCheckTarget((type_).baseType) || type_.flags&TypeFlagsUnion && some((type_).types, isExcessPropertyCheckTarget) || type_.flags&TypeFlagsIntersection && every((type_).types, isExcessPropertyCheckTarget))
	}
	checkJsxExpression := func(node JsxExpression, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		checkGrammarJsxExpression(node)
		if node.expression {
			type_ := checkExpression(node.expression, checkMode)
			if node.dotDotDotToken && type_ != anyType && !isArrayType(type_) {
				error(node, Diagnostics.JSX_spread_child_must_be_an_array_type)
			}
			return type_
		} else {
			return errorType
		}
	}
	getDeclarationNodeFlagsFromSymbol := func(s Symbol) NodeFlags {
		// converted from conditional expression
		switch {
		case s.valueDeclaration:
			return getCombinedNodeFlagsCached(s.valueDeclaration)
		default:
			return 0
		}
	}
	isPrototypeProperty := func(symbol Symbol) /* TODO inferred type boolean | undefined */ any {
		if symbol.flags&SymbolFlagsMethod || getCheckFlags(symbol)&CheckFlagsSyntheticMethod {
			return true
		}
		if isInJSFile(symbol.valueDeclaration) {
			parent := symbol.valueDeclaration.parent
			return parent && isBinaryExpression(parent) && getAssignmentDeclarationKind(parent) == AssignmentDeclarationKindPrototypeProperty
		}
	}
	checkPropertyAccessibility := func(node /* TODO(TypeNode UnionType): PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError /* TODO inferred type boolean */ any /*  = true */) bool {
		errorNode := /* TODO(Node ConditionalExpression): !reportError ? undefined : node.kind === SyntaxKind.QualifiedName ? node.right : node.kind === SyntaxKind.ImportType ? node : node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name */ TODO
		return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
	}
	checkPropertyAccessibilityAtLocation := func(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
		flags := getDeclarationModifierFlagsFromSymbol(prop, writing)
		if isSuper {
			if languageVersion < ScriptTargetES2015 {
				if symbolHasNonMethodDeclaration(prop) {
					if errorNode {
						error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword)
					}
					return false
				}
			}
			if flags & ModifierFlagsAbstract {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)))
				}
				return false
			}
			if !(flags & ModifierFlagsStatic) && prop.declarations. /*?*/ some(isClassInstanceProperty) {
				if errorNode {
					error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop))
				}
				return false
			}
		}
		if (flags & ModifierFlagsAbstract) && symbolHasNonMethodDeclaration(prop) && (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop))
			if declaringClassDeclaration && isNodeUsedDuringClassInitialization(location) {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name))
				}
				return false
			}
		}
		if !(flags & ModifierFlagsNonPublicAccessibilityModifier) {
			return true
		}
		if flags & ModifierFlagsPrivate {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop))
			if !isNodeWithinClass(location, declaringClassDeclaration) {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)))
				}
				return false
			}
			return true
		}
		if isSuper {
			return true
		}
		enclosingClass := forEachEnclosingClass(location, func(enclosingDeclaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ any {
			enclosingClass := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration))
			return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
		})
		if !enclosingClass {
			enclosingClass = getEnclosingClassFromThisParameter(location)
			enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
			if flags&ModifierFlagsStatic || !enclosingClass {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType))
				}
				return false
			}
		}
		if flags & ModifierFlagsStatic {
			return true
		}
		if containingType.flags & TypeFlagsTypeParameter {
			containingType = /* TODO(Node ConditionalExpression): (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)! */ TODO
		}
		if !containingType || !hasBaseType(containingType, enclosingClass) {
			if errorNode {
				error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType))
			}
			return false
		}
		return true
	}
	getEnclosingClassFromThisParameter := func(node Node) *InterfaceType {
		thisParameter := getThisParameterFromNodeContext(node)
		thisType := thisParameter. /*?*/ type_ && getTypeFromTypeNode(thisParameter.type_)
		if thisType {
			if thisType.flags & TypeFlagsTypeParameter {
				thisType = getConstraintOfTypeParameter(thisType)
			}
		} else {
			thisContainer := getThisContainer(node, false, false)
			if isFunctionLike(thisContainer) {
				thisType = getContextualThisParameterType(thisContainer)
			}
		}
		if thisType && getObjectFlags(thisType)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) {
			return getTargetType(thisType)
		}
		return nil
	}
	getThisParameterFromNodeContext := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ any {
		thisContainer := getThisContainer(node, false, false)
		// converted from conditional expression
		switch {
		case thisContainer && isFunctionLike(thisContainer):
			return getThisParameter(thisContainer)
		default:
			return nil
		}
	}
	symbolHasNonMethodDeclaration := func(symbol Symbol) /* TODO inferred type boolean */ any {
		return !!forEachProperty(symbol, func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
			return !(prop.flags & SymbolFlagsMethod)
		})
	}
	checkNonNullExpression := func(node /* TODO(TypeNode UnionType): Expression | QualifiedName */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return checkNonNullType(checkExpression(node), node)
	}
	isNullableType := func(type_ Type) /* TODO inferred type boolean */ any {
		return hasTypeFacts(type_, TypeFactsIsUndefinedOrNull)
	}
	getNonNullableTypeIfNeeded := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case isNullableType(type_):
			return getNonNullableType(type_)
		default:
			return type_
		}
	}
	reportObjectPossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		nodeText := /* TODO(Node ConditionalExpression): isEntityNameExpression(node) ? entityNameToString(node) : undefined */ TODO
		if node.kind == SyntaxKindNullKeyword {
			error(node, Diagnostics.The_value_0_cannot_be_used_here, "null")
			return
		}
		if nodeText != nil && nodeText.length < 100 {
			if isIdentifier(node) && nodeText == "undefined" {
				error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined")
				return
			}
			error(node /* TODO(Node ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ? Diagnostics._0_is_possibly_null_or_undefined : Diagnostics._0_is_possibly_undefined : Diagnostics._0_is_possibly_null */, TODO, nodeText)
		} else {
			error(node /* TODO(Node ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ? Diagnostics.Object_is_possibly_null_or_undefined : Diagnostics.Object_is_possibly_undefined : Diagnostics.Object_is_possibly_null */, TODO)
		}
	}
	reportCannotInvokePossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		error(node /* TODO(Node ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ? Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined : Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined : Diagnostics.Cannot_invoke_an_object_which_is_possibly_null */, TODO)
	}
	checkNonNullTypeWithReporter := func(type_ Type, node Node, reportError func(node Node, facts TypeFacts)) Type {
		if strictNullChecks && type_.flags&TypeFlagsUnknown {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_of_type_unknown, nodeText)
					return errorType
				}
			}
			error(node, Diagnostics.Object_is_of_type_unknown)
			return errorType
		}
		facts := getTypeFacts(type_, TypeFactsIsUndefinedOrNull)
		if facts & TypeFactsIsUndefinedOrNull {
			reportError(node, facts)
			t := getNonNullableType(type_)
			// converted from conditional expression
			switch {
			case t.flags & (TypeFlagsNullable | TypeFlagsNever):
				return errorType
			default:
				return t
			}
		}
		return type_
	}
	checkNonNullType := func(type_ Type, node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return checkNonNullTypeWithReporter(type_, node, reportObjectPossiblyNullOrUndefinedError)
	}
	checkNonNullNonVoidType := func(type_ Type, node Node) Type {
		nonNullType := checkNonNullType(type_, node)
		if nonNullType.flags & TypeFlagsVoid {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if isIdentifier(node) && nodeText == "undefined" {
					error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText)
					return nonNullType
				}
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_possibly_undefined, nodeText)
					return nonNullType
				}
			}
			error(node, Diagnostics.Object_is_possibly_undefined)
		}
		return nonNullType
	}
	checkPropertyAccessExpression := func(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case node.flags & NodeFlagsOptionalChain:
			return checkPropertyAccessChain(node, checkMode)
		default:
			return checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly)
		}
	}
	checkPropertyAccessChain := func(node PropertyAccessChain, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType != leftType)
	}
	checkQualifiedName := func(node QualifiedName, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		leftType := /* TODO(Node ConditionalExpression): isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left) */ TODO
		return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode)
	}
	isMethodAccessForCall := func(node Node) /* TODO inferred type boolean */ any {
		for node.parent.kind == SyntaxKindParenthesizedExpression {
			node = node.parent
		}
		return isCallOrNewExpression(node.parent) && node.parent.expression == node
	}
	lookupSymbolForPrivateIdentifierDeclaration := func(propName __String, location Node) *Symbol {
		for containingClass := getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass) {
			TODO_IDENTIFIER := containingClass
			name := getSymbolNameForPrivateIdentifier(symbol, propName)
			prop := (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name))
			if prop {
				return prop
			}
		}
	}
	checkGrammarPrivateIdentifierExpression := func(privId PrivateIdentifier) bool {
		if !getContainingClass(privId) {
			return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		if !isForInStatement(privId.parent) {
			if !isExpressionNode(privId) {
				return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression)
			}
			isInOperation := isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind == SyntaxKindInKeyword
			if !getSymbolForPrivateIdentifierExpression(privId) && !isInOperation {
				return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId))
			}
		}
		return false
	}
	checkPrivateIdentifierExpression := func(privId PrivateIdentifier) Type {
		checkGrammarPrivateIdentifierExpression(privId)
		symbol := getSymbolForPrivateIdentifierExpression(privId)
		if symbol {
			markPropertyAsReferenced(symbol, nil, false)
		}
		return anyType
	}
	getSymbolForPrivateIdentifierExpression := func(privId PrivateIdentifier) *Symbol {
		if !isExpressionNode(privId) {
			return nil
		}
		links := getNodeLinks(privId)
		if links.resolvedSymbol == nil {
			links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId)
		}
		return links.resolvedSymbol
	}
	getPrivateIdentifierPropertyOfType := func(leftType Type, lexicallyScopedIdentifier Symbol) *Symbol {
		return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName)
	}
	checkPrivateIdentifierPropertyAccess := func(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier *Symbol) bool {
		var propertyOnType *Symbol
		properties := getPropertiesOfType(leftType)
		if properties {
			forEach(properties, func(symbol Symbol) /* TODO inferred type true | undefined */ any {
				decl := symbol.valueDeclaration
				if decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText == right.escapedText {
					propertyOnType = symbol
					return true
				}
			})
		}
		diagName := diagnosticName(right)
		if propertyOnType {
			typeValueDecl := Debug.checkDefined(propertyOnType.valueDeclaration)
			typeClass := Debug.checkDefined(getContainingClass(typeValueDecl))
			if lexicallyScopedIdentifier. /*?*/ valueDeclaration {
				lexicalValueDecl := lexicallyScopedIdentifier.valueDeclaration
				lexicalClass := getContainingClass(lexicalValueDecl)
				Debug.assert(!!lexicalClass)
				if findAncestor(lexicalClass, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
					return typeClass == n
				}) {
					diagnostic := error(right, Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, typeToString(leftType))
					addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl, Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), createDiagnosticForNode(typeValueDecl, Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName))
					return true
				}
			}
			error(right, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass.name || anon))
			return true
		}
		return false
	}
	isThisPropertyAccessInConstructor := func(node /* TODO(TypeNode UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) /* TODO inferred type boolean | undefined */ any {
		return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop)) && getThisContainer(node, true, false) == getDeclaringConstructor(prop)
	}
	checkPropertyAccessExpressionOrQualifiedName := func(node /* TODO(TypeNode UnionType): PropertyAccessExpression | QualifiedName */ any, left /* TODO(TypeNode UnionType): Expression | QualifiedName */ any, leftType Type, right /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		parentSymbol := getNodeLinks(left).resolvedSymbol
		assignmentKind := getAssignmentTargetKind(node)
		apparentType := getApparentType( /* TODO(Node ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType */ TODO)
		isAnyLike := isTypeAny(apparentType) || apparentType == silentNeverType
		var prop *Symbol
		if isPrivateIdentifier(right) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				if assignmentKind != AssignmentKindNone {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldSet)
				}
				if assignmentKind != AssignmentKindDefinite {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldGet)
				}
			}
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			if assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration) {
				grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right))
			}
			if isAnyLike {
				if lexicallyScopedSymbol {
					// converted from conditional expression
					switch {
					case isErrorType(apparentType):
						return errorType
					default:
						return apparentType
					}
				}
				if getContainingClassExcludingClassDecorators(right) == nil {
					grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
					return anyType
				}
			}
			prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol)
			if prop == nil {
				if checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
					return errorType
				}
				containingClass := getContainingClassExcludingClassDecorators(right)
				if containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), compilerOptions.checkJs) {
					grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right))
				}
			} else {
				isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
				if isSetonlyAccessor && assignmentKind != AssignmentKindDefinite {
					error(node, Diagnostics.Private_accessor_was_defined_without_a_getter)
				}
			}
		} else {
			if isAnyLike {
				if isIdentifier(left) && parentSymbol {
					markLinkedReferences(node, ReferenceHintProperty, nil, leftType)
				}
				// converted from conditional expression
				switch {
				case isErrorType(apparentType):
					return errorType
				default:
					return apparentType
				}
			}
			prop = getPropertyOfType(apparentType, right.escapedText, isConstEnumObjectType(apparentType), node.kind == SyntaxKindQualifiedName)
		}
		markLinkedReferences(node, ReferenceHintProperty, prop, leftType)
		var propType Type
		if !prop {
			indexInfo := /* TODO(Node ConditionalExpression): !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ? getApplicableIndexInfoForName(apparentType, right.escapedText) : undefined */ TODO
			if !(indexInfo && indexInfo.type_) {
				isUncheckedJS := isUncheckedJSSuggestion(node, leftType.symbol, true)
				if !isUncheckedJS && isJSLiteralType(leftType) {
					return anyType
				}
				if leftType.symbol == globalThisSymbol {
					if globalThisSymbol.exports.has(right.escapedText) && (globalThisSymbol.exports.get(right.escapedText).flags & SymbolFlagsBlockScoped) {
						error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType))
					} else if noImplicitAny {
						error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType))
					}
					return anyType
				}
				if right.escapedText && !checkAndReportErrorForExtendingInterface(node) {
					reportNonexistentProperty(right /* TODO(Node ConditionalExpression): isThisTypeParameter(leftType) ? apparentType : leftType */, TODO, isUncheckedJS)
				}
				return errorType
			}
			if indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node)) {
				error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType))
			}
			propType = indexInfo.type_
			if compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) != AssignmentKindDefinite {
				propType = getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{propType, missingType})
			}
			if compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node) {
				error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText))
			}
			if indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration) {
				addDeprecatedSuggestion(right, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration */ any{indexInfo.declaration}, right.escapedText)
			}
		} else {
			targetPropSymbol := resolveAliasWithDeprecationCheck(prop, right)
			if isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations {
				addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText)
			}
			checkPropertyNotUsedBeforeDeclaration(prop, node, right)
			markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol))
			getNodeLinks(node).resolvedSymbol = prop
			checkPropertyAccessibility(node, left.kind == SyntaxKindSuperKeyword, isWriteAccess(node), apparentType, prop)
			if isAssignmentToReadonlyEntity(node, prop, assignmentKind) {
				error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right))
				return errorType
			}
			propType = /* TODO(Node ConditionalExpression): isThisPropertyAccessInConstructor(node, prop) ? autoType : writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
		}
		return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
	}
	isUncheckedJSSuggestion := func(node Node, suggestion *Symbol, excludeClasses bool) bool {
		file := getSourceFileOfNode(node)
		if file {
			if compilerOptions.checkJs == nil && file.checkJsDirective == nil && (file.scriptKind == ScriptKindJS || file.scriptKind == ScriptKindJSX) {
				declarationFile := forEach(suggestion. /*?*/ declarations, getSourceFileOfNode)
				suggestionHasNoExtendsOrDecorators := !suggestion. /*?*/ valueDeclaration || !isClassLike(suggestion.valueDeclaration) || suggestion.valueDeclaration.heritageClauses. /*?*/ length || classOrConstructorParameterIsDecorated(false, suggestion.valueDeclaration)
				return !(file != declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile)) && !(excludeClasses && suggestion && suggestion.flags&SymbolFlagsClass && suggestionHasNoExtendsOrDecorators) && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword && suggestionHasNoExtendsOrDecorators)
			}
		}
		return false
	}
	getFlowTypeOfAccessExpression := func(node /* TODO(TypeNode UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop *Symbol, propType Type, errorNode Node, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind == AssignmentKindDefinite {
			return removeMissingType(propType, !!(prop && prop.flags&SymbolFlagsOptional))
		}
		if prop && !(prop.flags & (SymbolFlagsVariable | SymbolFlagsProperty | SymbolFlagsAccessor)) && !(prop.flags&SymbolFlagsMethod && propType.flags&TypeFlagsUnion) && !isDuplicatedCommonJSExport(prop.declarations) {
			return propType
		}
		if propType == autoType {
			return getFlowTypeOfProperty(node, prop)
		}
		propType = getNarrowableTypeForReference(propType, node, checkMode)
		assumeUninitialized := false
		if strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword {
			declaration := prop && prop.valueDeclaration
			if declaration && isPropertyWithoutInitializer(declaration) {
				if !isStatic(declaration) {
					flowContainer := getControlFlowContainer(node)
					if flowContainer.kind == SyntaxKindConstructor && flowContainer.parent == declaration.parent && !(declaration.flags & NodeFlagsAmbient) {
						assumeUninitialized = true
					}
				}
			}
		} else if strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(prop.valueDeclaration) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && getControlFlowContainer(node) == getControlFlowContainer(prop.valueDeclaration) {
			assumeUninitialized = true
		}
		flowType := getFlowTypeOfReference(node, propType /* TODO(Node ConditionalExpression): assumeUninitialized ? getOptionalType(propType) : propType */, TODO)
		if assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType) {
			error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop))
			return propType
		}
		// converted from conditional expression
		switch {
		case assignmentKind:
			return getBaseTypeOfLiteralType(flowType)
		default:
			return flowType
		}
	}
	checkPropertyNotUsedBeforeDeclaration := func(prop Symbol, node /* TODO(TypeNode UnionType): PropertyAccessExpression | QualifiedName */ any, right /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier */ any) {
		TODO_IDENTIFIER := prop
		if !valueDeclaration || getSourceFileOfNode(node).isDeclarationFile {
			return
		}
		var diagnosticMessage TODO
		declarationName := idText(right)
		if isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(valueDeclaration) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration)&ModifierFlagsStatic) && (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop)) {
			diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName)
		} else if valueDeclaration.kind == SyntaxKindClassDeclaration && node.parent.kind != SyntaxKindTypeReference && !(valueDeclaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) {
			diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName)
		}
		if diagnosticMessage {
			addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName))
		}
	}
	isInPropertyInitializerOrClassStaticBlock := func(node Node) bool {
		return !!findAncestor(node, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			switch node.kind {
			case SyntaxKindPropertyDeclaration:
				return true
			case SyntaxKindPropertyAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSpreadAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindComputedPropertyName:
				fallthrough // TODO: merge cases
			case SyntaxKindTemplateSpan:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxAttribute:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxAttributes:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxSpreadAttribute:
				fallthrough // TODO: merge cases
			case SyntaxKindJsxOpeningElement:
				fallthrough // TODO: merge cases
			case SyntaxKindExpressionWithTypeArguments:
				fallthrough // TODO: merge cases
			case SyntaxKindHeritageClause:
				return false
			case SyntaxKindArrowFunction:
				fallthrough // TODO: merge cases
			case SyntaxKindExpressionStatement:
				// converted from conditional expression
				switch {
				case isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent):
					return true
				default:
					return "quit"
				}
			default:
				// converted from conditional expression
				switch {
				case isExpressionNode(node):
					return false
				default:
					return "quit"
				}
			}
		})
	}
	isPropertyDeclaredInAncestorClass := func(prop Symbol) bool {
		if !(prop.parent.flags & SymbolFlagsClass) {
			return false
		}
		var classType *InterfaceType = getTypeOfSymbol(prop.parent)
		for true {
			classType = classType.symbol && getSuperClass(classType)
			if !classType {
				return false
			}
			superProperty := getPropertyOfType(classType, prop.escapedName)
			if superProperty && superProperty.valueDeclaration {
				return true
			}
		}
	}
	getSuperClass := func(classType InterfaceType) *Type {
		x := getBaseTypes(classType)
		if x.length == 0 {
			return nil
		}
		return getIntersectionType(x)
	}
	reportNonexistentProperty := func(propNode /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo *Diagnostic
		if !isPrivateIdentifier(propNode) && containingType.flags&TypeFlagsUnion && !(containingType.flags & TypeFlagsPrimitive) {
			for _, subtype := range (containingType).types {
				if !getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText) {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype))
					break
				}
			}
		}
		if typeHasStaticProperty(propNode.escapedText, containingType) {
			propName := declarationNameToString(propNode)
			typeName := typeToString(containingType)
			errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName+"."+propName)
		} else {
			promisedType := getPromisedTypeOfPromise(containingType)
			if promisedType && getPropertyOfType(promisedType, propNode.escapedText) {
				errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType))
				relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await)
			} else {
				missingProperty := declarationNameToString(propNode)
				container := typeToString(containingType)
				libSuggestion := getSuggestedLibForNonExistentProperty(missingProperty, containingType)
				if libSuggestion != nil {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion)
				} else {
					suggestion := getSuggestedSymbolForNonexistentProperty(propNode, containingType)
					if suggestion != nil {
						suggestedName := symbolName(suggestion)
						message := /* TODO(Node ConditionalExpression): isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */ TODO
						errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName)
						relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName)
					} else {
						diagnostic := /* TODO(Node ConditionalExpression): containerSeemsToBeEmptyDomElement(containingType) ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom : Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO
						errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container)
					}
				}
			}
		}
		resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
		if relatedInfo {
			addRelatedInfo(resultDiagnostic, relatedInfo)
		}
		addErrorOrSuggestion(!isUncheckedJS || errorInfo.code != Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic)
	}
	containerSeemsToBeEmptyDomElement := func(containingType Type) /* TODO inferred type boolean | undefined */ any {
		return (compilerOptions.lib && !compilerOptions.lib.includes("dom")) && everyContainedType(containingType, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return type_.symbol && regexp.MustParse(`^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$`).test(unescapeLeadingUnderscores(type_.symbol.escapedName))
		}) && isEmptyObjectType(containingType)
	}
	typeHasStaticProperty := func(propName __String, containingType Type) bool {
		prop := containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName)
		return prop != nil && !!prop.valueDeclaration && isStatic(prop.valueDeclaration)
	}
	getSuggestedLibForNonExistentName := func(name /* TODO(TypeNode UnionType): __String | Identifier */ any) /* TODO inferred type string | undefined */ any {
		missingName := diagnosticName(name)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(missingName)
		return typeFeatures && firstIterator(typeFeatures.keys())
	}
	getSuggestedLibForNonExistentProperty := func(missingProperty string, containingType Type) /* TODO inferred type string | undefined */ any {
		container := getApparentType(containingType).symbol
		if !container {
			return nil
		}
		containingTypeName := symbolName(container)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(containingTypeName)
		if typeFeatures {
			for _, TODO_IDENTIFIER := range typeFeatures {
				if contains(featuresOfType, missingProperty) {
					return libTarget
				}
			}
		}
	}
	getSuggestedSymbolForNonexistentClassMember := func(name string, baseType Type) *Symbol {
		return getSpellingSuggestionForName(name, getPropertiesOfType(baseType), SymbolFlagsClassMember)
	}
	getSuggestedSymbolForNonexistentProperty := func(name /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		props := getPropertiesOfType(containingType)
		if /* TODO(Node TypeOfExpression): typeof name */ TODO != "string" {
			parent := name.parent
			if isPropertyAccessExpression(parent) {
				props = filter(props, func(prop /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean */ any {
					return isValidPropertyAccessForCompletions(parent, containingType, prop)
				})
			}
			name = idText(name)
		}
		return getSpellingSuggestionForName(name, props, SymbolFlagsValue)
	}
	getSuggestedSymbolForNonexistentJSXAttribute := func(name /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		strName := /* TODO(Node ConditionalExpression): isString(name) ? name : idText(name) */ TODO
		properties := getPropertiesOfType(containingType)
		jsxSpecific := /* TODO(Node ConditionalExpression): strName === "for" ? find(properties, x => symbolName(x) === "htmlFor") : strName === "class" ? find(properties, x => symbolName(x) === "className") : undefined */ TODO
		return /* TODO(Node BinaryExpression): jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
	}
	getSuggestionForNonexistentProperty := func(name /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *string {
		suggestion := getSuggestedSymbolForNonexistentProperty(name, containingType)
		return suggestion && symbolName(suggestion)
	}
	getSuggestionForSymbolNameLookup := func(symbols SymbolTable, name __String, meaning SymbolFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		symbol := getSymbol(symbols, name, meaning)
		if symbol {
			return symbol
		}
		var candidates []Symbol
		if symbols == globals {
			primitives := mapDefined([] /* TODO inferred type string */ any{"string", "number", "boolean", "object", "bigint", "symbol"}, func(s /* TODO inferred type string */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
				return /* TODO(Node ConditionalExpression): symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as __String) ? createSymbol(SymbolFlags.TypeAlias, s as __String) as Symbol : undefined */ TODO
			})
			candidates = primitives.concat(arrayFrom(symbols.values()))
		} else {
			candidates = arrayFrom(symbols.values())
		}
		return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
	}
	getSuggestedSymbolForNonexistentSymbol := func(location Node, outerName __String, meaning SymbolFlags) *Symbol {
		Debug.assert(outerName != nil, "outername should always be defined")
		result := resolveNameForSymbolSuggestion(location, outerName, meaning, nil, false, false)
		return result
	}
	getSuggestedSymbolForNonexistentModule := func(name Identifier, targetModule Symbol) *Symbol {
		return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlagsModuleMember)
	}
	getSuggestionForNonexistentIndexSignature := func(objectType Type, expr ElementAccessExpression, keyedType Type) *string {
		hasProp := func(name /* TODO(TypeNode UnionType): "set" | "get" */ any) /* TODO inferred type boolean */ any {
			prop := getPropertyOfObjectType(objectType, name)
			if prop {
				s := getSingleCallSignature(getTypeOfSymbol(prop))
				return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0))
			}
			return false
		}
		suggestedMethod := /* TODO(Node ConditionalExpression): isAssignmentTarget(expr) ? "set" : "get" */ TODO
		if !hasProp(suggestedMethod) {
			return nil
		}
		suggestion := tryGetPropertyAccessOrIdentifierToString(expr.expression)
		if suggestion == nil {
			suggestion = suggestedMethod
		} else {
			suggestion += "." + suggestedMethod
		}
		return suggestion
	}
	getSuggestedTypeForNonexistentStringLiteralType := func(source StringLiteralType, target UnionType) *StringLiteralType {
		candidates := target.types.filter(func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO(TypeNode TypePredicate): type is StringLiteralType */ any {
			return !!(type_.flags & TypeFlagsStringLiteral)
		})
		return getSpellingSuggestion(source.value, candidates, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType */ any) /* TODO inferred type string */ any {
			return type_.value
		})
	}
	getSpellingSuggestionForName := func(name string, symbols []Symbol, meaning SymbolFlags) *Symbol {
		return getSpellingSuggestion(name, symbols, getCandidateName)
		getCandidateName := func(candidate Symbol) /* TODO inferred type string | undefined */ any {
			candidateName := symbolName(candidate)
			if startsWith(candidateName, '"') {
				return nil
			}
			if candidate.flags & meaning {
				return candidateName
			}
			if candidate.flags & SymbolFlagsAlias {
				alias := tryResolveAlias(candidate)
				if alias && alias.flags&meaning {
					return candidateName
				}
			}
			return nil
		}
	}
	markPropertyAsReferenced := func(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
		valueDeclaration := prop && (prop.flags & SymbolFlagsClassMember) && prop.valueDeclaration
		if !valueDeclaration {
			return
		}
		hasPrivateModifier := hasEffectiveModifier(valueDeclaration, ModifierFlagsPrivate)
		hasPrivateIdentifier := prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name)
		if !hasPrivateModifier && !hasPrivateIdentifier {
			return
		}
		if nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlagsSetAccessor) {
			return
		}
		if isSelfTypeAccess {
			containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
			if containingMethod && containingMethod.symbol == prop {
				return
			}
		}
		( /* TODO(Node ConditionalExpression): getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop */ TODO).isReferenced = SymbolFlagsAll
	}
	isSelfTypeAccess := func(name /* TODO(TypeNode UnionType): Expression | QualifiedName */ any, parent *Symbol) /* TODO inferred type boolean */ any {
		return name.kind == SyntaxKindThisKeyword || !!parent && isEntityNameExpression(name) && parent == getResolvedSymbol(getFirstIdentifier(name))
	}
	isValidPropertyAccess := func(node /* TODO(TypeNode UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
		switch node.kind {
		case SyntaxKindPropertyAccessExpression:
			return isValidPropertyAccessWithType(node, node.expression.kind == SyntaxKindSuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)))
		case SyntaxKindQualifiedName:
			return isValidPropertyAccessWithType(node, false, propertyName, getWidenedType(checkExpression(node.left)))
		case SyntaxKindImportType:
			return isValidPropertyAccessWithType(node, false, propertyName, getTypeFromTypeNode(node))
		}
	}
	isValidPropertyAccessForCompletions := func(node /* TODO(TypeNode UnionType): PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
		return isPropertyAccessible(node, node.kind == SyntaxKindPropertyAccessExpression && node.expression.kind == SyntaxKindSuperKeyword, false, type_, property)
	}
	isValidPropertyAccessWithType := func(node /* TODO(TypeNode UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
		if isTypeAny(type_) {
			return true
		}
		prop := getPropertyOfType(type_, propertyName)
		return !!prop && isPropertyAccessible(node, isSuper, false, type_, prop)
	}
	isPropertyAccessible := func(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
		if isTypeAny(containingType) {
			return true
		}
		if property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration) {
			declClass := getContainingClass(property.valueDeclaration)
			return !isOptionalChain(node) && !!findAncestor(node, func(parent /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
				return parent == declClass
			})
		}
		return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
	}
	getForInVariableSymbol := func(node ForInStatement) *Symbol {
		initializer := node.initializer
		if initializer.kind == SyntaxKindVariableDeclarationList {
			variable := (initializer).declarations[0]
			if variable && !isBindingPattern(variable.name) {
				return getSymbolOfDeclaration(variable)
			}
		} else if initializer.kind == SyntaxKindIdentifier {
			return getResolvedSymbol(initializer)
		}
		return nil
	}
	hasNumericPropertyNames := func(type_ Type) /* TODO inferred type boolean */ any {
		return getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, numberType)
	}
	isForInVariableForNumericPropertyNames := func(expr Expression) /* TODO inferred type boolean */ any {
		e := skipParentheses(expr)
		if e.kind == SyntaxKindIdentifier {
			symbol := getResolvedSymbol(e)
			if symbol.flags & SymbolFlagsVariable {
				var child Node = expr
				node := expr.parent
				for node {
					if node.kind == SyntaxKindForInStatement && child == (node).statement && getForInVariableSymbol(node) == symbol && hasNumericPropertyNames(getTypeOfExpression((node).expression)) {
						return true
					}
					child = node
					node = node.parent
				}
			}
		}
		return false
	}
	checkIndexedAccess := func(node ElementAccessExpression, checkMode *CheckMode) Type {
		// converted from conditional expression
		switch {
		case node.flags & NodeFlagsOptionalChain:
			return checkElementAccessChain(node, checkMode)
		default:
			return checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode)
		}
	}
	checkElementAccessChain := func(node ElementAccessChain, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		exprType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(exprType, node.expression)
		return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType != exprType)
	}
	checkElementAccessExpression := func(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
		objectType := /* TODO(Node ConditionalExpression): getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType */ TODO
		indexExpression := node.argumentExpression
		indexType := checkExpression(indexExpression)
		if isErrorType(objectType) || objectType == silentNeverType {
			return objectType
		}
		if isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
			error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal)
			return errorType
		}
		effectiveIndexType := /* TODO(Node ConditionalExpression): isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType */ TODO
		assignmentTargetKind := getAssignmentTargetKind(node)
		var accessFlags AccessFlags
		if assignmentTargetKind == AssignmentKindNone {
			accessFlags = AccessFlagsExpressionPosition
		} else {
			accessFlags = AccessFlagsWriting | ( /* TODO(Node ConditionalExpression): isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0 */ TODO)
			if assignmentTargetKind == AssignmentKindCompound {
				accessFlags |= AccessFlagsExpressionPosition
			}
		}
		indexedAccessType := getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType
		return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node)
	}
	callLikeExpressionMayHaveTypeArguments := func(node CallLikeExpression) /* TODO(TypeNode TypePredicate): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ any {
		return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node)
	}
	resolveUntypedCall := func(node CallLikeExpression) Signature {
		if callLikeExpressionMayHaveTypeArguments(node) {
			forEach(node.typeArguments, checkSourceElement)
		}
		if node.kind == SyntaxKindTaggedTemplateExpression {
			checkExpression(node.template)
		} else if isJsxOpeningLikeElement(node) {
			checkExpression(node.attributes)
		} else if isBinaryExpression(node) {
			checkExpression(node.left)
		} else if isCallOrNewExpression(node) {
			forEach(node.arguments, func(argument /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ any) {
				checkExpression(argument)
			})
		}
		return anySignature
	}
	resolveErrorCall := func(node CallLikeExpression) Signature {
		resolveUntypedCall(node)
		return unknownSignature
	}
	reorderCandidates := func(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
		var lastParent Node
		var lastSymbol *Symbol
		cutoffIndex := 0
		var index *number
		specializedIndex := -1
		var spliceIndex number
		Debug.assert(!result.length)
		for _, signature := range signatures {
			symbol := signature.declaration && getSymbolOfDeclaration(signature.declaration)
			parent := signature.declaration && signature.declaration.parent
			if !lastSymbol || symbol == lastSymbol {
				if lastParent && parent == lastParent {
					index = index + 1
				} else {
					lastParent = parent
					index = cutoffIndex
				}
			} else {
				index = /* TODO(Node BinaryExpression): cutoffIndex = result.length */ TODO
				lastParent = parent
			}
			lastSymbol = symbol
			if signatureHasLiteralTypes(signature) {
				specializedIndex++
				spliceIndex = specializedIndex
				cutoffIndex++
			} else {
				spliceIndex = index
			}
			result.splice(spliceIndex, 0 /* TODO(Node ConditionalExpression): callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature */, TODO)
		}
	}
	isSpreadArgument := func(arg *Expression) /* TODO(TypeNode TypePredicate): arg is Expression */ any {
		return !!arg && (arg.kind == SyntaxKindSpreadElement || arg.kind == SyntaxKindSyntheticExpression && (arg).isSpread)
	}
	getSpreadArgumentIndex := func(args []Expression) number {
		return findIndex(args, isSpreadArgument)
	}
	acceptsVoid := func(t Type) bool {
		return !!(t.flags & TypeFlagsVoid)
	}
	acceptsVoidUndefinedUnknownOrAny := func(t Type) bool {
		return !!(t.flags & (TypeFlagsVoid | TypeFlagsUndefined | TypeFlagsUnknown | TypeFlagsAny))
	}
	hasCorrectArity := func(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma /* TODO inferred type boolean */ any /*  = false */) /* TODO inferred type boolean */ any {
		var argCount number
		callIsIncomplete := false
		effectiveParameterCount := getParameterCount(signature)
		effectiveMinimumArguments := getMinArgumentCount(signature)
		if node.kind == SyntaxKindTaggedTemplateExpression {
			argCount = args.length
			if node.template.kind == SyntaxKindTemplateExpression {
				lastSpan := last(node.template.templateSpans)
				callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated
			} else {
				templateLiteral := node.template
				Debug.assert(templateLiteral.kind == SyntaxKindNoSubstitutionTemplateLiteral)
				callIsIncomplete = !!templateLiteral.isUnterminated
			}
		} else if node.kind == SyntaxKindDecorator {
			argCount = getDecoratorArgumentCount(node, signature)
		} else if node.kind == SyntaxKindBinaryExpression {
			argCount = 1
		} else if isJsxOpeningLikeElement(node) {
			callIsIncomplete = node.attributes.end == node.end
			if callIsIncomplete {
				return true
			}
			argCount = /* TODO(Node ConditionalExpression): effectiveMinimumArguments === 0 ? args.length : 1 */ TODO
			effectiveParameterCount = /* TODO(Node ConditionalExpression): args.length === 0 ? effectiveParameterCount : 1 */ TODO
			effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1)
		} else if !node.arguments {
			Debug.assert(node.kind == SyntaxKindNewExpression)
			return getMinArgumentCount(signature) == 0
		} else {
			argCount = /* TODO(Node ConditionalExpression): signatureHelpTrailingComma ? args.length + 1 : args.length */ TODO
			callIsIncomplete = node.arguments.end == node.end
			spreadArgIndex := getSpreadArgumentIndex(args)
			if spreadArgIndex >= 0 {
				return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature))
			}
		}
		if !hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
			return false
		}
		if callIsIncomplete || argCount >= effectiveMinimumArguments {
			return true
		}
		for i := argCount; i < effectiveMinimumArguments; i++ {
			type_ := getTypeAtPosition(signature, i)
			if filterType(type_ /* TODO(Node ConditionalExpression): isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid */, TODO).flags & TypeFlagsNever {
				return false
			}
		}
		return true
	}
	hasCorrectTypeArgumentArity := func(signature Signature, typeArguments *NodeArray[TypeNode]) /* TODO inferred type boolean */ any {
		numTypeParameters := length(signature.typeParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(signature.typeParameters)
		return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters)
	}
	isInstantiatedGenericParameter := func(signature Signature, pos number) /* TODO inferred type boolean */ any {
		var type_ TODO
		return !!(signature.target && ( /* TODO(Node BinaryExpression): type = tryGetTypeAtPosition(signature.target, pos) */ TODO) && isGenericType(type_))
	}
	getSingleCallSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall, false)
	}
	getSingleCallOrConstructSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall, false) || getSingleSignature(type_, SignatureKindConstruct, false)
	}
	getSingleSignature := func(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_)
			if allowMembers || resolved.properties.length == 0 && resolved.indexInfos.length == 0 {
				if kind == SignatureKindCall && resolved.callSignatures.length == 1 && resolved.constructSignatures.length == 0 {
					return resolved.callSignatures[0]
				}
				if kind == SignatureKindConstruct && resolved.constructSignatures.length == 1 && resolved.callSignatures.length == 0 {
					return resolved.constructSignatures[0]
				}
			}
		}
		return nil
	}
	instantiateSignatureInContextOf := func(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
		context := createInferenceContext(getTypeParametersForMapper(signature), signature, InferenceFlagsNone, compareTypes)
		restType := getEffectiveRestType(contextualSignature)
		mapper := inferenceContext && ( /* TODO(Node ConditionalExpression): restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper */ TODO)
		sourceSignature := /* TODO(Node ConditionalExpression): mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature */ TODO
		applyToParameterTypes(sourceSignature, signature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
			inferTypes(context.inferences, source, target)
		})
		if !inferenceContext {
			applyToReturnTypes(contextualSignature, signature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
				inferTypes(context.inferences, source, target, InferencePriorityReturnType)
			})
		}
		return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration))
	}
	inferJsxTypeArguments := func(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		checkAttrType := checkExpressionWithContextualType(node.attributes, paramType, context, checkMode)
		inferTypes(context.inferences, checkAttrType, paramType)
		return getInferredTypes(context)
	}
	getThisArgumentType := func(thisArgumentNode *Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !thisArgumentNode {
			return voidType
		}
		thisArgumentType := checkExpression(thisArgumentNode)
		// converted from conditional expression
		switch {
		case isRightSideOfInstanceofExpression(thisArgumentNode):
			return thisArgumentType
		case isOptionalChainRoot(thisArgumentNode.parent):
			return getNonNullableType(thisArgumentType)
		case isOptionalChain(thisArgumentNode.parent):
			return removeOptionalTypeMarker(thisArgumentType)
		default:
			return thisArgumentType
		}
	}
	inferTypeArguments := func(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
		if isJsxOpeningLikeElement(node) {
			return inferJsxTypeArguments(node, signature, checkMode, context)
		}
		if node.kind != SyntaxKindDecorator && node.kind != SyntaxKindBinaryExpression {
			skipBindingPatterns := every(signature.typeParameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type boolean */ any {
				return !!getDefaultFromTypeParameter(p)
			})
			contextualType := getContextualType(node /* TODO(Node ConditionalExpression): skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None */, TODO)
			if contextualType {
				inferenceTargetType := getReturnTypeOfSignature(signature)
				if couldContainTypeVariables(inferenceTargetType) {
					outerContext := getInferenceContext(node)
					isFromBindingPattern := !skipBindingPatterns && getContextualType(node, ContextFlagsSkipBindingPatterns) != contextualType
					if !isFromBindingPattern {
						outerMapper := getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlagsNoDefault))
						instantiatedType := instantiateType(contextualType, outerMapper)
						contextualSignature := getSingleCallSignature(instantiatedType)
						inferenceSourceType := /* TODO(Node ConditionalExpression): contextualSignature && contextualSignature.typeParameters ? getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) : instantiatedType */ TODO
						inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriorityReturnType)
					}
					returnContext := createInferenceContext(signature.typeParameters, signature, context.flags)
					returnSourceType := instantiateType(contextualType, outerContext && outerContext.returnMapper)
					inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType)
					context.returnMapper = /* TODO(Node ConditionalExpression): some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined */ TODO
				}
			}
		}
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(Node ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		if restType && restType.flags&TypeFlagsTypeParameter {
			info := find(context.inferences, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type boolean */ any {
				return info.typeParameter == restType
			})
			if info {
				info.impliedArity = /* TODO(Node ConditionalExpression): findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined */ TODO
			}
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && couldContainTypeVariables(thisType) {
			thisArgumentNode := getThisArgumentOfCall(node)
			inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType)
		}
		for i := 0; i < argCount; i++ {
			arg := args[i]
			if arg.kind != SyntaxKindOmittedExpression {
				paramType := getTypeAtPosition(signature, i)
				if couldContainTypeVariables(paramType) {
					argType := checkExpressionWithContextualType(arg, paramType, context, checkMode)
					inferTypes(context.inferences, argType, paramType)
				}
			}
		}
		if restType && couldContainTypeVariables(restType) {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode)
			inferTypes(context.inferences, spreadType, restType)
		}
		return getInferredTypes(context)
	}
	getMutableArrayOrTupleType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, getMutableArrayOrTupleType)
		case type_.flags&TypeFlagsAny || isMutableArrayOrTuple(getBaseConstraintOfType(type_) || type_):
			return type_
		case isTupleType(type_):
			return createTupleType(getElementTypes(type_), type_.target.elementFlags, false, type_.target.labeledElementDeclarations)
		default:
			return createTupleType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type_}, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ any{ElementFlagsVariadic})
		}
	}
	getSpreadArgumentType := func(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		inConstContext := isConstTypeVariable(restType)
		if index >= argCount-1 {
			arg := args[argCount-1]
			if isSpreadArgument(arg) {
				spreadType := /* TODO(Node ConditionalExpression): arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode) */ TODO
				if isArrayLikeType(spreadType) {
					return getMutableArrayOrTupleType(spreadType)
				}
				return createArrayType(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType /* TODO(Node ConditionalExpression): arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg */, TODO), inConstContext)
			}
		}
		types := [] /* TODO inferred type never */ any{}
		flags := [] /* TODO inferred type never */ any{}
		names := [] /* TODO inferred type never */ any{}
		for i := index; i < argCount; i++ {
			arg := args[i]
			if isSpreadArgument(arg) {
				spreadType := /* TODO(Node ConditionalExpression): arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpression((arg as SpreadElement).expression) */ TODO
				if isArrayLikeType(spreadType) {
					types.push(spreadType)
					flags.push(ElementFlagsVariadic)
				} else {
					types.push(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType /* TODO(Node ConditionalExpression): arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg */, TODO))
					flags.push(ElementFlagsRest)
				}
			} else {
				contextualType := /* TODO(Node ConditionalExpression): isTupleType(restType) ? getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType : getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual) */ TODO
				argType := checkExpressionWithContextualType(arg, contextualType, context, checkMode)
				hasPrimitiveContextualType := inConstContext || maybeTypeOfKind(contextualType, TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
				types.push( /* TODO(Node ConditionalExpression): hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType) */ TODO)
				flags.push(ElementFlagsRequired)
			}
			if arg.kind == SyntaxKindSyntheticExpression && (arg).tupleNameSource {
				names.push((arg).tupleNameSource)
			} else {
				names.push(nil)
			}
		}
		return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names)
	}
	checkTypeArguments := func(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) *[]Type {
		isJavascript := isInJSFile(signature.declaration)
		typeParameters := signature.typeParameters
		typeArgumentTypes := fillMissingTypeArguments(map_(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript)
		var mapper *TypeMapper
		for i := 0; i < typeArgumentNodes.length; i++ {
			Debug.assert(typeParameters[i] != nil, "Should not call checkTypeArguments with too many type arguments")
			constraint := getConstraintOfTypeParameter(typeParameters[i])
			if constraint {
				errorInfo := /* TODO(Node ConditionalExpression): reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined */ TODO
				typeArgumentHeadMessage := headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1
				if !mapper {
					mapper = createTypeMapper(typeParameters, typeArgumentTypes)
				}
				typeArgument := typeArgumentTypes[i]
				if !checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument) /* TODO(Node ConditionalExpression): reportErrors ? typeArgumentNodes[i] : undefined */, TODO, typeArgumentHeadMessage, errorInfo) {
					return nil
				}
			}
		}
		return typeArgumentTypes
	}
	getJsxReferenceKind := func(node JsxOpeningLikeElement) JsxReferenceKind {
		if isJsxIntrinsicTagName(node.tagName) {
			return JsxReferenceKindMixed
		}
		tagType := getApparentType(checkExpression(node.tagName))
		if length(getSignaturesOfType(tagType, SignatureKindConstruct)) {
			return JsxReferenceKindComponent
		}
		if length(getSignaturesOfType(tagType, SignatureKindCall)) {
			return JsxReferenceKindFunction
		}
		return JsxReferenceKindMixed
	}
	checkApplicableSignatureForJsxOpeningLikeElement := func(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO inferred type boolean */ any {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		attributesType := checkExpressionWithContextualType(node.attributes, paramType, nil, checkMode)
		checkAttributesType := /* TODO(Node ConditionalExpression): checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(attributesType) : attributesType */ TODO
		return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(checkAttributesType, paramType, relation /* TODO(Node ConditionalExpression): reportErrors ? node.tagName : undefined */, TODO, node.attributes, nil, containingMessageChain, errorOutputContainer)
		checkTagNameDoesNotExpectTooManyArguments := func() bool {
			if getJsxNamespaceContainerForImplicitImport(node) {
				return true
			}
			tagType := /* TODO(Node ConditionalExpression): (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) ? checkExpression(node.tagName) : undefined */ TODO
			if !tagType {
				return true
			}
			tagCallSignatures := getSignaturesOfType(tagType, SignatureKindCall)
			if !length(tagCallSignatures) {
				return true
			}
			factory := getJsxFactoryEntity(node)
			if !factory {
				return true
			}
			factorySymbol := resolveEntityName(factory, SymbolFlagsValue, true, false, node)
			if !factorySymbol {
				return true
			}
			factoryType := getTypeOfSymbol(factorySymbol)
			callSignatures := getSignaturesOfType(factoryType, SignatureKindCall)
			if !length(callSignatures) {
				return true
			}
			hasFirstParamSignatures := false
			maxParamCount := 0
			for _, sig := range callSignatures {
				firstparam := getTypeAtPosition(sig, 0)
				signaturesOfParam := getSignaturesOfType(firstparam, SignatureKindCall)
				if !length(signaturesOfParam) {
					continue
				}
				for _, paramSig := range signaturesOfParam {
					hasFirstParamSignatures = true
					if hasEffectiveRestParameter(paramSig) {
						return true
					}
					paramCount := getParameterCount(paramSig)
					if paramCount > maxParamCount {
						maxParamCount = paramCount
					}
				}
			}
			if !hasFirstParamSignatures {
				return true
			}
			absoluteMinArgCount := Infinity
			for _, tagSig := range tagCallSignatures {
				tagRequiredArgCount := getMinArgumentCount(tagSig)
				if tagRequiredArgCount < absoluteMinArgCount {
					absoluteMinArgCount = tagRequiredArgCount
				}
			}
			if absoluteMinArgCount <= maxParamCount {
				return true
			}
			if reportErrors {
				diag := createDiagnosticForNode(node.tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(node.tagName), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
				tagNameDeclaration := getSymbolAtLocation(node.tagName). /*?*/ valueDeclaration
				if tagNameDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName)))
				}
				if errorOutputContainer && errorOutputContainer.skipLogging {
					(errorOutputContainer.errors || ( /* TODO(Node BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
				}
				if !errorOutputContainer.skipLogging {
					diagnostics.add(diag)
				}
			}
			return false
		}
	}
	getEffectiveCheckNode := func(argument Expression) Expression {
		argument = skipParentheses(argument)
		// converted from conditional expression
		switch {
		case isSatisfiesExpression(argument):
			return skipParentheses(argument.expression)
		default:
			return argument
		}
	}
	getSignatureApplicabilityError := func(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain *func() *DiagnosticMessageChain, inferenceContext *InferenceContext) *[]Diagnostic {
		var errorOutputContainer /* TODO(TypeNode TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any = /* TODO(Node ObjectLiteralExpression): { errors: undefined, skipLogging: true } */ TODO
		if isJsxOpeningLikeElement(node) {
			if !checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
			return nil
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && thisType != voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) {
			thisArgumentNode := getThisArgumentOfCall(node)
			thisArgumentType := getThisArgumentType(thisArgumentNode)
			errorNode := /* TODO(Node ConditionalExpression): reportErrors ? (thisArgumentNode || node) : undefined */ TODO
			headMessage := Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1
			if !checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
		}
		headMessage := Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(Node ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		for i := 0; i < argCount; i++ {
			arg := args[i]
			if arg.kind != SyntaxKindOmittedExpression {
				paramType := getTypeAtPosition(signature, i)
				argType := checkExpressionWithContextualType(arg, paramType, nil, checkMode)
				regularArgType := /* TODO(Node ConditionalExpression): checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType */ TODO
				checkArgType := /* TODO(Node ConditionalExpression): inferenceContext ? instantiateType(regularArgType, inferenceContext.nonFixingMapper) : regularArgType */ TODO
				effectiveCheckArgumentNode := getEffectiveCheckNode(arg)
				if !checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation /* TODO(Node ConditionalExpression): reportErrors ? effectiveCheckArgumentNode : undefined */, TODO, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer) {
					Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors")
					maybeAddMissingAwaitInfo(arg, checkArgType, paramType)
					return errorOutputContainer.errors || emptyArray
				}
			}
		}
		if restType {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, nil, checkMode)
			restArgCount := args.length - argCount
			errorNode := /* TODO(Node ConditionalExpression): !reportErrors ? undefined : restArgCount === 0 ? node : restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) : setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end) */ TODO
			if !checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, nil, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors")
				maybeAddMissingAwaitInfo(errorNode, spreadType, restType)
				return errorOutputContainer.errors || emptyArray
			}
		}
		return nil
		maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
			if errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length {
				if getAwaitedTypeOfPromise(target) {
					return
				}
				awaitedTypeOfSource := getAwaitedTypeOfPromise(source)
				if awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation) {
					addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await))
				}
			}
		}
	}
	getThisArgumentOfCall := func(node CallLikeExpression) *Expression {
		if node.kind == SyntaxKindBinaryExpression {
			return node.right
		}
		expression := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.CallExpression ? node.expression : node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag : node.kind === SyntaxKind.Decorator && !legacyDecorators ? node.expression : undefined */ TODO
		if expression {
			callee := skipOuterExpressions(expression)
			if isAccessExpression(callee) {
				return callee.expression
			}
		}
	}
	createSyntheticExpression := func(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(TypeNode UnionType): ParameterDeclaration | NamedTupleMember */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SyntheticExpression */ any {
		result := parseNodeFactory.createSyntheticExpression(type_, isSpread, tupleNameSource)
		setTextRangeWorker(result, parent)
		setParent(result, parent)
		return result
	}
	getEffectiveCallArguments := func(node CallLikeExpression) []Expression {
		if node.kind == SyntaxKindTaggedTemplateExpression {
			template := node.template
			var args []Expression = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SyntheticExpression */ any{createSyntheticExpression(template, getGlobalTemplateStringsArrayType())}
			if template.kind == SyntaxKindTemplateExpression {
				forEach(template.templateSpans, func(span /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateSpan */ any) {
					args.push(span.expression)
				})
			}
			return args
		}
		if node.kind == SyntaxKindDecorator {
			return getEffectiveDecoratorArguments(node)
		}
		if node.kind == SyntaxKindBinaryExpression {
			return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ any{node.left}
		}
		if isJsxOpeningLikeElement(node) {
			// converted from conditional expression
			switch {
			case node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0):
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributes */ any{node.attributes}
			default:
				return emptyArray
			}
		}
		args := node.arguments || emptyArray
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex >= 0 {
			effectiveArgs := args.slice(0, spreadIndex)
			for i := spreadIndex; i < args.length; i++ {
				arg := args[i]
				spreadType := arg.kind == SyntaxKindSpreadElement && ( /* TODO(Node ConditionalExpression): flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression) */ TODO)
				if spreadType && isTupleType(spreadType) {
					forEach(getElementTypes(spreadType), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, i /* TODO inferred type number */ any) {
						flags := spreadType.target.elementFlags[i]
						syntheticArg := createSyntheticExpression(arg /* TODO(Node ConditionalExpression): flags & ElementFlags.Rest ? createArrayType(t) : t */, TODO, !!(flags & ElementFlagsVariable), spreadType.target.labeledElementDeclarations[i])
						effectiveArgs.push(syntheticArg)
					})
				} else {
					effectiveArgs.push(arg)
				}
			}
			return effectiveArgs
		}
		return args
	}
	getEffectiveDecoratorArguments := func(node Decorator) []Expression {
		expr := node.expression
		signature := getDecoratorCallSignature(node)
		if signature {
			var args []Expression = [] /* TODO inferred type never */ any{}
			for _, param := range signature.parameters {
				type_ := getTypeOfSymbol(param)
				args.push(createSyntheticExpression(expr, type_))
			}
			return args
		}
		return Debug.fail()
	}
	getDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO inferred type number */ any {
		// converted from conditional expression
		switch {
		case compilerOptions.experimentalDecorators:
			return getLegacyDecoratorArgumentCount(node, signature)
		default:
			return Math.min(Math.max(getParameterCount(signature), 1), 2)
		}
	}
	getLegacyDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO inferred type 1 | 2 | 3 */ any {
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			return 1
		case SyntaxKindPropertyDeclaration:
			// converted from conditional expression
			switch {
			case hasAccessorModifier(node.parent):
				return 3
			default:
				return 2
			}
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			// converted from conditional expression
			switch {
			case signature.parameters.length <= 2:
				return 2
			default:
				return 3
			}
		case SyntaxKindParameter:
			return 3
		default:
			return Debug.fail()
		}
	}
	getDiagnosticSpanForCallNode := func(node CallExpression) /* TODO inferred type { start: number; length: number; sourceFile: import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile; } */ any {
		sourceFile := getSourceFileOfNode(node)
		TODO_IDENTIFIER := getErrorSpanForNode(sourceFile /* TODO(Node ConditionalExpression): isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression */, TODO)
		return /* TODO(Node ObjectLiteralExpression): { start, length, sourceFile } */ TODO
	}
	getDiagnosticForCallNode := func(node CallLikeExpression, message /* TODO(TypeNode UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
		if isCallExpression(node) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(node)
			if /* TODO(Node BinaryExpression): "message" in message */ TODO {
				return createFileDiagnostic(sourceFile, start, length, message, args...)
			}
			return createDiagnosticForFileFromMessageChain(sourceFile, message)
		} else {
			if /* TODO(Node BinaryExpression): "message" in message */ TODO {
				return createDiagnosticForNode(node, message, args...)
			}
			return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
		}
	}
	getErrorNodeForCallNode := func(callLike CallLikeExpression) Node {
		if isCallOrNewExpression(callLike) {
			// converted from conditional expression
			switch {
			case isPropertyAccessExpression(callLike.expression):
				return callLike.expression.name
			default:
				return callLike.expression
			}
		}
		if isTaggedTemplateExpression(callLike) {
			// converted from conditional expression
			switch {
			case isPropertyAccessExpression(callLike.tag):
				return callLike.tag.name
			default:
				return callLike.tag
			}
		}
		if isJsxOpeningLikeElement(callLike) {
			return callLike.tagName
		}
		return callLike
	}
	isPromiseResolveArityError := func(node CallLikeExpression) /* TODO inferred type boolean */ any {
		if !isCallExpression(node) || !isIdentifier(node.expression) {
			return false
		}
		symbol := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue, nil, false)
		decl := symbol. /*?*/ valueDeclaration
		if !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression) {
			return false
		}
		globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
		if !globalPromiseSymbol {
			return false
		}
		constructorSymbol := getSymbolAtLocation(decl.parent.parent.expression, true)
		return constructorSymbol == globalPromiseSymbol
	}
	getArgumentArityError := func(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ any {
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex > -1 {
			return createDiagnosticForNode(args[spreadIndex], Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter)
		}
		min := Number.POSITIVE_INFINITY
		max := Number.NEGATIVE_INFINITY
		maxBelow := Number.NEGATIVE_INFINITY
		minAbove := Number.POSITIVE_INFINITY
		var closestSignature *Signature
		for _, sig := range signatures {
			minParameter := getMinArgumentCount(sig)
			maxParameter := getParameterCount(sig)
			if minParameter < min {
				min = minParameter
				closestSignature = sig
			}
			max = Math.max(max, maxParameter)
			if minParameter < args.length && minParameter > maxBelow {
				maxBelow = minParameter
			}
			if args.length < maxParameter && maxParameter < minAbove {
				minAbove = maxParameter
			}
		}
		hasRestParameter := some(signatures, hasEffectiveRestParameter)
		parameterRange := /* TODO(Node ConditionalExpression): hasRestParameter ? min : min < max ? min + "-" + max : min */ TODO
		isVoidPromiseError := !hasRestParameter && parameterRange == 1 && args.length == 0 && isPromiseResolveArityError(node)
		if isVoidPromiseError && isInJSFile(node) {
			return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments)
		}
		error := /* TODO(Node ConditionalExpression): isDecorator(node) ? hasRestParameter ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 : Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 : hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 : isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise : Diagnostics.Expected_0_arguments_but_got_1 */ TODO
		if min < args.length && args.length < max {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
				chain = chainDiagnosticMessages(chain, headMessage)
				return getDiagnosticForCallNode(node, chain)
			}
			return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
		} else if args.length < min {
			var diagnostic Diagnostic
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				diagnostic = getDiagnosticForCallNode(node, chain)
			} else {
				diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length)
			}
			parameter := closestSignature. /*?*/ declaration. /*?*/ parameters[ /* TODO(Node ConditionalExpression): closestSignature.thisParameter ? args.length + 1 : args.length */ TODO]
			if parameter {
				var messageAndArgs DiagnosticAndArguments = /* TODO(Node ConditionalExpression): isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided] : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))] : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))] */ TODO
				parameterError := createDiagnosticForNode(parameter, messageAndArgs...)
				return addRelatedInfo(diagnostic, parameterError)
			}
			return diagnostic
		} else {
			errorSpan := factory.createNodeArray(args.slice(max))
			pos := first(errorSpan).pos
			end := last(errorSpan).end
			if end == pos {
				end++
			}
			setTextRangePosEnd(errorSpan, pos, end)
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length)
		}
	}
	getTypeArgumentArityError := func(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
		argCount := typeArguments.length
		if signatures.length == 1 {
			sig := signatures[0]
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(Node ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(Node ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
		}
		belowArgCount := -Infinity
		aboveArgCount := Infinity
		for _, sig := range signatures {
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if min > argCount {
				aboveArgCount = Math.min(aboveArgCount, min)
			} else if max < argCount {
				belowArgCount = Math.max(belowArgCount, max)
			}
		}
		if belowArgCount != -Infinity && aboveArgCount != Infinity {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
		}
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(Node ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(Node ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
	}
	resolveCall := func(node CallLikeExpression, signatures []Signature, candidatesOutArray *[]Signature, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
		isTaggedTemplate := node.kind == SyntaxKindTaggedTemplateExpression
		isDecorator := node.kind == SyntaxKindDecorator
		isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
		isInstanceof := node.kind == SyntaxKindBinaryExpression
		reportErrors := !isInferencePartiallyBlocked && !candidatesOutArray
		var typeArguments *NodeArray[TypeNode]
		if !isDecorator && !isInstanceof && !isSuperCall(node) {
			typeArguments = (node).typeArguments
			if isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (node).expression.kind != SyntaxKindSuperKeyword {
				forEach(typeArguments, checkSourceElement)
			}
		}
		candidates := candidatesOutArray || [] /* TODO inferred type never */ any{}
		reorderCandidates(signatures, candidates, callChainFlags)
		Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this")
		args := getEffectiveCallArguments(node)
		isSingleNonGenericCandidate := candidates.length == 1 && !candidates[0].typeParameters
		argCheckMode := /* TODO(Node ConditionalExpression): !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal */ TODO
		var candidatesForArgumentError *[]Signature
		var candidateForArgumentArityError *Signature
		var candidateForTypeArgumentError *Signature
		var result *Signature
		signatureHelpTrailingComma := !!(checkMode & CheckModeIsForSignatureHelp) && node.kind == SyntaxKindCallExpression && node.arguments.hasTrailingComma
		if candidates.length > 1 {
			result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if !result {
			result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if result {
			return result
		}
		result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode)
		getNodeLinks(node).resolvedSignature = result
		if reportErrors {
			if !headMessage && isInstanceof {
				headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method
			}
			if candidatesForArgumentError {
				if candidatesForArgumentError.length == 1 || candidatesForArgumentError.length > 3 {
					last := candidatesForArgumentError[candidatesForArgumentError.length-1]
					var chain *DiagnosticMessageChain
					if candidatesForArgumentError.length > 3 {
						chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error)
						chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call)
					}
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					diags := getSignatureApplicabilityError(node, args, last, assignableRelation, CheckModeNormal, true, func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ any {
						return chain
					}, nil)
					if diags {
						for _, d := range diags {
							if last.declaration && candidatesForArgumentError.length > 3 {
								addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here))
							}
							addImplementationSuccessElaboration(last, d)
							diagnostics.add(d)
						}
					} else {
						Debug.fail("No error for last overload signature")
					}
				} else {
					var allDiagnostics [][]DiagnosticRelatedInformation = [] /* TODO inferred type never */ any{}
					max := 0
					min := Number.MAX_VALUE
					minIndex := 0
					i := 0
					for _, c := range candidatesForArgumentError {
						chain := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ any {
							return chainDiagnosticMessages(nil, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i+1, candidates.length, signatureToString(c))
						}
						diags := getSignatureApplicabilityError(node, args, c, assignableRelation, CheckModeNormal, true, chain, nil)
						if diags {
							if diags.length <= min {
								min = diags.length
								minIndex = i
							}
							max = Math.max(max, diags.length)
							allDiagnostics.push(diags)
						} else {
							Debug.fail("No error for 3 or fewer overload signatures")
						}
						i++
					}
					diags := /* TODO(Node ConditionalExpression): max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics) */ TODO
					Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures")
					chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic), Diagnostics.No_overload_matches_this_call)
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					related := [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ any{ /* TODO(Node SpreadElement): ...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[] */ }
					var diag Diagnostic
					if every(diags, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ any) /* TODO inferred type boolean */ any {
						return d.start == diags[0].start && d.length == diags[0].length && d.file == diags[0].file
					}) {
						TODO_IDENTIFIER := diags[0]
						diag = /* TODO(Node ObjectLiteralExpression): { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related } */ TODO
					} else {
						diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related)
					}
					addImplementationSuccessElaboration(candidatesForArgumentError[0], diag)
					diagnostics.add(diag)
				}
			} else if candidateForArgumentArityError {
				diagnostics.add(getArgumentArityError(node, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{candidateForArgumentArityError}, args, headMessage))
			} else if candidateForTypeArgumentError {
				checkTypeArguments(candidateForTypeArgumentError, (node).typeArguments, true, headMessage)
			} else {
				signaturesWithCorrectTypeArgumentArity := filter(signatures, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
					return hasCorrectTypeArgumentArity(s, typeArguments)
				})
				if signaturesWithCorrectTypeArgumentArity.length == 0 {
					diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments, headMessage))
				} else {
					diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage))
				}
			}
		}
		return result
		addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
			oldCandidatesForArgumentError := candidatesForArgumentError
			oldCandidateForArgumentArityError := candidateForArgumentArityError
			oldCandidateForTypeArgumentError := candidateForTypeArgumentError
			failedSignatureDeclarations := failed.declaration. /*?*/ symbol. /*?*/ declarations || emptyArray
			isOverload := failedSignatureDeclarations.length > 1
			implDecl := /* TODO(Node ConditionalExpression): isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined */ TODO
			if implDecl {
				candidate := getSignatureFromDeclaration(implDecl)
				isSingleNonGenericCandidate := !candidate.typeParameters
				if chooseOverload([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{candidate}, assignableRelation, isSingleNonGenericCandidate) {
					addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible))
				}
			}
			candidatesForArgumentError = oldCandidatesForArgumentError
			candidateForArgumentArityError = oldCandidateForArgumentArityError
			candidateForTypeArgumentError = oldCandidateForTypeArgumentError
		}
		chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma /* TODO inferred type boolean */ any /*  = false */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
			candidatesForArgumentError = nil
			candidateForArgumentArityError = nil
			candidateForTypeArgumentError = nil
			if isSingleNonGenericCandidate {
				candidate := candidates[0]
				if some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					return nil
				}
				if getSignatureApplicabilityError(node, args, candidate, relation, CheckModeNormal, false, nil, nil) {
					candidatesForArgumentError = [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{candidate}
					return nil
				}
				return candidate
			}
			for candidateIndex := 0; candidateIndex < candidates.length; candidateIndex++ {
				candidate := candidates[candidateIndex]
				if !hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					continue
				}
				var checkCandidate Signature
				var inferenceContext *InferenceContext
				if candidate.typeParameters {
					paramLocation := candidate.typeParameters[0].symbol.declarations[0]. /*?*/ parent
					candidateParameterContext := paramLocation || ( /* TODO(Node ConditionalExpression): candidate.declaration && isConstructorDeclaration(candidate.declaration) ? candidate.declaration.parent : candidate.declaration */ TODO)
					if candidateParameterContext && findAncestor(node, func(a /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
						return a == candidateParameterContext
					}) {
						candidate = getImplementationSignature(candidate)
					}
					var typeArgumentTypes *[]Type
					if some(typeArguments) {
						typeArgumentTypes = checkTypeArguments(candidate, typeArguments, false)
						if !typeArgumentTypes {
							candidateForTypeArgumentError = candidate
							continue
						}
					} else {
						inferenceContext = createInferenceContext(candidate.typeParameters, candidate /* TODO(Node ConditionalExpression): isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None */, TODO)
						typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode|CheckModeSkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper)
						argCheckMode |= /* TODO(Node ConditionalExpression): inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal */ TODO
					}
					checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters)
					if getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma) {
						candidateForArgumentArityError = checkCandidate
						continue
					}
				} else {
					checkCandidate = candidate
				}
				if getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, nil, inferenceContext) {
					(candidatesForArgumentError || ( /* TODO(Node BinaryExpression): candidatesForArgumentError = [] */ TODO)).push(checkCandidate)
					continue
				}
				if argCheckMode {
					argCheckMode = CheckModeNormal
					if inferenceContext {
						typeArgumentTypes := instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper)
						checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters)
						if getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma) {
							candidateForArgumentArityError = checkCandidate
							continue
						}
					}
					if getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, nil, inferenceContext) {
						(candidatesForArgumentError || ( /* TODO(Node BinaryExpression): candidatesForArgumentError = [] */ TODO)).push(checkCandidate)
						continue
					}
				}
				candidates[candidateIndex] = checkCandidate
				return checkCandidate
			}
			return nil
		}
	}
	getCandidateForOverloadFailure := func(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
		Debug.assert(candidates.length > 0)
		checkNodeDeferred(node)
		// converted from conditional expression
		switch {
		case hasCandidatesOutArray || candidates.length == 1 || candidates.some(func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
			return !!c.typeParameters
		}):
			return pickLongestCandidateSignature(node, candidates, args, checkMode)
		default:
			return createUnionOfSignaturesForOverloadFailure(candidates)
		}
	}
	createUnionOfSignaturesForOverloadFailure := func(candidates []Signature) Signature {
		thisParameters := mapDefined(candidates, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			return c.thisParameter
		})
		var thisParameter *Symbol
		if thisParameters.length {
			thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map_(getTypeOfParameter))
		}
		TODO_IDENTIFIER := minAndMax(candidates, getNumNonRestParameters)
		var parameters []Symbol = [] /* TODO inferred type never */ any{}
		for i := 0; i < maxNonRestParam; i++ {
			symbols := mapDefined(candidates, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
				return /* TODO(Node ConditionalExpression): signatureHasRestParameter(s) ? i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) : i < s.parameters.length ? s.parameters[i] : undefined */ TODO
			})
			Debug.assert(symbols.length != 0)
			parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, func(candidate /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
				return tryGetTypeAtPosition(candidate, i)
			})))
		}
		restParameterSymbols := mapDefined(candidates, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
			return /* TODO(Node ConditionalExpression): signatureHasRestParameter(c) ? last(c.parameters) : undefined */ TODO
		})
		flags := SignatureFlagsIsSignatureCandidateForOverloadFailure
		if restParameterSymbols.length != 0 {
			type_ := createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReductionSubtype))
			parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type_))
			flags |= SignatureFlagsHasRestParameter
		}
		if candidates.some(signatureHasLiteralTypes) {
			flags |= SignatureFlagsHasLiteralTypes
		}
		return createSignature(candidates[0].declaration, nil, thisParameter, parameters, getIntersectionType(candidates.map_(getReturnTypeOfSignature)), nil, minArgumentCount, flags)
	}
	getNumNonRestParameters := func(signature Signature) number {
		numParams := signature.parameters.length
		// converted from conditional expression
		switch {
		case signatureHasRestParameter(signature):
			return numParams - 1
		default:
			return numParams
		}
	}
	createCombinedSymbolFromTypes := func(sources []Symbol, types []Type) Symbol {
		return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReductionSubtype))
	}
	createCombinedSymbolForOverloadFailure := func(sources []Symbol, type_ Type) Symbol {
		return createSymbolWithType(first(sources), type_)
	}
	pickLongestCandidateSignature := func(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
		bestIndex := getLongestCandidateIndex(candidates /* TODO(Node ConditionalExpression): apparentArgumentCount === undefined ? args.length : apparentArgumentCount */, TODO)
		candidate := candidates[bestIndex]
		TODO_IDENTIFIER := candidate
		if !typeParameters {
			return candidate
		}
		var typeArgumentNodes *[]TypeNode = /* TODO(Node ConditionalExpression): callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined */ TODO
		instantiated := /* TODO(Node ConditionalExpression): typeArgumentNodes ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node))) : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode) */ TODO
		candidates[bestIndex] = instantiated
		return instantiated
	}
	getTypeArgumentsFromNodes := func(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
		typeArguments := typeArgumentNodes.map_(getTypeOfNode)
		for typeArguments.length > typeParameters.length {
			typeArguments.pop()
		}
		for typeArguments.length < typeParameters.length {
			typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs))
		}
		return typeArguments
	}
	inferSignatureInstantiationForOverloadFailure := func(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
		inferenceContext := createInferenceContext(typeParameters, candidate /* TODO(Node ConditionalExpression): isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None */, TODO)
		typeArgumentTypes := inferTypeArguments(node, candidate, args, checkMode|CheckModeSkipContextSensitive|CheckModeSkipGenericFunctions, inferenceContext)
		return createSignatureInstantiation(candidate, typeArgumentTypes)
	}
	getLongestCandidateIndex := func(candidates []Signature, argsCount number) number {
		maxParamsIndex := -1
		maxParams := -1
		for i := 0; i < candidates.length; i++ {
			candidate := candidates[i]
			paramCount := getParameterCount(candidate)
			if hasEffectiveRestParameter(candidate) || paramCount >= argsCount {
				return i
			}
			if paramCount > maxParams {
				maxParams = paramCount
				maxParamsIndex = i
			}
		}
		return maxParamsIndex
	}
	resolveCallExpression := func(node CallExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		if node.expression.kind == SyntaxKindSuperKeyword {
			superType := checkSuperExpression(node.expression)
			if isTypeAny(superType) {
				for _, arg := range node.arguments {
					checkExpression(arg)
				}
				return anySignature
			}
			if !isErrorType(superType) {
				baseTypeNode := getEffectiveBaseTypeNode(getContainingClass(node))
				if baseTypeNode {
					baseConstructors := getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode)
					return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			}
			return resolveUntypedCall(node)
		}
		var callChainFlags SignatureFlags
		funcType := checkExpression(node.expression)
		if isCallChain(node) {
			nonOptionalType := getOptionalExpressionType(funcType, node.expression)
			callChainFlags = /* TODO(Node ConditionalExpression): nonOptionalType === funcType ? SignatureFlags.None : isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain : SignatureFlags.IsInnerCallChain */ TODO
			funcType = nonOptionalType
		} else {
			callChainFlags = SignatureFlagsNone
		}
		funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError)
		if funcType == silentNeverType {
			return silentNeverSignature
		}
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			if !isErrorType(funcType) && node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if numConstructSignatures {
				error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			} else {
				var relatedInformation *DiagnosticRelatedInformation
				if node.arguments.length == 1 {
					text := getSourceFileOfNode(node).text
					if isLineBreak(text.charCodeAt(skipTrivia(text, node.expression.end, true) - 1)) {
						relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon)
					}
				}
				invocationError(node.expression, apparentType, SignatureKindCall, relatedInformation)
			}
			return resolveErrorCall(node)
		}
		if checkMode&CheckModeSkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction) {
			skippedGenericFunction(node, checkMode)
			return resolvingSignature
		}
		if callSignatures.some(func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
			return isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration)
		}) {
			error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
	}
	isGenericFunctionReturningFunction := func(signature Signature) /* TODO inferred type boolean */ any {
		return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)))
	}
	isUntypedFunctionCall := func(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
		return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags&TypeFlagsTypeParameter) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags&TypeFlagsUnion) && !(getReducedType(apparentFuncType).flags&TypeFlagsNever) && isTypeAssignableTo(funcType, globalFunctionType)
	}
	resolveNewExpression := func(node NewExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		expressionType := checkNonNullExpression(node.expression)
		if expressionType == silentNeverType {
			return silentNeverSignature
		}
		expressionType = getApparentType(expressionType)
		if isErrorType(expressionType) {
			return resolveErrorCall(node)
		}
		if isTypeAny(expressionType) {
			if node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		constructSignatures := getSignaturesOfType(expressionType, SignatureKindConstruct)
		if constructSignatures.length {
			if !isConstructorAccessible(node, constructSignatures[0]) {
				return resolveErrorCall(node)
			}
			if someSignature(constructSignatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
				return !!(signature.flags & SignatureFlagsAbstract)
			}) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			valueDecl := expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol)
			if valueDecl && hasSyntacticModifier(valueDecl, ModifierFlagsAbstract) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
		}
		callSignatures := getSignaturesOfType(expressionType, SignatureKindCall)
		if callSignatures.length {
			signature := resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
			if !noImplicitAny {
				if signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) != voidType {
					error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword)
				}
				if getThisTypeOfSignature(signature) == voidType {
					error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void)
				}
			}
			return signature
		}
		invocationError(node.expression, expressionType, SignatureKindConstruct)
		return resolveErrorCall(node)
	}
	someSignature := func(signatures /* TODO(TypeNode UnionType): Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
		if isArray(signatures) {
			return some(signatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
				return someSignature(signature, f)
			})
		}
		// converted from conditional expression
		switch {
		case signatures.compositeKind == TypeFlagsUnion:
			return some(signatures.compositeSignatures, f)
		default:
			return f(signatures)
		}
	}
	typeHasProtectedAccessibleBase := func(target Symbol, type_ InterfaceType) bool {
		baseTypes := getBaseTypes(type_)
		if !length(baseTypes) {
			return false
		}
		firstBase := baseTypes[0]
		if firstBase.flags & TypeFlagsIntersection {
			types := (firstBase).types
			mixinFlags := findMixins(types)
			i := 0
			for _, intersectionMember := range (firstBase).types {
				if !mixinFlags[i] {
					if getObjectFlags(intersectionMember) & (ObjectFlagsClass | ObjectFlagsInterface) {
						if intersectionMember.symbol == target {
							return true
						}
						if typeHasProtectedAccessibleBase(target, intersectionMember) {
							return true
						}
					}
				}
				i++
			}
			return false
		}
		if firstBase.symbol == target {
			return true
		}
		return typeHasProtectedAccessibleBase(target, firstBase)
	}
	isConstructorAccessible := func(node NewExpression, signature Signature) /* TODO inferred type boolean */ any {
		if !signature || !signature.declaration {
			return true
		}
		declaration := signature.declaration
		modifiers := getSelectedEffectiveModifierFlags(declaration, ModifierFlagsNonPublicAccessibilityModifier)
		if !modifiers || declaration.kind != SyntaxKindConstructor {
			return true
		}
		declaringClassDeclaration := getClassLikeDeclarationOfSymbol(declaration.parent.symbol)
		declaringClass := getDeclaredTypeOfSymbol(declaration.parent.symbol)
		if !isNodeWithinClass(node, declaringClassDeclaration) {
			containingClass := getContainingClass(node)
			if containingClass && modifiers&ModifierFlagsProtected {
				containingType := getTypeOfNode(containingClass)
				if typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType) {
					return true
				}
			}
			if modifiers & ModifierFlagsPrivate {
				error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			if modifiers & ModifierFlagsProtected {
				error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			return false
		}
		return true
	}
	invocationErrorDetails := func(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TypeNode TypeLiteral): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ any {
		var errorInfo *DiagnosticMessageChain
		isCall := kind == SignatureKindCall
		awaitedType := getAwaitedType(apparentType)
		maybeMissingAwait := awaitedType && getSignaturesOfType(awaitedType, kind).length > 0
		if apparentType.flags & TypeFlagsUnion {
			types := (apparentType).types
			hasSignatures := false
			for _, constituent := range types {
				signatures := getSignaturesOfType(constituent, kind)
				if signatures.length != 0 {
					hasSignatures = true
					if errorInfo {
						break
					}
				} else {
					if !errorInfo {
						errorInfo = chainDiagnosticMessages(errorInfo /* TODO(Node ConditionalExpression): isCall ? Diagnostics.Type_0_has_no_call_signatures : Diagnostics.Type_0_has_no_construct_signatures */, TODO, typeToString(constituent))
						errorInfo = chainDiagnosticMessages(errorInfo /* TODO(Node ConditionalExpression): isCall ? Diagnostics.Not_all_constituents_of_type_0_are_callable : Diagnostics.Not_all_constituents_of_type_0_are_constructable */, TODO, typeToString(apparentType))
					}
					if hasSignatures {
						break
					}
				}
			}
			if !hasSignatures {
				errorInfo = chainDiagnosticMessages(nil /* TODO(Node ConditionalExpression): isCall ? Diagnostics.No_constituent_of_type_0_is_callable : Diagnostics.No_constituent_of_type_0_is_constructable */, TODO, typeToString(apparentType))
			}
			if !errorInfo {
				errorInfo = chainDiagnosticMessages(errorInfo /* TODO(Node ConditionalExpression): isCall ? Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other : Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other */, TODO, typeToString(apparentType))
			}
		} else {
			errorInfo = chainDiagnosticMessages(errorInfo /* TODO(Node ConditionalExpression): isCall ? Diagnostics.Type_0_has_no_call_signatures : Diagnostics.Type_0_has_no_construct_signatures */, TODO, typeToString(apparentType))
		}
		headMessage := /* TODO(Node ConditionalExpression): isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable */ TODO
		if isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length == 0 {
			TODO_IDENTIFIER := getNodeLinks(errorTarget)
			if resolvedSymbol && resolvedSymbol.flags&SymbolFlagsGetAccessor {
				headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without
			}
		}
		return /* TODO(Node ObjectLiteralExpression): { messageChain: chainDiagnosticMessages(errorInfo, headMessage), relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined, } */ TODO
	}
	invocationError := func(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
		TODO_IDENTIFIER := invocationErrorDetails(errorTarget, apparentType, kind)
		diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
		if relatedInfo {
			addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo))
		}
		if isCallExpression(errorTarget.parent) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(errorTarget.parent)
			diagnostic.start = start
			diagnostic.length = length
		}
		diagnostics.add(diagnostic)
		invocationErrorRecovery(apparentType, kind /* TODO(Node ConditionalExpression): relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic */, TODO)
	}
	invocationErrorRecovery := func(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
		if !apparentType.symbol {
			return
		}
		importNode := getSymbolLinks(apparentType.symbol).originatingImport
		if importNode && !isImportCall(importNode) {
			sigs := getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target), kind)
			if !sigs || !sigs.length {
				return
			}
			addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead))
		}
	}
	resolveTaggedTemplateExpression := func(node TaggedTemplateExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		tagType := checkExpression(node.tag)
		apparentType := getApparentType(tagType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if isArrayLiteralExpression(node.parent) {
				diagnostic := createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked)
				diagnostics.add(diagnostic)
				return resolveErrorCall(node)
			}
			invocationError(node.tag, apparentType, SignatureKindCall)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	getDiagnosticHeadMessageForDecoratorResolution := func(node Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ any {
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression
		case SyntaxKindParameter:
			return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression
		case SyntaxKindPropertyDeclaration:
			return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression
		default:
			return Debug.fail()
		}
	}
	resolveDecorator := func(node Decorator, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		funcType := checkExpression(node.expression)
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression) {
			nodeStr := getTextOfNode(node.expression, false)
			error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr)
			return resolveErrorCall(node)
		}
		headMessage := getDiagnosticHeadMessageForDecoratorResolution(node)
		if !callSignatures.length {
			errorDetails := invocationErrorDetails(node.expression, apparentType, SignatureKindCall)
			messageChain := chainDiagnosticMessages(errorDetails.messageChain, headMessage)
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain)
			if errorDetails.relatedMessage {
				addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage))
			}
			diagnostics.add(diag)
			invocationErrorRecovery(apparentType, SignatureKindCall, diag)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone, headMessage)
	}
	createSignatureForJSXIntrinsic := func(node JsxOpeningLikeElement, result Type) Signature {
		namespace := getJsxNamespaceAt(node)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, JsxNames.Element, SymbolFlagsType)
		returnNode := typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlagsType, node)
		declaration := factory.createFunctionTypeNode(nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any{factory.createParameterDeclaration(nil, nil, "props", nil, nodeBuilder.typeToTypeNode(result, node))} /* TODO(Node ConditionalExpression): returnNode ? factory.createTypeReferenceNode(returnNode, /*typeArguments* / undefined) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */, TODO)
		parameterSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "props")
		parameterSymbol.links.type_ = result
		return createSignature(declaration, nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{parameterSymbol} /* TODO(Node ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */, TODO, nil, 1, SignatureFlagsNone)
	}
	resolveJsxOpeningLikeElement := func(node JsxOpeningLikeElement, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		if isJsxIntrinsicTagName(node.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
			fakeSignature := createSignatureForJSXIntrinsic(node, result)
			checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), nil, CheckModeNormal), result, node.tagName, node.attributes)
			if length(node.typeArguments) {
				forEach(node.typeArguments, checkSourceElement)
				diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)))
			}
			return fakeSignature
		}
		exprTypes := checkExpression(node.tagName)
		apparentType := getApparentType(exprTypes)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		signatures := getUninstantiatedJsxSignaturesOfType(exprTypes, node)
		if isUntypedFunctionCall(exprTypes, apparentType, signatures.length, 0) {
			return resolveUntypedCall(node)
		}
		if signatures.length == 0 {
			error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName))
			return resolveErrorCall(node)
		}
		return resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	resolveInstanceofExpression := func(node InstanceofExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		rightType := checkExpression(node.right)
		if !isTypeAny(rightType) {
			hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(rightType)
			if hasInstanceMethodType {
				apparentType := getApparentType(hasInstanceMethodType)
				if isErrorType(apparentType) {
					return resolveErrorCall(node)
				}
				callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
				constructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct)
				if isUntypedFunctionCall(hasInstanceMethodType, apparentType, callSignatures.length, constructSignatures.length) {
					return resolveUntypedCall(node)
				}
				if callSignatures.length {
					return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			} else if !(typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)) {
				error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method)
				return resolveErrorCall(node)
			}
		}
		return anySignature
	}
	isPotentiallyUncalledDecorator := func(decorator Decorator, signatures []Signature) /* TODO inferred type boolean | 0 */ any {
		return signatures.length && every(signatures, func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
			return signature.minArgumentCount == 0 && !signatureHasRestParameter(signature) && signature.parameters.length < getDecoratorArgumentCount(decorator, signature)
		})
	}
	resolveSignature := func(node CallLikeExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		switch node.kind {
		case SyntaxKindCallExpression:
			return resolveCallExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindNewExpression:
			return resolveNewExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindTaggedTemplateExpression:
			return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode)
		case SyntaxKindDecorator:
			return resolveDecorator(node, candidatesOutArray, checkMode)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode)
		case SyntaxKindBinaryExpression:
			return resolveInstanceofExpression(node, candidatesOutArray, checkMode)
		}
		Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.")
	}
	getResolvedSignature := func(node CallLikeExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
		links := getNodeLinks(node)
		cached := links.resolvedSignature
		if cached && cached != resolvingSignature && !candidatesOutArray {
			return cached
		}
		saveResolutionStart := resolutionStart
		if !cached {
			resolutionStart = resolutionTargets.length
		}
		links.resolvedSignature = resolvingSignature
		result := resolveSignature(node, candidatesOutArray, checkMode || CheckModeNormal)
		resolutionStart = saveResolutionStart
		if result != resolvingSignature {
			if links.resolvedSignature != resolvingSignature {
				result = links.resolvedSignature
			}
			links.resolvedSignature = /* TODO(Node ConditionalExpression): flowLoopStart === flowLoopCount ? result : cached */ TODO
		}
		return result
	}
	isJSConstructor := func(node Node) /* TODO(TypeNode TypePredicate): node is FunctionDeclaration | FunctionExpression */ any {
		if !node || !isInJSFile(node) {
			return false
		}
		func_ := /* TODO(Node ConditionalExpression): isFunctionDeclaration(node) || isFunctionExpression(node) ? node : (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer : undefined */ TODO
		if func_ {
			if getJSDocClassTag(node) {
				return true
			}
			if isPropertyAssignment(walkUpParenthesizedExpressions(func_.parent)) {
				return false
			}
			symbol := getSymbolOfDeclaration(func_)
			return !!symbol. /*?*/ members. /*?*/ size
		}
		return false
	}
	mergeJSSymbols := func(target Symbol, source *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol | undefined */ any {
		if source {
			links := getSymbolLinks(source)
			if !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) {
				inferred := /* TODO(Node ConditionalExpression): isTransientSymbol(target) ? target : cloneSymbol(target) */ TODO
				inferred.exports = inferred.exports || createSymbolTable()
				inferred.members = inferred.members || createSymbolTable()
				inferred.flags |= source.flags & SymbolFlagsClass
				if source.exports. /*?*/ size {
					mergeSymbolTable(inferred.exports, source.exports)
				}
				if source.members. /*?*/ size {
					mergeSymbolTable(inferred.members, source.members)
				}
				(links.inferredClassSymbol || ( /* TODO(Node BinaryExpression): links.inferredClassSymbol = new Map() */ TODO)).set(getSymbolId(inferred), inferred)
				return inferred
			}
			return links.inferredClassSymbol.get(getSymbolId(target))
		}
	}
	getAssignedClassSymbol := func(decl Declaration) *Symbol {
		assignmentSymbol := decl && getSymbolOfExpando(decl, true)
		prototype := assignmentSymbol. /*?*/ exports. /*?*/ get("prototype")
		init := prototype. /*?*/ valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration)
		// converted from conditional expression
		switch {
		case init:
			return getSymbolOfDeclaration(init)
		default:
			return nil
		}
	}
	getSymbolOfExpando := func(node Node, allowDeclaration bool) *Symbol {
		if !node.parent {
			return nil
		}
		var name /* TODO(TypeNode UnionType): Expression | BindingName | undefined */ any
		var decl Node
		if isVariableDeclaration(node.parent) && node.parent.initializer == node {
			if !isInJSFile(node) && !(isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) {
				return nil
			}
			name = node.parent.name
			decl = node.parent
		} else if isBinaryExpression(node.parent) {
			parentNode := node.parent
			parentNodeOperator := node.parent.operatorToken.kind
			if parentNodeOperator == SyntaxKindEqualsToken && (allowDeclaration || parentNode.right == node) {
				name = parentNode.left
				decl = name
			} else if parentNodeOperator == SyntaxKindBarBarToken || parentNodeOperator == SyntaxKindQuestionQuestionToken {
				if isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer == parentNode {
					name = parentNode.parent.name
					decl = parentNode.parent
				} else if isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind == SyntaxKindEqualsToken && (allowDeclaration || parentNode.parent.right == parentNode) {
					name = parentNode.parent.left
					decl = name
				}
				if !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left) {
					return nil
				}
			}
		} else if allowDeclaration && isFunctionDeclaration(node) {
			name = node.name
			decl = node
		}
		if !decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) {
			return nil
		}
		return getSymbolOfNode(decl)
	}
	getAssignedJSPrototype := func(node Node) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralExpression | undefined */ any {
		if !node.parent {
			return false
		}
		var parent Node = node.parent
		for parent && parent.kind == SyntaxKindPropertyAccessExpression {
			parent = parent.parent
		}
		if parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind == SyntaxKindEqualsToken {
			right := getInitializerOfBinaryExpression(parent)
			return isObjectLiteralExpression(right) && right
		}
	}
	checkCallExpression := func(node /* TODO(TypeNode UnionType): CallExpression | NewExpression */ any, checkMode CheckMode) Type {
		checkGrammarTypeArguments(node, node.typeArguments)
		signature := getResolvedSignature(node, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		checkDeprecatedSignature(signature, node)
		if node.expression.kind == SyntaxKindSuperKeyword {
			return voidType
		}
		if node.kind == SyntaxKindNewExpression {
			declaration := signature.declaration
			if declaration && declaration.kind != SyntaxKindConstructor && declaration.kind != SyntaxKindConstructSignature && declaration.kind != SyntaxKindConstructorType && !(isJSDocSignature(declaration) && getJSDocRoot(declaration). /*?*/ parent. /*?*/ kind == SyntaxKindConstructor) && !isJSDocConstructSignature(declaration) && !isJSConstructor(declaration) {
				if noImplicitAny {
					error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type)
				}
				return anyType
			}
		}
		if isInJSFile(node) && isCommonJsRequire(node) {
			return resolveExternalModuleTypeByLiteral(node.arguments[0])
		}
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags&TypeFlagsESSymbolLike && isSymbolOrSymbolForCall(node) {
			return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent))
		}
		if node.kind == SyntaxKindCallExpression && !node.questionDotToken && node.parent.kind == SyntaxKindExpressionStatement && returnType.flags&TypeFlagsVoid && getTypePredicateOfSignature(signature) {
			if !isDottedName(node.expression) {
				error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name)
			} else if !getEffectsSignature(node) {
				diagnostic := error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation)
				getTypeOfDottedName(node.expression, diagnostic)
			}
		}
		if isInJSFile(node) {
			jsSymbol := getSymbolOfExpando(node, false)
			if jsSymbol. /*?*/ exports. /*?*/ size {
				jsAssignmentType := createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray)
				jsAssignmentType.objectFlags |= ObjectFlagsJSLiteral
				return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{returnType, jsAssignmentType})
			}
		}
		return returnType
	}
	checkDeprecatedSignature := func(signature Signature, node CallLikeExpression) {
		if signature.flags & SignatureFlagsIsSignatureCandidateForOverloadFailure {
			return
		}
		if signature.declaration && signature.declaration.flags&NodeFlagsDeprecated {
			suggestionNode := getDeprecatedSuggestionNode(node)
			name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
			addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature))
		}
	}
	getDeprecatedSuggestionNode := func(node Node) Node {
		node = skipParentheses(node)
		switch node.kind {
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindDecorator:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			return getDeprecatedSuggestionNode((node).expression)
		case SyntaxKindTaggedTemplateExpression:
			return getDeprecatedSuggestionNode((node).tag)
		case SyntaxKindJsxOpeningElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			return getDeprecatedSuggestionNode((node).tagName)
		case SyntaxKindElementAccessExpression:
			return (node).argumentExpression
		case SyntaxKindPropertyAccessExpression:
			return (node).name
		case SyntaxKindTypeReference:
			typeReference := node
			// converted from conditional expression
			switch {
			case isQualifiedName(typeReference.typeName):
				return typeReference.typeName.right
			default:
				return typeReference
			}
		default:
			return node
		}
	}
	isSymbolOrSymbolForCall := func(node Node) /* TODO inferred type boolean */ any {
		if !isCallExpression(node) {
			return false
		}
		left := node.expression
		if isPropertyAccessExpression(left) && left.name.escapedText == "for" {
			left = left.expression
		}
		if !isIdentifier(left) || left.escapedText != "Symbol" {
			return false
		}
		globalESSymbol := getGlobalESSymbolConstructorSymbol(false)
		if !globalESSymbol {
			return false
		}
		return globalESSymbol == resolveName(left, "Symbol", SymbolFlagsValue, nil, false)
	}
	checkImportCallExpression := func(node ImportCall) Type {
		checkGrammarImportCallExpression(node)
		if node.arguments.length == 0 {
			return createPromiseReturnType(node, anyType)
		}
		specifier := node.arguments[0]
		specifierType := checkExpressionCached(specifier)
		optionsType := /* TODO(Node ConditionalExpression): node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : undefined */ TODO
		for i := 2; i < node.arguments.length; i++ {
			checkExpressionCached(node.arguments[i])
		}
		if specifierType.flags&TypeFlagsUndefined || specifierType.flags&TypeFlagsNull || !isTypeAssignableTo(specifierType, stringType) {
			error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType))
		}
		if optionsType {
			importCallOptionsType := getGlobalImportCallOptionsType(true)
			if importCallOptionsType != emptyObjectType {
				checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, TypeFlagsUndefined), node.arguments[1])
			}
		}
		moduleSymbol := resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			esModuleSymbol := resolveESModuleSymbol(moduleSymbol, specifier, true, false)
			if esModuleSymbol {
				return createPromiseReturnType(node, getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier))
			}
		}
		return createPromiseReturnType(node, anyType)
	}
	createDefaultPropertyWrapperForModule := func(symbol Symbol, originalSymbol *Symbol, anonymousSymbol *Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ any {
		memberTable := createSymbolTable()
		newSymbol := createSymbol(SymbolFlagsAlias, InternalSymbolNameDefault)
		newSymbol.parent = originalSymbol
		newSymbol.links.nameType = getStringLiteralType("default")
		newSymbol.links.aliasTarget = resolveSymbol(symbol)
		memberTable.set(InternalSymbolNameDefault, newSymbol)
		return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
	}
	getTypeWithSyntheticDefaultOnly := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		hasDefaultOnly := isOnlyImportableAsDefault(moduleSpecifier)
		if hasDefaultOnly && type_ && !isErrorType(type_) {
			synthType := type_
			if !synthType.defaultOnlyType {
				type_ := createDefaultPropertyWrapperForModule(symbol, originalSymbol)
				synthType.defaultOnlyType = type_
			}
			return synthType.defaultOnlyType
		}
		return nil
	}
	getTypeWithSyntheticDefaultImportType := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
		if allowSyntheticDefaultImports && type_ && !isErrorType(type_) {
			synthType := type_
			if !synthType.syntheticType {
				file := originalSymbol.declarations. /*?*/ find(isSourceFile)
				hasSyntheticDefault := canHaveSyntheticDefault(file, originalSymbol, false, moduleSpecifier)
				if hasSyntheticDefault {
					anonymousSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
					defaultContainingObject := createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
					anonymousSymbol.links.type_ = defaultContainingObject
					synthType.syntheticType = /* TODO(Node ConditionalExpression): isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags* / 0, /*readonly* / false) : defaultContainingObject */ TODO
				} else {
					synthType.syntheticType = type_
				}
			}
			return synthType.syntheticType
		}
		return type_
	}
	isCommonJsRequire := func(node Node) bool {
		if !isRequireCall(node, true) {
			return false
		}
		if !isIdentifier(node.expression) {
			return Debug.fail()
		}
		resolvedRequire := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue, nil, true)
		if resolvedRequire == requireSymbol {
			return true
		}
		if resolvedRequire.flags & SymbolFlagsAlias {
			return false
		}
		targetDeclarationKind := /* TODO(Node ConditionalExpression): resolvedRequire.flags & SymbolFlags.Function ? SyntaxKind.FunctionDeclaration : resolvedRequire.flags & SymbolFlags.Variable ? SyntaxKind.VariableDeclaration : SyntaxKind.Unknown */ TODO
		if targetDeclarationKind != SyntaxKindUnknown {
			decl := getDeclarationOfKind(resolvedRequire, targetDeclarationKind)
			return !!decl && !!(decl.flags & NodeFlagsAmbient)
		}
		return false
	}
	checkTaggedTemplateExpression := func(node TaggedTemplateExpression) Type {
		if !checkGrammarTaggedTemplateChain(node) {
			checkGrammarTypeArguments(node, node.typeArguments)
		}
		if languageVersion < LanguageFeatureMinimumTargetTaggedTemplates {
			checkExternalEmitHelpers(node, ExternalEmitHelpersMakeTemplateObject)
		}
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		return getReturnTypeOfSignature(signature)
	}
	checkAssertion := func(node AssertionExpression, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if node.kind == SyntaxKindTypeAssertionExpression {
			file := getSourceFileOfNode(node)
			if file && fileExtensionIsOneOf(file.fileName, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Extension */ any{ExtensionCts, ExtensionMts}) {
				grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead)
			}
		}
		return checkAssertionWorker(node, checkMode)
	}
	isValidConstAssertionArgument := func(node Node) bool {
		switch node.kind {
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTemplateExpression:
			return true
		case SyntaxKindParenthesizedExpression:
			return isValidConstAssertionArgument((node).expression)
		case SyntaxKindPrefixUnaryExpression:
			op := (node).operator
			arg := (node).operand
			return op == SyntaxKindMinusToken && (arg.kind == SyntaxKindNumericLiteral || arg.kind == SyntaxKindBigIntLiteral) || op == SyntaxKindPlusToken && arg.kind == SyntaxKindNumericLiteral
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			expr := skipParentheses((node).expression)
			symbol := /* TODO(Node ConditionalExpression): isEntityNameExpression(expr) ? resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors* / true) : undefined */ TODO
			return !!(symbol && symbol.flags&SymbolFlagsEnum)
		}
		return false
	}
	checkAssertionWorker := func(node /* TODO(TypeNode UnionType): JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		exprType := checkExpression(expression, checkMode)
		if isConstTypeReference(type_) {
			if !isValidConstAssertionArgument(expression) {
				error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals)
			}
			return getRegularTypeOfLiteralType(exprType)
		}
		links := getNodeLinks(node)
		links.assertionExpressionType = exprType
		checkSourceElement(type_)
		checkNodeDeferred(node)
		return getTypeFromTypeNode(type_)
	}
	getAssertionTypeAndExpression := func(node /* TODO(TypeNode UnionType): JSDocTypeAssertion | AssertionExpression */ any) /* TODO inferred type { type: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode; expression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; } */ any {
		var type_ TypeNode
		var expression Expression
		switch node.kind {
		case SyntaxKindAsExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAssertionExpression:
			type_ = node.type_
			expression = node.expression
			break
		case SyntaxKindParenthesizedExpression:
			type_ = getJSDocTypeAssertionType(node)
			expression = node.expression
			break
		}
		return /* TODO(Node ObjectLiteralExpression): { type, expression } */ TODO
	}
	checkAssertionDeferred := func(node /* TODO(TypeNode UnionType): JSDocTypeAssertion | AssertionExpression */ any) {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		errNode := /* TODO(Node ConditionalExpression): isParenthesizedExpression(node) ? type : node */ TODO
		links := getNodeLinks(node)
		Debug.assertIsDefined(links.assertionExpressionType)
		exprType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(links.assertionExpressionType))
		targetType := getTypeFromTypeNode(type_)
		if !isErrorType(targetType) {
			addLazyDiagnostic(func() {
				widenedType := getWidenedType(exprType)
				if !isTypeComparableTo(targetType, widenedType) {
					checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first)
				}
			})
		}
	}
	checkNonNullChain := func(node NonNullChain) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType != leftType)
	}
	checkNonNullAssertion := func(node NonNullExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case node.flags & NodeFlagsOptionalChain:
			return checkNonNullChain(node)
		default:
			return getNonNullableType(checkExpression(node.expression))
		}
	}
	checkExpressionWithTypeArguments := func(node /* TODO(TypeNode UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		checkGrammarExpressionWithTypeArguments(node)
		forEach(node.typeArguments, checkSourceElement)
		if node.kind == SyntaxKindExpressionWithTypeArguments {
			parent := walkUpParenthesizedExpressions(node.parent)
			if parent.kind == SyntaxKindBinaryExpression && (parent).operatorToken.kind == SyntaxKindInstanceOfKeyword && isNodeDescendantOf(node, (parent).right) {
				error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression)
			}
		}
		exprType := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.ExpressionWithTypeArguments ? checkExpression(node.expression) : isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) : checkExpression(node.exprName) */ TODO
		return getInstantiationExpressionType(exprType, node)
	}
	getInstantiationExpressionType := func(exprType Type, node NodeWithTypeArguments) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		typeArguments := node.typeArguments
		if exprType == silentNeverType || isErrorType(exprType) || !some(typeArguments) {
			return exprType
		}
		hasSomeApplicableSignature := false
		var nonApplicableType *Type
		result := getInstantiatedType(exprType)
		errorType := /* TODO(Node ConditionalExpression): hasSomeApplicableSignature ? nonApplicableType : exprType */ TODO
		if errorType {
			diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType)))
		}
		return result
		getInstantiatedType := func(type_ Type) Type {
			hasSignatures := false
			hasApplicableSignature := false
			result := getInstantiatedTypePart(type_)
			/* TODO(Node BinaryExpression): hasSomeApplicableSignature ||= hasApplicableSignature */ TODO
			if hasSignatures && !hasApplicableSignature {
				/* TODO(Node BinaryExpression): nonApplicableType ??= type */ TODO
			}
			return result
			getInstantiatedTypePart := func(type_ Type) Type {
				if type_.flags & TypeFlagsObject {
					resolved := resolveStructuredTypeMembers(type_)
					callSignatures := getInstantiatedSignatures(resolved.callSignatures)
					constructSignatures := getInstantiatedSignatures(resolved.constructSignatures)
					/* TODO(Node BinaryExpression): hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0 */ TODO
					/* TODO(Node BinaryExpression): hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0 */ TODO
					if callSignatures != resolved.callSignatures || constructSignatures != resolved.constructSignatures {
						result := createAnonymousType(createSymbol(SymbolFlagsNone, InternalSymbolNameInstantiationExpression), resolved.members, callSignatures, constructSignatures, resolved.indexInfos)
						result.objectFlags |= ObjectFlagsInstantiationExpressionType
						result.node = node
						return result
					}
				} else if type_.flags & TypeFlagsInstantiableNonPrimitive {
					constraint := getBaseConstraintOfType(type_)
					if constraint {
						instantiated := getInstantiatedTypePart(constraint)
						if instantiated != constraint {
							return instantiated
						}
					}
				} else if type_.flags & TypeFlagsUnion {
					return mapType(type_, getInstantiatedType)
				} else if type_.flags & TypeFlagsIntersection {
					return getIntersectionType(sameMap((type_).types, getInstantiatedTypePart))
				}
				return type_
			}
		}
		getInstantiatedSignatures := func(signatures []Signature) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ any {
			applicableSignatures := filter(signatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
				return !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments)
			})
			return sameMap(applicableSignatures, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
				typeArgumentTypes := checkTypeArguments(sig, typeArguments, true)
				// converted from conditional expression
				switch {
				case typeArgumentTypes:
					return getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration))
				default:
					return sig
				}
			})
		}
	}
	checkSatisfiesExpression := func(node SatisfiesExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		checkSourceElement(node.type_)
		return checkSatisfiesExpressionWorker(node.expression, node.type_)
	}
	checkSatisfiesExpressionWorker := func(expression Expression, target TypeNode, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		exprType := checkExpression(expression, checkMode)
		targetType := getTypeFromTypeNode(target)
		if isErrorType(targetType) {
			return targetType
		}
		errorNode := findAncestor(target.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return n.kind == SyntaxKindSatisfiesExpression || n.kind == SyntaxKindJSDocSatisfiesTag
		})
		checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1)
		return exprType
	}
	checkMetaProperty := func(node MetaProperty) Type {
		checkGrammarMetaProperty(node)
		if node.keywordToken == SyntaxKindNewKeyword {
			return checkNewTargetMetaProperty(node)
		}
		if node.keywordToken == SyntaxKindImportKeyword {
			return checkImportMetaProperty(node)
		}
		return Debug.assertNever(node.keywordToken)
	}
	checkMetaPropertyKeyword := func(node MetaProperty) Type {
		switch node.keywordToken {
		case SyntaxKindImportKeyword:
			return getGlobalImportMetaExpressionType()
		case SyntaxKindNewKeyword:
			type_ := checkNewTargetMetaProperty(node)
			// converted from conditional expression
			switch {
			case isErrorType(type_):
				return errorType
			default:
				return createNewTargetExpressionType(type_)
			}
		default:
			Debug.assertNever(node.keywordToken)
		}
	}
	checkNewTargetMetaProperty := func(node MetaProperty) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		container := getNewTargetContainer(node)
		if !container {
			error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target")
			return errorType
		} else if container.kind == SyntaxKindConstructor {
			symbol := getSymbolOfDeclaration(container.parent)
			return getTypeOfSymbol(symbol)
		} else {
			symbol := getSymbolOfDeclaration(container)
			return getTypeOfSymbol(symbol)
		}
	}
	checkImportMetaProperty := func(node MetaProperty) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any {
		if moduleKind == ModuleKindNode16 || moduleKind == ModuleKindNodeNext {
			if getSourceFileOfNode(node).impliedNodeFormat != ModuleKindESNext {
				error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output)
			}
		} else if moduleKind < ModuleKindES2020 && moduleKind != ModuleKindSystem {
			error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext)
		}
		file := getSourceFileOfNode(node)
		Debug.assert(!!(file.flags & NodeFlagsPossiblyContainsImportMeta), "Containing file is missing import meta node flag.")
		// converted from conditional expression
		switch {
		case node.name.escapedText == "meta":
			return getGlobalImportMetaType()
		default:
			return errorType
		}
	}
	getTypeOfParameter := func(symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		declaration := symbol.valueDeclaration
		return addOptionality(getTypeOfSymbol(symbol), false, !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)))
	}
	getTupleElementLabelFromBindingElement := func(node /* TODO(TypeNode UnionType): BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
		switch node.name.kind {
		case SyntaxKindIdentifier:
			name := node.name.escapedText
			if node.dotDotDotToken {
				// converted from conditional expression
				switch {
				case elementFlags & ElementFlagsVariable:
					return name
				default:
					return /* TODO(Node TemplateExpression): `${name}_${index}` */ TODO
				}
			} else {
				// converted from conditional expression
				switch {
				case elementFlags & ElementFlagsFixed:
					return name
				default:
					return /* TODO(Node TemplateExpression): `${name}_n` */ TODO
				}
			}
			fallthrough
		case SyntaxKindArrayBindingPattern:
			if node.dotDotDotToken {
				elements := node.name.elements
				lastElement := tryCast(lastOrUndefined(elements), isBindingElement)
				elementCount := elements.length - ( /* TODO(Node ConditionalExpression): lastElement?.dotDotDotToken ? 1 : 0 */ TODO)
				if index < elementCount {
					element := elements[index]
					if isBindingElement(element) {
						return getTupleElementLabelFromBindingElement(element, index, elementFlags)
					}
				} else if lastElement. /*?*/ dotDotDotToken {
					return getTupleElementLabelFromBindingElement(lastElement, index-elementCount, elementFlags)
				}
			}
			break
		}
		return /* TODO(Node TemplateExpression): `arg_${index}` */ TODO
	}
	/* OVERLOAD: function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember): __String; */
	/* OVERLOAD: function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index: number, elementFlags: ElementFlags, restSymbol?: Symbol): __String; */
	getTupleElementLabel := func(d /* TODO(TypeNode UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index /* TODO inferred type number */ any /*  = 0 */, elementFlags /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any /*  = ElementFlags.Fixed */, restSymbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any {
		if !d {
			restParameter := tryCast(restSymbol. /*?*/ valueDeclaration, isParameter)
			// converted from conditional expression
			switch {
			case restParameter:
				return getTupleElementLabelFromBindingElement(restParameter, index, elementFlags)
			default:
				return /* TODO(Node TemplateExpression): `${restSymbol?.escapedName ?? "arg"}_${index}` */ TODO
			}
		}
		Debug.assert(isIdentifier(d.name))
		return d.name.escapedText
	}
	getParameterNameAtPosition := func(signature Signature, pos number, overrideRestType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any {
		paramCount := signature.parameters.length - ( /* TODO(Node ConditionalExpression): signatureHasRestParameter(signature) ? 1 : 0 */ TODO)
		if pos < paramCount {
			return signature.parameters[pos].escapedName
		}
		restParameter := signature.parameters[paramCount] || unknownSymbol
		restType := overrideRestType || getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			tupleType := (restType).target
			index := pos - paramCount
			associatedName := tupleType.labeledElementDeclarations[index]
			elementFlags := tupleType.elementFlags[index]
			return getTupleElementLabel(associatedName, index, elementFlags, restParameter)
		}
		return restParameter.escapedName
	}
	getParameterIdentifierInfoAtPosition := func(signature Signature, pos number) * /* TODO(TypeNode TypeLiteral): { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
		if signature.declaration. /*?*/ kind == SyntaxKindJSDocFunctionType {
			return nil
		}
		paramCount := signature.parameters.length - ( /* TODO(Node ConditionalExpression): signatureHasRestParameter(signature) ? 1 : 0 */ TODO)
		if pos < paramCount {
			param := signature.parameters[pos]
			paramIdent := getParameterDeclarationIdentifier(param)
			// converted from conditional expression
			switch {
			case paramIdent:
				return /* TODO(Node ObjectLiteralExpression): { parameter: paramIdent, parameterName: param.escapedName, isRestParameter: false, } */ TODO
			default:
				return nil
			}
		}
		restParameter := signature.parameters[paramCount] || unknownSymbol
		restIdent := getParameterDeclarationIdentifier(restParameter)
		if !restIdent {
			return nil
		}
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType).target).labeledElementDeclarations
			index := pos - paramCount
			associatedName := associatedNames[index]
			isRestTupleElement := !!associatedName. /*?*/ dotDotDotToken
			if associatedName {
				Debug.assert(isIdentifier(associatedName.name))
				return /* TODO(Node ObjectLiteralExpression): { parameter: associatedName.name, parameterName: associatedName.name.escapedText, isRestParameter: isRestTupleElement } */ TODO
			}
			return nil
		}
		if pos == paramCount {
			return /* TODO(Node ObjectLiteralExpression): { parameter: restIdent, parameterName: restParameter.escapedName, isRestParameter: true } */ TODO
		}
		return nil
	}
	getParameterDeclarationIdentifier := func(symbol Symbol) /* TODO inferred type false | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | undefined */ any {
		return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name
	}
	isValidDeclarationForTupleLabel := func(d Declaration) /* TODO(TypeNode TypePredicate): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ any {
		return d.kind == SyntaxKindNamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name))
	}
	getNameableDeclarationAtPosition := func(signature Signature, pos number) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ any {
		paramCount := signature.parameters.length - ( /* TODO(Node ConditionalExpression): signatureHasRestParameter(signature) ? 1 : 0 */ TODO)
		if pos < paramCount {
			decl := signature.parameters[pos].valueDeclaration
			// converted from conditional expression
			switch {
			case decl && isValidDeclarationForTupleLabel(decl):
				return decl
			default:
				return nil
			}
		}
		restParameter := signature.parameters[paramCount] || unknownSymbol
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType).target).labeledElementDeclarations
			index := pos - paramCount
			return associatedNames && associatedNames[index]
		}
		// converted from conditional expression
		switch {
		case restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration):
			return restParameter.valueDeclaration
		default:
			return nil
		}
	}
	getTypeAtPosition := func(signature Signature, pos number) Type {
		return tryGetTypeAtPosition(signature, pos) || anyType
	}
	tryGetTypeAtPosition := func(signature Signature, pos number) *Type {
		paramCount := signature.parameters.length - ( /* TODO(Node ConditionalExpression): signatureHasRestParameter(signature) ? 1 : 0 */ TODO)
		if pos < paramCount {
			return getTypeOfParameter(signature.parameters[pos])
		}
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[paramCount])
			index := pos - paramCount
			if !isTupleType(restType) || restType.target.combinedFlags&ElementFlagsVariable || index < restType.target.fixedLength {
				return getIndexedAccessType(restType, getNumberLiteralType(index))
			}
		}
		return nil
	}
	getRestTypeAtPosition := func(source Signature, pos number, readonly bool) Type {
		parameterCount := getParameterCount(source)
		minArgumentCount := getMinArgumentCount(source)
		restType := getEffectiveRestType(source)
		if restType && pos >= parameterCount-1 {
			// converted from conditional expression
			switch {
			case pos == parameterCount-1:
				return restType
			default:
				return createArrayType(getIndexedAccessType(restType, numberType))
			}
		}
		types := [] /* TODO inferred type never */ any{}
		flags := [] /* TODO inferred type never */ any{}
		names := [] /* TODO inferred type never */ any{}
		for i := pos; i < parameterCount; i++ {
			if !restType || i < parameterCount-1 {
				types.push(getTypeAtPosition(source, i))
				flags.push( /* TODO(Node ConditionalExpression): i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional */ TODO)
			} else {
				types.push(restType)
				flags.push(ElementFlagsVariadic)
			}
			names.push(getNameableDeclarationAtPosition(source, i))
		}
		return createTupleType(types, flags, readonly, names)
	}
	getRestOrAnyTypeAtPosition := func(source Signature, pos number) Type {
		restType := getRestTypeAtPosition(source, pos)
		elementType := restType && getElementTypeOfArrayType(restType)
		// converted from conditional expression
		switch {
		case elementType && isTypeAny(elementType):
			return anyType
		default:
			return restType
		}
	}
	getParameterCount := func(signature Signature) /* TODO inferred type number */ any {
		length := signature.parameters.length
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[length-1])
			if isTupleType(restType) {
				return length + restType.target.fixedLength - ( /* TODO(Node ConditionalExpression): restType.target.combinedFlags & ElementFlags.Variable ? 0 : 1 */ TODO)
			}
		}
		return length
	}
	getMinArgumentCount := func(signature Signature, flags MinArgumentCountFlags) /* TODO inferred type number */ any {
		strongArityForUntypedJS := flags & MinArgumentCountFlagsStrongArityForUntypedJS
		voidIsNonOptional := flags & MinArgumentCountFlagsVoidIsNonOptional
		if voidIsNonOptional || signature.resolvedMinArgumentCount == nil {
			var minArgumentCount *number
			if signatureHasRestParameter(signature) {
				restType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
				if isTupleType(restType) {
					firstOptionalIndex := findIndex(restType.target.elementFlags, func(f /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ any) /* TODO inferred type boolean */ any {
						return !(f & ElementFlagsRequired)
					})
					requiredCount := /* TODO(Node ConditionalExpression): firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex */ TODO
					if requiredCount > 0 {
						minArgumentCount = signature.parameters.length - 1 + requiredCount
					}
				}
			}
			if minArgumentCount == nil {
				if !strongArityForUntypedJS && signature.flags&SignatureFlagsIsUntypedSignatureInJSFile {
					return 0
				}
				minArgumentCount = signature.minArgumentCount
			}
			if voidIsNonOptional {
				return minArgumentCount
			}
			for i := minArgumentCount - 1; i >= 0; i-- {
				type_ := getTypeAtPosition(signature, i)
				if filterType(type_, acceptsVoid).flags & TypeFlagsNever {
					break
				}
				minArgumentCount = i
			}
			signature.resolvedMinArgumentCount = minArgumentCount
		}
		return signature.resolvedMinArgumentCount
	}
	hasEffectiveRestParameter := func(signature Signature) /* TODO inferred type boolean */ any {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			return !isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlagsVariable)
		}
		return false
	}
	getEffectiveRestType := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			if !isTupleType(restType) {
				// converted from conditional expression
				switch {
				case isTypeAny(restType):
					return anyArrayType
				default:
					return restType
				}
			}
			if restType.target.combinedFlags & ElementFlagsVariable {
				return sliceTupleType(restType, restType.target.fixedLength)
			}
		}
		return nil
	}
	getNonArrayRestType := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		restType := getEffectiveRestType(signature)
		// converted from conditional expression
		switch {
		case restType && !isArrayType(restType) && !isTypeAny(restType):
			return restType
		default:
			return nil
		}
	}
	getTypeOfFirstParameterOfSignature := func(signature Signature) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType)
	}
	getTypeOfFirstParameterOfSignatureWithFallback := func(signature Signature, fallbackType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case signature.parameters.length > 0:
			return getTypeAtPosition(signature, 0)
		default:
			return fallbackType
		}
	}
	inferFromAnnotatedParameters := func(signature Signature, context Signature, inferenceContext InferenceContext) {
		len := signature.parameters.length - ( /* TODO(Node ConditionalExpression): signatureHasRestParameter(signature) ? 1 : 0 */ TODO)
		for i := 0; i < len; i++ {
			declaration := signature.parameters[i].valueDeclaration
			typeNode := getEffectiveTypeAnnotationNode(declaration)
			if typeNode {
				source := addOptionality(getTypeFromTypeNode(typeNode), false, isOptionalDeclaration(declaration))
				target := getTypeAtPosition(context, i)
				inferTypes(inferenceContext.inferences, source, target)
			}
		}
	}
	assignContextualParameterTypes := func(signature Signature, context Signature) {
		if context.typeParameters {
			if !signature.typeParameters {
				signature.typeParameters = context.typeParameters
			} else {
				return
			}
		}
		if context.thisParameter {
			parameter := signature.thisParameter
			if !parameter || parameter.valueDeclaration && !(parameter.valueDeclaration).type_ {
				if !parameter {
					signature.thisParameter = createSymbolWithType(context.thisParameter, nil)
				}
				assignParameterType(signature.thisParameter, getTypeOfSymbol(context.thisParameter))
			}
		}
		len := signature.parameters.length - ( /* TODO(Node ConditionalExpression): signatureHasRestParameter(signature) ? 1 : 0 */ TODO)
		for i := 0; i < len; i++ {
			parameter := signature.parameters[i]
			declaration := parameter.valueDeclaration
			if !getEffectiveTypeAnnotationNode(declaration) {
				type_ := tryGetTypeAtPosition(context, i)
				if type_ && declaration.initializer {
					initializerType := checkDeclarationInitializer(declaration, CheckModeNormal)
					if !isTypeAssignableTo(initializerType, type_) && isTypeAssignableTo(type_ /* TODO(Node BinaryExpression): initializerType = widenTypeInferredFromInitializer(declaration, initializerType) */, TODO) {
						type_ = initializerType
					}
				}
				assignParameterType(parameter, type_)
			}
		}
		if signatureHasRestParameter(signature) {
			parameter := last(signature.parameters)
			if /* TODO(Node ConditionalExpression): parameter.valueDeclaration ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration) // a declarationless parameter may still have a `.type` already set by its construction logic // (which may pull a type from a jsdoc) - only allow fixing on `DeferredType` parameters with a fallback type : !!(getCheckFlags(parameter) & CheckFlags.DeferredType) */ TODO {
				contextualParameterType := getRestTypeAtPosition(context, len)
				assignParameterType(parameter, contextualParameterType)
			}
		}
	}
	assignNonContextualParameterTypes := func(signature Signature) {
		if signature.thisParameter {
			assignParameterType(signature.thisParameter)
		}
		for _, parameter := range signature.parameters {
			assignParameterType(parameter)
		}
	}
	assignParameterType := func(parameter Symbol, contextualType Type) {
		links := getSymbolLinks(parameter)
		if !links.type_ {
			declaration := parameter.valueDeclaration
			links.type_ = addOptionality(contextualType || ( /* TODO(Node ConditionalExpression): declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true) : getTypeOfSymbol(parameter) */ TODO), false, !!declaration && !declaration.initializer && isOptionalDeclaration(declaration))
			if declaration && declaration.name.kind != SyntaxKindIdentifier {
				if links.type_ == unknownType {
					links.type_ = getTypeFromBindingPattern(declaration.name)
				}
				assignBindingElementTypes(declaration.name, links.type_)
			}
		} else if contextualType {
			Debug.assertEqual(links.type_, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type")
		}
	}
	assignBindingElementTypes := func(pattern BindingPattern, parentType Type) {
		for _, element := range pattern.elements {
			if !isOmittedExpression(element) {
				type_ := getBindingElementTypeFromParentType(element, parentType, false)
				if element.name.kind == SyntaxKindIdentifier {
					getSymbolLinks(getSymbolOfDeclaration(element)).type_ = type_
				} else {
					assignBindingElementTypes(element.name, type_)
				}
			}
		}
	}
	createClassDecoratorContextType := func(classType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassDecoratorContextType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{classType})
	}
	createClassMethodDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	createClassGetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	createClassSetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	createClassAccessorDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	createClassFieldDecoratorContextType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	getClassMemberDecoratorContextOverrideType := func(nameType Type, isPrivate bool, isStatic bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		key := /* TODO(Node TemplateExpression): `${isPrivate ? "p" : "P"}${isStatic ? "s" : "S"}${nameType.id}` */ TODO
		overrideType := decoratorContextOverrideTypeCache.get(key)
		if !overrideType {
			members := createSymbolTable()
			members.set("name", createProperty("name", nameType))
			members.set("private", createProperty("private" /* TODO(Node ConditionalExpression): isPrivate ? trueType : falseType */, TODO))
			members.set("static", createProperty("static" /* TODO(Node ConditionalExpression): isStatic ? trueType : falseType */, TODO))
			overrideType = createAnonymousType(nil, members, emptyArray, emptyArray, emptyArray)
			decoratorContextOverrideTypeCache.set(key, overrideType)
		}
		return overrideType
	}
	createClassMemberDecoratorContextTypeForNode := func(node /* TODO(TypeNode UnionType): MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		isStatic := hasStaticModifier(node)
		isPrivate := isPrivateIdentifier(node.name)
		nameType := /* TODO(Node ConditionalExpression): isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name) */ TODO
		contextType := /* TODO(Node ConditionalExpression): isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) : isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) : isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) : isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) : isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) : Debug.failBadSyntaxKind(node) */ TODO
		overrideType := getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
		return getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{contextType, overrideType})
	}
	createClassAccessorDecoratorTargetType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	createClassAccessorDecoratorResultType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(true), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{thisType, valueType})
	}
	createClassFieldDecoratorInitializerMutatorType := func(thisType Type, valueType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		thisParam := createParameter("this", thisType)
		valueParam := createParameter("value", valueType)
		return createFunctionType(nil, thisParam, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{valueParam}, valueType, nil, 1)
	}
	createESDecoratorCallSignature := func(targetType Type, contextType Type, nonOptionalReturnType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		targetParam := createParameter("target", targetType)
		contextParam := createParameter("context", contextType)
		returnType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{nonOptionalReturnType, voidType})
		return createCallSignature(nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{targetParam, contextParam}, returnType)
	}
	getESDecoratorCallSignature := func(decorator Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			switch parent.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				node := parent
				targetType := getTypeOfSymbol(getSymbolOfDeclaration(node))
				contextType := createClassDecoratorContextType(targetType)
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType)
				break
				fallthrough
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				node := parent
				if !isClassLike(node.parent) {
					break
				}
				valueType := /* TODO(Node ConditionalExpression): isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) : getTypeOfNode(node) */ TODO
				thisType := /* TODO(Node ConditionalExpression): hasStaticModifier(node) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) : getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent)) */ TODO
				targetType := /* TODO(Node ConditionalExpression): isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) : isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) : valueType */ TODO
				contextType := createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)
				returnType := /* TODO(Node ConditionalExpression): isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) : isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) : valueType */ TODO
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType)
				break
				fallthrough
			case SyntaxKindPropertyDeclaration:
				node := parent
				if !isClassLike(node.parent) {
					break
				}
				valueType := getTypeOfNode(node)
				thisType := /* TODO(Node ConditionalExpression): hasStaticModifier(node) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) : getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent)) */ TODO
				targetType := /* TODO(Node ConditionalExpression): hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) : undefinedType */ TODO
				contextType := createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)
				returnType := /* TODO(Node ConditionalExpression): hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) : createClassFieldDecoratorInitializerMutatorType(thisType, valueType) */ TODO
				links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType)
				break
			}
		}
		// converted from conditional expression
		switch {
		case links.decoratorSignature == anySignature:
			return nil
		default:
			return links.decoratorSignature
		}
	}
	getLegacyDecoratorCallSignature := func(decorator Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			switch parent.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				node := parent
				targetType := getTypeOfSymbol(getSymbolOfDeclaration(node))
				targetParam := createParameter("target", targetType)
				links.decoratorSignature = createCallSignature(nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{targetParam}, getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{targetType, voidType}))
				break
				fallthrough
			case SyntaxKindParameter:
				node := parent
				if !isConstructorDeclaration(node.parent) && !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent)) {
					break
				}
				if getThisParameter(node.parent) == node {
					break
				}
				index := /* TODO(Node ConditionalExpression): getThisParameter(node.parent) ? node.parent.parameters.indexOf(node) - 1 : node.parent.parameters.indexOf(node) */ TODO
				Debug.assert(index >= 0)
				targetType := /* TODO(Node ConditionalExpression): isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) : getParentTypeOfClassElement(node.parent) */ TODO
				keyType := /* TODO(Node ConditionalExpression): isConstructorDeclaration(node.parent) ? undefinedType : getClassElementPropertyKeyType(node.parent) */ TODO
				indexType := getNumberLiteralType(index)
				targetParam := createParameter("target", targetType)
				keyParam := createParameter("propertyKey", keyType)
				indexParam := createParameter("parameterIndex", indexType)
				links.decoratorSignature = createCallSignature(nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{targetParam, keyParam, indexParam}, voidType)
				break
				fallthrough
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyDeclaration:
				node := parent
				if !isClassLike(node.parent) {
					break
				}
				targetType := getParentTypeOfClassElement(node)
				targetParam := createParameter("target", targetType)
				keyType := getClassElementPropertyKeyType(node)
				keyParam := createParameter("propertyKey", keyType)
				returnType := /* TODO(Node ConditionalExpression): isPropertyDeclaration(node) ? voidType : createTypedPropertyDescriptorType(getTypeOfNode(node)) */ TODO
				hasPropDesc := !isPropertyDeclaration(parent) || hasAccessorModifier(parent)
				if hasPropDesc {
					descriptorType := createTypedPropertyDescriptorType(getTypeOfNode(node))
					descriptorParam := createParameter("descriptor", descriptorType)
					links.decoratorSignature = createCallSignature(nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{targetParam, keyParam, descriptorParam}, getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{returnType, voidType}))
				} else {
					links.decoratorSignature = createCallSignature(nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{targetParam, keyParam}, getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{returnType, voidType}))
				}
				break
			}
		}
		// converted from conditional expression
		switch {
		case links.decoratorSignature == anySignature:
			return nil
		default:
			return links.decoratorSignature
		}
	}
	getDecoratorCallSignature := func(decorator Decorator) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ any {
		// converted from conditional expression
		switch {
		case legacyDecorators:
			return getLegacyDecoratorCallSignature(decorator)
		default:
			return getESDecoratorCallSignature(decorator)
		}
	}
	createPromiseType := func(promisedType Type) Type {
		globalPromiseType := getGlobalPromiseType(true)
		if globalPromiseType != emptyGenericType {
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseType, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{promisedType})
		}
		return unknownType
	}
	createPromiseLikeType := func(promisedType Type) Type {
		globalPromiseLikeType := getGlobalPromiseLikeType(true)
		if globalPromiseLikeType != emptyGenericType {
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseLikeType, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{promisedType})
		}
		return unknownType
	}
	createPromiseReturnType := func(func_ /* TODO(TypeNode UnionType): FunctionLikeDeclaration | ImportCall */ any, promisedType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		promiseType := createPromiseType(promisedType)
		if promiseType == unknownType {
			error(func_ /* TODO(Node ConditionalExpression): isImportCall(func) ? Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option : Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option */, TODO)
			return errorType
		} else if !getGlobalPromiseConstructorSymbol(true) {
			error(func_ /* TODO(Node ConditionalExpression): isImportCall(func) ? Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option : Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option */, TODO)
		}
		return promiseType
	}
	createNewTargetExpressionType := func(targetType Type) Type {
		symbol := createSymbol(SymbolFlagsNone, "NewTargetExpression")
		targetPropertySymbol := createSymbol(SymbolFlagsProperty, "target", CheckFlagsReadonly)
		targetPropertySymbol.parent = symbol
		targetPropertySymbol.links.type_ = targetType
		members := createSymbolTable([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{targetPropertySymbol})
		symbol.members = members
		return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	getReturnTypeFromBody := func(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
		if !func_.body {
			return errorType
		}
		functionFlags := getFunctionFlags(func_)
		isAsync := (functionFlags & FunctionFlagsAsync) != 0
		isGenerator := (functionFlags & FunctionFlagsGenerator) != 0
		var returnType *Type
		var yieldType *Type
		var nextType *Type
		var fallbackReturnType Type = voidType
		if func_.body.kind != SyntaxKindBlock {
			returnType = checkExpressionCached(func_.body, checkMode && checkMode&~CheckModeSkipGenericFunctions)
			if isAsync {
				returnType = unwrapAwaitedType(checkAwaitedType(returnType, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
			}
		} else if isGenerator {
			returnTypes := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !returnTypes {
				fallbackReturnType = neverType
			} else if returnTypes.length > 0 {
				returnType = getUnionType(returnTypes, UnionReductionSubtype)
			}
			TODO_IDENTIFIER := checkAndAggregateYieldOperandTypes(func_, checkMode)
			yieldType = /* TODO(Node ConditionalExpression): some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined */ TODO
			nextType = /* TODO(Node ConditionalExpression): some(nextTypes) ? getIntersectionType(nextTypes) : undefined */ TODO
		} else {
			types := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !types {
				// converted from conditional expression
				switch {
				case functionFlags & FunctionFlagsAsync:
					return createPromiseReturnType(func_, neverType)
				default:
					return neverType
				}
			}
			if types.length == 0 {
				contextualReturnType := getContextualReturnType(func_, nil)
				returnType := /* TODO(Node ConditionalExpression): contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType */ TODO
				// converted from conditional expression
				switch {
				case functionFlags & FunctionFlagsAsync:
					return createPromiseReturnType(func_, returnType)
				default:
					return returnType
				}
			}
			returnType = getUnionType(types, UnionReductionSubtype)
		}
		if returnType || yieldType || nextType {
			if yieldType {
				reportErrorsFromWidening(func_, yieldType, WideningKindGeneratorYield)
			}
			if returnType {
				reportErrorsFromWidening(func_, returnType, WideningKindFunctionReturn)
			}
			if nextType {
				reportErrorsFromWidening(func_, nextType, WideningKindGeneratorNext)
			}
			if returnType && isUnitType(returnType) || yieldType && isUnitType(yieldType) || nextType && isUnitType(nextType) {
				contextualSignature := getContextualSignatureForFunctionLikeDeclaration(func_)
				contextualType := /* TODO(Node ConditionalExpression): !contextualSignature ? undefined : contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType : instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags* / undefined) */ TODO
				if isGenerator {
					yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKindYield, isAsync)
					returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKindReturn, isAsync)
					nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKindNext, isAsync)
				} else {
					returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync)
				}
			}
			if yieldType {
				yieldType = getWidenedType(yieldType)
			}
			if returnType {
				returnType = getWidenedType(returnType)
			}
			if nextType {
				nextType = getWidenedType(nextType)
			}
		}
		if isGenerator {
			return createGeneratorType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(IterationTypeKindNext, func_) || unknownType, isAsync)
		} else {
			// converted from conditional expression
			switch {
			case isAsync:
				return createPromiseType(returnType || fallbackReturnType)
			default:
				return returnType || fallbackReturnType
			}
		}
	}
	createGeneratorType := func(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		resolver := /* TODO(Node ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		globalGeneratorType := resolver.getGlobalGeneratorType(false)
		yieldType = resolver.resolveIterationType(yieldType, nil) || unknownType
		returnType = resolver.resolveIterationType(returnType, nil) || unknownType
		if globalGeneratorType == emptyGenericType {
			globalIterableIteratorType := resolver.getGlobalIterableIteratorType(false)
			if globalIterableIteratorType != emptyGenericType {
				return createTypeFromGenericGlobalType(globalIterableIteratorType, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{yieldType, returnType, nextType})
			}
			resolver.getGlobalIterableIteratorType(true)
			return emptyObjectType
		}
		return createTypeFromGenericGlobalType(globalGeneratorType, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{yieldType, returnType, nextType})
	}
	checkAndAggregateYieldOperandTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO inferred type { yieldTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; nextTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; } */ any {
		var yieldTypes []Type = [] /* TODO inferred type never */ any{}
		var nextTypes []Type = [] /* TODO inferred type never */ any{}
		isAsync := (getFunctionFlags(func_) & FunctionFlagsAsync) != 0
		forEachYieldExpression(func_.body, func(yieldExpression /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").YieldExpression */ any) {
			yieldExpressionType := /* TODO(Node ConditionalExpression): yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType */ TODO
			pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync))
			var nextType *Type
			if yieldExpression.asteriskToken {
				iterationTypes := getIterationTypesOfIterable(yieldExpressionType /* TODO(Node ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */, TODO, yieldExpression.expression)
				nextType = iterationTypes && iterationTypes.nextType
			} else {
				nextType = getContextualType(yieldExpression, nil)
			}
			if nextType {
				pushIfUnique(nextTypes, nextType)
			}
		})
		return /* TODO(Node ObjectLiteralExpression): { yieldTypes, nextTypes } */ TODO
	}
	getYieldedTypeOfYieldExpression := func(node YieldExpression, expressionType Type, sentType Type, isAsync bool) *Type {
		errorNode := node.expression || node
		yieldedType := /* TODO(Node ConditionalExpression): node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType */ TODO
		// converted from conditional expression
		switch {
		case !isAsync:
			return yieldedType
		default:
			return getAwaitedType(yieldedType, errorNode /* TODO(Node ConditionalExpression): node.asteriskToken ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member */, TODO)
		}
	}
	getNotEqualFactsFromTypeofSwitch := func(start number, end number, witnesses []*string) TypeFacts {
		var facts TypeFacts = TypeFactsNone
		for i := 0; i < witnesses.length; i++ {
			witness := /* TODO(Node ConditionalExpression): i < start || i >= end ? witnesses[i] : undefined */ TODO
			facts |= /* TODO(Node ConditionalExpression): witness !== undefined ? typeofNEFacts.get(witness) || TypeFacts.TypeofNEHostObject : 0 */ TODO
		}
		return facts
	}
	isExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		links := getNodeLinks(node)
		if links.isExhaustive == nil {
			links.isExhaustive = 0
			exhaustive := computeExhaustiveSwitchStatement(node)
			if links.isExhaustive == 0 {
				links.isExhaustive = exhaustive
			}
		} else if links.isExhaustive == 0 {
			links.isExhaustive = false
		}
		return links.isExhaustive
	}
	computeExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		if node.expression.kind == SyntaxKindTypeOfExpression {
			witnesses := getSwitchClauseTypeOfWitnesses(node)
			if !witnesses {
				return false
			}
			operandConstraint := getBaseConstraintOrType(checkExpressionCached((node.expression).expression))
			notEqualFacts := getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
			if operandConstraint.flags & TypeFlagsAnyOrUnknown {
				return (TypeFactsAllTypeofNE & notEqualFacts) == TypeFactsAllTypeofNE
			}
			return !someType(operandConstraint, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return getTypeFacts(t, notEqualFacts) == notEqualFacts
			})
		}
		type_ := checkExpressionCached(node.expression)
		if !isLiteralType(type_) {
			return false
		}
		switchTypes := getSwitchClauseTypes(node)
		if !switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever) {
			return false
		}
		return eachTypeContainedIn(mapType(type_, getRegularTypeOfLiteralType), switchTypes)
	}
	functionHasImplicitReturn := func(func_ FunctionLikeDeclaration) /* TODO inferred type boolean | undefined */ any {
		return func_.endFlowNode && isReachableFlowNode(func_.endFlowNode)
	}
	checkAndAggregateReturnExpressionTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) *[]Type {
		functionFlags := getFunctionFlags(func_)
		var aggregatedTypes []Type = [] /* TODO inferred type never */ any{}
		hasReturnWithNoExpression := functionHasImplicitReturn(func_)
		hasReturnOfTypeNever := false
		forEachReturnStatement(func_.body, func(returnStatement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ any) {
			expr := returnStatement.expression
			if expr {
				expr = skipParentheses(expr, true)
				if functionFlags&FunctionFlagsAsync && expr.kind == SyntaxKindAwaitExpression {
					expr = skipParentheses((expr).expression, true)
				}
				if expr.kind == SyntaxKindCallExpression && (expr).expression.kind == SyntaxKindIdentifier && checkExpressionCached((expr).expression).symbol == getMergedSymbol(func_.symbol) && (!isFunctionExpressionOrArrowFunction(func_.symbol.valueDeclaration) || isConstantReference((expr).expression)) {
					hasReturnOfTypeNever = true
					return
				}
				type_ := checkExpressionCached(expr, checkMode && checkMode&~CheckModeSkipGenericFunctions)
				if functionFlags & FunctionFlagsAsync {
					type_ = unwrapAwaitedType(checkAwaitedType(type_, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
				}
				if type_.flags & TypeFlagsNever {
					hasReturnOfTypeNever = true
				}
				pushIfUnique(aggregatedTypes, type_)
			} else {
				hasReturnWithNoExpression = true
			}
		})
		if aggregatedTypes.length == 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func_)) {
			return nil
		}
		if strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(func_) && aggregatedTypes.some(func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return t.symbol == func_.symbol
		})) {
			pushIfUnique(aggregatedTypes, undefinedType)
		}
		return aggregatedTypes
	}
	mayReturnNever := func(func_ FunctionLikeDeclaration) bool {
		switch func_.kind {
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			return true
		case SyntaxKindMethodDeclaration:
			return func_.parent.kind == SyntaxKindObjectLiteralExpression
		default:
			return false
		}
	}
	getTypePredicateFromBody := func(func_ FunctionLikeDeclaration) *TypePredicate {
		switch func_.kind {
		case SyntaxKindConstructor:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return nil
		}
		functionFlags := getFunctionFlags(func_)
		if functionFlags != FunctionFlagsNormal {
			return nil
		}
		var singleReturn *Expression
		if func_.body && func_.body.kind != SyntaxKindBlock {
			singleReturn = func_.body
		} else {
			bailedEarly := forEachReturnStatement(func_.body, func(returnStatement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ any) /* TODO inferred type true | undefined */ any {
				if singleReturn || !returnStatement.expression {
					return true
				}
				singleReturn = returnStatement.expression
			})
			if bailedEarly || !singleReturn || functionHasImplicitReturn(func_) {
				return nil
			}
		}
		return checkIfExpressionRefinesAnyParameter(func_, singleReturn)
	}
	checkIfExpressionRefinesAnyParameter := func(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
		expr = skipParentheses(expr, true)
		returnType := checkExpressionCached(expr)
		if !(returnType.flags & TypeFlagsBoolean) {
			return nil
		}
		return forEach(func_.parameters, func(param /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any, i /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate | undefined */ any {
			initType := getTypeOfSymbol(param.symbol)
			if !initType || initType.flags&TypeFlagsBoolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param) {
				return
			}
			trueType := checkIfExpressionRefinesParameter(func_, expr, param, initType)
			if trueType {
				return createTypePredicate(TypePredicateKindIdentifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType)
			}
		})
	}
	checkIfExpressionRefinesParameter := func(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) *Type {
		antecedent := (expr).flowNode || expr.parent.kind == SyntaxKindReturnStatement && (expr.parent).flowNode || createFlowNode(FlowFlagsStart, nil, nil)
		trueCondition := createFlowNode(FlowFlagsTrueCondition, expr, antecedent)
		trueType := getFlowTypeOfReference(param.name, initType, initType, func_, trueCondition)
		if trueType == initType {
			return nil
		}
		falseCondition := createFlowNode(FlowFlagsFalseCondition, expr, antecedent)
		falseSubtype := getFlowTypeOfReference(param.name, initType, trueType, func_, falseCondition)
		// converted from conditional expression
		switch {
		case falseSubtype.flags & TypeFlagsNever:
			return trueType
		default:
			return nil
		}
	}
	checkAllCodePathsInNonVoidFunctionReturnOrThrow := func(func_ /* TODO(TypeNode UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnType *Type) {
		addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics)
		return
		checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
			functionFlags := getFunctionFlags(func_)
			type_ := returnType && unwrapReturnType(returnType, functionFlags)
			if type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)) {
				return
			}
			if func_.kind == SyntaxKindMethodSignature || nodeIsMissing(func_.body) || func_.body.kind != SyntaxKindBlock || !functionHasImplicitReturn(func_) {
				return
			}
			hasExplicitReturn := func_.flags & NodeFlagsHasExplicitReturn
			errorNode := getEffectiveReturnTypeNode(func_) || func_
			if type_ && type_.flags&TypeFlagsNever {
				error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point)
			} else if type_ && !hasExplicitReturn {
				error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value)
			} else if type_ && strictNullChecks && !isTypeAssignableTo(undefinedType, type_) {
				error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined)
			} else if compilerOptions.noImplicitReturns {
				if !type_ {
					if !hasExplicitReturn {
						return
					}
					inferredReturnType := getReturnTypeOfSignature(getSignatureFromDeclaration(func_))
					if isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {
						return
					}
				}
				error(errorNode, Diagnostics.Not_all_code_paths_return_a_value)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(TypeNode UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		checkNodeDeferred(node)
		if isFunctionExpression(node) {
			checkCollisionsForDeclarationName(node, node.name)
		}
		if checkMode && checkMode&CheckModeSkipContextSensitive && isContextSensitive(node) {
			if !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) {
				contextualSignature := getContextualSignature(node)
				if contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature)) {
					links := getNodeLinks(node)
					if links.contextFreeType {
						return links.contextFreeType
					}
					returnType := getReturnTypeFromBody(node, checkMode)
					returnOnlySignature := createSignature(nil, nil, nil, emptyArray, returnType, nil, 0, SignatureFlagsIsNonInferrable)
					returnOnlyType := createAnonymousType(node.symbol, emptySymbols, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any{returnOnlySignature}, emptyArray, emptyArray)
					returnOnlyType.objectFlags |= ObjectFlagsNonInferrableType
					links.contextFreeType = returnOnlyType
					return links.contextFreeType
				}
			}
			return anyFunctionType
		}
		hasGrammarError := checkGrammarFunctionLikeDeclaration(node)
		if !hasGrammarError && node.kind == SyntaxKindFunctionExpression {
			checkGrammarForGenerator(node)
		}
		contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	contextuallyCheckFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(TypeNode UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsContextChecked) {
			contextualSignature := getContextualSignature(node)
			if !(links.flags & NodeCheckFlagsContextChecked) {
				links.flags |= NodeCheckFlagsContextChecked
				signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKindCall))
				if !signature {
					return
				}
				if isContextSensitive(node) {
					if contextualSignature {
						inferenceContext := getInferenceContext(node)
						var instantiatedContextualSignature *Signature
						if checkMode && checkMode&CheckModeInferential {
							inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
							restType := getEffectiveRestType(contextualSignature)
							if restType && restType.flags&TypeFlagsTypeParameter {
								instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext.nonFixingMapper)
							}
						}
						/* TODO(Node BinaryExpression): instantiatedContextualSignature ||= inferenceContext ? instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature */ TODO
						assignContextualParameterTypes(signature, instantiatedContextualSignature)
					} else {
						assignNonContextualParameterTypes(signature)
					}
				} else if contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length {
					inferenceContext := getInferenceContext(node)
					if checkMode && checkMode&CheckModeInferential {
						inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
					}
				}
				if contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType {
					returnType := getReturnTypeFromBody(node, checkMode)
					if !signature.resolvedReturnType {
						signature.resolvedReturnType = returnType
					}
				}
				checkSignatureDeclaration(node)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethodDeferred := func(node /* TODO(TypeNode UnionType): ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
		Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
		functionFlags := getFunctionFlags(node)
		returnType := getReturnTypeFromAnnotation(node)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
		if node.body {
			if !getEffectiveReturnTypeNode(node) {
				getReturnTypeOfSignature(getSignatureFromDeclaration(node))
			}
			if node.body.kind == SyntaxKindBlock {
				checkSourceElement(node.body)
			} else {
				exprType := checkExpression(node.body)
				returnOrPromisedType := returnType && unwrapReturnType(returnType, functionFlags)
				if returnOrPromisedType {
					effectiveCheckNode := getEffectiveCheckNode(node.body)
					if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
						awaitedType := checkAwaitedType(exprType, false, effectiveCheckNode, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
						checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					}
				}
			}
		}
	}
	checkArithmeticOperandType := func(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid /* TODO inferred type boolean */ any /*  = false */) bool {
		if !isTypeAssignableTo(type_, numberOrBigIntType) {
			awaitedType := isAwaitValid && getAwaitedTypeOfPromise(type_)
			errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic)
			return false
		}
		return true
	}
	isReadonlyAssignmentDeclaration := func(d Declaration) /* TODO inferred type boolean */ any {
		if !isCallExpression(d) {
			return false
		}
		if !isBindableObjectDefinePropertyCall(d) {
			return false
		}
		objectLitType := checkExpressionCached(d.arguments[2])
		valueType := getTypeOfPropertyOfType(objectLitType, "value")
		if valueType {
			writableProp := getPropertyOfType(objectLitType, "writable")
			writableType := writableProp && getTypeOfSymbol(writableProp)
			if !writableType || writableType == falseType || writableType == regularFalseType {
				return true
			}
			if writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration) {
				initializer := writableProp.valueDeclaration.initializer
				rawOriginalType := checkExpression(initializer)
				if rawOriginalType == falseType || rawOriginalType == regularFalseType {
					return true
				}
			}
			return false
		}
		setProp := getPropertyOfType(objectLitType, "set")
		return !setProp
	}
	isReadonlySymbol := func(symbol Symbol) bool {
		return !!(getCheckFlags(symbol)&CheckFlagsReadonly || symbol.flags&SymbolFlagsProperty && getDeclarationModifierFlagsFromSymbol(symbol)&ModifierFlagsReadonly || symbol.flags&SymbolFlagsVariable && getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant || symbol.flags&SymbolFlagsAccessor && !(symbol.flags&SymbolFlagsSetAccessor) || symbol.flags&SymbolFlagsEnumMember || some(symbol.declarations, isReadonlyAssignmentDeclaration))
	}
	isAssignmentToReadonlyEntity := func(expr Expression, symbol Symbol, assignmentKind AssignmentKind) /* TODO inferred type boolean */ any {
		if assignmentKind == AssignmentKindNone {
			return false
		}
		if isReadonlySymbol(symbol) {
			if symbol.flags&SymbolFlagsProperty && isAccessExpression(expr) && expr.expression.kind == SyntaxKindThisKeyword {
				ctor := getContainingFunction(expr)
				if !(ctor && (ctor.kind == SyntaxKindConstructor || isJSConstructor(ctor))) {
					return true
				}
				if symbol.valueDeclaration {
					isAssignmentDeclaration := isBinaryExpression(symbol.valueDeclaration)
					isLocalPropertyDeclaration := ctor.parent == symbol.valueDeclaration.parent
					isLocalParameterProperty := ctor == symbol.valueDeclaration.parent
					isLocalThisPropertyAssignment := isAssignmentDeclaration && symbol.parent. /*?*/ valueDeclaration == ctor.parent
					isLocalThisPropertyAssignmentConstructorFunction := isAssignmentDeclaration && symbol.parent. /*?*/ valueDeclaration == ctor
					isWriteableSymbol := isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction
					return !isWriteableSymbol
				}
			}
			return true
		}
		if isAccessExpression(expr) {
			node := skipParentheses(expr.expression)
			if node.kind == SyntaxKindIdentifier {
				symbol := getNodeLinks(node).resolvedSymbol
				if symbol.flags & SymbolFlagsAlias {
					declaration := getDeclarationOfAliasSymbol(symbol)
					return !!declaration && declaration.kind == SyntaxKindNamespaceImport
				}
			}
		}
		return false
	}
	checkReferenceExpression := func(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
		node := skipOuterExpressions(expr, OuterExpressionKindsAssertions|OuterExpressionKindsParentheses)
		if node.kind != SyntaxKindIdentifier && !isAccessExpression(node) {
			error(expr, invalidReferenceMessage)
			return false
		}
		if node.flags & NodeFlagsOptionalChain {
			error(expr, invalidOptionalChainMessage)
			return false
		}
		return true
	}
	checkDeleteExpression := func(node DeleteExpression) Type {
		checkExpression(node.expression)
		expr := skipParentheses(node.expression)
		if !isAccessExpression(expr) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference)
			return booleanType
		}
		if isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier)
		}
		links := getNodeLinks(expr)
		symbol := getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol)
		if symbol {
			if isReadonlySymbol(symbol) {
				error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property)
			} else {
				checkDeleteExpressionMustBeOptional(expr, symbol)
			}
		}
		return booleanType
	}
	checkDeleteExpressionMustBeOptional := func(expr AccessExpression, symbol Symbol) {
		type_ := getTypeOfSymbol(symbol)
		if strictNullChecks && !(type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsNever)) && !( /* TODO(Node ConditionalExpression): exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : hasTypeFacts(type, TypeFacts.IsUndefined) */ TODO) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional)
		}
	}
	checkTypeOfExpression := func(node TypeOfExpression) Type {
		checkExpression(node.expression)
		return typeofType
	}
	checkVoidExpression := func(node VoidExpression) Type {
		checkNodeDeferred(node)
		return undefinedWideningType
	}
	checkAwaitGrammar := func(node /* TODO(TypeNode UnionType): AwaitExpression | VariableDeclarationList */ any) bool {
		hasError := false
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			message := /* TODO(Node ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block : Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block */ TODO
			error(node, message)
			hasError = true
		} else if !(node.flags & NodeFlagsAwaitContext) {
			if isInTopLevelContext(node) {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					var span *TextSpan
					if !isEffectiveExternalModule(sourceFile, compilerOptions) {
						/* TODO(Node BinaryExpression): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
						message := /* TODO(Node ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module : Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module */ TODO
						diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
						diagnostics.add(diagnostic)
						hasError = true
					}
					switch moduleKind {
					case ModuleKindNode16:
						fallthrough // TODO: merge cases
					case ModuleKindNodeNext:
						if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
							/* TODO(Node BinaryExpression): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
							diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
							hasError = true
							break
						}
						fallthrough
					case ModuleKindES2022:
						fallthrough // TODO: merge cases
					case ModuleKindESNext:
						fallthrough // TODO: merge cases
					case ModuleKindPreserve:
						fallthrough // TODO: merge cases
					case ModuleKindSystem:
						if languageVersion >= ScriptTargetES2017 {
							break
						}
						fallthrough
					default:
						/* TODO(Node BinaryExpression): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
						message := /* TODO(Node ConditionalExpression): isAwaitExpression(node) ? Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher : Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher */ TODO
						diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message))
						hasError = true
						break
					}
				}
			} else {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					span := getSpanOfTokenAtPosition(sourceFile, node.pos)
					message := /* TODO(Node ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules : Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */ TODO
					diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
					if container && container.kind != SyntaxKindConstructor && (getFunctionFlags(container)&FunctionFlagsAsync) == 0 {
						relatedInfo := createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
						addRelatedInfo(diagnostic, relatedInfo)
					}
					diagnostics.add(diagnostic)
					hasError = true
				}
			}
		}
		if isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node) {
			error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer)
			hasError = true
		}
		return hasError
	}
	checkAwaitExpression := func(node AwaitExpression) Type {
		addLazyDiagnostic(func() /* TODO inferred type boolean */ any {
			return checkAwaitGrammar(node)
		})
		operandType := checkExpression(node.expression)
		awaitedType := checkAwaitedType(operandType, true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		if awaitedType == operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlagsAnyOrUnknown) {
			addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression))
		}
		return awaitedType
	}
	checkPrefixUnaryExpression := func(node PrefixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		switch node.operand.kind {
		case SyntaxKindNumericLiteral:
			switch node.operator {
			case SyntaxKindMinusToken:
				return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand).text))
			case SyntaxKindPlusToken:
				return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand).text))
			}
			break
		case SyntaxKindBigIntLiteral:
			if node.operator == SyntaxKindMinusToken {
				return getFreshTypeOfLiteralType(getBigIntLiteralType( /* TODO(Node ObjectLiteralExpression): { negative: true, base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text), } */ TODO))
			}
		}
		switch node.operator {
		case SyntaxKindPlusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindTildeToken:
			checkNonNullType(operandType, node.operand)
			if maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsESSymbolLike) {
				error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator))
			}
			if node.operator == SyntaxKindPlusToken {
				if maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsBigIntLike) {
					error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)))
				}
				return numberType
			}
			return getUnaryResultType(operandType)
		case SyntaxKindExclamationToken:
			checkTruthinessOfType(operandType, node.operand)
			facts := getTypeFacts(operandType, TypeFactsTruthy|TypeFactsFalsy)
			// converted from conditional expression
			switch {
			case facts == TypeFactsTruthy:
				return falseType
			case facts == TypeFactsFalsy:
				return trueType
			default:
				return booleanType
			}
		case SyntaxKindPlusPlusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusMinusToken:
			ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
			if ok {
				checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
			}
			return getUnaryResultType(operandType)
		}
		return errorType
	}
	checkPostfixUnaryExpression := func(node PostfixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
		if ok {
			checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
		}
		return getUnaryResultType(operandType)
	}
	getUnaryResultType := func(operandType Type) Type {
		if maybeTypeOfKind(operandType, TypeFlagsBigIntLike) {
			// converted from conditional expression
			switch {
			case isTypeAssignableToKind(operandType, TypeFlagsAnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlagsNumberLike):
				return numberOrBigIntType
			default:
				return bigintType
			}
		}
		return numberType
	}
	maybeTypeOfKindConsideringBaseConstraint := func(type_ Type, kind TypeFlags) bool {
		if maybeTypeOfKind(type_, kind) {
			return true
		}
		baseConstraint := getBaseConstraintOrType(type_)
		return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind)
	}
	maybeTypeOfKind := func(type_ Type, kind TypeFlags) bool {
		if type_.flags & kind {
			return true
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			types := (type_).types
			for _, t := range types {
				if maybeTypeOfKind(t, kind) {
					return true
				}
			}
		}
		return false
	}
	isTypeAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		if source.flags & kind {
			return true
		}
		if strict && source.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull) {
			return false
		}
		return !!(kind&TypeFlagsNumberLike) && isTypeAssignableTo(source, numberType) || !!(kind&TypeFlagsBigIntLike) && isTypeAssignableTo(source, bigintType) || !!(kind&TypeFlagsStringLike) && isTypeAssignableTo(source, stringType) || !!(kind&TypeFlagsBooleanLike) && isTypeAssignableTo(source, booleanType) || !!(kind&TypeFlagsVoid) && isTypeAssignableTo(source, voidType) || !!(kind&TypeFlagsNever) && isTypeAssignableTo(source, neverType) || !!(kind&TypeFlagsNull) && isTypeAssignableTo(source, nullType) || !!(kind&TypeFlagsUndefined) && isTypeAssignableTo(source, undefinedType) || !!(kind&TypeFlagsESSymbol) && isTypeAssignableTo(source, esSymbolType) || !!(kind&TypeFlagsNonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType)
	}
	allTypesAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		// converted from conditional expression
		switch {
		case source.flags & TypeFlagsUnion:
			return every((source).types, func(subType /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return allTypesAssignableToKind(subType, kind, strict)
			})
		default:
			return isTypeAssignableToKind(source, kind, strict)
		}
	}
	isConstEnumObjectType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsAnonymous) && !!type_.symbol && isConstEnumSymbol(type_.symbol)
	}
	isConstEnumSymbol := func(symbol Symbol) bool {
		return (symbol.flags & SymbolFlagsConstEnum) != 0
	}
	getSymbolHasInstanceMethodOfObjectType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		hasInstancePropertyName := getPropertyNameForKnownSymbolName("hasInstance")
		if allTypesAssignableToKind(type_, TypeFlagsNonPrimitive) {
			hasInstanceProperty := getPropertyOfType(type_, hasInstancePropertyName)
			if hasInstanceProperty {
				hasInstancePropertyType := getTypeOfSymbol(hasInstanceProperty)
				if hasInstancePropertyType && getSignaturesOfType(hasInstancePropertyType, SignatureKindCall).length != 0 {
					return hasInstancePropertyType
				}
			}
		}
	}
	checkInstanceOfExpression := func(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if !isTypeAny(leftType) && allTypesAssignableToKind(leftType, TypeFlagsPrimitive) {
			error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter)
		}
		Debug.assert(isInstanceOfExpression(left.parent))
		signature := getResolvedSignature(left.parent, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		returnType := getReturnTypeOfSignature(signature)
		checkTypeAssignableTo(returnType, booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression)
		return booleanType
	}
	hasEmptyObjectIntersection := func(type_ Type) bool {
		return someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return t == unknownEmptyObjectType || !!(t.flags&TypeFlagsIntersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t))
		})
	}
	checkInExpression := func(left Expression, right Expression, leftType Type, rightType Type) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if isPrivateIdentifier(left) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				checkExternalEmitHelpers(left, ExternalEmitHelpersClassPrivateFieldIn)
			}
			if !getNodeLinks(left).resolvedSymbol && getContainingClass(left) {
				isUncheckedJS := isUncheckedJSSuggestion(left, rightType.symbol, true)
				reportNonexistentProperty(left, rightType, isUncheckedJS)
			}
		} else {
			checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left)
		}
		if checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right) {
			if hasEmptyObjectIntersection(rightType) {
				error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType))
			}
		}
		return booleanType
	}
	checkObjectLiteralAssignment := func(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
		properties := node.properties
		if strictNullChecks && properties.length == 0 {
			return checkNonNullType(sourceType, node)
		}
		for i := 0; i < properties.length; i++ {
			checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis)
		}
		return sourceType
	}
	checkObjectLiteralDestructuringPropertyAssignment := func(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis /* TODO inferred type boolean */ any /*  = false */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		properties := node.properties
		property := properties[propertyIndex]
		if property.kind == SyntaxKindPropertyAssignment || property.kind == SyntaxKindShorthandPropertyAssignment {
			name := property.name
			exprType := getLiteralTypeFromPropertyName(name)
			if isTypeUsableAsPropertyName(exprType) {
				text := getPropertyNameFromType(exprType)
				prop := getPropertyOfType(objectLiteralType, text)
				if prop {
					markPropertyAsReferenced(prop, property, rightIsThis)
					checkPropertyAccessibility(property, false, true, objectLiteralType, prop)
				}
			}
			elementType := getIndexedAccessType(objectLiteralType, exprType, AccessFlagsExpressionPosition|( /* TODO(Node ConditionalExpression): hasDefaultValue(property) ? AccessFlags.AllowMissing : 0 */ TODO), name)
			type_ := getFlowTypeOfDestructuring(property, elementType)
			return checkDestructuringAssignment( /* TODO(Node ConditionalExpression): property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer */ TODO, type_)
		} else if property.kind == SyntaxKindSpreadAssignment {
			if propertyIndex < properties.length-1 {
				error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				if languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
					checkExternalEmitHelpers(property, ExternalEmitHelpersRest)
				}
				var nonRestNames []PropertyName = [] /* TODO inferred type never */ any{}
				if allProperties {
					for _, otherProperty := range allProperties {
						if !isSpreadAssignment(otherProperty) {
							nonRestNames.push(otherProperty.name)
						}
					}
				}
				type_ := getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol)
				checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				return checkDestructuringAssignment(property.expression, type_)
			}
		} else {
			error(property, Diagnostics.Property_assignment_expected)
		}
	}
	checkArrayLiteralAssignment := func(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
		elements := node.elements
		if languageVersion < LanguageFeatureMinimumTargetDestructuringAssignment && compilerOptions.downlevelIteration {
			checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
		}
		possiblyOutOfBoundsType := checkIteratedTypeOrElementType(IterationUseDestructuring|IterationUsePossiblyOutOfBounds, sourceType, undefinedType, node) || errorType
		var inBoundsType *Type = /* TODO(Node ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType */ TODO
		for i := 0; i < elements.length; i++ {
			type_ := possiblyOutOfBoundsType
			if node.elements[i].kind == SyntaxKindSpreadElement {
				type_ = /* TODO(Node BinaryExpression): inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType) */ TODO
			}
			checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type_, checkMode)
		}
		return sourceType
	}
	checkArrayLiteralDestructuringElementAssignment := func(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		elements := node.elements
		element := elements[elementIndex]
		if element.kind != SyntaxKindOmittedExpression {
			if element.kind != SyntaxKindSpreadElement {
				indexType := getNumberLiteralType(elementIndex)
				if isArrayLikeType(sourceType) {
					accessFlags := AccessFlagsExpressionPosition | ( /* TODO(Node ConditionalExpression): hasDefaultValue(element) ? AccessFlags.AllowMissing : 0 */ TODO)
					elementType := getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType
					assignedType := /* TODO(Node ConditionalExpression): hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType */ TODO
					type_ := getFlowTypeOfDestructuring(element, assignedType)
					return checkDestructuringAssignment(element, type_, checkMode)
				}
				return checkDestructuringAssignment(element, elementType, checkMode)
			}
			if elementIndex < elements.length-1 {
				error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				restExpression := (element).expression
				if restExpression.kind == SyntaxKindBinaryExpression && (restExpression).operatorToken.kind == SyntaxKindEqualsToken {
					error((restExpression).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer)
				} else {
					checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
					type_ := /* TODO(Node ConditionalExpression): everyType(sourceType, isTupleType) ? mapType(sourceType, t => sliceTupleType(t as TupleTypeReference, elementIndex)) : createArrayType(elementType) */ TODO
					return checkDestructuringAssignment(restExpression, type_, checkMode)
				}
			}
		}
		return nil
	}
	checkDestructuringAssignment := func(exprOrAssignment /* TODO(TypeNode UnionType): Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
		var target Expression
		if exprOrAssignment.kind == SyntaxKindShorthandPropertyAssignment {
			prop := exprOrAssignment
			if prop.objectAssignmentInitializer {
				if strictNullChecks && !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFactsIsUndefined)) {
					sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
				}
				checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode)
			}
			target = (exprOrAssignment).name
		} else {
			target = exprOrAssignment
		}
		if target.kind == SyntaxKindBinaryExpression && (target).operatorToken.kind == SyntaxKindEqualsToken {
			checkBinaryExpression(target, checkMode)
			target = (target).left
			if strictNullChecks {
				sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
			}
		}
		if target.kind == SyntaxKindObjectLiteralExpression {
			return checkObjectLiteralAssignment(target, sourceType, rightIsThis)
		}
		if target.kind == SyntaxKindArrayLiteralExpression {
			return checkArrayLiteralAssignment(target, sourceType, checkMode)
		}
		return checkReferenceAssignment(target, sourceType, checkMode)
	}
	checkReferenceAssignment := func(target Expression, sourceType Type, checkMode CheckMode) Type {
		targetType := checkExpression(target, checkMode)
		error := /* TODO(Node ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ? Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access : Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */ TODO
		optionalError := /* TODO(Node ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ? Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access : Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */ TODO
		if checkReferenceExpression(target, error, optionalError) {
			checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target)
		}
		if isPrivateIdentifierPropertyAccessExpression(target) {
			checkExternalEmitHelpers(target.parent, ExternalEmitHelpersClassPrivateFieldSet)
		}
		return sourceType
	}
	isSideEffectFree := func(node Node) bool {
		node = skipParentheses(node)
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindRegularExpressionLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTaggedTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindTrueKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFalseKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNullKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindUndefinedKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeOfExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNonNullExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxElement:
			return true
		case SyntaxKindConditionalExpression:
			return isSideEffectFree((node).whenTrue) && isSideEffectFree((node).whenFalse)
		case SyntaxKindBinaryExpression:
			if isAssignmentOperator((node).operatorToken.kind) {
				return false
			}
			return isSideEffectFree((node).left) && isSideEffectFree((node).right)
		case SyntaxKindPrefixUnaryExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPostfixUnaryExpression:
			switch (node).operator {
			case SyntaxKindExclamationToken:
				fallthrough // TODO: merge cases
			case SyntaxKindPlusToken:
				fallthrough // TODO: merge cases
			case SyntaxKindMinusToken:
				fallthrough // TODO: merge cases
			case SyntaxKindTildeToken:
				return true
			}
			return false
		case SyntaxKindVoidExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			fallthrough // TODO: merge cases
		default:
			return false
		}
	}
	isTypeEqualityComparableTo := func(source Type, target Type) /* TODO inferred type boolean */ any {
		return (target.flags&TypeFlagsNullable) != 0 || isTypeComparableTo(source, target)
	}
	createCheckBinaryExpression := func() /* TODO inferred type (node: import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression, checkMode: import("/home/jabaile/work/TypeScript/src/compiler/checker").CheckMode | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		type WorkArea struct {
			checkMode  *CheckMode
			skip       bool
			stackIndex number
			typeStack  []*Type
		}
		trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)
		return func(node BinaryExpression, checkMode *CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
			result := trampoline(node, checkMode)
			Debug.assertIsDefined(result)
			return result
		}
		onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) /* TODO inferred type WorkArea */ any {
			if state {
				state.stackIndex++
				state.skip = false
				setLeftType(state, nil)
				setLastResult(state, nil)
			} else {
				state = /* TODO(Node ObjectLiteralExpression): { checkMode, skip: false, stackIndex: 0, typeStack: [undefined, undefined], } */ TODO
			}
			if isInJSFile(node) && getAssignedExpandoInitializer(node) {
				state.skip = true
				setLastResult(state, checkExpression(node.right, checkMode))
				return state
			}
			checkNullishCoalesceOperands(node)
			operator := node.operatorToken.kind
			if operator == SyntaxKindEqualsToken && (node.left.kind == SyntaxKindObjectLiteralExpression || node.left.kind == SyntaxKindArrayLiteralExpression) {
				state.skip = true
				setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind == SyntaxKindThisKeyword))
				return state
			}
			return state
		}
		onLeft := func(left Expression, state WorkArea, _node BinaryExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ any {
			if !state.skip {
				return maybeCheckExpression(state, left)
			}
		}
		onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
			if !state.skip {
				leftType := getLastResult(state)
				Debug.assertIsDefined(leftType)
				setLeftType(state, leftType)
				setLastResult(state, nil)
				operator := operatorToken.kind
				if isLogicalOrCoalescingBinaryOperator(operator) {
					parent := node.parent
					for parent.kind == SyntaxKindParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent) {
						parent = parent.parent
					}
					if operator == SyntaxKindAmpersandAmpersandToken || isIfStatement(parent) {
						checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType /* TODO(Node ConditionalExpression): isIfStatement(parent) ? parent.thenStatement : undefined */, TODO)
					}
					if isBinaryLogicalOperator(operator) {
						checkTruthinessOfType(leftType, node.left)
					}
				}
			}
		}
		onRight := func(right Expression, state WorkArea, _node BinaryExpression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ any {
			if !state.skip {
				return maybeCheckExpression(state, right)
			}
		}
		onExit := func(node BinaryExpression, state WorkArea) *Type {
			var result *Type
			if state.skip {
				result = getLastResult(state)
			} else {
				leftType := getLeftType(state)
				Debug.assertIsDefined(leftType)
				rightType := getLastResult(state)
				Debug.assertIsDefined(rightType)
				result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node)
			}
			state.skip = false
			setLeftType(state, nil)
			setLastResult(state, nil)
			state.stackIndex--
			return result
		}
		foldState := func(state WorkArea, result *Type, _side /* TODO(TypeNode UnionType): "left" | "right" */ any) /* TODO inferred type WorkArea */ any {
			setLastResult(state, result)
			return state
		}
		maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
			if isBinaryExpression(node) {
				return node
			}
			setLastResult(state, checkExpression(node, state.checkMode))
		}
		getLeftType := func(state WorkArea) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
			return state.typeStack[state.stackIndex]
		}
		setLeftType := func(state WorkArea, type_ *Type) {
			state.typeStack[state.stackIndex] = type_
		}
		getLastResult := func(state WorkArea) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
			return state.typeStack[state.stackIndex+1]
		}
		setLastResult := func(state WorkArea, type_ *Type) {
			state.typeStack[state.stackIndex+1] = type_
		}
	}
	checkNullishCoalesceOperands := func(node BinaryExpression) {
		TODO_IDENTIFIER := node
		if operatorToken.kind == SyntaxKindQuestionQuestionToken {
			if isBinaryExpression(left) && (left.operatorToken.kind == SyntaxKindBarBarToken || left.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			if isBinaryExpression(right) && (right.operatorToken.kind == SyntaxKindBarBarToken || right.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			leftTarget := skipOuterExpressions(left, OuterExpressionKindsAll)
			nullishSemantics := getSyntacticNullishnessSemantics(leftTarget)
			if nullishSemantics != PredicateSemanticsSometimes {
				if node.parent.kind == SyntaxKindBinaryExpression {
					error(leftTarget, Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses)
				} else {
					if nullishSemantics == PredicateSemanticsAlways {
						error(leftTarget, Diagnostics.This_expression_is_always_nullish)
					} else {
						error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish)
					}
				}
			}
		}
	}
	getSyntacticNullishnessSemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		switch node.kind {
		case SyntaxKindAwaitExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindYieldExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindThisKeyword:
			return PredicateSemanticsSometimes
		case SyntaxKindBinaryExpression:
			switch (node).operatorToken.kind {
			case SyntaxKindEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionToken:
				fallthrough // TODO: merge cases
			case SyntaxKindQuestionQuestionEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarBarEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandAmpersandEqualsToken:
				return PredicateSemanticsSometimes
			}
			return PredicateSemanticsNever
		case SyntaxKindConditionalExpression:
			return getSyntacticNullishnessSemantics((node).whenTrue) | getSyntacticNullishnessSemantics((node).whenFalse)
		case SyntaxKindNullKeyword:
			return PredicateSemanticsAlways
		case SyntaxKindIdentifier:
			if getResolvedSymbol(node) == undefinedSymbol {
				return PredicateSemanticsAlways
			}
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsNever
	}
	checkBinaryLikeExpression := func(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		if operator == SyntaxKindEqualsToken && (left.kind == SyntaxKindObjectLiteralExpression || left.kind == SyntaxKindArrayLiteralExpression) {
			return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind == SyntaxKindThisKeyword)
		}
		var leftType Type
		if isBinaryLogicalOperator(operator) {
			leftType = checkTruthinessExpression(left, checkMode)
		} else {
			leftType = checkExpression(left, checkMode)
		}
		rightType := checkExpression(right, checkMode)
		return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
	}
	checkBinaryLikeExpressionWorker := func(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		switch operator {
		case SyntaxKindAsteriskToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAsteriskAsteriskToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAsteriskEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAsteriskAsteriskEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindSlashToken:
			fallthrough // TODO: merge cases
		case SyntaxKindSlashEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindPercentToken:
			fallthrough // TODO: merge cases
		case SyntaxKindPercentEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindMinusEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindLessThanLessThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindLessThanLessThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindCaretToken:
			fallthrough // TODO: merge cases
		case SyntaxKindCaretEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandEqualsToken:
			if leftType == silentNeverType || rightType == silentNeverType {
				return silentNeverType
			}
			leftType = checkNonNullType(leftType, left)
			rightType = checkNonNullType(rightType, right)
			var suggestedOperator *PunctuationSyntaxKind
			if (leftType.flags & TypeFlagsBooleanLike) && (rightType.flags & TypeFlagsBooleanLike) && ( /* TODO(Node BinaryExpression): suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind) */ TODO) != nil {
				error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator))
				return numberType
			} else {
				leftOk := checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true)
				rightOk := checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true)
				var resultType Type
				if (isTypeAssignableToKind(leftType, TypeFlagsAnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlagsAnyOrUnknown)) || !(maybeTypeOfKind(leftType, TypeFlagsBigIntLike) || maybeTypeOfKind(rightType, TypeFlagsBigIntLike)) {
					resultType = numberType
				} else if bothAreBigIntLike(leftType, rightType) {
					switch operator {
					case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
						reportOperatorError()
						break
					case SyntaxKindAsteriskAsteriskToken:
						fallthrough // TODO: merge cases
					case SyntaxKindAsteriskAsteriskEqualsToken:
						if languageVersion < ScriptTargetES2016 {
							error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later)
						}
					}
					resultType = bigintType
				} else {
					reportOperatorError(bothAreBigIntLike)
					resultType = errorType
				}
				if leftOk && rightOk {
					checkAssignmentOperator(resultType)
					switch operator {
					case SyntaxKindLessThanLessThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindLessThanLessThanEqualsToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanEqualsToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
						fallthrough // TODO: merge cases
					case SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
						rhsEval := evaluate(right)
						if /* TODO(Node TypeOfExpression): typeof rhsEval.value */ TODO == "number" && Math.abs(rhsEval.value) >= 32 {
							errorOrSuggestion(isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), errorNode || operatorToken, Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2, getTextOfNode(left), tokenToString(operator) /* TODO(Node BinaryExpression): rhsEval.value % 32 */, TODO)
						}
						break
					default:
						break
					}
				}
				return resultType
			}
			fallthrough
		case SyntaxKindPlusToken:
			fallthrough // TODO: merge cases
		case SyntaxKindPlusEqualsToken:
			if leftType == silentNeverType || rightType == silentNeverType {
				return silentNeverType
			}
			if !isTypeAssignableToKind(leftType, TypeFlagsStringLike) && !isTypeAssignableToKind(rightType, TypeFlagsStringLike) {
				leftType = checkNonNullType(leftType, left)
				rightType = checkNonNullType(rightType, right)
			}
			var resultType *Type
			if isTypeAssignableToKind(leftType, TypeFlagsNumberLike, true) && isTypeAssignableToKind(rightType, TypeFlagsNumberLike, true) {
				resultType = numberType
			} else if isTypeAssignableToKind(leftType, TypeFlagsBigIntLike, true) && isTypeAssignableToKind(rightType, TypeFlagsBigIntLike, true) {
				resultType = bigintType
			} else if isTypeAssignableToKind(leftType, TypeFlagsStringLike, true) || isTypeAssignableToKind(rightType, TypeFlagsStringLike, true) {
				resultType = stringType
			} else if isTypeAny(leftType) || isTypeAny(rightType) {
				resultType = /* TODO(Node ConditionalExpression): isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType */ TODO
			}
			if resultType && !checkForDisallowedESSymbolOperand(operator) {
				return resultType
			}
			if !resultType {
				closeEnoughKind := TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsAnyOrUnknown
				reportOperatorError(func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isTypeAssignableToKind(left, closeEnoughKind) && isTypeAssignableToKind(right, closeEnoughKind)
				})
				return anyType
			}
			if operator == SyntaxKindPlusEqualsToken {
				checkAssignmentOperator(resultType)
			}
			return resultType
		case SyntaxKindLessThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindLessThanEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindGreaterThanEqualsToken:
			if checkForDisallowedESSymbolOperand(operator) {
				leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left))
				rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right))
				reportOperatorErrorUnless(func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					if isTypeAny(left) || isTypeAny(right) {
						return true
					}
					leftAssignableToNumber := isTypeAssignableTo(left, numberOrBigIntType)
					rightAssignableToNumber := isTypeAssignableTo(right, numberOrBigIntType)
					return leftAssignableToNumber && rightAssignableToNumber || !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right)
				})
			}
			return booleanType
		case SyntaxKindEqualsEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindExclamationEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindEqualsEqualsEqualsToken:
			fallthrough // TODO: merge cases
		case SyntaxKindExclamationEqualsEqualsToken:
			if !(checkMode && checkMode&CheckModeTypeOnly) {
				if (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) && (!isInJSFile(left) || (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken)) {
					eqType := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
					error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value /* TODO(Node ConditionalExpression): eqType ? "false" : "true" */, TODO)
				}
				checkNaNEquality(errorNode, operator, left, right)
				reportOperatorErrorUnless(func(left /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, right /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left)
				})
			}
			return booleanType
		case SyntaxKindInstanceOfKeyword:
			return checkInstanceOfExpression(left, right, leftType, rightType, checkMode)
		case SyntaxKindInKeyword:
			return checkInExpression(left, right, leftType, rightType)
		case SyntaxKindAmpersandAmpersandToken:
			fallthrough // TODO: merge cases
		case SyntaxKindAmpersandAmpersandEqualsToken:
			resultType := /* TODO(Node ConditionalExpression): hasTypeFacts(leftType, TypeFacts.Truthy) ? getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) : leftType */ TODO
			if operator == SyntaxKindAmpersandAmpersandEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindBarBarToken:
			fallthrough // TODO: merge cases
		case SyntaxKindBarBarEqualsToken:
			resultType := /* TODO(Node ConditionalExpression): hasTypeFacts(leftType, TypeFacts.Falsy) ? getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) : leftType */ TODO
			if operator == SyntaxKindBarBarEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindQuestionQuestionToken:
			fallthrough // TODO: merge cases
		case SyntaxKindQuestionQuestionEqualsToken:
			resultType := /* TODO(Node ConditionalExpression): hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ? getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) : leftType */ TODO
			if operator == SyntaxKindQuestionQuestionEqualsToken {
				checkAssignmentOperator(rightType)
			}
			return resultType
			fallthrough
		case SyntaxKindEqualsToken:
			declKind := /* TODO(Node ConditionalExpression): isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None */ TODO
			checkAssignmentDeclaration(declKind, rightType)
			if isAssignmentDeclaration(declKind) {
				if !(rightType.flags & TypeFlagsObject) || declKind != AssignmentDeclarationKindModuleExports && declKind != AssignmentDeclarationKindPrototype && !isEmptyObjectType(rightType) && !isFunctionObjectType(rightType) && !(getObjectFlags(rightType)&ObjectFlagsClass) {
					checkAssignmentOperator(rightType)
				}
				return leftType
			} else {
				checkAssignmentOperator(rightType)
				return rightType
			}
			fallthrough
		case SyntaxKindCommaToken:
			if !compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent) {
				sf := getSourceFileOfNode(left)
				sourceText := sf.text
				start := skipTrivia(sourceText, left.pos)
				isInDiag2657 := sf.parseDiagnostics.some(func(diag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any) /* TODO inferred type boolean */ any {
					if diag.code != Diagnostics.JSX_expressions_must_have_one_parent_element.code {
						return false
					}
					return textSpanContainsPosition(diag, start)
				})
				if !isInDiag2657 {
					error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects)
				}
			}
			return rightType
		default:
			return Debug.fail()
		}
		bothAreBigIntLike := func(left Type, right Type) bool {
			return isTypeAssignableToKind(left, TypeFlagsBigIntLike) && isTypeAssignableToKind(right, TypeFlagsBigIntLike)
		}
		checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
			if kind == AssignmentDeclarationKindModuleExports {
				for _, prop := range getPropertiesOfObjectType(rightType) {
					propType := getTypeOfSymbol(prop)
					if propType.symbol && propType.symbol.flags&SymbolFlagsClass {
						name := prop.escapedName
						symbol := resolveName(prop.valueDeclaration, name, SymbolFlagsType, nil, false)
						if symbol. /*?*/ declarations && symbol.declarations.some(isJSDocTypedefTag) {
							addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop)
							addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol)
						}
					}
				}
			}
		}
		isIndirectCall := func(node BinaryExpression) bool {
			return node.parent.kind == SyntaxKindParenthesizedExpression && isNumericLiteral(node.left) && node.left.text == "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression == node.parent || node.parent.parent.kind == SyntaxKindTaggedTemplateExpression) && (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText == "eval")
		}
		checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
			offendingSymbolOperand := /* TODO(Node ConditionalExpression): maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlags.ESSymbolLike) ? left : maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlags.ESSymbolLike) ? right : undefined */ TODO
			if offendingSymbolOperand {
				error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator))
				return false
			}
			return true
		}
		getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
			switch operator {
			case SyntaxKindBarToken:
				fallthrough // TODO: merge cases
			case SyntaxKindBarEqualsToken:
				return SyntaxKindBarBarToken
			case SyntaxKindCaretToken:
				fallthrough // TODO: merge cases
			case SyntaxKindCaretEqualsToken:
				return SyntaxKindExclamationEqualsEqualsToken
			case SyntaxKindAmpersandToken:
				fallthrough // TODO: merge cases
			case SyntaxKindAmpersandEqualsToken:
				return SyntaxKindAmpersandAmpersandToken
			default:
				return nil
			}
		}
		checkAssignmentOperator := func(valueType Type) {
			if isAssignmentOperator(operator) {
				addLazyDiagnostic(checkAssignmentOperatorWorker)
			}
			checkAssignmentOperatorWorker := func() {
				assigneeType := leftType
				if isCompoundAssignment(operatorToken.kind) && left.kind == SyntaxKindPropertyAccessExpression {
					assigneeType = checkPropertyAccessExpression(left, nil, true)
				}
				if checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access) {
					var headMessage *DiagnosticMessage
					if exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlagsUndefined) {
						target := getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText)
						if isExactOptionalPropertyMismatch(valueType, target) {
							headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target
						}
					}
					checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage)
				}
			}
		}
		isAssignmentDeclaration := func(kind AssignmentDeclarationKind) /* TODO inferred type boolean */ any {
			switch kind {
			case AssignmentDeclarationKindModuleExports:
				return true
			case AssignmentDeclarationKindExportsProperty:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindProperty:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindPrototype:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindPrototypeProperty:
				fallthrough // TODO: merge cases
			case AssignmentDeclarationKindThisProperty:
				symbol := getSymbolOfNode(left)
				init := getAssignedExpandoInitializer(right)
				return !!init && isObjectLiteralExpression(init) && !!symbol. /*?*/ exports. /*?*/ size
			default:
				return false
			}
		}
		reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
			if !typesAreCompatible(leftType, rightType) {
				reportOperatorError(typesAreCompatible)
				return true
			}
			return false
		}
		reportOperatorError := func(isRelated func(left Type, right Type) bool) {
			wouldWorkWithAwait := false
			errNode := errorNode || operatorToken
			if isRelated {
				awaitedLeftType := getAwaitedTypeNoAlias(leftType)
				awaitedRightType := getAwaitedTypeNoAlias(rightType)
				wouldWorkWithAwait = !(awaitedLeftType == leftType && awaitedRightType == rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType)
			}
			effectiveLeft := leftType
			effectiveRight := rightType
			if !wouldWorkWithAwait && isRelated {
				[]TODO{effectiveLeft, effectiveRight} = getBaseTypesIfUnrelated(leftType, rightType, isRelated)
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
			if !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) {
				errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(operatorToken.kind), leftStr, rightStr)
			}
		}
		tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic | undefined */ any {
			switch operatorToken.kind {
			case SyntaxKindEqualsEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsEqualsToken:
				fallthrough // TODO: merge cases
			case SyntaxKindExclamationEqualsToken:
				return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap, leftStr, rightStr)
			default:
				return nil
			}
		}
		checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
			isLeftNaN := isGlobalNaN(skipParentheses(left))
			isRightNaN := isGlobalNaN(skipParentheses(right))
			if isLeftNaN || isRightNaN {
				err := error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString( /* TODO(Node ConditionalExpression): operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword */ TODO))
				if isLeftNaN && isRightNaN {
					return
				}
				operatorString := /* TODO(Node ConditionalExpression): operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "" */ TODO
				location := /* TODO(Node ConditionalExpression): isLeftNaN ? right : left */ TODO
				expression := skipParentheses(location)
				addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0 /* TODO(Node TemplateExpression): `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})` */, TODO))
			}
		}
		isGlobalNaN := func(expr Expression) bool {
			if isIdentifier(expr) && expr.escapedText == "NaN" {
				globalNaNSymbol := getGlobalNaNSymbol()
				return !!globalNaNSymbol && globalNaNSymbol == getResolvedSymbol(expr)
			}
			return false
		}
	}
	getBaseTypesIfUnrelated := func(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TypeNode TupleType): [Type, Type] */ any {
		effectiveLeft := leftType
		effectiveRight := rightType
		leftBase := getBaseTypeOfLiteralType(leftType)
		rightBase := getBaseTypeOfLiteralType(rightType)
		if !isRelated(leftBase, rightBase) {
			effectiveLeft = leftBase
			effectiveRight = rightBase
		}
		return []TODO{effectiveLeft, effectiveRight}
	}
	checkYieldExpression := func(node YieldExpression) Type {
		addLazyDiagnostic(checkYieldExpressionGrammar)
		func_ := getContainingFunction(node)
		if !func_ {
			return anyType
		}
		functionFlags := getFunctionFlags(func_)
		if !(functionFlags & FunctionFlagsGenerator) {
			return anyType
		}
		isAsync := (functionFlags & FunctionFlagsAsync) != 0
		if node.asteriskToken {
			if isAsync && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncDelegatorIncludes)
			}
			if !isAsync && languageVersion < LanguageFeatureMinimumTargetGenerators && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersValues)
			}
		}
		returnType := getReturnTypeFromAnnotation(func_)
		if returnType && returnType.flags&TypeFlagsUnion {
			returnType = filterType(returnType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, nil)
			})
		}
		iterationTypes := returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync)
		signatureYieldType := iterationTypes && iterationTypes.yieldType || anyType
		signatureNextType := iterationTypes && iterationTypes.nextType || anyType
		yieldExpressionType := /* TODO(Node ConditionalExpression): node.expression ? checkExpression(node.expression) : undefinedWideningType */ TODO
		yieldedType := getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
		if returnType && yieldedType {
			checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression)
		}
		if node.asteriskToken {
			use := /* TODO(Node ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */ TODO
			return getIterationTypeOfIterable(use, IterationTypeKindReturn, yieldExpressionType, node.expression) || anyType
		} else if returnType {
			return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, isAsync) || anyType
		}
		type_ := getContextualIterationType(IterationTypeKindNext, func_)
		if !type_ {
			type_ = anyType
			addLazyDiagnostic(func() {
				if noImplicitAny && !expressionResultIsUnused(node) {
					contextualType := getContextualType(node, nil)
					if !contextualType || isTypeAny(contextualType) {
						error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation)
					}
				}
			})
		}
		return type_
		checkYieldExpressionGrammar := func() {
			if !(node.flags & NodeFlagsYieldContext) {
				grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body)
			}
			if isInParameterInitializerBeforeContainingFunction(node) {
				error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer)
			}
		}
	}
	checkConditionalExpression := func(node ConditionalExpression, checkMode CheckMode) Type {
		type_ := checkTruthinessExpression(node.condition, checkMode)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type_, node.whenTrue)
		type1 := checkExpression(node.whenTrue, checkMode)
		type2 := checkExpression(node.whenFalse, checkMode)
		return getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{type1, type2}, UnionReductionSubtype)
	}
	isTemplateLiteralContext := func(node Node) bool {
		parent := node.parent
		return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && parent.argumentExpression == node
	}
	checkTemplateExpression := func(node TemplateExpression) Type {
		texts := [] /* TODO inferred type string */ any{node.head.text}
		types := [] /* TODO inferred type never */ any{}
		for _, span := range node.templateSpans {
			type_ := checkExpression(span.expression)
			if maybeTypeOfKindConsideringBaseConstraint(type_, TypeFlagsESSymbolLike) {
				error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String)
			}
			texts.push(span.literal.text)
			types.push( /* TODO(Node ConditionalExpression): isTypeAssignableTo(type, templateConstraintType) ? type : stringType */ TODO)
		}
		evaluated := node.parent.kind != SyntaxKindTaggedTemplateExpression && evaluate(node).value
		if evaluated {
			return getFreshTypeOfLiteralType(getStringLiteralType(evaluated))
		}
		if isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node, nil) || unknownType, isTemplateLiteralContextualType) {
			return getTemplateLiteralType(texts, types)
		}
		return stringType
	}
	isTemplateLiteralContextualType := func(type_ Type) bool {
		return !!(type_.flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral) || type_.flags&TypeFlagsInstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsStringLike))
	}
	getContextNode := func(node Expression) Expression {
		if isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent) {
			return node.parent.parent
		}
		return node
	}
	checkExpressionWithContextualType := func(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
		contextNode := getContextNode(node)
		pushContextualType(contextNode, contextualType, false)
		pushInferenceContext(contextNode, inferenceContext)
		type_ := checkExpression(node, checkMode|CheckModeContextual|( /* TODO(Node ConditionalExpression): inferenceContext ? CheckMode.Inferential : 0 */ TODO))
		if inferenceContext && inferenceContext.intraExpressionInferenceSites {
			inferenceContext.intraExpressionInferenceSites = nil
		}
		result := /* TODO(Node ConditionalExpression): maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags* / undefined)) ? getRegularTypeOfLiteralType(type) : type */ TODO
		popInferenceContext()
		popContextualType()
		return result
	}
	checkExpressionCached := func(node /* TODO(TypeNode UnionType): Expression | QualifiedName */ any, checkMode CheckMode) Type {
		if checkMode {
			return checkExpression(node, checkMode)
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			saveFlowLoopStart := flowLoopStart
			saveFlowTypeCache := flowTypeCache
			flowLoopStart = flowLoopCount
			flowTypeCache = nil
			links.resolvedType = checkExpression(node, checkMode)
			flowTypeCache = saveFlowTypeCache
			flowLoopStart = saveFlowLoopStart
		}
		return links.resolvedType
	}
	isTypeAssertion := func(node Expression) /* TODO inferred type boolean */ any {
		node = skipParentheses(node, true)
		return node.kind == SyntaxKindTypeAssertionExpression || node.kind == SyntaxKindAsExpression || isJSDocTypeAssertion(node)
	}
	checkDeclarationInitializer := func(declaration HasExpressionInitializer, checkMode CheckMode, contextualType *Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		initializer := getEffectiveInitializer(declaration)
		if isInJSFile(declaration) {
			typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
			if typeNode {
				return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
			}
		}
		type_ := getQuickTypeOfExpression(initializer) || ( /* TODO(Node ConditionalExpression): contextualType ? checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext* / undefined, checkMode || CheckMode.Normal) : checkExpressionCached(initializer, checkMode) */ TODO)
		if isParameter( /* TODO(Node ConditionalExpression): isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration */ TODO) {
			if declaration.name.kind == SyntaxKindObjectBindingPattern && isObjectLiteralType(type_) {
				return padObjectLiteralType(type_, declaration.name)
			}
			if declaration.name.kind == SyntaxKindArrayBindingPattern && isTupleType(type_) {
				return padTupleType(type_, declaration.name)
			}
		}
		return type_
	}
	padObjectLiteralType := func(type_ ObjectType, pattern ObjectBindingPattern) Type {
		var missingElements *[]BindingElement
		for _, e := range pattern.elements {
			if e.initializer {
				name := getPropertyNameFromBindingElement(e)
				if name && !getPropertyOfType(type_, name) {
					missingElements = append(missingElements, e)
				}
			}
		}
		if !missingElements {
			return type_
		}
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, prop)
		}
		for _, e := range missingElements {
			symbol := createSymbol(SymbolFlagsProperty|SymbolFlagsOptional, getPropertyNameFromBindingElement(e))
			symbol.links.type_ = getTypeFromBindingElement(e, false, false)
			members.set(symbol.escapedName, symbol)
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
		result.objectFlags = type_.objectFlags
		return result
	}
	getPropertyNameFromBindingElement := func(e BindingElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		exprType := getLiteralTypeFromPropertyName(e.propertyName || e.name)
		// converted from conditional expression
		switch {
		case isTypeUsableAsPropertyName(exprType):
			return getPropertyNameFromType(exprType)
		default:
			return nil
		}
	}
	padTupleType := func(type_ TupleTypeReference, pattern ArrayBindingPattern) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if type_.target.combinedFlags&ElementFlagsVariable || getTypeReferenceArity(type_) >= pattern.elements.length {
			return type_
		}
		patternElements := pattern.elements
		elementTypes := getElementTypes(type_).slice()
		elementFlags := type_.target.elementFlags.slice()
		for i := getTypeReferenceArity(type_); i < patternElements.length; i++ {
			e := patternElements[i]
			if i < patternElements.length-1 || !(e.kind == SyntaxKindBindingElement && e.dotDotDotToken) {
				elementTypes.push( /* TODO(Node ConditionalExpression): !isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false) : anyType */ TODO)
				elementFlags.push(ElementFlagsOptional)
				if !isOmittedExpression(e) && !hasDefaultValue(e) {
					reportImplicitAny(e, anyType)
				}
			}
		}
		return createTupleType(elementTypes, elementFlags, type_.target.readonly)
	}
	widenTypeInferredFromInitializer := func(declaration HasExpressionInitializer, type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		widened := /* TODO(Node ConditionalExpression): getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type) */ TODO
		if isInJSFile(declaration) {
			if isEmptyLiteralType(widened) {
				reportImplicitAny(declaration, anyType)
				return anyType
			} else if isEmptyArrayLiteralType(widened) {
				reportImplicitAny(declaration, anyArrayType)
				return anyArrayType
			}
		}
		return widened
	}
	isLiteralOfContextualType := func(candidateType Type, contextualType *Type) bool {
		if contextualType {
			if contextualType.flags & TypeFlagsUnionOrIntersection {
				types := (contextualType).types
				return some(types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return isLiteralOfContextualType(candidateType, t)
				})
			}
			if contextualType.flags & TypeFlagsInstantiableNonPrimitive {
				constraint := getBaseConstraintOfType(contextualType) || unknownType
				return maybeTypeOfKind(constraint, TypeFlagsString) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || maybeTypeOfKind(constraint, TypeFlagsNumber) && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || maybeTypeOfKind(constraint, TypeFlagsBigInt) && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || maybeTypeOfKind(constraint, TypeFlagsESSymbol) && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol) || isLiteralOfContextualType(candidateType, constraint)
			}
			return !!(contextualType.flags&(TypeFlagsStringLiteral|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || contextualType.flags&TypeFlagsNumberLiteral && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || contextualType.flags&TypeFlagsBigIntLiteral && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || contextualType.flags&TypeFlagsBooleanLiteral && maybeTypeOfKind(candidateType, TypeFlagsBooleanLiteral) || contextualType.flags&TypeFlagsUniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol))
		}
		return false
	}
	isConstContext := func(node Expression) bool {
		parent := node.parent
		return isAssertionExpression(parent) && isConstTypeReference(parent.type_) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, ContextFlagsNone)) || (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent)
	}
	checkExpressionForMutableLocation := func(node Expression, checkMode *CheckMode, forceTuple bool) Type {
		type_ := checkExpression(node, checkMode, forceTuple)
		// converted from conditional expression
		switch {
		case isConstContext(node) || isCommonJsExportedExpression(node):
			return getRegularTypeOfLiteralType(type_)
		case isTypeAssertion(node):
			return type_
		default:
			return getWidenedLiteralLikeTypeForContextualType(type_, instantiateContextualType(getContextualType(node, nil), node, nil))
		}
	}
	checkPropertyAssignment := func(node PropertyAssignment, checkMode CheckMode) Type {
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		return checkExpressionForMutableLocation(node.initializer, checkMode)
	}
	checkObjectLiteralMethod := func(node MethodDeclaration, checkMode CheckMode) Type {
		checkGrammarMethod(node)
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		uninstantiatedType := checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
	}
	instantiateTypeWithSingleGenericCallSignature := func(node /* TODO(TypeNode UnionType): Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if checkMode && checkMode&(CheckModeInferential|CheckModeSkipGenericFunctions) {
			callSignature := getSingleSignature(type_, SignatureKindCall, true)
			constructSignature := getSingleSignature(type_, SignatureKindConstruct, true)
			signature := callSignature || constructSignature
			if signature && signature.typeParameters {
				contextualType := getApparentTypeOfContextualType(node, ContextFlagsNoConstraints)
				if contextualType {
					contextualSignature := getSingleSignature(getNonNullableType(contextualType) /* TODO(Node ConditionalExpression): callSignature ? SignatureKind.Call : SignatureKind.Construct */, TODO, false)
					if contextualSignature && !contextualSignature.typeParameters {
						if checkMode & CheckModeSkipGenericFunctions {
							skippedGenericFunction(node, checkMode)
							return anyFunctionType
						}
						context := getInferenceContext(node)
						returnType := context.signature && getReturnTypeOfSignature(context.signature)
						returnSignature := returnType && getSingleCallOrConstructSignature(returnType)
						if returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates) {
							uniqueTypeParameters := getUniqueTypeParameters(context, signature.typeParameters)
							instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
							inferences := map_(context.inferences, func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any {
								return createInferenceInfo(info.typeParameter)
							})
							applyToParameterTypes(instantiatedSignature, contextualSignature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
								inferTypes(inferences, source, target, 0, true)
							})
							if some(inferences, hasInferenceCandidates) {
								applyToReturnTypes(instantiatedSignature, contextualSignature, func(source /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any, target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
									inferTypes(inferences, source, target)
								})
								if !hasOverlappingInferences(context.inferences, inferences) {
									mergeInferences(context.inferences, inferences)
									context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters)
									return getOrCreateTypeFromSignature(instantiatedSignature)
								}
							}
						}
						return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context), flatMap(inferenceContexts, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ any {
							return c && map_(c.inferences, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any {
								return i.typeParameter
							})
						}).slice())
					}
				}
			}
		}
		return type_
	}
	skippedGenericFunction := func(node Node, checkMode CheckMode) {
		if checkMode & CheckModeInferential {
			context := getInferenceContext(node)
			context.flags |= InferenceFlagsSkippedGenericFunction
		}
	}
	hasInferenceCandidates := func(info InferenceInfo) /* TODO inferred type boolean */ any {
		return !!(info.candidates || info.contraCandidates)
	}
	hasInferenceCandidatesOrDefault := func(info InferenceInfo) /* TODO inferred type boolean */ any {
		return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter))
	}
	hasOverlappingInferences := func(a []InferenceInfo, b []InferenceInfo) /* TODO inferred type boolean */ any {
		for i := 0; i < a.length; i++ {
			if hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i]) {
				return true
			}
		}
		return false
	}
	mergeInferences := func(target []InferenceInfo, source []InferenceInfo) {
		for i := 0; i < target.length; i++ {
			if !hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i]) {
				target[i] = source[i]
			}
		}
	}
	getUniqueTypeParameters := func(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
		var result []TypeParameter = [] /* TODO inferred type never */ any{}
		var oldTypeParameters *[]TypeParameter
		var newTypeParameters *[]TypeParameter
		for _, tp := range typeParameters {
			name := tp.symbol.escapedName
			if hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name) {
				newName := getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name)
				symbol := createSymbol(SymbolFlagsTypeParameter, newName)
				newTypeParameter := createTypeParameter(symbol)
				newTypeParameter.target = tp
				oldTypeParameters = append(oldTypeParameters, tp)
				newTypeParameters = append(newTypeParameters, newTypeParameter)
				result.push(newTypeParameter)
			} else {
				result.push(tp)
			}
		}
		if newTypeParameters {
			mapper := createTypeMapper(oldTypeParameters, newTypeParameters)
			for _, tp := range newTypeParameters {
				tp.mapper = mapper
			}
		}
		return result
	}
	hasTypeParameterByName := func(typeParameters *[]TypeParameter, name __String) /* TODO inferred type boolean */ any {
		return some(typeParameters, func(tp /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any) /* TODO inferred type boolean */ any {
			return tp.symbol.escapedName == name
		})
	}
	getUniqueTypeParameterName := func(typeParameters []TypeParameter, baseName __String) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any {
		len := (baseName).length
		for len > 1 && (baseName).charCodeAt(len-1) >= CharacterCodes_0 && (baseName).charCodeAt(len-1) <= CharacterCodes_9 {
			len--
		}
		s := (baseName).slice(0, len)
		for index := 1; true; index++ {
			augmentedName := s + index
			if !hasTypeParameterByName(typeParameters, augmentedName) {
				return augmentedName
			}
		}
	}
	getReturnTypeOfSingleNonGenericCallSignature := func(funcType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		signature := getSingleCallSignature(funcType)
		if signature && !signature.typeParameters {
			return getReturnTypeOfSignature(signature)
		}
	}
	getReturnTypeOfSingleNonGenericSignatureOfCallChain := func(expr CallChain) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		funcType := checkExpression(expr.expression)
		nonOptionalType := getOptionalExpressionType(funcType, expr.expression)
		returnType := getReturnTypeOfSingleNonGenericCallSignature(funcType)
		return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType != funcType)
	}
	getTypeOfExpression := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		quickType := getQuickTypeOfExpression(node)
		if quickType {
			return quickType
		}
		if node.flags&NodeFlagsTypeCached && flowTypeCache {
			cachedType := flowTypeCache[getNodeId(node)]
			if cachedType {
				return cachedType
			}
		}
		startInvocationCount := flowInvocationCount
		type_ := checkExpression(node, CheckModeTypeOnly)
		if flowInvocationCount != startInvocationCount {
			cache := flowTypeCache || ( /* TODO(Node BinaryExpression): flowTypeCache = [] */ TODO)
			cache[getNodeId(node)] = type_
			setNodeFlags(node, node.flags|NodeFlagsTypeCached)
		}
		return type_
	}
	getQuickTypeOfExpression := func(node Expression) *Type {
		expr := skipParentheses(node, true)
		if isJSDocTypeAssertion(expr) {
			type_ := getJSDocTypeAssertionType(expr)
			if !isConstTypeReference(type_) {
				return getTypeFromTypeNode(type_)
			}
		}
		expr = skipParentheses(node)
		if isAwaitExpression(expr) {
			type_ := getQuickTypeOfExpression(expr.expression)
			// converted from conditional expression
			switch {
			case type_:
				return getAwaitedType(type_)
			default:
				return nil
			}
		}
		if isCallExpression(expr) && expr.expression.kind != SyntaxKindSuperKeyword && !isRequireCall(expr, true) && !isSymbolOrSymbolForCall(expr) {
			// converted from conditional expression
			switch {
			case isCallChain(expr):
				return getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr)
			default:
				return getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression))
			}
		} else if isAssertionExpression(expr) && !isConstTypeReference(expr.type_) {
			return getTypeFromTypeNode((expr).type_)
		} else if isLiteralExpression(node) || isBooleanLiteral(node) {
			return checkExpression(node)
		}
		return nil
	}
	getContextFreeTypeOfExpression := func(node Expression) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		links := getNodeLinks(node)
		if links.contextFreeType {
			return links.contextFreeType
		}
		pushContextualType(node, anyType, false)
		type_ := /* TODO(Node BinaryExpression): links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
		popContextualType()
		return type_
	}
	checkExpression := func(node /* TODO(TypeNode UnionType): Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
		tracing. /*?*/ push(tracing.Phase.Check, "checkExpression" /* TODO(Node ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		uninstantiatedType := checkExpressionWorker(node, checkMode, forceTuple)
		type_ := instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
		if isConstEnumObjectType(type_) {
			checkConstEnumAccess(node, type_)
		}
		currentNode = saveCurrentNode
		tracing. /*?*/ pop()
		return type_
	}
	checkConstEnumAccess := func(node /* TODO(TypeNode UnionType): Expression | QualifiedName */ any, type_ Type) {
		ok := (node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent).expression == node) || (node.parent.kind == SyntaxKindElementAccessExpression && (node.parent).expression == node) || ((node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindQualifiedName) && isInRightSideOfImportOrExportAssignment(node) || (node.parent.kind == SyntaxKindTypeQuery && (node.parent).exprName == node)) || (node.parent.kind == SyntaxKindExportSpecifier)
		if !ok {
			error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query)
		}
		if compilerOptions.isolatedModules || compilerOptions.verbatimModuleSyntax && ok && !resolveName(node, getFirstIdentifier(node), SymbolFlagsAlias, nil, false, true) {
			Debug.assert(!!(type_.symbol.flags & SymbolFlagsConstEnum))
			constEnumDeclaration := type_.symbol.valueDeclaration
			redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
			if constEnumDeclaration.flags&NodeFlagsAmbient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
				error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
			}
		}
	}
	checkParenthesizedExpression := func(node ParenthesizedExpression, checkMode CheckMode) Type {
		if hasJSDocNodes(node) {
			if isJSDocSatisfiesExpression(node) {
				return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode)
			}
			if isJSDocTypeAssertion(node) {
				return checkAssertionWorker(node, checkMode)
			}
		}
		return checkExpression(node.expression, checkMode)
	}
	checkExpressionWorker := func(node /* TODO(TypeNode UnionType): Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
		kind := node.kind
		if cancellationToken {
			switch kind {
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				cancellationToken.throwIfCancellationRequested()
			}
		}
		switch kind {
		case SyntaxKindIdentifier:
			return checkIdentifier(node, checkMode)
		case SyntaxKindPrivateIdentifier:
			return checkPrivateIdentifierExpression(node)
		case SyntaxKindThisKeyword:
			return checkThisExpression(node)
		case SyntaxKindSuperKeyword:
			return checkSuperExpression(node)
		case SyntaxKindNullKeyword:
			return nullWideningType
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			// converted from conditional expression
			switch {
			case hasSkipDirectInferenceFlag(node):
				return blockedStringType
			default:
				return getFreshTypeOfLiteralType(getStringLiteralType((node).text))
			}
		case SyntaxKindNumericLiteral:
			checkGrammarNumericLiteral(node)
			return getFreshTypeOfLiteralType(getNumberLiteralType(+(node).text))
		case SyntaxKindBigIntLiteral:
			checkGrammarBigIntLiteral(node)
			return getFreshTypeOfLiteralType(getBigIntLiteralType( /* TODO(Node ObjectLiteralExpression): { negative: false, base10Value: parsePseudoBigInt((node as BigIntLiteral).text), } */ TODO))
		case SyntaxKindTrueKeyword:
			return trueType
		case SyntaxKindFalseKeyword:
			return falseType
		case SyntaxKindTemplateExpression:
			return checkTemplateExpression(node)
		case SyntaxKindRegularExpressionLiteral:
			return checkRegularExpressionLiteral(node)
		case SyntaxKindArrayLiteralExpression:
			return checkArrayLiteral(node, checkMode, forceTuple)
		case SyntaxKindObjectLiteralExpression:
			return checkObjectLiteral(node, checkMode)
		case SyntaxKindPropertyAccessExpression:
			return checkPropertyAccessExpression(node, checkMode)
		case SyntaxKindQualifiedName:
			return checkQualifiedName(node, checkMode)
		case SyntaxKindElementAccessExpression:
			return checkIndexedAccess(node, checkMode)
		case SyntaxKindCallExpression:
			if (node).expression.kind == SyntaxKindImportKeyword {
				return checkImportCallExpression(node)
			}
			fallthrough
		case SyntaxKindNewExpression:
			return checkCallExpression(node, checkMode)
		case SyntaxKindTaggedTemplateExpression:
			return checkTaggedTemplateExpression(node)
		case SyntaxKindParenthesizedExpression:
			return checkParenthesizedExpression(node, checkMode)
		case SyntaxKindClassExpression:
			return checkClassExpression(node)
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		case SyntaxKindTypeOfExpression:
			return checkTypeOfExpression(node)
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			return checkAssertion(node, checkMode)
		case SyntaxKindNonNullExpression:
			return checkNonNullAssertion(node)
		case SyntaxKindExpressionWithTypeArguments:
			return checkExpressionWithTypeArguments(node)
		case SyntaxKindSatisfiesExpression:
			return checkSatisfiesExpression(node)
		case SyntaxKindMetaProperty:
			return checkMetaProperty(node)
		case SyntaxKindDeleteExpression:
			return checkDeleteExpression(node)
		case SyntaxKindVoidExpression:
			return checkVoidExpression(node)
		case SyntaxKindAwaitExpression:
			return checkAwaitExpression(node)
		case SyntaxKindPrefixUnaryExpression:
			return checkPrefixUnaryExpression(node)
		case SyntaxKindPostfixUnaryExpression:
			return checkPostfixUnaryExpression(node)
		case SyntaxKindBinaryExpression:
			return checkBinaryExpression(node, checkMode)
		case SyntaxKindConditionalExpression:
			return checkConditionalExpression(node, checkMode)
		case SyntaxKindSpreadElement:
			return checkSpreadExpression(node, checkMode)
		case SyntaxKindOmittedExpression:
			return undefinedWideningType
		case SyntaxKindYieldExpression:
			return checkYieldExpression(node)
		case SyntaxKindSyntheticExpression:
			return checkSyntheticExpression(node)
		case SyntaxKindJsxExpression:
			return checkJsxExpression(node, checkMode)
		case SyntaxKindJsxElement:
			return checkJsxElement(node, checkMode)
		case SyntaxKindJsxSelfClosingElement:
			return checkJsxSelfClosingElement(node, checkMode)
		case SyntaxKindJsxFragment:
			return checkJsxFragment(node)
		case SyntaxKindJsxAttributes:
			return checkJsxAttributes(node, checkMode)
		case SyntaxKindJsxOpeningElement:
			Debug.fail("Shouldn't ever directly check a JsxOpeningElement")
		}
		return errorType
	}
	checkTypeParameter := func(node TypeParameterDeclaration) {
		checkGrammarModifiers(node)
		if node.expression {
			grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected)
		}
		checkSourceElement(node.constraint)
		checkSourceElement(node.default_)
		typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
		getBaseConstraintOfType(typeParameter)
		if !hasNonCircularTypeParameterDefault(typeParameter) {
			error(node.default_, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter))
		}
		constraintType := getConstraintOfTypeParameter(typeParameter)
		defaultType := getDefaultFromTypeParameter(typeParameter)
		if constraintType && defaultType {
			checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default_, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
		}
		checkNodeDeferred(node)
		addLazyDiagnostic(func() {
			return checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0)
		})
	}
	checkTypeParameterDeferred := func(node TypeParameterDeclaration) {
		if isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent) {
			typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
			modifiers := getTypeParameterModifiers(typeParameter) & (ModifierFlagsIn | ModifierFlagsOut)
			if modifiers {
				symbol := getSymbolOfDeclaration(node.parent)
				if isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped)) {
					error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types)
				} else if modifiers == ModifierFlagsIn || modifiers == ModifierFlagsOut {
					tracing. /*?*/ push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred" /* TODO(Node ObjectLiteralExpression): { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) } */, TODO)
					source := createMarkerType(symbol, typeParameter /* TODO(Node ConditionalExpression): modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck */, TODO)
					target := createMarkerType(symbol, typeParameter /* TODO(Node ConditionalExpression): modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck */, TODO)
					saveVarianceTypeParameter := typeParameter
					varianceTypeParameter = typeParameter
					checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation)
					varianceTypeParameter = saveVarianceTypeParameter
					tracing. /*?*/ pop()
				}
			}
		}
	}
	checkParameter := func(node ParameterDeclaration) {
		checkGrammarModifiers(node)
		checkVariableLikeDeclaration(node)
		func_ := getContainingFunction(node)
		if hasSyntacticModifier(node, ModifierFlagsParameterPropertyModifier) {
			if !(func_.kind == SyntaxKindConstructor && nodeIsPresent(func_.body)) {
				error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation)
			}
			if func_.kind == SyntaxKindConstructor && isIdentifier(node.name) && node.name.escapedText == "constructor" {
				error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name)
			}
		}
		if !node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func_).body {
			error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature)
		}
		if node.name && isIdentifier(node.name) && (node.name.escapedText == "this" || node.name.escapedText == "new") {
			if func_.parameters.indexOf(node) != 0 {
				error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText)
			}
			if func_.kind == SyntaxKindConstructor || func_.kind == SyntaxKindConstructSignature || func_.kind == SyntaxKindConstructorType {
				error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindArrowFunction {
				error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor {
				error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters)
			}
		}
		if node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType) {
			error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type)
		}
	}
	checkTypePredicate := func(node TypePredicateNode) {
		parent := getTypePredicateParent(node)
		if !parent {
			error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods)
			return
		}
		signature := getSignatureFromDeclaration(parent)
		typePredicate := getTypePredicateOfSignature(signature)
		if !typePredicate {
			return
		}
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if typePredicate.kind != TypePredicateKindThis && typePredicate.kind != TypePredicateKindAssertsThis {
			if typePredicate.parameterIndex >= 0 {
				if signatureHasRestParameter(signature) && typePredicate.parameterIndex == signature.parameters.length-1 {
					error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter)
				} else {
					if typePredicate.type_ {
						leadingError := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ any {
							return chainDiagnosticMessages(nil, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type)
						}
						checkTypeAssignableTo(typePredicate.type_, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type_, nil, leadingError)
					}
				}
			} else if parameterName {
				hasReportedError := false
				for _, TODO_IDENTIFIER := range parent.parameters {
					if isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName) {
						hasReportedError = true
						break
					}
				}
				if !hasReportedError {
					error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName)
				}
			}
		}
	}
	getTypePredicateParent := func(node Node) *SignatureDeclaration {
		switch node.parent.kind {
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindCallSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			parent := node.parent
			if node == parent.type_ {
				return parent
			}
		}
	}
	checkIfTypePredicateVariableIsDeclaredInBindingPattern := func(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) /* TODO inferred type true | undefined */ any {
		for _, element := range pattern.elements {
			if isOmittedExpression(element) {
				continue
			}
			name := element.name
			if name.kind == SyntaxKindIdentifier && name.escapedText == predicateVariableName {
				error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName)
				return true
			} else if name.kind == SyntaxKindArrayBindingPattern || name.kind == SyntaxKindObjectBindingPattern {
				if checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName) {
					return true
				}
			}
		}
	}
	checkSignatureDeclaration := func(node SignatureDeclaration) {
		if node.kind == SyntaxKindIndexSignature {
			checkGrammarIndexSignature(node)
		} else if node.kind == SyntaxKindFunctionType || node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindConstructorType || node.kind == SyntaxKindCallSignature || node.kind == SyntaxKindConstructor || node.kind == SyntaxKindConstructSignature {
			checkGrammarFunctionLikeDeclaration(node)
		}
		functionFlags := getFunctionFlags(node)
		if !(functionFlags & FunctionFlagsInvalid) {
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsyncGenerator && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncGeneratorIncludes)
			}
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetAsyncFunctions {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAwaiter)
			}
			if (functionFlags&FunctionFlagsAsyncGenerator) != FunctionFlagsNormal && languageVersion < LanguageFeatureMinimumTargetGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersGenerator)
			}
		}
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkUnmatchedJSDocParameters(node)
		forEach(node.parameters, checkParameter)
		if node.type_ {
			checkSourceElement(node.type_)
		}
		addLazyDiagnostic(checkSignatureDeclarationDiagnostics)
		checkSignatureDeclarationDiagnostics := func() {
			checkCollisionWithArgumentsInGeneratedCode(node)
			returnTypeNode := getEffectiveReturnTypeNode(node)
			returnTypeErrorLocation := returnTypeNode
			if isInJSFile(node) {
				typeTag := getJSDocTypeTag(node)
				if typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type_) {
					signature := getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
					if signature && signature.declaration {
						returnTypeNode = getEffectiveReturnTypeNode(signature.declaration)
						returnTypeErrorLocation = typeTag.typeExpression.type_
					}
				}
			}
			if noImplicitAny && !returnTypeNode {
				switch node.kind {
				case SyntaxKindConstructSignature:
					error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
					break
				case SyntaxKindCallSignature:
					error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
					break
				}
			}
			if returnTypeNode && returnTypeErrorLocation {
				functionFlags := getFunctionFlags(node)
				if (functionFlags & (FunctionFlagsInvalid | FunctionFlagsGenerator)) == FunctionFlagsGenerator {
					returnType := getTypeFromTypeNode(returnTypeNode)
					if returnType == voidType {
						error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation)
					} else {
						checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation)
					}
				} else if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
					checkAsyncFunctionReturnType(node, returnTypeNode, returnTypeErrorLocation)
				}
			}
			if node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindJSDocFunctionType {
				registerForUnusedIdentifiersCheck(node)
			}
		}
	}
	checkGeneratorInstantiationAssignabilityToReturnType := func(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) /* TODO inferred type boolean */ any {
		generatorYieldType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, returnType, (functionFlags&FunctionFlagsAsync) != 0) || anyType
		generatorReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, (functionFlags&FunctionFlagsAsync) != 0) || generatorYieldType
		generatorNextType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, (functionFlags&FunctionFlagsAsync) != 0) || unknownType
		generatorInstantiation := createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlagsAsync))
		return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
	}
	checkClassForDuplicateDeclarations := func(node ClassLikeDeclaration) {
		instanceNames := make(map[__String]DeclarationMeaning)
		staticNames := make(map[__String]DeclarationMeaning)
		privateIdentifiers := make(map[__String]DeclarationMeaning)
		for _, member := range node.members {
			if member.kind == SyntaxKindConstructor {
				for _, param := range (member).parameters {
					if isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name) {
						addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaningGetOrSetAccessor)
					}
				}
			} else {
				isStaticMember := isStatic(member)
				name := member.name
				if !name {
					continue
				}
				isPrivate := isPrivateIdentifier(name)
				privateStaticFlags := /* TODO(Node ConditionalExpression): isPrivate && isStaticMember ? DeclarationMeaning.PrivateStatic : 0 */ TODO
				names := /* TODO(Node ConditionalExpression): isPrivate ? privateIdentifiers : isStaticMember ? staticNames : instanceNames */ TODO
				memberName := name && getEffectivePropertyNameForPropertyNameNode(name)
				if memberName {
					switch member.kind {
					case SyntaxKindGetAccessor:
						addName(names, name, memberName, DeclarationMeaningGetAccessor|privateStaticFlags)
						break
					case SyntaxKindSetAccessor:
						addName(names, name, memberName, DeclarationMeaningSetAccessor|privateStaticFlags)
						break
					case SyntaxKindPropertyDeclaration:
						addName(names, name, memberName, DeclarationMeaningGetOrSetAccessor|privateStaticFlags)
						break
					case SyntaxKindMethodDeclaration:
						addName(names, name, memberName, DeclarationMeaningMethod|privateStaticFlags)
						break
					}
				}
			}
		}
		addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
			prev := names.get(name)
			if prev {
				if (prev & DeclarationMeaningPrivateStatic) != (meaning & DeclarationMeaningPrivateStatic) {
					error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location))
				} else {
					prevIsMethod := !!(prev & DeclarationMeaningMethod)
					isMethod := !!(meaning & DeclarationMeaningMethod)
					if prevIsMethod || isMethod {
						if prevIsMethod != isMethod {
							error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
						}
					} else if prev & meaning & ~DeclarationMeaningPrivateStatic {
						error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
					} else {
						names.set(name, prev|meaning)
					}
				}
			} else {
				names.set(name, meaning)
			}
		}
	}
	checkClassForStaticPropertyNameConflicts := func(node ClassLikeDeclaration) {
		for _, member := range node.members {
			memberNameNode := member.name
			isStaticMember := isStatic(member)
			if isStaticMember && memberNameNode {
				memberName := getEffectivePropertyNameForPropertyNameNode(memberNameNode)
				switch memberName {
				case "name":
					fallthrough // TODO: merge cases
				case "length":
					fallthrough // TODO: merge cases
				case "caller":
					fallthrough // TODO: merge cases
				case "arguments":
					if useDefineForClassFields {
						break
					}
					fallthrough
				case "prototype":
					message := Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1
					className := getNameOfSymbolAsWritten(getSymbolOfDeclaration(node))
					error(memberNameNode, message, memberName, className)
					break
				}
			}
		}
	}
	checkObjectTypeForDuplicateDeclarations := func(node /* TODO(TypeNode UnionType): TypeLiteralNode | InterfaceDeclaration */ any) {
		names := make(map[string]bool)
		for _, member := range node.members {
			if member.kind == SyntaxKindPropertySignature {
				var memberName string
				name := member.name
				switch name.kind {
				case SyntaxKindStringLiteral:
					fallthrough // TODO: merge cases
				case SyntaxKindNumericLiteral:
					memberName = name.text
					break
				case SyntaxKindIdentifier:
					memberName = idText(name)
					break
				default:
					continue
				}
				if names.get(memberName) {
					error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName)
					error(member.name, Diagnostics.Duplicate_identifier_0, memberName)
				} else {
					names.set(memberName, true)
				}
			}
		}
	}
	checkTypeForDuplicateIndexSignatures := func(node /* TODO(TypeNode UnionType): ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
		if node.kind == SyntaxKindInterfaceDeclaration {
			nodeSymbol := getSymbolOfDeclaration(node)
			if nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] != node {
				return
			}
		}
		indexSymbol := getIndexSymbol(getSymbolOfDeclaration(node))
		if indexSymbol. /*?*/ declarations {
			indexSignatureMap := make(map[TypeId] /* TODO(TypeNode TypeLiteral): { type: Type; declarations: IndexSignatureDeclaration[]; } */ any)
			for _, declaration := range indexSymbol.declarations {
				if declaration.parameters.length == 1 && declaration.parameters[0].type_ {
					forEachType(getTypeFromTypeNode(declaration.parameters[0].type_), func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) {
						entry := indexSignatureMap.get(getTypeId(type_))
						if entry {
							entry.declarations.push(declaration)
						} else {
							indexSignatureMap.set(getTypeId(type_) /* TODO(Node ObjectLiteralExpression): { type, declarations: [declaration] } */, TODO)
						}
					})
				}
			}
			indexSignatureMap.forEach(func(entry /* TODO inferred type { type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type; declarations: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[]; } */ any) {
				if entry.declarations.length > 1 {
					for _, declaration := range entry.declarations {
						error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type_))
					}
				}
			})
		}
	}
	checkPropertyDeclaration := func(node /* TODO(TypeNode UnionType): PropertyDeclaration | PropertySignature */ any) {
		if !checkGrammarModifiers(node) && !checkGrammarProperty(node) {
			checkGrammarComputedPropertyName(node.name)
		}
		checkVariableLikeDeclaration(node)
		setNodeLinksForPrivateIdentifierScope(node)
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindPropertyDeclaration && node.initializer {
			error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
	}
	checkPropertySignature := func(node PropertySignature) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		return checkPropertyDeclaration(node)
	}
	checkMethodDeclaration := func(node /* TODO(TypeNode UnionType): MethodDeclaration | MethodSignature */ any) {
		if !checkGrammarMethod(node) {
			checkGrammarComputedPropertyName(node.name)
		}
		if isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) == "constructor" {
			error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator)
		}
		checkFunctionOrMethodDeclaration(node)
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindMethodDeclaration && node.body {
			error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
		if isPrivateIdentifier(node.name) && !getContainingClass(node) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		setNodeLinksForPrivateIdentifierScope(node)
	}
	setNodeLinksForPrivateIdentifierScope := func(node /* TODO(TypeNode UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
		if isPrivateIdentifier(node.name) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				for lexicalScope := getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope) {
					getNodeLinks(lexicalScope).flags |= NodeCheckFlagsContainsClassWithPrivateIdentifiers
				}
				if isClassExpression(node.parent) {
					enclosingIterationStatement := getEnclosingIterationStatement(node.parent)
					if enclosingIterationStatement {
						getNodeLinks(node.name).flags |= NodeCheckFlagsBlockScopedBindingInLoop
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					}
				}
			}
		}
	}
	checkClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
		checkGrammarModifiers(node)
		forEachChild(node, checkSourceElement)
	}
	checkConstructorDeclaration := func(node ConstructorDeclaration) {
		checkSignatureDeclaration(node)
		if !checkGrammarConstructorTypeParameters(node) {
			checkGrammarConstructorTypeAnnotation(node)
		}
		checkSourceElement(node.body)
		symbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(symbol, node.kind)
		if node == firstDeclaration {
			checkFunctionOrConstructorSymbol(symbol)
		}
		if nodeIsMissing(node.body) {
			return
		}
		addLazyDiagnostic(checkConstructorDeclarationDiagnostics)
		return
		isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
			if isPrivateIdentifierClassElementDeclaration(n) {
				return true
			}
			return n.kind == SyntaxKindPropertyDeclaration && !isStatic(n) && !!(n).initializer
		}
		checkConstructorDeclarationDiagnostics := func() {
			containingClassDecl := node.parent
			if getClassExtendsHeritageElement(containingClassDecl) {
				captureLexicalThis(node.parent, containingClassDecl)
				classExtendsNull := classDeclarationExtendsNull(containingClassDecl)
				superCall := findFirstSuperCall(node.body)
				if superCall {
					if classExtendsNull {
						error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null)
					}
					superCallShouldBeRootLevel := !emitStandardClassFields && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any) /* TODO inferred type boolean */ any {
						return hasSyntacticModifier(p, ModifierFlagsParameterPropertyModifier)
					}))
					if superCallShouldBeRootLevel {
						if !superCallIsRootLevelInConstructor(superCall, node.body) {
							error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers)
						} else {
							var superCallStatement *ExpressionStatement
							for _, statement := range node.body.statements {
								if isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression)) {
									superCallStatement = statement
									break
								}
								if nodeImmediatelyReferencesSuperOrThis(statement) {
									break
								}
							}
							if superCallStatement == nil {
								error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers)
							}
						}
					}
				} else if !classExtendsNull {
					error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call)
				}
			}
		}
	}
	superCallIsRootLevelInConstructor := func(superCall Node, body Block) /* TODO inferred type boolean */ any {
		superCallParent := walkUpParenthesizedExpressions(superCall.parent)
		return isExpressionStatement(superCallParent) && superCallParent.parent == body
	}
	nodeImmediatelyReferencesSuperOrThis := func(node Node) bool {
		if node.kind == SyntaxKindSuperKeyword || node.kind == SyntaxKindThisKeyword {
			return true
		}
		if isThisContainerOrFunctionBlock(node) {
			return false
		}
		return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis)
	}
	checkAccessorDeclaration := func(node AccessorDeclaration) {
		if isIdentifier(node.name) && idText(node.name) == "constructor" && isClassLike(node.parent) {
			error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor)
		}
		addLazyDiagnostic(checkAccessorDeclarationDiagnostics)
		checkSourceElement(node.body)
		setNodeLinksForPrivateIdentifierScope(node)
		checkAccessorDeclarationDiagnostics := func() {
			if !checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node) {
				checkGrammarComputedPropertyName(node.name)
			}
			checkDecorators(node)
			checkSignatureDeclaration(node)
			if node.kind == SyntaxKindGetAccessor {
				if !(node.flags & NodeFlagsAmbient) && nodeIsPresent(node.body) && (node.flags & NodeFlagsHasImplicitReturn) {
					if !(node.flags & NodeFlagsHasExplicitReturn) {
						error(node.name, Diagnostics.A_get_accessor_must_return_a_value)
					}
				}
			}
			if node.name.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.name)
			}
			if hasBindableName(node) {
				symbol := getSymbolOfDeclaration(node)
				getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
				setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
				if getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlagsTypeChecked) {
					getNodeLinks(getter).flags |= NodeCheckFlagsTypeChecked
					getterFlags := getEffectiveModifierFlags(getter)
					setterFlags := getEffectiveModifierFlags(setter)
					if (getterFlags & ModifierFlagsAbstract) != (setterFlags & ModifierFlagsAbstract) {
						error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
						error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
					}
					if ((getterFlags & ModifierFlagsProtected) && !(setterFlags & (ModifierFlagsProtected | ModifierFlagsPrivate))) || ((getterFlags & ModifierFlagsPrivate) && !(setterFlags & ModifierFlagsPrivate)) {
						error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
						error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
					}
				}
			}
			returnType := getTypeOfAccessors(getSymbolOfDeclaration(node))
			if node.kind == SyntaxKindGetAccessor {
				checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
			}
		}
	}
	checkMissingDeclaration := func(node Node) {
		checkDecorators(node)
	}
	getEffectiveTypeArgumentAtIndex := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
		if node.typeArguments && index < node.typeArguments.length {
			return getTypeFromTypeNode(node.typeArguments[index])
		}
		return getEffectiveTypeArguments(node, typeParameters)[index]
	}
	getEffectiveTypeArguments := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
		return fillMissingTypeArguments(map_(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node))
	}
	checkTypeArgumentConstraints := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
		var typeArguments *[]Type
		var mapper *TypeMapper
		result := true
		for i := 0; i < typeParameters.length; i++ {
			constraint := getConstraintOfTypeParameter(typeParameters[i])
			if constraint {
				if !typeArguments {
					typeArguments = getEffectiveTypeArguments(node, typeParameters)
					mapper = createTypeMapper(typeParameters, typeArguments)
				}
				result = result && checkTypeAssignableTo(typeArguments[i], instantiateType(constraint, mapper), node.typeArguments[i], Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
			}
		}
		return result
	}
	getTypeParametersForTypeAndSymbol := func(type_ Type, symbol Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ any {
		if !isErrorType(type_) {
			return symbol.flags&SymbolFlagsTypeAlias && getSymbolLinks(symbol).typeParameters || ( /* TODO(Node ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined */ TODO)
		}
		return nil
	}
	getTypeParametersForTypeReferenceOrImport := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ any {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				return getTypeParametersForTypeAndSymbol(type_, symbol)
			}
		}
		return nil
	}
	checkTypeReferenceNode := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any) {
		checkGrammarTypeArguments(node, node.typeArguments)
		if node.kind == SyntaxKindTypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end != node.typeArguments.pos {
			sourceFile := getSourceFileOfNode(node)
			if scanTokenAtPosition(sourceFile, node.typeName.end) == SyntaxKindDotToken {
				grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
		forEach(node.typeArguments, checkSourceElement)
		checkTypeReferenceOrImport(node)
	}
	checkTypeReferenceOrImport := func(node /* TODO(TypeNode UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			if node.typeArguments {
				addLazyDiagnostic(func() {
					typeParameters := getTypeParametersForTypeReferenceOrImport(node)
					if typeParameters {
						checkTypeArgumentConstraints(node, typeParameters)
					}
				})
			}
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				if some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return isTypeDeclaration(d) && !!(d.flags & NodeFlagsDeprecated)
				}) {
					addDeprecatedSuggestion(getDeprecatedSuggestionNode(node), symbol.declarations, symbol.escapedName)
				}
			}
		}
	}
	getTypeArgumentConstraint := func(node TypeNode) *Type {
		typeReferenceNode := tryCast(node.parent, isTypeReferenceType)
		if !typeReferenceNode {
			return nil
		}
		typeParameters := getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
		if !typeParameters {
			return nil
		}
		constraint := getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)])
		return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)))
	}
	checkTypeQuery := func(node TypeQueryNode) {
		getTypeFromTypeQueryNode(node)
	}
	checkTypeLiteral := func(node TypeLiteralNode) {
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(checkTypeLiteralDiagnostics)
		checkTypeLiteralDiagnostics := func() {
			type_ := getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
			checkIndexConstraints(type_, type_.symbol)
			checkTypeForDuplicateIndexSignatures(node)
			checkObjectTypeForDuplicateDeclarations(node)
		}
	}
	checkArrayType := func(node ArrayTypeNode) {
		checkSourceElement(node.elementType)
	}
	checkTupleType := func(node TupleTypeNode) {
		seenOptionalElement := false
		seenRestElement := false
		for _, e := range node.elements {
			flags := getTupleElementFlags(e)
			if flags & ElementFlagsVariadic {
				type_ := getTypeFromTypeNode((e).type_)
				if !isArrayLikeType(type_) {
					error(e, Diagnostics.A_rest_element_type_must_be_an_array_type)
					break
				}
				if isArrayType(type_) || isTupleType(type_) && type_.target.combinedFlags&ElementFlagsRest {
					flags |= ElementFlagsRest
				}
			}
			if flags & ElementFlagsRest {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element)
					break
				}
				seenRestElement = true
			} else if flags & ElementFlagsOptional {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element)
					break
				}
				seenOptionalElement = true
			} else if flags&ElementFlagsRequired && seenOptionalElement {
				grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element)
				break
			}
		}
		forEach(node.elements, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkUnionOrIntersectionType := func(node UnionOrIntersectionTypeNode) {
		forEach(node.types, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkIndexedAccessIndexType := func(type_ Type, accessNode /* TODO(TypeNode UnionType): IndexedAccessTypeNode | ElementAccessExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if !(type_.flags & TypeFlagsIndexedAccess) {
			return type_
		}
		objectType := (type_).objectType
		indexType := (type_).indexType
		objectIndexType := /* TODO(Node ConditionalExpression): isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping ? getIndexTypeForMappedType(objectType, IndexFlags.None) : getIndexType(objectType, IndexFlags.None) */ TODO
		hasNumberIndexInfo := !!getIndexInfoOfType(objectType, numberType)
		if everyType(indexType, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && isApplicableIndexType(t, numberType)
		}) {
			if accessNode.kind == SyntaxKindElementAccessExpression && isAssignmentTarget(accessNode) && getObjectFlags(objectType)&ObjectFlagsMapped && getMappedTypeModifiers(objectType)&MappedTypeModifiersIncludeReadonly {
				error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
			return type_
		}
		if isGenericObjectType(objectType) {
			propertyName := getPropertyNameFromIndex(indexType, accessNode)
			if propertyName {
				propertySymbol := forEachType(getApparentType(objectType), func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
					return getPropertyOfType(t, propertyName)
				})
				if propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol)&ModifierFlagsNonPublicAccessibilityModifier {
					error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName))
					return errorType
				}
			}
		}
		error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType))
		return errorType
	}
	checkIndexedAccessType := func(node IndexedAccessTypeNode) {
		checkSourceElement(node.objectType)
		checkSourceElement(node.indexType)
		checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node)
	}
	checkMappedType := func(node MappedTypeNode) {
		checkGrammarMappedType(node)
		checkSourceElement(node.typeParameter)
		checkSourceElement(node.nameType)
		checkSourceElement(node.type_)
		if !node.type_ {
			reportImplicitAny(node, anyType)
		}
		type_ := getTypeFromMappedTypeNode(node)
		nameType := getNameTypeFromMappedType(type_)
		if nameType {
			checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType)
		} else {
			constraintType := getConstraintTypeFromMappedType(type_)
			checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter))
		}
	}
	checkGrammarMappedType := func(node MappedTypeNode) /* TODO inferred type boolean | undefined */ any {
		if node.members. /*?*/ length {
			return grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
	}
	checkThisType := func(node ThisTypeNode) {
		getTypeFromThisTypeNode(node)
	}
	checkTypeOperator := func(node TypeOperatorNode) {
		checkGrammarTypeOperatorNode(node)
		checkSourceElement(node.type_)
	}
	checkConditionalType := func(node ConditionalTypeNode) {
		forEachChild(node, checkSourceElement)
	}
	checkInferType := func(node InferTypeNode) {
		if !findAncestor(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			return n.parent && n.parent.kind == SyntaxKindConditionalType && (n.parent).extendsType == n
		}) {
			grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type)
		}
		checkSourceElement(node.typeParameter)
		symbol := getSymbolOfDeclaration(node.typeParameter)
		if symbol.declarations && symbol.declarations.length > 1 {
			links := getSymbolLinks(symbol)
			if !links.typeParametersChecked {
				links.typeParametersChecked = true
				typeParameter := getDeclaredTypeOfTypeParameter(symbol)
				var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol, SyntaxKindTypeParameter)
				if !areTypeParametersIdentical(declarations, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ any{typeParameter}, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] */ any {
					return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ any{decl}
				}) {
					name := symbolToString(symbol)
					for _, declaration := range declarations {
						error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name)
					}
				}
			}
		}
		registerForUnusedIdentifiersCheck(node)
	}
	checkTemplateLiteralType := func(node TemplateLiteralTypeNode) {
		for _, span := range node.templateSpans {
			checkSourceElement(span.type_)
			type_ := getTypeFromTypeNode(span.type_)
			checkTypeAssignableTo(type_, templateConstraintType, span.type_)
		}
		getTypeFromTypeNode(node)
	}
	checkImportType := func(node ImportTypeNode) {
		checkSourceElement(node.argument)
		if node.attributes {
			getResolutionModeOverride(node.attributes, grammarErrorOnNode)
		}
		checkTypeReferenceOrImport(node)
	}
	checkNamedTupleMember := func(node NamedTupleMember) {
		if node.dotDotDotToken && node.questionToken {
			grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest)
		}
		if node.type_.kind == SyntaxKindOptionalType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type)
		}
		if node.type_.kind == SyntaxKindRestType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type)
		}
		checkSourceElement(node.type_)
		getTypeFromTypeNode(node)
	}
	isPrivateWithinAmbient := func(node Node) bool {
		return (hasEffectiveModifier(node, ModifierFlagsPrivate) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlagsAmbient)
	}
	getEffectiveDeclarationFlags := func(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
		flags := getCombinedModifierFlagsCached(n)
		if n.parent.kind != SyntaxKindInterfaceDeclaration && n.parent.kind != SyntaxKindClassDeclaration && n.parent.kind != SyntaxKindClassExpression && n.flags&NodeFlagsAmbient {
			container := getEnclosingContainer(n)
			if (container && container.flags&NodeFlagsExportContext) && !(flags & ModifierFlagsAmbient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) {
				flags |= ModifierFlagsExport
			}
			flags |= ModifierFlagsAmbient
		}
		return flags & flagsToCheck
	}
	checkFunctionOrConstructorSymbol := func(symbol Symbol) {
		addLazyDiagnostic(func() {
			return checkFunctionOrConstructorSymbolWorker(symbol)
		})
	}
	checkFunctionOrConstructorSymbolWorker := func(symbol Symbol) {
		getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
			implementationSharesContainerWithFirstOverload := implementation != nil && implementation.parent == overloads[0].parent
			// converted from conditional expression
			switch {
			case implementationSharesContainerWithFirstOverload:
				return implementation
			default:
				return overloads[0]
			}
		}
		checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
			someButNotAllOverloadFlags := /* TODO(Node BinaryExpression): someOverloadFlags ^ allOverloadFlags */ TODO
			if someButNotAllOverloadFlags != 0 {
				canonicalFlags := getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
				group(overloads, func(o /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type string */ any {
					return getSourceFileOfNode(o).fileName
				}).forEach(func(overloadsInFile /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration[] */ any) {
					canonicalFlagsForFile := getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck)
					for _, o := range overloadsInFile {
						deviation := /* TODO(Node BinaryExpression): getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags */ TODO
						deviationInFile := /* TODO(Node BinaryExpression): getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile */ TODO
						if deviationInFile & ModifierFlagsExport {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported)
						} else if deviationInFile & ModifierFlagsAmbient {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient)
						} else if deviation & (ModifierFlagsPrivate | ModifierFlagsProtected) {
							error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected)
						} else if deviation & ModifierFlagsAbstract {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract)
						}
					}
				})
			}
		}
		checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
			if someHaveQuestionToken != allHaveQuestionToken {
				canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
				forEach(overloads, func(o /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
					deviation := hasQuestionToken(o) != canonicalHasQuestionToken
					if deviation {
						error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required)
					}
				})
			}
		}
		var flagsToCheck ModifierFlags = ModifierFlagsExport | ModifierFlagsAmbient | ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAbstract
		var someNodeFlags ModifierFlags = ModifierFlagsNone
		allNodeFlags := flagsToCheck
		someHaveQuestionToken := false
		allHaveQuestionToken := true
		hasOverloads := false
		var bodyDeclaration *FunctionLikeDeclaration
		var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
		var previousDeclaration *SignatureDeclaration
		declarations := symbol.declarations
		isConstructor := (symbol.flags & SymbolFlagsConstructor) != 0
		reportImplementationExpectedError := func(node SignatureDeclaration) {
			if node.name && nodeIsMissing(node.name) {
				return
			}
			seen := false
			subsequentNode := forEachChild(node.parent, func(c /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ any {
				if seen {
					return c
				} else {
					seen = c == node
				}
			})
			if subsequentNode && subsequentNode.pos == node.end {
				if subsequentNode.kind == node.kind {
					var errorNode Node = (subsequentNode).name || subsequentNode
					subsequentName := (subsequentNode).name
					if node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText == subsequentName.escapedText || isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) || isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) == getEscapedTextOfIdentifierOrLiteral(subsequentName)) {
						reportError := (node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature) && isStatic(node) != isStatic(subsequentNode)
						if reportError {
							diagnostic := /* TODO(Node ConditionalExpression): isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static */ TODO
							error(errorNode, diagnostic)
						}
						return
					}
					if nodeIsPresent((subsequentNode).body) {
						error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name))
						return
					}
				}
			}
			var errorNode Node = node.name || node
			if isConstructor {
				error(errorNode, Diagnostics.Constructor_implementation_is_missing)
			} else {
				if hasSyntacticModifier(node, ModifierFlagsAbstract) {
					error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive)
				} else {
					error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration)
				}
			}
		}
		duplicateFunctionDeclaration := false
		multipleConstructorImplementation := false
		hasNonAmbientClass := false
		functionDeclarations := [] /* TODO inferred type never */ any{}
		if declarations {
			for _, current := range declarations {
				node := current
				inAmbientContext := node.flags & NodeFlagsAmbient
				inAmbientContextOrInterface := node.parent && (node.parent.kind == SyntaxKindInterfaceDeclaration || node.parent.kind == SyntaxKindTypeLiteral) || inAmbientContext
				if inAmbientContextOrInterface {
					previousDeclaration = nil
				}
				if (node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression) && !inAmbientContext {
					hasNonAmbientClass = true
				}
				if node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindConstructor {
					functionDeclarations.push(node)
					currentNodeFlags := getEffectiveDeclarationFlags(node, flagsToCheck)
					someNodeFlags |= currentNodeFlags
					allNodeFlags &= currentNodeFlags
					someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node)
					allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node)
					bodyIsPresent := nodeIsPresent((node).body)
					if bodyIsPresent && bodyDeclaration {
						if isConstructor {
							multipleConstructorImplementation = true
						} else {
							duplicateFunctionDeclaration = true
						}
					} else if previousDeclaration. /*?*/ parent == node.parent && previousDeclaration.end != node.pos {
						reportImplementationExpectedError(previousDeclaration)
					}
					if bodyIsPresent {
						if !bodyDeclaration {
							bodyDeclaration = node
						}
					} else {
						hasOverloads = true
					}
					previousDeclaration = node
					if !inAmbientContextOrInterface {
						lastSeenNonAmbientDeclaration = node
					}
				}
				if isInJSFile(current) && isFunctionLike(current) && current.jsDoc {
					hasOverloads = length(getJSDocOverloadTags(current)) > 0
				}
			}
		}
		if multipleConstructorImplementation {
			forEach(functionDeclarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
				error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed)
			})
		}
		if duplicateFunctionDeclaration {
			forEach(functionDeclarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
				error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation)
			})
		}
		if hasNonAmbientClass && !isConstructor && symbol.flags&SymbolFlagsFunction && declarations {
			relatedDiagnostics := filter(declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
				return d.kind == SyntaxKindClassDeclaration
			}).map_(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
				return createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class)
			})
			forEach(declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
				diagnostic := /* TODO(Node ConditionalExpression): declaration.kind === SyntaxKind.ClassDeclaration ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0 : declaration.kind === SyntaxKind.FunctionDeclaration ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient : undefined */ TODO
				if diagnostic {
					addRelatedInfo(error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)), relatedDiagnostics...)
				}
			})
		}
		if lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlagsAbstract) && !lastSeenNonAmbientDeclaration.questionToken {
			reportImplementationExpectedError(lastSeenNonAmbientDeclaration)
		}
		if hasOverloads {
			if declarations {
				checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags)
				checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken)
			}
			if bodyDeclaration {
				signatures := getSignaturesOfSymbol(symbol)
				bodySignature := getSignatureFromDeclaration(bodyDeclaration)
				for _, signature := range signatures {
					if !isImplementationCompatibleWithOverload(bodySignature, signature) {
						errorNode := /* TODO(Node ConditionalExpression): signature.declaration && isJSDocSignature(signature.declaration) ? (signature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName : signature.declaration */ TODO
						addRelatedInfo(error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here))
						break
					}
				}
			}
		}
	}
	checkExportsOnMergedDeclarations := func(node Declaration) {
		addLazyDiagnostic(func() {
			return checkExportsOnMergedDeclarationsWorker(node)
		})
	}
	checkExportsOnMergedDeclarationsWorker := func(node Declaration) {
		symbol := node.localSymbol
		if !symbol {
			symbol = getSymbolOfDeclaration(node)
			if !symbol.exportSymbol {
				return
			}
		}
		if getDeclarationOfKind(symbol, node.kind) != node {
			return
		}
		exportedDeclarationSpaces := DeclarationSpacesNone
		nonExportedDeclarationSpaces := DeclarationSpacesNone
		defaultExportedDeclarationSpaces := DeclarationSpacesNone
		for _, d := range symbol.declarations {
			declarationSpaces := getDeclarationSpaces(d)
			effectiveDeclarationFlags := getEffectiveDeclarationFlags(d, ModifierFlagsExport|ModifierFlagsDefault)
			if effectiveDeclarationFlags & ModifierFlagsExport {
				if effectiveDeclarationFlags & ModifierFlagsDefault {
					defaultExportedDeclarationSpaces |= declarationSpaces
				} else {
					exportedDeclarationSpaces |= declarationSpaces
				}
			} else {
				nonExportedDeclarationSpaces |= declarationSpaces
			}
		}
		nonDefaultExportedDeclarationSpaces := exportedDeclarationSpaces | nonExportedDeclarationSpaces
		commonDeclarationSpacesForExportsAndLocals := exportedDeclarationSpaces & nonExportedDeclarationSpaces
		commonDeclarationSpacesForDefaultAndNonDefault := defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces
		if commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault {
			for _, d := range symbol.declarations {
				declarationSpaces := getDeclarationSpaces(d)
				name := getNameOfDeclaration(d)
				if declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault {
					error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name))
				} else if declarationSpaces & commonDeclarationSpacesForExportsAndLocals {
					error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name))
				}
			}
		}
		getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
			d := decl
			switch d.kind {
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocTypedefTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocCallbackTag:
				fallthrough // TODO: merge cases
			case SyntaxKindJSDocEnumTag:
				return DeclarationSpacesExportType
			case SyntaxKindModuleDeclaration:
				// converted from conditional expression
				switch {
				case isAmbientModule(d) || getModuleInstanceState(d) != ModuleInstanceStateNonInstantiated:
					return DeclarationSpacesExportNamespace | DeclarationSpacesExportValue
				default:
					return DeclarationSpacesExportNamespace
				}
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindEnumDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindEnumMember:
				return DeclarationSpacesExportType | DeclarationSpacesExportValue
			case SyntaxKindSourceFile:
				return DeclarationSpacesExportType | DeclarationSpacesExportValue | DeclarationSpacesExportNamespace
			case SyntaxKindExportAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindBinaryExpression:
				node := d
				expression := /* TODO(Node ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
				if !isEntityNameExpression(expression) {
					return DeclarationSpacesExportValue
				}
				d = expression
				fallthrough
			case SyntaxKindImportEqualsDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindNamespaceImport:
				fallthrough // TODO: merge cases
			case SyntaxKindImportClause:
				result := DeclarationSpacesNone
				target := resolveAlias(getSymbolOfDeclaration(d))
				forEach(target.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
					result |= getDeclarationSpaces(d)
				})
				return result
			case SyntaxKindVariableDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindBindingElement:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindImportSpecifier:
				fallthrough // TODO: merge cases
			case SyntaxKindIdentifier:
				return DeclarationSpacesExportValue
			case SyntaxKindMethodSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertySignature:
				return DeclarationSpacesExportType
			default:
				return Debug.failBadSyntaxKind(d)
			}
		}
	}
	getAwaitedTypeOfPromise := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		promisedType := getPromisedTypeOfPromise(type_, errorNode)
		return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, args...)
	}
	getPromisedTypeOfPromise := func(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TypeNode TypeLiteral): { value?: Type; } */ any) *Type {
		if isTypeAny(type_) {
			return nil
		}
		typeAsPromise := type_
		if typeAsPromise.promisedTypeOfPromise {
			return typeAsPromise.promisedTypeOfPromise
		}
		if isReferenceToType(type_, getGlobalPromiseType(false)) {
			typeAsPromise.promisedTypeOfPromise = getTypeArguments(type_)[0]
			return typeAsPromise.promisedTypeOfPromise
		}
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return nil
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then")
		if isTypeAny(thenFunction) {
			return nil
		}
		thenSignatures := /* TODO(Node ConditionalExpression): thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : emptyArray */ TODO
		if thenSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.A_promise_must_have_a_then_method)
			}
			return nil
		}
		var thisTypeForError *Type
		var candidates *[]Signature
		for _, thenSignature := range thenSignatures {
			thisType := getThisTypeOfSignature(thenSignature)
			if thisType && thisType != voidType && !isTypeRelatedTo(type_, thisType, subtypeRelation) {
				thisTypeForError = thisType
			} else {
				candidates = append(candidates, thenSignature)
			}
		}
		if !candidates {
			Debug.assertIsDefined(thisTypeForError)
			if thisTypeForErrorOut {
				thisTypeForErrorOut.value = thisTypeForError
			}
			if errorNode {
				error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForError))
			}
			return nil
		}
		onfulfilledParameterType := getTypeWithFacts(getUnionType(map_(candidates, getTypeOfFirstParameterOfSignature)), TypeFactsNEUndefinedOrNull)
		if isTypeAny(onfulfilledParameterType) {
			return nil
		}
		onfulfilledParameterSignatures := getSignaturesOfType(onfulfilledParameterType, SignatureKindCall)
		if onfulfilledParameterSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback)
			}
			return nil
		}
		typeAsPromise.promisedTypeOfPromise = getUnionType(map_(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReductionSubtype)
		return typeAsPromise.promisedTypeOfPromise
	}
	checkAwaitedType := func(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		awaitedType := /* TODO(Node ConditionalExpression): withAlias ? getAwaitedType(type, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args) */ TODO
		return awaitedType || errorType
	}
	isThenableType := func(type_ Type) bool {
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return false
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then")
		return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFactsNEUndefinedOrNull), SignatureKindCall).length > 0
	}
	type AwaitedTypeInstantiation struct {
		_awaitedTypeBrand/* TODO(Node NeverKeyword): never */ any
		aliasSymbol        Symbol
		aliasTypeArguments []Type
	}
	isAwaitedTypeInstantiation := func(type_ Type) /* TODO(TypeNode TypePredicate): type is AwaitedTypeInstantiation */ any {
		if type_.flags & TypeFlagsConditional {
			awaitedSymbol := getGlobalAwaitedSymbol(false)
			return !!awaitedSymbol && type_.aliasSymbol == awaitedSymbol && type_.aliasTypeArguments. /*?*/ length == 1
		}
		return false
	}
	unwrapAwaitedType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_.flags & TypeFlagsUnion:
			return mapType(type_, unwrapAwaitedType)
		case isAwaitedTypeInstantiation(type_):
			return type_.aliasTypeArguments[0]
		default:
			return type_
		}
	}
	isAwaitedTypeNeeded := func(type_ Type) /* TODO inferred type boolean */ any {
		if isTypeAny(type_) || isAwaitedTypeInstantiation(type_) {
			return false
		}
		if isGenericObjectType(type_) {
			baseConstraint := getBaseConstraintOfType(type_)
			if /* TODO(Node ConditionalExpression): baseConstraint ? baseConstraint.flags & TypeFlags.AnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) : maybeTypeOfKind(type, TypeFlags.TypeVariable) */ TODO {
				return true
			}
		}
		return false
	}
	tryCreateAwaitedType := func(type_ Type) *Type {
		awaitedSymbol := getGlobalAwaitedSymbol(true)
		if awaitedSymbol {
			return getTypeAliasInstantiation(awaitedSymbol, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{unwrapAwaitedType(type_)})
		}
		return nil
	}
	createAwaitedTypeIfNeeded := func(type_ Type) Type {
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(Node BinaryExpression): tryCreateAwaitedType(type) ?? type */ TODO
		}
		Debug.assert(isAwaitedTypeInstantiation(type_) || getPromisedTypeOfPromise(type_) == nil, "type provided should not be a non-generic 'promise'-like.")
		return type_
	}
	getAwaitedType := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		awaitedType := getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage, args...)
		return awaitedType && createAwaitedTypeIfNeeded(awaitedType)
	}
	getAwaitedTypeNoAlias := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		if isTypeAny(type_) {
			return type_
		}
		if isAwaitedTypeInstantiation(type_) {
			return type_
		}
		typeAsAwaitable := type_
		if typeAsAwaitable.awaitedTypeOfType {
			return typeAsAwaitable.awaitedTypeOfType
		}
		if type_.flags & TypeFlagsUnion {
			if awaitedTypeStack.lastIndexOf(type_.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			mapper := /* TODO(Node ConditionalExpression): errorNode ? (constituentType: Type) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias */ TODO
			awaitedTypeStack.push(type_.id)
			mapped := mapType(type_, mapper)
			awaitedTypeStack.pop()
			typeAsAwaitable.awaitedTypeOfType = mapped
			return typeAsAwaitable.awaitedTypeOfType
		}
		if isAwaitedTypeNeeded(type_) {
			typeAsAwaitable.awaitedTypeOfType = type_
			return typeAsAwaitable.awaitedTypeOfType
		}
		var thisTypeForErrorOut /* TODO(TypeNode TypeLiteral): { value: Type | undefined; } */ any = /* TODO(Node ObjectLiteralExpression): { value: undefined } */ TODO
		promisedType := getPromisedTypeOfPromise(type_, nil, thisTypeForErrorOut)
		if promisedType {
			if type_.id == promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			awaitedTypeStack.push(type_.id)
			awaitedType := getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, args...)
			awaitedTypeStack.pop()
			if !awaitedType {
				return nil
			}
			typeAsAwaitable.awaitedTypeOfType = awaitedType
			return typeAsAwaitable.awaitedTypeOfType
		}
		if isThenableType(type_) {
			if errorNode {
				Debug.assertIsDefined(diagnosticMessage)
				var chain *DiagnosticMessageChain
				if thisTypeForErrorOut.value {
					chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForErrorOut.value))
				}
				chain = chainDiagnosticMessages(chain, diagnosticMessage, args...)
				diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain))
			}
			return nil
		}
		typeAsAwaitable.awaitedTypeOfType = type_
		return typeAsAwaitable.awaitedTypeOfType
	}
	checkAsyncFunctionReturnType := func(node /* TODO(TypeNode UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
		returnType := getTypeFromTypeNode(returnTypeNode)
		if languageVersion >= ScriptTargetES2015 {
			if isErrorType(returnType) {
				return
			}
			globalPromiseType := getGlobalPromiseType(true)
			if globalPromiseType != emptyGenericType && !isReferenceToType(returnType, globalPromiseType) {
				reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType))
				return
			}
		} else {
			markLinkedReferences(node, ReferenceHintAsyncFunction)
			if isErrorType(returnType) {
				return
			}
			promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
			if promiseConstructorName == nil {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType))
				return
			}
			promiseConstructorSymbol := resolveEntityName(promiseConstructorName, SymbolFlagsValue, true)
			promiseConstructorType := /* TODO(Node ConditionalExpression): promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType */ TODO
			if isErrorType(promiseConstructorType) {
				if promiseConstructorName.kind == SyntaxKindIdentifier && promiseConstructorName.escapedText == "Promise" && getTargetType(returnType) == getGlobalPromiseType(false) {
					error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option)
				} else {
					reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				}
				return
			}
			globalPromiseConstructorLikeType := getGlobalPromiseConstructorLikeType(true)
			if globalPromiseConstructorLikeType == emptyObjectType {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				return
			}
			headMessage := Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value
			errorInfo := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ any {
				return /* TODO(Node ConditionalExpression): returnTypeNode === returnTypeErrorLocation ? undefined : chainDiagnosticMessages(/*details* / undefined, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type) */ TODO
			}
			if !checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) {
				return
			}
			rootName := promiseConstructorName && getFirstIdentifier(promiseConstructorName)
			collidingSymbol := getSymbol(node.locals, rootName.escapedText, SymbolFlagsValue)
			if collidingSymbol {
				error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName))
				return
			}
		}
		checkAwaitedType(returnType, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
			if returnTypeNode == returnTypeErrorLocation {
				error(returnTypeErrorLocation, message, typeName)
			} else {
				diag := error(returnTypeErrorLocation, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
				addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName))
			}
		}
	}
	checkGrammarDecorator := func(decorator Decorator) bool {
		sourceFile := getSourceFileOfNode(decorator)
		if !hasParseDiagnostics(sourceFile) {
			var node Expression = decorator.expression
			if isParenthesizedExpression(node) {
				return false
			}
			canHaveCallExpression := true
			var errorNode Node
			for true {
				if isExpressionWithTypeArguments(node) || isNonNullExpression(node) {
					node = node.expression
					continue
				}
				if isCallExpression(node) {
					if !canHaveCallExpression {
						errorNode = node
					}
					if node.questionDotToken {
						errorNode = node.questionDotToken
					}
					node = node.expression
					canHaveCallExpression = false
					continue
				}
				if isPropertyAccessExpression(node) {
					if node.questionDotToken {
						errorNode = node.questionDotToken
					}
					node = node.expression
					canHaveCallExpression = false
					continue
				}
				if !isIdentifier(node) {
					errorNode = node
				}
				break
			}
			if errorNode {
				addRelatedInfo(error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator), createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator))
				return true
			}
		}
		return false
	}
	checkDecorator := func(node Decorator) {
		checkGrammarDecorator(node)
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags & TypeFlagsAny {
			return
		}
		decoratorSignature := getDecoratorCallSignature(node)
		if !decoratorSignature. /*?*/ resolvedReturnType {
			return
		}
		var headMessage DiagnosticMessage
		expectedReturnType := decoratorSignature.resolvedReturnType
		switch node.parent.kind {
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		case SyntaxKindPropertyDeclaration:
			if !legacyDecorators {
				headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
				break
			}
			fallthrough
		case SyntaxKindParameter:
			headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any
			break
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		default:
			return Debug.failBadSyntaxKind(node.parent)
		}
		checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage)
	}
	createCallSignature := func(typeParameters *[]TypeParameter, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /*  = parameters.length */, flags SignatureFlags /*  = SignatureFlags.None */) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any {
		decl := factory.createFunctionTypeNode(nil, emptyArray, factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
		return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
	}
	createFunctionType := func(typeParameters *[]TypeParameter, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		signature := createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
		return getOrCreateTypeFromSignature(signature)
	}
	createGetterFunctionType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		return createFunctionType(nil, nil, emptyArray, type_)
	}
	createSetterFunctionType := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ any {
		valueParam := createParameter("value", type_)
		return createFunctionType(nil, nil, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ any{valueParam}, voidType)
	}
	getEntityNameForDecoratorMetadata := func(node *TypeNode) *EntityName {
		if node {
			switch node.kind {
			case SyntaxKindIntersectionType:
				fallthrough // TODO: merge cases
			case SyntaxKindUnionType:
				return getEntityNameForDecoratorMetadataFromTypeList((node).types)
			case SyntaxKindConditionalType:
				return getEntityNameForDecoratorMetadataFromTypeList([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ any{(node).trueType, (node).falseType})
			case SyntaxKindParenthesizedType:
				fallthrough // TODO: merge cases
			case SyntaxKindNamedTupleMember:
				return getEntityNameForDecoratorMetadata((node).type_)
			case SyntaxKindTypeReference:
				return (node).typeName
			}
		}
	}
	getEntityNameForDecoratorMetadataFromTypeList := func(types []TypeNode) *EntityName {
		var commonEntityName *EntityName
		for _, typeNode := range types {
			for typeNode.kind == SyntaxKindParenthesizedType || typeNode.kind == SyntaxKindNamedTupleMember {
				typeNode = (typeNode).type_
			}
			if typeNode.kind == SyntaxKindNeverKeyword {
				continue
			}
			if !strictNullChecks && (typeNode.kind == SyntaxKindLiteralType && (typeNode).literal.kind == SyntaxKindNullKeyword || typeNode.kind == SyntaxKindUndefinedKeyword) {
				continue
			}
			individualEntityName := getEntityNameForDecoratorMetadata(typeNode)
			if !individualEntityName {
				return nil
			}
			if commonEntityName {
				if !isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || commonEntityName.escapedText != individualEntityName.escapedText {
					return nil
				}
			} else {
				commonEntityName = individualEntityName
			}
		}
		return commonEntityName
	}
	getParameterTypeNodeForDecoratorCheck := func(node ParameterDeclaration) *TypeNode {
		typeNode := getEffectiveTypeAnnotationNode(node)
		// converted from conditional expression
		switch {
		case isRestParameter(node):
			return getRestParameterElementType(typeNode)
		default:
			return typeNode
		}
	}
	checkDecorators := func(node Node) {
		if !canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
			return
		}
		firstDecorator := find(node.modifiers, isDecorator)
		if !firstDecorator {
			return
		}
		if legacyDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersDecorate)
			if node.kind == SyntaxKindParameter {
				checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersParam)
			}
		} else if languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersESDecorateAndRunInitializers)
			if isClassDeclaration(node) {
				if !node.name {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				} else {
					member := getFirstTransformableStaticClassElement(node)
					if member {
						checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
					}
				}
			} else if !isClassExpression(node) {
				if isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				}
				if isComputedPropertyName(node.name) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersPropKey)
				}
			}
		}
		markLinkedReferences(node, ReferenceHintDecorator)
		for _, modifier := range node.modifiers {
			if isDecorator(modifier) {
				checkDecorator(modifier)
			}
		}
	}
	checkFunctionDeclaration := func(node FunctionDeclaration) {
		addLazyDiagnostic(checkFunctionDeclarationDiagnostics)
		checkFunctionDeclarationDiagnostics := func() {
			checkFunctionOrMethodDeclaration(node)
			checkGrammarForGenerator(node)
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	checkJSDocTypeAliasTag := func(node /* TODO(TypeNode UnionType): JSDocTypedefTag | JSDocCallbackTag */ any) {
		if !node.typeExpression {
			error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags)
		}
		if node.name {
			checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		}
		checkSourceElement(node.typeExpression)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	}
	checkJSDocTemplateTag := func(node JSDocTemplateTag) {
		checkSourceElement(node.constraint)
		for _, tp := range node.typeParameters {
			checkSourceElement(tp)
		}
	}
	checkJSDocTypeTag := func(node JSDocTypeTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocSatisfiesTag := func(node JSDocSatisfiesTag) {
		checkSourceElement(node.typeExpression)
		host := getEffectiveJSDocHost(node)
		if host {
			tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
			if length(tags) > 1 {
				for i := 1; i < length(tags); i++ {
					tagName := tags[i].tagName
					error(tagName, Diagnostics._0_tag_already_specified, idText(tagName))
				}
			}
		}
	}
	checkJSDocLinkLikeTag := func(node /* TODO(TypeNode UnionType): JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
		if node.name {
			resolveJSDocMemberName(node.name, true)
		}
	}
	checkJSDocParameterTag := func(node JSDocParameterTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocPropertyTag := func(node JSDocPropertyTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocFunctionType := func(node JSDocFunctionType) {
		addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny)
		checkSignatureDeclaration(node)
		checkJSDocFunctionTypeImplicitAny := func() {
			if !node.type_ && !isJSDocConstructSignature(node) {
				reportImplicitAny(node, anyType)
			}
		}
	}
	checkJSDocThisTag := func(node JSDocThisTag) {
		host := getEffectiveJSDocHost(node)
		if host && isArrowFunction(host) {
			error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
		}
	}
	checkJSDocImportTag := func(node JSDocImportTag) {
		checkImportAttributes(node)
	}
	checkJSDocImplementsTag := func(node JSDocImplementsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
		}
	}
	checkJSDocAugmentsTag := func(node JSDocAugmentsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
			return
		}
		augmentsTags := getJSDocTags(classLike).filter(isJSDocAugmentsTag)
		Debug.assert(augmentsTags.length > 0)
		if augmentsTags.length > 1 {
			error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag)
		}
		name := getIdentifierFromEntityNameExpression(node.class.expression)
		extend := getClassExtendsHeritageElement(classLike)
		if extend {
			className := getIdentifierFromEntityNameExpression(extend.expression)
			if className && name.escapedText != className.escapedText {
				error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className))
			}
		}
	}
	checkJSDocAccessibilityModifiers := func(node /* TODO(TypeNode UnionType): JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
		host := getJSDocHost(node)
		if host && isPrivateIdentifierClassElementDeclaration(host) {
			error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
		}
	}
	/* OVERLOAD: function getIdentifierFromEntityNameExpression(node: Identifier | PropertyAccessExpression): Identifier | PrivateIdentifier; */
	/* OVERLOAD: function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined; */
	getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier | undefined */ any {
		switch node.kind {
		case SyntaxKindIdentifier:
			return node
		case SyntaxKindPropertyAccessExpression:
			return (node).name
		default:
			return nil
		}
	}
	checkFunctionOrMethodDeclaration := func(node /* TODO(TypeNode UnionType): FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
		checkDecorators(node)
		checkSignatureDeclaration(node)
		functionFlags := getFunctionFlags(node)
		if node.name && node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		if hasBindableName(node) {
			symbol := getSymbolOfDeclaration(node)
			localSymbol := node.localSymbol || symbol
			firstDeclaration := localSymbol.declarations. /*?*/ find(func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
				return declaration.kind == node.kind && !(declaration.flags & NodeFlagsJavaScriptFile)
			})
			if node == firstDeclaration {
				checkFunctionOrConstructorSymbol(localSymbol)
			}
			if symbol.parent {
				checkFunctionOrConstructorSymbol(symbol)
			}
		}
		body := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.MethodSignature ? undefined : node.body */ TODO
		checkSourceElement(body)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node))
		addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics)
		if isInJSFile(node) {
			typeTag := getJSDocTypeTag(node)
			if typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node) {
				error(typeTag.typeExpression.type_, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature)
			}
		}
		checkFunctionOrMethodDeclarationDiagnostics := func() {
			if !getEffectiveReturnTypeNode(node) {
				if nodeIsMissing(body) && !isPrivateWithinAmbient(node) {
					reportImplicitAny(node, anyType)
				}
				if functionFlags&FunctionFlagsGenerator && nodeIsPresent(body) {
					getReturnTypeOfSignature(getSignatureFromDeclaration(node))
				}
			}
		}
	}
	registerForUnusedIdentifiersCheck := func(node PotentiallyUnusedIdentifier) {
		addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics)
		registerForUnusedIdentifiersCheckDiagnostics := func() {
			sourceFile := getSourceFileOfNode(node)
			potentiallyUnusedIdentifiers := allPotentiallyUnusedIdentifiers.get(sourceFile.path)
			if !potentiallyUnusedIdentifiers {
				potentiallyUnusedIdentifiers = [] /* TODO inferred type never */ any{}
				allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers)
			}
			potentiallyUnusedIdentifiers.push(node)
		}
	}
	type PotentiallyUnusedIdentifier /* TODO(TypeNode UnionType): SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any
	checkUnusedIdentifiers := func(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
		for _, node := range potentiallyUnusedIdentifiers {
			switch node.kind {
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassExpression:
				checkUnusedClassMembers(node, addDiagnostic)
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindSourceFile:
				fallthrough // TODO: merge cases
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindBlock:
				fallthrough // TODO: merge cases
			case SyntaxKindCaseBlock:
				fallthrough // TODO: merge cases
			case SyntaxKindForStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForInStatement:
				fallthrough // TODO: merge cases
			case SyntaxKindForOfStatement:
				checkUnusedLocalsAndParameters(node, addDiagnostic)
				break
			case SyntaxKindConstructor:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindArrowFunction:
				fallthrough // TODO: merge cases
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				if node.body {
					checkUnusedLocalsAndParameters(node, addDiagnostic)
				}
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindMethodSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindCallSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionType:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				checkUnusedTypeParameters(node, addDiagnostic)
				break
			case SyntaxKindInferType:
				checkUnusedInferTypeParameter(node, addDiagnostic)
				break
			default:
				Debug.assertNever(node, "Node should not have been registered for unused identifiers check")
			}
		}
	}
	errorUnusedLocal := func(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
		node := getNameOfDeclaration(declaration) || declaration
		message := /* TODO(Node ConditionalExpression): isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read */ TODO
		addDiagnostic(declaration, UnusedKindLocal, createDiagnosticForNode(node, message, name))
	}
	isIdentifierThatStartsWithUnderscore := func(node Node) /* TODO inferred type boolean */ any {
		return isIdentifier(node) && idText(node).charCodeAt(0) == CharacterCodes_
	}
	checkUnusedClassMembers := func(node /* TODO(TypeNode UnionType): ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
		for _, member := range node.members {
			switch member.kind {
			case SyntaxKindMethodDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindGetAccessor:
				fallthrough // TODO: merge cases
			case SyntaxKindSetAccessor:
				if member.kind == SyntaxKindSetAccessor && member.symbol.flags&SymbolFlagsGetAccessor {
					break
				}
				symbol := getSymbolOfDeclaration(member)
				if !symbol.isReferenced && (hasEffectiveModifier(member, ModifierFlagsPrivate) || isNamedDeclaration(member) && isPrivateIdentifier(member.name)) && !(member.flags & NodeFlagsAmbient) {
					addDiagnostic(member, UnusedKindLocal, createDiagnosticForNode(member.name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)))
				}
				break
			case SyntaxKindConstructor:
				for _, parameter := range (member).parameters {
					if !parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlagsPrivate) {
						addDiagnostic(parameter, UnusedKindLocal, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)))
					}
				}
				break
			case SyntaxKindIndexSignature:
				fallthrough // TODO: merge cases
			case SyntaxKindSemicolonClassElement:
				fallthrough // TODO: merge cases
			case SyntaxKindClassStaticBlockDeclaration:
				break
			default:
				Debug.fail("Unexpected class member")
			}
		}
	}
	checkUnusedInferTypeParameter := func(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
		TODO_IDENTIFIER := node
		if isTypeParameterUnused(typeParameter) {
			addDiagnostic(node, UnusedKindParameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)))
		}
	}
	checkUnusedTypeParameters := func(node /* TODO(TypeNode UnionType): ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
		declarations := getSymbolOfDeclaration(node).declarations
		if !declarations || last(declarations) != node {
			return
		}
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		seenParentsWithEveryUnused := make(map[DeclarationWithTypeParameterChildren]struct{})
		for _, typeParameter := range typeParameters {
			if !isTypeParameterUnused(typeParameter) {
				continue
			}
			name := idText(typeParameter.name)
			TODO_IDENTIFIER := typeParameter
			if parent.kind != SyntaxKindInferType && parent.typeParameters.every(isTypeParameterUnused) {
				if tryAddToSet(seenParentsWithEveryUnused, parent) {
					sourceFile := getSourceFileOfNode(parent)
					range_ := /* TODO(Node ConditionalExpression): isJSDocTemplateTag(parent) // Whole @template tag ? rangeOfNode(parent) // Include the `<>` in the error message : rangeOfTypeParameters(sourceFile, parent.typeParameters!) */ TODO
					only := parent.typeParameters.length == 1
					var messageAndArg DiagnosticAndArguments = /* TODO(Node ConditionalExpression): only ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name] : [Diagnostics.All_type_parameters_are_unused] */ TODO
					addDiagnostic(typeParameter, UnusedKindParameter, createFileDiagnostic(sourceFile, range_.pos, range_.end-range_.pos, messageAndArg...))
				}
			} else {
				addDiagnostic(typeParameter, UnusedKindParameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name))
			}
		}
	}
	isTypeParameterUnused := func(typeParameter TypeParameterDeclaration) bool {
		return !(getMergedSymbol(typeParameter.symbol).isReferenced & SymbolFlagsTypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name)
	}
	addToGroup := func(map_ Map[string /* TODO(TypeNode TupleType): [K, V[]] */, any], key K, value V, getKey func(key K) /* TODO(TypeNode UnionType): number | string */ any) {
		keyString := String(getKey(key))
		group := map_.get(keyString)
		if group {
			group[1].push(value)
		} else {
			map_.set(keyString, []TODO{key, [] /* TODO inferred type V */ any{value}})
		}
	}
	tryGetRootParameterDeclaration := func(node Node) *ParameterDeclaration {
		return tryCast(getRootDeclaration(node), isParameter)
	}
	isValidUnusedLocalDeclaration := func(declaration Declaration) bool {
		if isBindingElement(declaration) {
			if isObjectBindingPattern(declaration.parent) {
				return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name))
			}
			return isIdentifierThatStartsWithUnderscore(declaration.name)
		}
		return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name)
	}
	checkUnusedLocalsAndParameters := func(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
		unusedImports := make(map[string] /* TODO(TypeNode TupleType): [ImportClause, ImportedDeclaration[]] */ any)
		unusedDestructures := make(map[string] /* TODO(TypeNode TupleType): [BindingPattern, BindingElement[]] */ any)
		unusedVariables := make(map[string] /* TODO(TypeNode TupleType): [VariableDeclarationList, VariableDeclaration[]] */ any)
		nodeWithLocals.locals.forEach(func(local /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
			if /* TODO(Node ConditionalExpression): local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol */ TODO {
				return
			}
			if local.declarations {
				for _, declaration := range local.declarations {
					if isValidUnusedLocalDeclaration(declaration) {
						continue
					}
					if isImportedDeclaration(declaration) {
						addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId)
					} else if isBindingElement(declaration) && isObjectBindingPattern(declaration.parent) {
						lastElement := last(declaration.parent.elements)
						if declaration == lastElement || !last(declaration.parent.elements).dotDotDotToken {
							addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
						}
					} else if isVariableDeclaration(declaration) {
						blockScopeKind := getCombinedNodeFlagsCached(declaration) & NodeFlagsBlockScoped
						name := getNameOfDeclaration(declaration)
						if blockScopeKind != NodeFlagsUsing && blockScopeKind != NodeFlagsAwaitUsing || !name || !isIdentifierThatStartsWithUnderscore(name) {
							addToGroup(unusedVariables, declaration.parent, declaration, getNodeId)
						}
					} else {
						parameter := local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration)
						name := local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration)
						if parameter && name {
							if !isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name) {
								if isBindingElement(declaration) && isArrayBindingPattern(declaration.parent) {
									addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
								} else {
									addDiagnostic(parameter, UnusedKindParameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)))
								}
							}
						} else {
							errorUnusedLocal(declaration, symbolName(local), addDiagnostic)
						}
					}
				}
			}
		})
		unusedImports.forEach(func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").ImportClause, ImportedDeclaration[]] */ any) {
			importDecl := importClause.parent
			nDeclarations := ( /* TODO(Node ConditionalExpression): importClause.name ? 1 : 0 */ TODO) + ( /* TODO(Node ConditionalExpression): importClause.namedBindings ? (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length) : 0 */ TODO)
			if nDeclarations == unuseds.length {
				addDiagnostic(importDecl, UnusedKindLocal /* TODO(Node ConditionalExpression): unuseds.length === 1 ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!)) : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused) */, TODO)
			} else {
				for _, unused := range unuseds {
					errorUnusedLocal(unused, idText(unused.name), addDiagnostic)
				}
			}
		})
		unusedDestructures.forEach(func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").BindingPattern, import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement[]] */ any) {
			kind := /* TODO(Node ConditionalExpression): tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local */ TODO
			if bindingPattern.elements.length == bindingElements.length {
				if bindingElements.length == 1 && bindingPattern.parent.kind == SyntaxKindVariableDeclaration && bindingPattern.parent.parent.kind == SyntaxKindVariableDeclarationList {
					addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId)
				} else {
					addDiagnostic(bindingPattern, kind /* TODO(Node ConditionalExpression): bindingElements.length === 1 ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name)) : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused) */, TODO)
				}
			} else {
				for _, e := range bindingElements {
					addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)))
				}
			}
		})
		unusedVariables.forEach(func(TODO_IDENTIFIER /* TODO inferred type [import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList, import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclaration[]] */ any) {
			if declarationList.declarations.length == declarations.length {
				addDiagnostic(declarationList, UnusedKindLocal /* TODO(Node ConditionalExpression): declarations.length === 1 ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name)) : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused) */, TODO)
			} else {
				for _, decl := range declarations {
					addDiagnostic(decl, UnusedKindLocal, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)))
				}
			}
		})
	}
	checkPotentialUncheckedRenamedBindingElementsInTypes := func() {
		for _, node := range potentialUnusedRenamedBindingElementsInTypes {
			if !getSymbolOfDeclaration(node). /*?*/ isReferenced {
				wrappingDeclaration := walkUpBindingElementsAndPatterns(node)
				Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here")
				diagnostic := createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName))
				if !wrappingDeclaration.type_ {
					addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	bindingNameText := func(name BindingName) string {
		switch name.kind {
		case SyntaxKindIdentifier:
			return idText(name)
		case SyntaxKindArrayBindingPattern:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectBindingPattern:
			return bindingNameText(cast(first(name.elements), isBindingElement).name)
		default:
			return Debug.assertNever(name)
		}
	}
	type ImportedDeclaration /* TODO(TypeNode UnionType): ImportClause | ImportSpecifier | NamespaceImport */ any
	isImportedDeclaration := func(node Node) /* TODO(TypeNode TypePredicate): node is ImportedDeclaration */ any {
		return node.kind == SyntaxKindImportClause || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindNamespaceImport
	}
	importClauseFromImported := func(decl ImportedDeclaration) ImportClause {
		// converted from conditional expression
		switch {
		case decl.kind == SyntaxKindImportClause:
			return decl
		case decl.kind == SyntaxKindNamespaceImport:
			return decl.parent
		default:
			return decl.parent.parent
		}
	}
	checkBlock := func(node Block) {
		if node.kind == SyntaxKindBlock {
			checkGrammarStatementInAmbientContext(node)
		}
		if isFunctionOrModuleBlock(node) {
			saveFlowAnalysisDisabled := flowAnalysisDisabled
			forEach(node.statements, checkSourceElement)
			flowAnalysisDisabled = saveFlowAnalysisDisabled
		} else {
			forEach(node.statements, checkSourceElement)
		}
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkCollisionWithArgumentsInGeneratedCode := func(node SignatureDeclaration) {
		if languageVersion >= ScriptTargetES2015 || !hasRestParameter(node) || node.flags&NodeFlagsAmbient || nodeIsMissing((node).body) {
			return
		}
		forEach(node.parameters, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any) {
			if p.name && !isBindingPattern(p.name) && p.name.escapedText == argumentsSymbol.escapedName {
				errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters)
			}
		})
	}
	needCollisionCheckForIdentifier := func(node Node, identifier *Identifier, name string) bool {
		if identifier. /*?*/ escapedText != name {
			return false
		}
		if node.kind == SyntaxKindPropertyDeclaration || node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor || node.kind == SyntaxKindPropertyAssignment {
			return false
		}
		if node.flags & NodeFlagsAmbient {
			return false
		}
		if isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) {
			if isTypeOnlyImportOrExportDeclaration(node) {
				return false
			}
		}
		root := getRootDeclaration(node)
		if isParameter(root) && nodeIsMissing((root.parent).body) {
			return false
		}
		return true
	}
	checkIfThisIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureThis {
				isDeclaration := node.kind != SyntaxKindIdentifier
				if isDeclaration {
					error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference)
				}
				return true
			}
			return false
		})
	}
	checkIfNewTargetIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureNewTarget {
				isDeclaration := node.kind != SyntaxKindIdentifier
				if isDeclaration {
					error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference)
				}
				return true
			}
			return false
		})
	}
	checkCollisionWithRequireExportsInGeneratedCode := func(node Node, name *Identifier) {
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKindES2015 {
			return
		}
		if !name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports") {
			return
		}
		if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
			return
		}
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent) {
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name))
		}
	}
	checkCollisionWithGlobalPromiseInGeneratedCode := func(node Node, name *Identifier) {
		if !name || languageVersion >= ScriptTargetES2017 || !needCollisionCheckForIdentifier(node, name, "Promise") {
			return
		}
		if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
			return
		}
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent) && parent.flags&NodeFlagsHasAsyncFunctions {
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name))
		}
	}
	recordPotentialCollisionWithWeakMapSetInGeneratedCode := func(node Node, name Identifier) {
		if languageVersion <= ScriptTargetES2021 && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet")) {
			potentialWeakMapSetCollisions.push(node)
		}
	}
	checkWeakMapSetCollision := func(node Node) {
		enclosingBlockScope := getEnclosingBlockScopeContainer(node)
		if getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlagsContainsClassWithPrivateIdentifiers {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && /* TODO(Node TypeOfExpression): typeof node.name.escapedText */ TODO == "string", "The target of a WeakMap/WeakSet collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText)
		}
	}
	recordPotentialCollisionWithReflectInGeneratedCode := func(node Node, name *Identifier) {
		if name && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && needCollisionCheckForIdentifier(node, name, "Reflect") {
			potentialReflectCollisions.push(node)
		}
	}
	checkReflectCollision := func(node Node) {
		hasCollision := false
		if isClassExpression(node) {
			for _, member := range node.members {
				if getNodeCheckFlags(member) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
					hasCollision = true
					break
				}
			}
		} else if isFunctionExpression(node) {
			if getNodeCheckFlags(node) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		} else {
			container := getEnclosingBlockScopeContainer(node)
			if container && getNodeCheckFlags(container)&NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		}
		if hasCollision {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect")
		}
	}
	checkCollisionsForDeclarationName := func(node Node, name *Identifier) {
		if !name {
			return
		}
		checkCollisionWithRequireExportsInGeneratedCode(node, name)
		checkCollisionWithGlobalPromiseInGeneratedCode(node, name)
		recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name)
		recordPotentialCollisionWithReflectInGeneratedCode(node, name)
		if isClassLike(node) {
			checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0)
			if !(node.flags & NodeFlagsAmbient) {
				checkClassNameCollisionWithObject(name)
			}
		} else if isEnumDeclaration(node) {
			checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0)
		}
	}
	checkVarDeclaredNamesNotShadowed := func(node /* TODO(TypeNode UnionType): VariableDeclaration | BindingElement */ any) /* TODO inferred type undefined */ any {
		if (getCombinedNodeFlagsCached(node)&NodeFlagsBlockScoped) != 0 || isPartOfParameterDeclaration(node) {
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags & SymbolFlagsFunctionScopedVariable {
			if !isIdentifier(node.name) {
				return Debug.fail()
			}
			localDeclarationSymbol := resolveName(node, node.name.escapedText, SymbolFlagsVariable, nil, false)
			if localDeclarationSymbol && localDeclarationSymbol != symbol && localDeclarationSymbol.flags&SymbolFlagsBlockScopedVariable {
				if getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlagsBlockScoped {
					varDeclList := getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					container := /* TODO(Node ConditionalExpression): varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent ? varDeclList.parent.parent : undefined */ TODO
					namesShareScope := container && (container.kind == SyntaxKindBlock && isFunctionLike(container.parent) || container.kind == SyntaxKindModuleBlock || container.kind == SyntaxKindModuleDeclaration || container.kind == SyntaxKindSourceFile)
					if !namesShareScope {
						name := symbolToString(localDeclarationSymbol)
						error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name)
					}
				}
			}
		}
	}
	convertAutoToAny := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		// converted from conditional expression
		switch {
		case type_ == autoType:
			return anyType
		case type_ == autoArrayType:
			return anyArrayType
		default:
			return type_
		}
	}
	checkVariableLikeDeclaration := func(node /* TODO(TypeNode UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
		checkDecorators(node)
		if !isBindingElement(node) {
			checkSourceElement(node.type_)
		}
		if !node.name {
			return
		}
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkExpressionCached(node.initializer)
			}
		}
		if isBindingElement(node) {
			if node.propertyName && isIdentifier(node.name) && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node)).body) {
				potentialUnusedRenamedBindingElementsInTypes.push(node)
				return
			}
			if isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRest)
			}
			if node.propertyName && node.propertyName.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.propertyName)
			}
			parent := node.parent.parent
			parentCheckMode := /* TODO(Node ConditionalExpression): node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
			parentType := getTypeForBindingElementParent(parent, parentCheckMode)
			name := node.propertyName || node.name
			if parentType && !isBindingPattern(name) {
				exprType := getLiteralTypeFromPropertyName(name)
				if isTypeUsableAsPropertyName(exprType) {
					nameText := getPropertyNameFromType(exprType)
					property := getPropertyOfType(parentType, nameText)
					if property {
						markPropertyAsReferenced(property, nil, false)
						checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind == SyntaxKindSuperKeyword, false, parentType, property)
					}
				}
			}
		}
		if isBindingPattern(node.name) {
			if node.name.kind == SyntaxKindArrayBindingPattern && languageVersion < LanguageFeatureMinimumTargetBindingPatterns && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
			}
			forEach(node.name.elements, checkSourceElement)
		}
		if node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node)).body) {
			error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation)
			return
		}
		if isBindingPattern(node.name) {
			if isInAmbientOrTypeNode(node) {
				return
			}
			needCheckInitializer := hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind != SyntaxKindForInStatement
			needCheckWidenedType := !some(node.name.elements, not(isOmittedExpression))
			if needCheckInitializer || needCheckWidenedType {
				widenedType := getWidenedTypeForVariableLikeDeclaration(node)
				if needCheckInitializer {
					initializerType := checkExpressionCached(node.initializer)
					if strictNullChecks && needCheckWidenedType {
						checkNonNullNonVoidType(initializerType, node)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer)
					}
				}
				if needCheckWidenedType {
					if isArrayBindingPattern(node.name) {
						checkIteratedTypeOrElementType(IterationUseDestructuring, widenedType, undefinedType, node)
					} else if strictNullChecks {
						checkNonNullNonVoidType(widenedType, node)
					}
				}
			}
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags&SymbolFlagsAlias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) {
			checkAliasSymbol(node)
			return
		}
		if node.name.kind == SyntaxKindBigIntLiteral {
			error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name)
		}
		type_ := convertAutoToAny(getTypeOfSymbol(symbol))
		if node == symbol.valueDeclaration {
			initializer := hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node)
			if initializer {
				isJSObjectLiteralInitializer := isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length == 0 || isPrototypeAccess(node.name)) && !!symbol.exports. /*?*/ size
				if !isJSObjectLiteralInitializer && node.parent.parent.kind != SyntaxKindForInStatement {
					initializerType := checkExpressionCached(initializer)
					checkTypeAssignableToAndOptionallyElaborate(initializerType, type_, node, initializer, nil)
					blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
					if blockScopeKind == NodeFlagsAwaitUsing {
						globalAsyncDisposableType := getGlobalAsyncDisposableType(true)
						globalDisposableType := getGlobalDisposableType(true)
						if globalAsyncDisposableType != emptyObjectType && globalDisposableType != emptyObjectType {
							optionalDisposableType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{globalAsyncDisposableType, globalDisposableType, nullType, undefinedType})
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined)
						}
					} else if blockScopeKind == NodeFlagsUsing {
						globalDisposableType := getGlobalDisposableType(true)
						if globalDisposableType != emptyObjectType {
							optionalDisposableType := getUnionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{globalDisposableType, nullType, undefinedType})
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined)
						}
					}
				}
			}
			if symbol.declarations && symbol.declarations.length > 1 {
				if some(symbol.declarations, func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
					return d != node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node)
				}) {
					error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
				}
			}
		} else {
			declarationType := convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node))
			if !isErrorType(type_) && !isErrorType(declarationType) && !isTypeIdenticalTo(type_, declarationType) && !(symbol.flags & SymbolFlagsAssignment) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type_, node, declarationType)
			}
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, nil)
			}
			if symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration) {
				error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
			}
		}
		if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature {
			checkExportsOnMergedDeclarations(node)
			if node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement {
				checkVarDeclaredNamesNotShadowed(node)
			}
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	errorNextVariableOrPropertyDeclarationMustHaveSameType := func(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
		nextDeclarationName := getNameOfDeclaration(nextDeclaration)
		message := /* TODO(Node ConditionalExpression): nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2 : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 */ TODO
		declName := declarationNameToString(nextDeclarationName)
		err := error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType))
		if firstDeclaration {
			addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName))
		}
	}
	areDeclarationFlagsIdentical := func(left Declaration, right Declaration) /* TODO inferred type boolean */ any {
		if (left.kind == SyntaxKindParameter && right.kind == SyntaxKindVariableDeclaration) || (left.kind == SyntaxKindVariableDeclaration && right.kind == SyntaxKindParameter) {
			return true
		}
		if hasQuestionToken(left) != hasQuestionToken(right) {
			return false
		}
		interestingFlags := ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAsync | ModifierFlagsAbstract | ModifierFlagsReadonly | ModifierFlagsStatic
		return getSelectedEffectiveModifierFlags(left, interestingFlags) == getSelectedEffectiveModifierFlags(right, interestingFlags)
	}
	checkVariableDeclaration := func(node VariableDeclaration) {
		tracing. /*?*/ push(tracing.Phase.Check, "checkVariableDeclaration" /* TODO(Node ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		checkGrammarVariableDeclaration(node)
		checkVariableLikeDeclaration(node)
		tracing. /*?*/ pop()
	}
	checkBindingElement := func(node BindingElement) {
		checkGrammarBindingElement(node)
		return checkVariableLikeDeclaration(node)
	}
	checkVariableDeclarationList := func(node VariableDeclarationList) {
		blockScopeKind := getCombinedNodeFlags(node) & NodeFlagsBlockScoped
		if (blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing) && languageVersion < LanguageFeatureMinimumTargetUsingAndAwaitUsing {
			checkExternalEmitHelpers(node, ExternalEmitHelpersAddDisposableResourceAndDisposeResources)
		}
		forEach(node.declarations, checkSourceElement)
	}
	checkVariableStatement := func(node VariableStatement) {
		if !checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList) {
			checkGrammarForDisallowedBlockScopedVariableStatement(node)
		}
		checkVariableDeclarationList(node.declarationList)
	}
	checkExpressionStatement := func(node ExpressionStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkExpression(node.expression)
	}
	checkIfStatement := func(node IfStatement) {
		checkGrammarStatementInAmbientContext(node)
		type_ := checkTruthinessExpression(node.expression)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type_, node.thenStatement)
		checkSourceElement(node.thenStatement)
		if node.thenStatement.kind == SyntaxKindEmptyStatement {
			error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement)
		}
		checkSourceElement(node.elseStatement)
	}
	checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType := func(condExpr Expression, condType Type, body /* TODO(TypeNode UnionType): Statement | Expression */ any) {
		if !strictNullChecks {
			return
		}
		bothHelper(condExpr, body)
		bothHelper := func(condExpr Expression, body /* TODO(TypeNode UnionType): Expression | Statement | undefined */ any) {
			condExpr = skipParentheses(condExpr)
			helper(condExpr, body)
			for isBinaryExpression(condExpr) && (condExpr.operatorToken.kind == SyntaxKindBarBarToken || condExpr.operatorToken.kind == SyntaxKindQuestionQuestionToken) {
				condExpr = skipParentheses(condExpr.left)
				helper(condExpr, body)
			}
		}
		helper := func(condExpr Expression, body /* TODO(TypeNode UnionType): Expression | Statement | undefined */ any) {
			location := /* TODO(Node ConditionalExpression): isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr */ TODO
			if isModuleExportsAccessExpression(location) {
				return
			}
			if isLogicalOrCoalescingBinaryExpression(location) {
				bothHelper(location, body)
				return
			}
			type_ := /* TODO(Node ConditionalExpression): location === condExpr ? condType : checkExpression(location) */ TODO
			if type_.flags&TypeFlagsEnumLiteral && isPropertyAccessExpression(location) && ( /* TODO(Node BinaryExpression): getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol */ TODO).flags&SymbolFlagsEnum {
				error(location, Diagnostics.This_condition_will_always_return_0 /* TODO(Node ConditionalExpression): !!(type as LiteralType).value ? "true" : "false" */, TODO)
				return
			}
			isPropertyExpressionCast := isPropertyAccessExpression(location) && isTypeAssertion(location.expression)
			if !hasTypeFacts(type_, TypeFactsTruthy) || isPropertyExpressionCast {
				return
			}
			callSignatures := getSignaturesOfType(type_, SignatureKindCall)
			isPromise := !!getAwaitedTypeOfPromise(type_)
			if callSignatures.length == 0 && !isPromise {
				return
			}
			testedNode := /* TODO(Node ConditionalExpression): isIdentifier(location) ? location : isPropertyAccessExpression(location) ? location.name : undefined */ TODO
			testedSymbol := testedNode && getSymbolAtLocation(testedNode)
			if !testedSymbol && !isPromise {
				return
			}
			isUsed := testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol) || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol)
			if !isUsed {
				if isPromise {
					errorAndMaybeSuggestAwait(location, true, Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type_))
				} else {
					error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead)
				}
			}
		}
	}
	isSymbolUsedInConditionBody := func(expr Expression, body /* TODO(TypeNode UnionType): Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
		return !!forEachChild(body /* TODO(Node FunctionExpression): function check(childNode): boolean | undefined { if (isIdentifier(childNode)) { const childSymbol = getSymbolAtLocation(childNode); if (childSymbol && childSymbol === testedSymbol) { // If the test was a simple identifier, the above check is sufficient if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) { return true; } // Otherwise we need to ensure the symbol is called on the same target let testedExpression = testedNode.parent; let childExpression = childNode.parent; while (testedExpression && childExpression) { if ( isIdentifier(testedExpression) && isIdentifier(childExpression) || testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword ) { return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression); } else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) { if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) { return false; } childExpression = childExpression.expression; testedExpression = testedExpression.expression; } else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) { childExpression = childExpression.expression; testedExpression = testedExpression.expression; } else { return false; } } } } return forEachChild(childNode, check); } */, TODO)
	}
	isSymbolUsedInBinaryExpressionChain := func(node Node, testedSymbol Symbol) bool {
		for isBinaryExpression(node) && node.operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
			isUsed := forEachChild(node.right /* TODO(Node FunctionExpression): function visit(child): boolean | undefined { if (isIdentifier(child)) { const symbol = getSymbolAtLocation(child); if (symbol && symbol === testedSymbol) { return true; } } return forEachChild(child, visit); } */, TODO)
			if isUsed {
				return true
			}
			node = node.parent
		}
		return false
	}
	checkDoStatement := func(node DoStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkSourceElement(node.statement)
		checkTruthinessExpression(node.expression)
	}
	checkWhileStatement := func(node WhileStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkTruthinessExpression(node.expression)
		checkSourceElement(node.statement)
	}
	checkTruthinessOfType := func(type_ Type, node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if type_.flags & TypeFlagsVoid {
			error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness)
		} else {
			semantics := getSyntacticTruthySemantics(node)
			if semantics != PredicateSemanticsSometimes {
				error(node /* TODO(Node ConditionalExpression): semantics === PredicateSemantics.Always ? Diagnostics.This_kind_of_expression_is_always_truthy : Diagnostics.This_kind_of_expression_is_always_falsy */, TODO)
			}
		}
		return type_
	}
	getSyntacticTruthySemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		switch node.kind {
		case SyntaxKindNumericLiteral:
			if (node).text == "0" || (node).text == "1" {
				return PredicateSemanticsSometimes
			}
			return PredicateSemanticsAlways
		case SyntaxKindArrayLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindBigIntLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindClassExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxElement:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxSelfClosingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindObjectLiteralExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindRegularExpressionLiteral:
			return PredicateSemanticsAlways
		case SyntaxKindVoidExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNullKeyword:
			return PredicateSemanticsNever
		case SyntaxKindNoSubstitutionTemplateLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			// converted from conditional expression
			switch {
			case !!(node).text:
				return PredicateSemanticsAlways
			default:
				return PredicateSemanticsNever
			}
		case SyntaxKindConditionalExpression:
			return getSyntacticTruthySemantics((node).whenTrue) | getSyntacticTruthySemantics((node).whenFalse)
		case SyntaxKindIdentifier:
			if getResolvedSymbol(node) == undefinedSymbol {
				return PredicateSemanticsNever
			}
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsSometimes
	}
	checkTruthinessExpression := func(node Expression, checkMode CheckMode) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return checkTruthinessOfType(checkExpression(node, checkMode), node)
	}
	checkForStatement := func(node ForStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if node.initializer && node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkGrammarVariableDeclarationList(node.initializer)
			}
		}
		if node.initializer {
			if node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkVariableDeclarationList(node.initializer)
			} else {
				checkExpression(node.initializer)
			}
		}
		if node.condition {
			checkTruthinessExpression(node.condition)
		}
		if node.incrementor {
			checkExpression(node.incrementor)
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForOfStatement := func(node ForOfStatement) {
		checkGrammarForInOrForOfStatement(node)
		container := getContainingFunctionOrClassStaticBlock(node)
		if node.awaitModifier {
			if container && isClassStaticBlockDeclaration(container) {
				grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block)
			} else {
				functionFlags := getFunctionFlags(container)
				if (functionFlags&(FunctionFlagsInvalid|FunctionFlagsAsync)) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetForAwaitOf {
					checkExternalEmitHelpers(node, ExternalEmitHelpersForAwaitOfIncludes)
				}
			}
		} else if compilerOptions.downlevelIteration && languageVersion < LanguageFeatureMinimumTargetForOf {
			checkExternalEmitHelpers(node, ExternalEmitHelpersForOfIncludes)
		}
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			checkVariableDeclarationList(node.initializer)
		} else {
			varExpr := node.initializer
			iteratedType := checkRightHandSideOfForOf(node)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				checkDestructuringAssignment(varExpr, iteratedType || errorType)
			} else {
				leftType := checkExpression(varExpr)
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access)
				if iteratedType {
					checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression)
				}
			}
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForInStatement := func(node ForInStatement) {
		checkGrammarForInOrForOfStatement(node)
		rightType := getNonNullableTypeIfNeeded(checkExpression(node.expression))
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			variable := (node.initializer).declarations[0]
			if variable && isBindingPattern(variable.name) {
				error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			}
			checkVariableDeclarationList(node.initializer)
		} else {
			varExpr := node.initializer
			leftType := checkExpression(varExpr)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			} else if !isTypeAssignableTo(getIndexTypeOrString(rightType), leftType) {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any)
			} else {
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access)
			}
		}
		if rightType == neverType || !isTypeAssignableToKind(rightType, TypeFlagsNonPrimitive|TypeFlagsInstantiableNonPrimitive) {
			error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType))
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkRightHandSideOfForOf := func(statement ForOfStatement) Type {
		use := /* TODO(Node ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
		return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression)
	}
	checkIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
		if isTypeAny(inputType) {
			return inputType
		}
		return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, true) || anyType
	}
	getIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) *Type {
		allowAsyncIterables := (use & IterationUseAllowsAsyncIterablesFlag) != 0
		if inputType == neverType {
			if errorNode {
				reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables)
			}
			return nil
		}
		uplevelIteration := languageVersion >= ScriptTargetES2015
		downlevelIteration := !uplevelIteration && compilerOptions.downlevelIteration
		possibleOutOfBounds := compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUsePossiblyOutOfBounds)
		if uplevelIteration || downlevelIteration || allowAsyncIterables {
			iterationTypes := getIterationTypesOfIterable(inputType, use /* TODO(Node ConditionalExpression): uplevelIteration ? errorNode : undefined */, TODO)
			if checkAssignability {
				if iterationTypes {
					diagnostic := /* TODO(Node ConditionalExpression): use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 : use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 : use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 : use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 : undefined */ TODO
					if diagnostic {
						checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic)
					}
				}
			}
			if iterationTypes || uplevelIteration {
				// converted from conditional expression
				switch {
				case possibleOutOfBounds:
					return includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType)
				default:
					return (iterationTypes && iterationTypes.yieldType)
				}
			}
		}
		arrayType := inputType
		hasStringConstituent := false
		if use & IterationUseAllowsStringInputFlag {
			if arrayType.flags & TypeFlagsUnion {
				arrayTypes := (inputType).types
				filteredTypes := filter(arrayTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
					return !(t.flags & TypeFlagsStringLike)
				})
				if filteredTypes != arrayTypes {
					arrayType = getUnionType(filteredTypes, UnionReductionSubtype)
				}
			} else if arrayType.flags & TypeFlagsStringLike {
				arrayType = neverType
			}
			hasStringConstituent = arrayType != inputType
			if hasStringConstituent {
				if arrayType.flags & TypeFlagsNever {
					// converted from conditional expression
					switch {
					case possibleOutOfBounds:
						return includeUndefinedInIndexSignature(stringType)
					default:
						return stringType
					}
				}
			}
		}
		if !isArrayLikeType(arrayType) {
			if errorNode {
				allowsStrings := !!(use & IterationUseAllowsStringInputFlag) && !hasStringConstituent
				TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
				errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType))
			}
			// converted from conditional expression
			switch {
			case hasStringConstituent:
				// converted from conditional expression
				switch {
				case possibleOutOfBounds:
					return includeUndefinedInIndexSignature(stringType)
				default:
					return stringType
				}
			default:
				return nil
			}
		}
		arrayElementType := getIndexTypeOfType(arrayType, numberType)
		if hasStringConstituent && arrayElementType {
			if arrayElementType.flags&TypeFlagsStringLike && !compilerOptions.noUncheckedIndexedAccess {
				return stringType
			}
			return getUnionType( /* TODO(Node ConditionalExpression): possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType] */ TODO, UnionReductionSubtype)
		}
		// converted from conditional expression
		switch {
		case (use & IterationUsePossiblyOutOfBounds):
			return includeUndefinedInIndexSignature(arrayElementType)
		default:
			return arrayElementType
		}
		getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration *bool) /* TODO(TypeNode TupleType): [error: DiagnosticMessage, maybeMissingAwait: boolean] */ any {
			if downlevelIteration {
				// converted from conditional expression
				switch {
				case allowsStrings:
					return []TODO{Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true}
				default:
					return []TODO{Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true}
				}
			}
			yieldType := getIterationTypeOfIterable(use, IterationTypeKindYield, inputType, nil)
			if yieldType {
				return []TODO{Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false}
			}
			if isES2015OrLaterIterable(inputType.symbol. /*?*/ escapedName) {
				return []TODO{Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true}
			}
			// converted from conditional expression
			switch {
			case allowsStrings:
				return []TODO{Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true}
			default:
				return []TODO{Diagnostics.Type_0_is_not_an_array_type, true}
			}
		}
	}
	isES2015OrLaterIterable := func(n __String) /* TODO inferred type boolean */ any {
		switch n {
		case "Float32Array":
			fallthrough // TODO: merge cases
		case "Float64Array":
			fallthrough // TODO: merge cases
		case "Int16Array":
			fallthrough // TODO: merge cases
		case "Int32Array":
			fallthrough // TODO: merge cases
		case "Int8Array":
			fallthrough // TODO: merge cases
		case "NodeList":
			fallthrough // TODO: merge cases
		case "Uint16Array":
			fallthrough // TODO: merge cases
		case "Uint32Array":
			fallthrough // TODO: merge cases
		case "Uint8Array":
			fallthrough // TODO: merge cases
		case "Uint8ClampedArray":
			return true
		}
		return false
	}
	getIterationTypeOfIterable := func(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) *Type {
		if isTypeAny(inputType) {
			return nil
		}
		iterationTypes := getIterationTypesOfIterable(inputType, use, errorNode)
		return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)]
	}
	createIterationTypes := func(yieldType Type /*  = neverType */, returnType Type /*  = neverType */, nextType Type /*  = unknownType */) IterationTypes {
		if yieldType.flags&TypeFlagsIntrinsic && returnType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) && nextType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) {
			id := getTypeListId([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{yieldType, returnType, nextType})
			iterationTypes := iterationTypesCache.get(id)
			if !iterationTypes {
				iterationTypes = /* TODO(Node ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
				iterationTypesCache.set(id, iterationTypes)
			}
			return iterationTypes
		}
		return /* TODO(Node ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
	}
	combineIterationTypes := func(array []*IterationTypes) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		var yieldTypes *[]Type
		var returnTypes *[]Type
		var nextTypes *[]Type
		for _, iterationTypes := range array {
			if iterationTypes == nil || iterationTypes == noIterationTypes {
				continue
			}
			if iterationTypes == anyIterationTypes {
				return anyIterationTypes
			}
			yieldTypes = append(yieldTypes, iterationTypes.yieldType)
			returnTypes = append(returnTypes, iterationTypes.returnType)
			nextTypes = append(nextTypes, iterationTypes.nextType)
		}
		if yieldTypes || returnTypes || nextTypes {
			return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes))
		}
		return noIterationTypes
	}
	getCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		return (type_)[cacheKey]
	}
	setCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		(type_)[cacheKey] = cachedTypes
		return (type_)[cacheKey]
	}
	getIterationTypesOfIterable := func(type_ Type, use IterationUse, errorNode Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		if !(type_.flags & TypeFlagsUnion) {
			var errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(Node ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer. /*?*/ errors {
						addRelatedInfo(rootDiag, errorOutputContainer.errors...)
					}
				}
				return nil
			} else if errorOutputContainer. /*?*/ errors. /*?*/ length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			return iterationTypes
		}
		cacheKey := /* TODO(Node ConditionalExpression): use & IterationUse.AllowsAsyncIterablesFlag ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable" */ TODO
		cachedTypes := getCachedIterationTypes(type_, cacheKey)
		if cachedTypes {
			// converted from conditional expression
			switch {
			case cachedTypes == noIterationTypes:
				return nil
			default:
				return cachedTypes
			}
		}
		var allIterationTypes *[]IterationTypes
		for _, constituent := range (type_).types {
			var errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(Node ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer. /*?*/ errors {
						addRelatedInfo(rootDiag, errorOutputContainer.errors...)
					}
				}
				setCachedIterationTypes(type_, cacheKey, noIterationTypes)
				return nil
			} else if errorOutputContainer. /*?*/ errors. /*?*/ length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			allIterationTypes = append(allIterationTypes, iterationTypes)
		}
		iterationTypes := /* TODO(Node ConditionalExpression): allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes */ TODO
		setCachedIterationTypes(type_, cacheKey, iterationTypes)
		// converted from conditional expression
		switch {
		case iterationTypes == noIterationTypes:
			return nil
		default:
			return iterationTypes
		}
	}
	getAsyncFromSyncIterationTypes := func(iterationTypes IterationTypes, errorNode Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		if iterationTypes == noIterationTypes {
			return noIterationTypes
		}
		if iterationTypes == anyIterationTypes {
			return anyIterationTypes
		}
		TODO_IDENTIFIER := iterationTypes
		if errorNode {
			getGlobalAwaitedSymbol(true)
		}
		return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType)
	}
	getIterationTypesOfIterableWorker := func(type_ Type, use IterationUse, errorNode Node, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		noCache := false
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, asyncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					noCache = true
				} else {
					// converted from conditional expression
					switch {
					case use & IterationUseForOfFlag:
						return getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
					default:
						return iterationTypes
					}
				}
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, syncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					noCache = true
				} else {
					if use & IterationUseAllowsAsyncIterablesFlag {
						if iterationTypes != noIterationTypes {
							iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
							// converted from conditional expression
							switch {
							case noCache:
								return iterationTypes
							default:
								return setCachedIterationTypes(type_, "iterationTypesOfAsyncIterable", iterationTypes)
							}
						}
					} else {
						return iterationTypes
					}
				}
			}
		}
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if iterationTypes != noIterationTypes {
				return iterationTypes
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if iterationTypes != noIterationTypes {
				if use & IterationUseAllowsAsyncIterablesFlag {
					iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
					// converted from conditional expression
					switch {
					case noCache:
						return iterationTypes
					default:
						return setCachedIterationTypes(type_, "iterationTypesOfAsyncIterable", iterationTypes)
					}
				} else {
					return iterationTypes
				}
			}
		}
		return noIterationTypes
	}
	getIterationTypesOfIterableCached := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		return getCachedIterationTypes(type_, resolver.iterableCacheKey)
	}
	getIterationTypesOfIterableFast := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		if isReferenceToType(type_, resolver.getGlobalIterableType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, nil) || yieldType, resolver.resolveIterationType(returnType, nil) || returnType, nextType))
		}
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, nil) || yieldType, resolver.resolveIterationType(returnType, nil) || returnType, nextType))
		}
	}
	getPropertyNameForKnownSymbolName := func(symbolName string) __String {
		ctorType := getGlobalESSymbolConstructorSymbol(false)
		uniqueType := ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName))
		// converted from conditional expression
		switch {
		case uniqueType && isTypeUsableAsPropertyName(uniqueType):
			return getPropertyNameFromType(uniqueType)
		default:
			return /* TODO(Node TemplateExpression): `__@${symbolName}` */ TODO
		}
	}
	getIterationTypesOfIterableSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		method := getPropertyOfType(type_, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName))
		methodType := /* TODO(Node ConditionalExpression): method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined */ TODO
		if isTypeAny(methodType) {
			// converted from conditional expression
			switch {
			case noCache:
				return anyIterationTypes
			default:
				return setCachedIterationTypes(type_, resolver.iterableCacheKey, anyIterationTypes)
			}
		}
		signatures := /* TODO(Node ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined */ TODO
		if !some(signatures) {
			// converted from conditional expression
			switch {
			case noCache:
				return noIterationTypes
			default:
				return setCachedIterationTypes(type_, resolver.iterableCacheKey, noIterationTypes)
			}
		}
		iteratorType := getIntersectionType(map_(signatures, getReturnTypeOfSignature))
		iterationTypes := /* TODO(Node BinaryExpression): getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
		// converted from conditional expression
		switch {
		case noCache:
			return iterationTypes
		default:
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, iterationTypes)
		}
	}
	reportTypeNotIterableError := func(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
		message := /* TODO(Node ConditionalExpression): allowAsyncIterables ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator */ TODO
		suggestAwait := !!getAwaitedTypeOfPromise(type_) || (!allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression == errorNode && getGlobalAsyncIterableType(false) != emptyGenericType && isTypeAssignableTo(type_, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(false), [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ any{anyType, anyType, anyType})))
		return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type_))
	}
	getIterationTypesOfIterator := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		return getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer, false)
	}
	getIterationTypesOfIteratorWorker := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		iterationTypes := getIterationTypesOfIteratorCached(type_, resolver) || getIterationTypesOfIteratorFast(type_, resolver)
		if iterationTypes == noIterationTypes && errorNode {
			iterationTypes = nil
			noCache = true
		}
		/* TODO(Node BinaryExpression): iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache) */ TODO
		// converted from conditional expression
		switch {
		case iterationTypes == noIterationTypes:
			return nil
		default:
			return iterationTypes
		}
	}
	getIterationTypesOfIteratorCached := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		return getCachedIterationTypes(type_, resolver.iteratorCacheKey)
	}
	getIterationTypesOfIteratorFast := func(type_ Type, resolver IterationTypesResolver) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		if isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
	}
	isIteratorResult := func(type_ Type, kind /* TODO(TypeNode UnionType): IterationTypeKind.Yield | IterationTypeKind.Return */ any) /* TODO inferred type boolean */ any {
		doneType := getTypeOfPropertyOfType(type_, "done") || falseType
		return isTypeAssignableTo( /* TODO(Node ConditionalExpression): kind === IterationTypeKind.Yield ? falseType : trueType */ TODO, doneType)
	}
	isYieldIteratorResult := func(type_ Type) /* TODO inferred type boolean */ any {
		return isIteratorResult(type_, IterationTypeKindYield)
	}
	isReturnIteratorResult := func(type_ Type) /* TODO inferred type boolean */ any {
		return isIteratorResult(type_, IterationTypeKindReturn)
	}
	getIterationTypesOfIteratorResult := func(type_ Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		cachedTypes := getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
		if cachedTypes {
			return cachedTypes
		}
		if isReferenceToType(type_, getGlobalIteratorYieldResultType(false)) {
			yieldType := getTypeArguments(type_)[0]
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, nil, nil))
		}
		if isReferenceToType(type_, getGlobalIteratorReturnResultType(false)) {
			returnType := getTypeArguments(type_)[0]
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(nil, returnType, nil))
		}
		yieldIteratorResult := filterType(type_, isYieldIteratorResult)
		yieldType := /* TODO(Node ConditionalExpression): yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value" as __String) : undefined */ TODO
		returnIteratorResult := filterType(type_, isReturnIteratorResult)
		returnType := /* TODO(Node ConditionalExpression): returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value" as __String) : undefined */ TODO
		if !yieldType && !returnType {
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", noIterationTypes)
		}
		return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, nil))
	}
	getIterationTypesOfMethod := func(type_ Type, resolver IterationTypesResolver, methodName /* TODO(TypeNode UnionType): "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
		method := getPropertyOfType(type_, methodName)
		if !method && methodName != "next" {
			return nil
		}
		methodType := /* TODO(Node ConditionalExpression): method && !(methodName === "next" && (method.flags & SymbolFlags.Optional)) ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull) : undefined */ TODO
		if isTypeAny(methodType) {
			return anyIterationTypes
		}
		methodSignatures := /* TODO(Node ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : emptyArray */ TODO
		if methodSignatures.length == 0 {
			if errorNode {
				diagnostic := /* TODO(Node ConditionalExpression): methodName === "next" ? resolver.mustHaveANextMethodDiagnostic : resolver.mustBeAMethodDiagnostic */ TODO
				if errorOutputContainer {
					/* TODO(Node BinaryExpression): errorOutputContainer.errors ??= [] */ TODO
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName))
				} else {
					error(errorNode, diagnostic, methodName)
				}
			}
			// converted from conditional expression
			switch {
			case methodName == "next":
				return noIterationTypes
			default:
				return nil
			}
		}
		if methodType. /*?*/ symbol && methodSignatures.length == 1 {
			globalGeneratorType := resolver.getGlobalGeneratorType(false)
			globalIteratorType := resolver.getGlobalIteratorType(false)
			isGeneratorMethod := globalGeneratorType.symbol. /*?*/ members. /*?*/ get(methodName) == methodType.symbol
			isIteratorMethod := !isGeneratorMethod && globalIteratorType.symbol. /*?*/ members. /*?*/ get(methodName) == methodType.symbol
			if isGeneratorMethod || isIteratorMethod {
				globalType := /* TODO(Node ConditionalExpression): isGeneratorMethod ? globalGeneratorType : globalIteratorType */ TODO
				TODO_IDENTIFIER := methodType
				return createIterationTypes(getMappedType(globalType.typeParameters[0], mapper), getMappedType(globalType.typeParameters[1], mapper) /* TODO(Node ConditionalExpression): methodName === "next" ? getMappedType(globalType.typeParameters![2], mapper!) : undefined */, TODO)
			}
		}
		var methodParameterTypes *[]Type
		var methodReturnTypes *[]Type
		for _, signature := range methodSignatures {
			if methodName != "throw" && some(signature.parameters) {
				methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0))
			}
			methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature))
		}
		var returnTypes *[]Type
		var nextType *Type
		if methodName != "throw" {
			methodParameterType := /* TODO(Node ConditionalExpression): methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType */ TODO
			if methodName == "next" {
				nextType = methodParameterType
			} else if methodName == "return" {
				resolvedMethodParameterType := resolver.resolveIterationType(methodParameterType, errorNode) || anyType
				returnTypes = append(returnTypes, resolvedMethodParameterType)
			}
		}
		var yieldType Type
		methodReturnType := /* TODO(Node ConditionalExpression): methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType */ TODO
		resolvedMethodReturnType := resolver.resolveIterationType(methodReturnType, errorNode) || anyType
		iterationTypes := getIterationTypesOfIteratorResult(resolvedMethodReturnType)
		if iterationTypes == noIterationTypes {
			if errorNode {
				if errorOutputContainer {
					/* TODO(Node BinaryExpression): errorOutputContainer.errors ??= [] */ TODO
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName))
				} else {
					error(errorNode, resolver.mustHaveAValueDiagnostic, methodName)
				}
			}
			yieldType = anyType
			returnTypes = append(returnTypes, anyType)
		} else {
			yieldType = iterationTypes.yieldType
			returnTypes = append(returnTypes, iterationTypes.returnType)
		}
		return createIterationTypes(yieldType, getUnionType(returnTypes), nextType)
	}
	getIterationTypesOfIteratorSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TypeNode TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ any {
		iterationTypes := combineIterationTypes([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any{getIterationTypesOfMethod(type_, resolver, "next", errorNode, errorOutputContainer), getIterationTypesOfMethod(type_, resolver, "return", errorNode, errorOutputContainer), getIterationTypesOfMethod(type_, resolver, "throw", errorNode, errorOutputContainer)})
		// converted from conditional expression
		switch {
		case noCache:
			return iterationTypes
		default:
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, iterationTypes)
		}
	}
	getIterationTypeOfGeneratorFunctionReturnType := func(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) *Type {
		if isTypeAny(returnType) {
			return nil
		}
		iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
		return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)]
	}
	getIterationTypesOfGeneratorFunctionReturnType := func(type_ Type, isAsyncGenerator bool) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ any {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		use := /* TODO(Node ConditionalExpression): isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType */ TODO
		resolver := /* TODO(Node ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		return getIterationTypesOfIterable(type_, use, nil) || getIterationTypesOfIterator(type_, resolver, nil, nil)
	}
	checkBreakOrContinueStatement := func(node BreakOrContinueStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			checkGrammarBreakOrContinueStatement(node)
		}
	}
	unwrapReturnType := func(returnType Type, functionFlags FunctionFlags) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		isGenerator := !!(functionFlags & FunctionFlagsGenerator)
		isAsync := !!(functionFlags & FunctionFlagsAsync)
		if isGenerator {
			returnIterationType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, isAsync)
			if !returnIterationType {
				return errorType
			}
			// converted from conditional expression
			switch {
			case isAsync:
				return getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType))
			default:
				return returnIterationType
			}
		}
		// converted from conditional expression
		switch {
		case isAsync:
			return getAwaitedTypeNoAlias(returnType) || errorType
		default:
			return returnType
		}
	}
	isUnwrappedReturnTypeUndefinedVoidOrAny := func(func_ SignatureDeclaration, returnType Type) bool {
		type_ := unwrapReturnType(returnType, getFunctionFlags(func_))
		return !!(type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)))
	}
	checkReturnStatement := func(node ReturnStatement) {
		if checkGrammarStatementInAmbientContext(node) {
			return
		}
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block)
			return
		}
		if !container {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body)
			return
		}
		signature := getSignatureFromDeclaration(container)
		returnType := getReturnTypeOfSignature(signature)
		functionFlags := getFunctionFlags(container)
		if strictNullChecks || node.expression || returnType.flags&TypeFlagsNever {
			exprType := /* TODO(Node ConditionalExpression): node.expression ? checkExpressionCached(node.expression) : undefinedType */ TODO
			if container.kind == SyntaxKindSetAccessor {
				if node.expression {
					error(node, Diagnostics.Setters_cannot_return_a_value)
				}
			} else if container.kind == SyntaxKindConstructor {
				if node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression) {
					error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class)
				}
			} else if getReturnTypeFromAnnotation(container) {
				unwrappedReturnType := /* TODO(Node BinaryExpression): unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
				unwrappedExprType := /* TODO(Node ConditionalExpression): functionFlags & FunctionFlags.Async ? checkAwaitedType(exprType, /*withAlias* / false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member) : exprType */ TODO
				if unwrappedReturnType {
					checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression)
				}
			}
		} else if container.kind != SyntaxKindConstructor && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) {
			error(node, Diagnostics.Not_all_code_paths_return_a_value)
		}
	}
	checkWithStatement := func(node WithStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if node.flags & NodeFlagsAwaitContext {
				grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block)
			}
		}
		checkExpression(node.expression)
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			start := getSpanOfTokenAtPosition(sourceFile, node.pos).start
			end := node.statement.pos
			grammarErrorAtPos(sourceFile, start, end-start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any)
		}
	}
	checkSwitchStatement := func(node SwitchStatement) {
		checkGrammarStatementInAmbientContext(node)
		var firstDefaultClause CaseOrDefaultClause
		hasDuplicateDefaultClause := false
		expressionType := checkExpression(node.expression)
		forEach(node.caseBlock.clauses, func(clause /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ any) {
			if clause.kind == SyntaxKindDefaultClause && !hasDuplicateDefaultClause {
				if firstDefaultClause == nil {
					firstDefaultClause = clause
				} else {
					grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement)
					hasDuplicateDefaultClause = true
				}
			}
			if clause.kind == SyntaxKindCaseClause {
				addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause))
			}
			forEach(clause.statements, checkSourceElement)
			if compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode) {
				error(clause, Diagnostics.Fallthrough_case_in_switch)
			}
			createLazyCaseClauseDiagnostics := func(clause CaseClause) /* TODO inferred type () => void */ any {
				return func() {
					caseType := checkExpression(clause.expression)
					if !isTypeEqualityComparableTo(expressionType, caseType) {
						checkTypeComparableTo(caseType, expressionType, clause.expression, nil)
					}
				}
			}
		})
		if node.caseBlock.locals {
			registerForUnusedIdentifiersCheck(node.caseBlock)
		}
	}
	checkLabeledStatement := func(node LabeledStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			findAncestor(node.parent, func(current /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
				if isFunctionLike(current) {
					return "quit"
				}
				if current.kind == SyntaxKindLabeledStatement && (current).label.escapedText == node.label.escapedText {
					grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label))
					return true
				}
				return false
			})
		}
		checkSourceElement(node.statement)
	}
	checkThrowStatement := func(node ThrowStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if isIdentifier(node.expression) && !node.expression.escapedText {
				grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here)
			}
		}
		if node.expression {
			checkExpression(node.expression)
		}
	}
	checkTryStatement := func(node TryStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkBlock(node.tryBlock)
		catchClause := node.catchClause
		if catchClause {
			if catchClause.variableDeclaration {
				declaration := catchClause.variableDeclaration
				checkVariableLikeDeclaration(declaration)
				typeNode := getEffectiveTypeAnnotationNode(declaration)
				if typeNode {
					type_ := getTypeFromTypeNode(typeNode)
					if type_ && !(type_.flags & TypeFlagsAnyOrUnknown) {
						grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified)
					}
				} else if declaration.initializer {
					grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer)
				} else {
					blockLocals := catchClause.block.locals
					if blockLocals {
						forEachKey(catchClause.locals, func(caughtName /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
							blockLocal := blockLocals.get(caughtName)
							if blockLocal. /*?*/ valueDeclaration && (blockLocal.flags&SymbolFlagsBlockScopedVariable) != 0 {
								grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName))
							}
						})
					}
				}
			}
			checkBlock(catchClause.block)
		}
		if node.finallyBlock {
			checkBlock(node.finallyBlock)
		}
	}
	checkIndexConstraints := func(type_ Type, symbol Symbol, isStaticIndex bool) {
		indexInfos := getIndexInfosOfType(type_)
		if indexInfos.length == 0 {
			return
		}
		for _, prop := range getPropertiesOfObjectType(type_) {
			if !(isStaticIndex && prop.flags&SymbolFlagsPrototype) {
				checkIndexConstraintForProperty(type_, prop, getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique, true), getNonMissingTypeOfSymbol(prop))
			}
		}
		typeDeclaration := symbol.valueDeclaration
		if typeDeclaration && isClassLike(typeDeclaration) {
			for _, member := range typeDeclaration.members {
				if !isStatic(member) && !hasBindableName(member) {
					symbol := getSymbolOfDeclaration(member)
					checkIndexConstraintForProperty(type_, symbol, getTypeOfExpression((member).name.expression), getNonMissingTypeOfSymbol(symbol))
				}
			}
		}
		if indexInfos.length > 1 {
			for _, info := range indexInfos {
				checkIndexConstraintForIndexSignature(type_, info)
			}
		}
	}
	checkIndexConstraintForProperty := func(type_ Type, prop Symbol, propNameType Type, propType Type) {
		declaration := prop.valueDeclaration
		name := getNameOfDeclaration(declaration)
		if name && isPrivateIdentifier(name) {
			return
		}
		indexInfos := getApplicableIndexInfos(type_, propNameType)
		interfaceDeclaration := /* TODO(Node ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		propDeclaration := /* TODO(Node ConditionalExpression): declaration && declaration.kind === SyntaxKind.BinaryExpression || name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined */ TODO
		localPropDeclaration := /* TODO(Node ConditionalExpression): getParentOfSymbol(prop) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			localIndexDeclaration := /* TODO(Node ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localPropDeclaration || localIndexDeclaration || ( /* TODO(Node ConditionalExpression): interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined */ TODO)
			if errorNode && !isTypeAssignableTo(propType, info.type_) {
				diagnostic := createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type_))
				if propDeclaration && errorNode != propDeclaration {
					addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	checkIndexConstraintForIndexSignature := func(type_ Type, checkInfo IndexInfo) {
		declaration := checkInfo.declaration
		indexInfos := getApplicableIndexInfos(type_, checkInfo.keyType)
		interfaceDeclaration := /* TODO(Node ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		localCheckDeclaration := /* TODO(Node ConditionalExpression): declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			if info == checkInfo {
				continue
			}
			localIndexDeclaration := /* TODO(Node ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localCheckDeclaration || localIndexDeclaration || ( /* TODO(Node ConditionalExpression): interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined */ TODO)
			if errorNode && !isTypeAssignableTo(checkInfo.type_, info.type_) {
				error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type_), typeToString(info.keyType), typeToString(info.type_))
			}
		}
	}
	checkTypeNameIsReserved := func(name Identifier, message DiagnosticMessage) {
		switch name.escapedText {
		case "any":
			fallthrough // TODO: merge cases
		case "unknown":
			fallthrough // TODO: merge cases
		case "never":
			fallthrough // TODO: merge cases
		case "number":
			fallthrough // TODO: merge cases
		case "bigint":
			fallthrough // TODO: merge cases
		case "boolean":
			fallthrough // TODO: merge cases
		case "string":
			fallthrough // TODO: merge cases
		case "symbol":
			fallthrough // TODO: merge cases
		case "void":
			fallthrough // TODO: merge cases
		case "object":
			fallthrough // TODO: merge cases
		case "undefined":
			error(name, message, name.escapedText)
		}
	}
	checkClassNameCollisionWithObject := func(name Identifier) {
		if languageVersion >= ScriptTargetES5 && name.escapedText == "Object" && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKindES2015 {
			error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[moduleKind])
		}
	}
	checkUnmatchedJSDocParameters := func(node SignatureDeclaration) {
		jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
		if !length(jsdocParameters) {
			return
		}
		isJs := isInJSFile(node)
		parameters := make(map[__String]struct{})
		excludedParameters := make(map[number]struct{})
		forEach(node.parameters, func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any, index /* TODO inferred type number */ any) {
			if isIdentifier(name) {
				parameters.add(name.escapedText)
			}
			if isBindingPattern(name) {
				excludedParameters.add(index)
			}
		})
		containsArguments := containsArgumentsReference(node)
		if containsArguments {
			lastJSDocParamIndex := jsdocParameters.length - 1
			lastJSDocParam := jsdocParameters[lastJSDocParamIndex]
			if isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type_ && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type_)) {
				error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name))
			}
		} else {
			forEach(jsdocParameters, func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocParameterTag */ any, index /* TODO inferred type number */ any) {
				if excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText) {
					return
				}
				if isQualifiedName(name) {
					if isJs {
						error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left))
					}
				} else {
					if !isNameFirst {
						errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name))
					}
				}
			})
		}
	}
	checkTypeParameters := func(typeParameterDeclarations *[]TypeParameterDeclaration) {
		seenDefault := false
		if typeParameterDeclarations {
			for i := 0; i < typeParameterDeclarations.length; i++ {
				node := typeParameterDeclarations[i]
				checkTypeParameter(node)
				addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i))
			}
		}
		createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO inferred type () => void */ any {
			return func() {
				if node.default_ {
					seenDefault = true
					checkTypeParametersNotReferenced(node.default_, typeParameterDeclarations, i)
				} else if seenDefault {
					error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters)
				}
				for j := 0; j < i; j++ {
					if typeParameterDeclarations[j].symbol == node.symbol {
						error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name))
					}
				}
			}
		}
	}
	checkTypeParametersNotReferenced := func(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
		visit(root)
		visit := func(node Node) {
			if node.kind == SyntaxKindTypeReference {
				type_ := getTypeFromTypeReference(node)
				if type_.flags & TypeFlagsTypeParameter {
					for i := index; i < typeParameters.length; i++ {
						if type_.symbol == getSymbolOfDeclaration(typeParameters[i]) {
							error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters)
						}
					}
				}
			}
			forEachChild(node, visit)
		}
	}
	checkTypeParameterListsIdentical := func(symbol Symbol) {
		if symbol.declarations && symbol.declarations.length == 1 {
			return
		}
		links := getSymbolLinks(symbol)
		if !links.typeParametersChecked {
			links.typeParametersChecked = true
			declarations := getClassOrInterfaceDeclarationsOfSymbol(symbol)
			if !declarations || declarations.length <= 1 {
				return
			}
			type_ := getDeclaredTypeOfSymbol(symbol)
			if !areTypeParametersIdentical(declarations, type_.localTypeParameters, getEffectiveTypeParameterDeclarations) {
				name := symbolToString(symbol)
				for _, declaration := range declarations {
					error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name)
				}
			}
		}
	}
	areTypeParametersIdentical := func(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) /* TODO inferred type boolean */ any {
		maxTypeArgumentCount := length(targetParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(targetParameters)
		for _, declaration := range declarations {
			sourceParameters := getTypeParameterDeclarations(declaration)
			numTypeParameters := sourceParameters.length
			if numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount {
				return false
			}
			for i := 0; i < numTypeParameters; i++ {
				source := sourceParameters[i]
				target := targetParameters[i]
				if source.name.escapedText != target.symbol.escapedName {
					return false
				}
				constraint := getEffectiveConstraintOfTypeParameter(source)
				sourceConstraint := constraint && getTypeFromTypeNode(constraint)
				targetConstraint := getConstraintOfTypeParameter(target)
				if sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint) {
					return false
				}
				sourceDefault := source.default_ && getTypeFromTypeNode(source.default_)
				targetDefault := getDefaultFromTypeParameter(target)
				if sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault) {
					return false
				}
			}
		}
		return true
	}
	getFirstTransformableStaticClassElement := func(node ClassLikeDeclaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Decorator | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassStaticBlockDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierPropertyDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierMethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierGetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierSetAccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyDeclaration & { initializer: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }) | undefined */ any {
		willTransformStaticElementsOfDecoratedClass := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators && classOrConstructorParameterIsDecorated(false, node)
		willTransformPrivateElementsOrClassStaticBlocks := languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		willTransformInitializers := !emitStandardClassFields
		if willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks {
			for _, member := range node.members {
				if willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(false, member, node) {
					return /* TODO(Node BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
				} else if willTransformPrivateElementsOrClassStaticBlocks {
					if isClassStaticBlockDeclaration(member) {
						return member
					} else if isStatic(member) {
						if isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member) {
							return member
						}
					}
				}
			}
		}
	}
	checkClassExpressionExternalHelpers := func(node ClassExpression) {
		if node.name {
			return
		}
		parent := walkUpOuterExpressions(node)
		if !isNamedEvaluationSource(parent) {
			return
		}
		willTransformESDecorators := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		var location Node
		if willTransformESDecorators && classOrConstructorParameterIsDecorated(false, node) {
			location = /* TODO(Node BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
		} else {
			location = getFirstTransformableStaticClassElement(node)
		}
		if location {
			checkExternalEmitHelpers(location, ExternalEmitHelpersSetFunctionName)
			if (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name) {
				checkExternalEmitHelpers(location, ExternalEmitHelpersPropKey)
			}
		}
	}
	checkClassExpression := func(node ClassExpression) Type {
		checkClassLikeDeclaration(node)
		checkNodeDeferred(node)
		checkClassExpressionExternalHelpers(node)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	checkClassExpressionDeferred := func(node ClassExpression) {
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassDeclaration := func(node ClassDeclaration) {
		firstDecorator := find(node.modifiers, isDecorator)
		if legacyDecorators && firstDecorator && some(node.members, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement */ any) /* TODO inferred type boolean */ any {
			return hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p)
		}) {
			grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator)
		}
		if !node.name && !hasSyntacticModifier(node, ModifierFlagsDefault) {
			grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name)
		}
		checkClassLikeDeclaration(node)
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassLikeDeclaration := func(node ClassLikeDeclaration) {
		checkGrammarClassLikeDeclaration(node)
		checkDecorators(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkExportsOnMergedDeclarations(node)
		symbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(symbol)
		checkTypeParameterListsIdentical(symbol)
		checkFunctionOrConstructorSymbol(symbol)
		checkClassForDuplicateDeclarations(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if !nodeInAmbientContext {
			checkClassForStaticPropertyNameConflicts(node)
		}
		baseTypeNode := getEffectiveBaseTypeNode(node)
		if baseTypeNode {
			forEach(baseTypeNode.typeArguments, checkSourceElement)
			if languageVersion < LanguageFeatureMinimumTargetClasses {
				checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpersExtends)
			}
			extendsNode := getClassExtendsHeritageElement(node)
			if extendsNode && extendsNode != baseTypeNode {
				checkExpression(extendsNode.expression)
			}
			baseTypes := getBaseTypes(type_)
			if baseTypes.length {
				addLazyDiagnostic(func() {
					baseType := baseTypes[0]
					baseConstructorType := getBaseConstructorTypeOfClass(type_)
					staticBaseType := getApparentType(baseConstructorType)
					checkBaseTypeAccessibility(staticBaseType, baseTypeNode)
					checkSourceElement(baseTypeNode.expression)
					if some(baseTypeNode.typeArguments) {
						forEach(baseTypeNode.typeArguments, checkSourceElement)
						for _, constructor := range getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode) {
							if !checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters) {
								break
							}
						}
					}
					baseWithThis := getTypeWithThisArgument(baseType, type_.thisType)
					if !checkTypeAssignableTo(typeWithThis, baseWithThis, nil) {
						issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1)
					} else {
						checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1)
					}
					if baseConstructorType.flags & TypeFlagsTypeVariable {
						if !isMixinConstructorType(staticType) {
							error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any)
						} else {
							constructSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
							if constructSignatures.some(func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type number */ any {
								return signature.flags & SignatureFlagsAbstract
							}) && !hasSyntacticModifier(node, ModifierFlagsAbstract) {
								error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract)
							}
						}
					}
					if !(staticBaseType.symbol && staticBaseType.symbol.flags&SymbolFlagsClass) && !(baseConstructorType.flags & TypeFlagsTypeVariable) {
						constructors := getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)
						if forEach(constructors, func(sig /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
							return !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType)
						}) {
							error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type)
						}
					}
					checkKindsOfPropertyMemberOverrides(type_, baseType)
				})
			}
		}
		checkMembersForOverrideModifier(node, type_, typeWithThis, staticType)
		implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
		if implementedTypeNodes {
			for _, typeRefNode := range implementedTypeNodes {
				if !isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression) {
					error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments)
				}
				checkTypeReferenceNode(typeRefNode)
				addLazyDiagnostic(createImplementsDiagnostics(typeRefNode))
			}
		}
		addLazyDiagnostic(func() {
			checkIndexConstraints(type_, symbol)
			checkIndexConstraints(staticType, symbol, true)
			checkTypeForDuplicateIndexSignatures(node)
			checkPropertyInitialization(node)
		})
		createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO inferred type () => void */ any {
			return func() {
				t := getReducedType(getTypeFromTypeNode(typeRefNode))
				if !isErrorType(t) {
					if isValidBaseType(t) {
						genericDiag := /* TODO(Node ConditionalExpression): t.symbol && t.symbol.flags & SymbolFlags.Class ? Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass : Diagnostics.Class_0_incorrectly_implements_interface_1 */ TODO
						baseWithThis := getTypeWithThisArgument(t, type_.thisType)
						if !checkTypeAssignableTo(typeWithThis, baseWithThis, nil) {
							issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag)
						}
					} else {
						error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members)
					}
				}
			}
		}
	}
	checkMembersForOverrideModifier := func(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(Node ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		for _, member := range node.members {
			if hasAmbientModifier(member) {
				continue
			}
			if isConstructorDeclaration(member) {
				forEach(member.parameters, func(param /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any) {
					if isParameterPropertyDeclaration(param, member) {
						checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, param, true)
					}
				})
			}
			checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, member, false)
		}
	}
	checkExistingMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, member /* TODO(TypeNode UnionType): ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors /* TODO inferred type boolean */ any /*  = true */) MemberOverrideStatus {
		declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
		if !declaredProp {
			return MemberOverrideStatusOk
		}
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp /* TODO(Node ConditionalExpression): reportErrors ? member : undefined */, TODO)
	}
	checkMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
		isJs := isInJSFile(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride) {
			thisType := /* TODO(Node ConditionalExpression): memberIsStatic ? staticType : typeWithThis */ TODO
			baseType := /* TODO(Node ConditionalExpression): memberIsStatic ? baseStaticType : baseWithThis */ TODO
			prop := getPropertyOfType(thisType, member.escapedName)
			baseProp := getPropertyOfType(baseType, member.escapedName)
			baseClassName := typeToString(baseWithThis)
			if prop && !baseProp && memberHasOverrideModifier {
				if errorNode {
					suggestion := getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
					/* TODO(Node ConditionalExpression): suggestion ? error( errorNode, isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1, baseClassName, symbolToString(suggestion), ) : error( errorNode, isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0, baseClassName, ) */ TODO
				}
				return MemberOverrideStatusHasInvalidOverride
			} else if prop && baseProp. /*?*/ declarations && compilerOptions.noImplicitOverride && !nodeInAmbientContext {
				baseHasAbstract := some(baseProp.declarations, hasAbstractModifier)
				if memberHasOverrideModifier {
					return MemberOverrideStatusOk
				}
				if !baseHasAbstract {
					if errorNode {
						diag := /* TODO(Node ConditionalExpression): memberIsParameterProperty ? isJs ? Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 : isJs ? Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0 */ TODO
						error(errorNode, diag, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				} else if memberHasAbstractModifier && baseHasAbstract {
					if errorNode {
						error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				}
			}
		} else if memberHasOverrideModifier {
			if errorNode {
				className := typeToString(type_)
				error(errorNode /* TODO(Node ConditionalExpression): isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class : Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class */, TODO, className)
			}
			return MemberOverrideStatusHasInvalidOverride
		}
		return MemberOverrideStatusOk
	}
	issueMemberSpecificError := func(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
		issuedMemberError := false
		for _, member := range node.members {
			if isStatic(member) {
				continue
			}
			declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
			if declaredProp {
				prop := getPropertyOfType(typeWithThis, declaredProp.escapedName)
				baseProp := getPropertyOfType(baseWithThis, declaredProp.escapedName)
				if prop && baseProp {
					rootChain := func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ any {
						return chainDiagnosticMessages(nil, Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, symbolToString(declaredProp), typeToString(typeWithThis), typeToString(baseWithThis))
					}
					if !checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, nil, rootChain) {
						issuedMemberError = true
					}
				}
			}
		}
		if !issuedMemberError {
			checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag)
		}
	}
	checkBaseTypeAccessibility := func(type_ Type, node ExpressionWithTypeArguments) {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length {
			declaration := signatures[0].declaration
			if declaration && hasEffectiveModifier(declaration, ModifierFlagsPrivate) {
				typeClassDeclaration := getClassLikeDeclarationOfSymbol(type_.symbol)
				if !isNodeWithinClass(node, typeClassDeclaration) {
					error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type_.symbol))
				}
			}
		}
	}
	getMemberOverrideModifierStatus := func(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
		if !member.name {
			return MemberOverrideStatusOk
		}
		classSymbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(classSymbol)
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(classSymbol)
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(Node ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		memberHasOverrideModifier := /* TODO(Node ConditionalExpression): member.parent ? hasOverrideModifier(member) : hasSyntacticModifier(member, ModifierFlags.Override) */ TODO
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), false, memberSymbol)
	}
	getTargetSymbol := func(s Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		// converted from conditional expression
		switch {
		case getCheckFlags(s) & CheckFlagsInstantiated:
			return (s).links.target
		default:
			return s
		}
	}
	getClassOrInterfaceDeclarationsOfSymbol := func(symbol Symbol) /* TODO inferred type (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration)[] | undefined */ any {
		return filter(symbol.declarations, func(d Declaration) /* TODO(TypeNode TypePredicate): d is ClassDeclaration | InterfaceDeclaration */ any {
			return d.kind == SyntaxKindClassDeclaration || d.kind == SyntaxKindInterfaceDeclaration
		})
	}
	checkKindsOfPropertyMemberOverrides := func(type_ InterfaceType, baseType BaseType) {
		baseProperties := getPropertiesOfType(baseType)
		type MemberInfo struct {
			missedProperties []string
			baseTypeName     string
			typeName         string
		}
		notImplementedInfo := make(map[ClassLikeDeclaration]MemberInfo)
		/* TODO(Node LabeledStatement): basePropertyCheck: for (const baseProperty of baseProperties) { const base = getTargetSymbol(baseProperty); if (base.flags & SymbolFlags.Prototype) { continue; } const baseSymbol = getPropertyOfObjectType(type, base.escapedName); if (!baseSymbol) { continue; } const derived = getTargetSymbol(baseSymbol); const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base); Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration."); // In order to resolve whether the inherited method was overridden in the base class or not, // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated* // type declaration, derived and base resolve to the same symbol even in the case of generic classes. if (derived === base) { // derived class inherits base without override/redeclaration const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!; // It is an error to inherit an abstract member without implementing it or being declared abstract. // If there is no declaration for the derived class (as in the case of class expressions), // then the class cannot be declared abstract. if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) { // Searches other base types for a declaration that would satisfy the inherited abstract member. // (The class may have more than one base type via declaration merging with an interface with the // same name.) for (const otherBaseType of getBaseTypes(type)) { if (otherBaseType === baseType) continue; const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escapedName); const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol); if (derivedElsewhere && derivedElsewhere !== base) { continue basePropertyCheck; } } const baseTypeName = typeToString(baseType); const typeName = typeToString(type); const basePropertyName = symbolToString(baseProperty); const missedProperties = append(notImplementedInfo.get(derivedClassDecl)?.missedProperties, basePropertyName); notImplementedInfo.set(derivedClassDecl, { baseTypeName, typeName, missedProperties }); } } else { // derived overrides base. const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived); if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) { // either base or derived property is private - not override, skip it continue; } let errorMessage: DiagnosticMessage; const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor; const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor; if (basePropertyFlags && derivedPropertyFlags) { // property/accessor is overridden with property/accessor if ( (getCheckFlags(base) & CheckFlags.Synthetic ? base.declarations?.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)) : base.declarations?.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))) || getCheckFlags(base) & CheckFlags.Mapped || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) ) { // when the base property is abstract or from an interface, base/derived flags don't need to match // for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all* // same when the derived property is from an assignment continue; } const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property; const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property; if (overriddenInstanceProperty || overriddenInstanceAccessor) { const errorMessage = overriddenInstanceProperty ? Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property : Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor; error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type)); } else if (useDefineForClassFields) { const uninitialized = derived.declarations?.find(d => d.kind === SyntaxKind.PropertyDeclaration && !(d as PropertyDeclaration).initializer); if ( uninitialized && !(derived.flags & SymbolFlags.Transient) && !(baseDeclarationFlags & ModifierFlags.Abstract) && !(derivedDeclarationFlags & ModifierFlags.Abstract) && !derived.declarations?.some(d => !!(d.flags & NodeFlags.Ambient)) ) { const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!); const propName = (uninitialized as PropertyDeclaration).name; if ( (uninitialized as PropertyDeclaration).exclamationToken || !constructor || !isIdentifier(propName) || !strictNullChecks || !isPropertyInitializedInConstructor(propName, type, constructor) ) { const errorMessage = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration; error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType)); } } } // correct case continue; } else if (isPrototypeProperty(base)) { if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) { // method is overridden with method or property -- correct case continue; } else { Debug.assert(!!(derived.flags & SymbolFlags.Accessor)); errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor; } } else if (base.flags & SymbolFlags.Accessor) { errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function; } else { errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function; } error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type)); } } */
		for _, TODO_IDENTIFIER := range notImplementedInfo {
			if length(memberInfo.missedProperties) == 1 {
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				}
			} else if length(memberInfo.missedProperties) > 5 {
				missedProperties := map_(memberInfo.missedProperties.slice(0, 4), func(prop /* TODO inferred type string */ any) /* TODO inferred type string */ any {
					return /* TODO(Node TemplateExpression): `'${prop}'` */ TODO
				}).join(", ")
				remainingMissedProperties := length(memberInfo.missedProperties) - 4
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				}
			} else {
				missedProperties := map_(memberInfo.missedProperties, func(prop /* TODO inferred type string */ any) /* TODO inferred type string */ any {
					return /* TODO(Node TemplateExpression): `'${prop}'` */ TODO
				}).join(", ")
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties)
				}
			}
		}
	}
	isPropertyAbstractOrInterface := func(declaration Declaration, baseDeclarationFlags ModifierFlags) /* TODO inferred type boolean */ any {
		return baseDeclarationFlags&ModifierFlagsAbstract && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent)
	}
	getNonInheritedProperties := func(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ any {
		if !length(baseTypes) {
			return properties
		}
		seen := make(map[__String]Symbol)
		forEach(properties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
			seen.set(p.escapedName, p)
		})
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if existing && prop.parent == existing.parent {
					seen.delete(prop.escapedName)
				}
			}
		}
		return arrayFrom(seen.values())
	}
	checkInheritedPropertiesAreIdentical := func(type_ InterfaceType, typeNode Node) bool {
		baseTypes := getBaseTypes(type_)
		if baseTypes.length < 2 {
			return true
		}
		type InheritanceInfoMap struct {
			prop           Symbol
			containingType Type
		}
		seen := make(map[__String]InheritanceInfoMap)
		forEach(resolveDeclaredMembers(type_).declaredProperties, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
			seen.set(p.escapedName /* TODO(Node ObjectLiteralExpression): { prop: p, containingType: type } */, TODO)
		})
		ok := true
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if !existing {
					seen.set(prop.escapedName /* TODO(Node ObjectLiteralExpression): { prop, containingType: base } */, TODO)
				} else {
					isInheritedProperty := existing.containingType != type_
					if isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop) {
						ok = false
						typeName1 := typeToString(existing.containingType)
						typeName2 := typeToString(base)
						errorInfo := chainDiagnosticMessages(nil, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2)
						errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type_), typeName1, typeName2)
						diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo))
					}
				}
			}
		}
		return ok
	}
	checkPropertyInitialization := func(node ClassLikeDeclaration) {
		if !strictNullChecks || !strictPropertyInitialization || node.flags&NodeFlagsAmbient {
			return
		}
		constructor := findConstructorDeclaration(node)
		for _, member := range node.members {
			if getEffectiveModifierFlags(member) & ModifierFlagsAmbient {
				continue
			}
			if !isStatic(member) && isPropertyWithoutInitializer(member) {
				propName := (member).name
				if isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName) {
					type_ := getTypeOfSymbol(getSymbolOfDeclaration(member))
					if !(type_.flags&TypeFlagsAnyOrUnknown || containsUndefinedType(type_)) {
						if !constructor || !isPropertyInitializedInConstructor(propName, type_, constructor) {
							error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName))
						}
					}
				}
			}
		}
	}
	isPropertyWithoutInitializer := func(node Node) /* TODO inferred type boolean */ any {
		return node.kind == SyntaxKindPropertyDeclaration && !hasAbstractModifier(node) && !(node).exclamationToken && !(node).initializer
	}
	isPropertyInitializedInStaticBlocks := func(propName /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) /* TODO inferred type boolean */ any {
		for _, staticBlock := range staticBlocks {
			if staticBlock.pos >= startPos && staticBlock.pos <= endPos {
				reference := factory.createPropertyAccessExpression(factory.createThis(), propName)
				setParent(reference.expression, reference)
				setParent(reference, staticBlock)
				reference.flowNode = staticBlock.returnFlowNode
				flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
				if !containsUndefinedType(flowType) {
					return true
				}
			}
		}
		return false
	}
	isPropertyInitializedInConstructor := func(propName /* TODO(TypeNode UnionType): Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) /* TODO inferred type boolean */ any {
		reference := /* TODO(Node ConditionalExpression): isComputedPropertyName(propName) ? factory.createElementAccessExpression(factory.createThis(), propName.expression) : factory.createPropertyAccessExpression(factory.createThis(), propName) */ TODO
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
		return !containsUndefinedType(flowType)
	}
	checkInterfaceDeclaration := func(node InterfaceDeclaration) {
		if !checkGrammarModifiers(node) {
			checkGrammarInterfaceDeclaration(node)
		}
		checkTypeParameters(node.typeParameters)
		addLazyDiagnostic(func() {
			checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0)
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			checkTypeParameterListsIdentical(symbol)
			firstInterfaceDecl := getDeclarationOfKind(symbol, SyntaxKindInterfaceDeclaration)
			if node == firstInterfaceDecl {
				type_ := getDeclaredTypeOfSymbol(symbol)
				typeWithThis := getTypeWithThisArgument(type_)
				if checkInheritedPropertiesAreIdentical(type_, node.name) {
					for _, baseType := range getBaseTypes(type_) {
						checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type_.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1)
					}
					checkIndexConstraints(type_, symbol)
				}
			}
			checkObjectTypeForDuplicateDeclarations(node)
		})
		forEach(getInterfaceBaseTypeNodes(node), func(heritageElement /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ any) {
			if !isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression) {
				error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments)
			}
			checkTypeReferenceNode(heritageElement)
		})
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(func() {
			checkTypeForDuplicateIndexSignatures(node)
			registerForUnusedIdentifiersCheck(node)
		})
	}
	checkTypeAliasDeclaration := func(node TypeAliasDeclaration) {
		checkGrammarModifiers(node)
		checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		checkExportsOnMergedDeclarations(node)
		checkTypeParameters(node.typeParameters)
		if node.type_.kind == SyntaxKindIntrinsicKeyword {
			typeParameterCount := length(node.typeParameters)
			valid := /* TODO(Node ConditionalExpression): typeParameterCount === 0 ? node.name.escapedText === "BuiltinIteratorReturn" : typeParameterCount === 1 && intrinsicTypeKinds.has(node.name.escapedText as string) */ TODO
			if !valid {
				error(node.type_, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types)
			}
		} else {
			checkSourceElement(node.type_)
			registerForUnusedIdentifiersCheck(node)
		}
	}
	computeEnumMemberValues := func(node EnumDeclaration) {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsEnumValuesComputed) {
			nodeLinks.flags |= NodeCheckFlagsEnumValuesComputed
			var autoValue *number = 0
			var previous *EnumMember
			for _, member := range node.members {
				result := computeEnumMemberValue(member, autoValue, previous)
				getNodeLinks(member).enumMemberValue = result
				autoValue = /* TODO(Node ConditionalExpression): typeof result.value === "number" ? result.value + 1 : undefined */ TODO
				previous = member
			}
		}
	}
	computeEnumMemberValue := func(member EnumMember, autoValue *number, previous *EnumMember) EvaluatorResult {
		if isComputedNonLiteralName(member.name) {
			error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums)
		} else {
			text := getTextOfPropertyName(member.name)
			if isNumericLiteralName(text) && !isInfinityOrNaNString(text) {
				error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name)
			}
		}
		if member.initializer {
			return computeConstantEnumMemberValue(member)
		}
		if member.parent.flags&NodeFlagsAmbient && !isEnumConst(member.parent) {
			return evaluatorResult(nil)
		}
		if autoValue == nil {
			error(member.name, Diagnostics.Enum_member_must_have_initializer)
			return evaluatorResult(nil)
		}
		if getIsolatedModules(compilerOptions) && previous. /*?*/ initializer {
			prevValue := getEnumMemberValue(previous)
			if !( /* TODO(Node TypeOfExpression): typeof prevValue.value */ TODO == "number" && !prevValue.resolvedOtherFiles) {
				error(member.name, Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled)
			}
		}
		return evaluatorResult(autoValue)
	}
	computeConstantEnumMemberValue := func(member EnumMember) EvaluatorResult {
		isConstEnum := isEnumConst(member.parent)
		initializer := member.initializer
		result := evaluate(initializer, member)
		if result.value != nil {
			if isConstEnum && /* TODO(Node TypeOfExpression): typeof result.value */ TODO == "number" && !isFinite(result.value) {
				error(initializer /* TODO(Node ConditionalExpression): isNaN(result.value) ? Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN : Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value */, TODO)
			} else if getIsolatedModules(compilerOptions) && /* TODO(Node TypeOfExpression): typeof result.value */ TODO == "string" && !result.isSyntacticallyString {
				error(initializer, Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled /* TODO(Node TemplateExpression): `${idText(member.parent.name)}.${getTextOfPropertyName(member.name)}` */, TODO)
			}
		} else if isConstEnum {
			error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions)
		} else if member.parent.flags & NodeFlagsAmbient {
			error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression)
		} else {
			checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values)
		}
		return result
	}
	evaluateEntityNameExpression := func(expr EntityNameExpression, location Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ any {
		symbol := resolveEntityName(expr, SymbolFlagsValue, true)
		if !symbol {
			return evaluatorResult(nil)
		}
		if expr.kind == SyntaxKindIdentifier {
			identifier := expr
			if isInfinityOrNaNString(identifier.escapedText) && (symbol == getGlobalSymbol(identifier.escapedText, SymbolFlagsValue, nil)) {
				return evaluatorResult(+(identifier.escapedText), false)
			}
		}
		if symbol.flags & SymbolFlagsEnumMember {
			// converted from conditional expression
			switch {
			case location:
				return evaluateEnumMember(expr, symbol, location)
			default:
				return getEnumMemberValue(symbol.valueDeclaration)
			}
		}
		if isConstantVariable(symbol) {
			declaration := symbol.valueDeclaration
			if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && (!location || declaration != location && isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
				result := evaluate(declaration.initializer, declaration)
				if location && getSourceFileOfNode(location) != getSourceFileOfNode(declaration) {
					return evaluatorResult(result.value, false, true, true)
				}
				return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles, true)
			}
		}
		return evaluatorResult(nil)
	}
	evaluateElementAccessExpression := func(expr ElementAccessExpression, location Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ any {
		root := expr.expression
		if isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression) {
			rootSymbol := resolveEntityName(root, SymbolFlagsValue, true)
			if rootSymbol && rootSymbol.flags&SymbolFlagsEnum {
				name := escapeLeadingUnderscores(expr.argumentExpression.text)
				member := rootSymbol.exports.get(name)
				if member {
					Debug.assert(getSourceFileOfNode(member.valueDeclaration) == getSourceFileOfNode(rootSymbol.valueDeclaration))
					// converted from conditional expression
					switch {
					case location:
						return evaluateEnumMember(expr, member, location)
					default:
						return getEnumMemberValue(member.valueDeclaration)
					}
				}
			}
		}
		return evaluatorResult(nil)
	}
	evaluateEnumMember := func(expr Expression, symbol Symbol, location Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ any {
		declaration := symbol.valueDeclaration
		if !declaration || declaration == location {
			error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol))
			return evaluatorResult(nil)
		}
		if !isBlockScopedNameDeclaredBeforeUse(declaration, location) {
			error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums)
			return evaluatorResult(0)
		}
		value := getEnumMemberValue(declaration)
		if location.parent != declaration.parent {
			return evaluatorResult(value.value, value.isSyntacticallyString, value.resolvedOtherFiles, true)
		}
		return value
	}
	checkEnumDeclaration := func(node EnumDeclaration) {
		addLazyDiagnostic(func() {
			return checkEnumDeclarationWorker(node)
		})
	}
	checkEnumDeclarationWorker := func(node EnumDeclaration) {
		checkGrammarModifiers(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkExportsOnMergedDeclarations(node)
		node.members.forEach(checkEnumMember)
		computeEnumMemberValues(node)
		enumSymbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(enumSymbol, node.kind)
		if node == firstDeclaration {
			if enumSymbol.declarations && enumSymbol.declarations.length > 1 {
				enumIsConst := isEnumConst(node)
				forEach(enumSymbol.declarations, func(decl /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) {
					if isEnumDeclaration(decl) && isEnumConst(decl) != enumIsConst {
						error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const)
					}
				})
			}
			seenEnumMissingInitialInitializer := false
			forEach(enumSymbol.declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type false | undefined */ any {
				if declaration.kind != SyntaxKindEnumDeclaration {
					return false
				}
				enumDeclaration := declaration
				if !enumDeclaration.members.length {
					return false
				}
				firstEnumMember := enumDeclaration.members[0]
				if !firstEnumMember.initializer {
					if seenEnumMissingInitialInitializer {
						error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element)
					} else {
						seenEnumMissingInitialInitializer = true
					}
				}
			})
		}
	}
	checkEnumMember := func(node EnumMember) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier)
		}
		if node.initializer {
			checkExpression(node.initializer)
		}
	}
	getFirstNonAmbientClassOrFunctionDeclaration := func(symbol Symbol) Declaration {
		declarations := symbol.declarations
		if declarations {
			for _, declaration := range declarations {
				if (declaration.kind == SyntaxKindClassDeclaration || (declaration.kind == SyntaxKindFunctionDeclaration && nodeIsPresent((declaration).body))) && !(declaration.flags & NodeFlagsAmbient) {
					return declaration
				}
			}
		}
		return nil
	}
	inSameLexicalScope := func(node1 Node, node2 Node) /* TODO inferred type boolean */ any {
		container1 := getEnclosingBlockScopeContainer(node1)
		container2 := getEnclosingBlockScopeContainer(node2)
		if isGlobalSourceFile(container1) {
			return isGlobalSourceFile(container2)
		} else if isGlobalSourceFile(container2) {
			return false
		} else {
			return container1 == container2
		}
	}
	checkModuleDeclaration := func(node ModuleDeclaration) {
		if node.body {
			checkSourceElement(node.body)
			if !isGlobalScopeAugmentation(node) {
				registerForUnusedIdentifiersCheck(node)
			}
		}
		addLazyDiagnostic(checkModuleDeclarationDiagnostics)
		checkModuleDeclarationDiagnostics := func() {
			isGlobalAugmentation := isGlobalScopeAugmentation(node)
			inAmbientContext := node.flags & NodeFlagsAmbient
			if isGlobalAugmentation && !inAmbientContext {
				error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context)
			}
			var isAmbientExternalModule bool = isAmbientModule(node)
			contextErrorMessage := /* TODO(Node ConditionalExpression): isAmbientExternalModule ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module */ TODO
			if checkGrammarModuleElementContext(node, contextErrorMessage) {
				return
			}
			if !checkGrammarModifiers(node) {
				if !inAmbientContext && node.name.kind == SyntaxKindStringLiteral {
					grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names)
				}
			}
			if isIdentifier(node.name) {
				checkCollisionsForDeclarationName(node, node.name)
				if !(node.flags & (NodeFlagsNamespace | NodeFlagsGlobalAugmentation)) {
					sourceFile := getSourceFileOfNode(node)
					pos := getNonModifierTokenPosOfNode(node)
					span := getSpanOfTokenAtPosition(sourceFile, pos)
					suggestionDiagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead))
				}
			}
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			if symbol.flags&SymbolFlagsValueModule && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions)) {
				if getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator {
					error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName)
				}
				if symbol.declarations. /*?*/ length > 1 {
					firstNonAmbientClassOrFunc := getFirstNonAmbientClassOrFunctionDeclaration(symbol)
					if firstNonAmbientClassOrFunc {
						if getSourceFileOfNode(node) != getSourceFileOfNode(firstNonAmbientClassOrFunc) {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged)
						} else if node.pos < firstNonAmbientClassOrFunc.pos {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged)
						}
					}
					mergedClass := getDeclarationOfKind(symbol, SyntaxKindClassDeclaration)
					if mergedClass && inSameLexicalScope(node, mergedClass) {
						getNodeLinks(node).flags |= NodeCheckFlagsLexicalModuleMergesWithClass
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(node.parent) == ModuleKindCommonJS {
					exportModifier := node.modifiers. /*?*/ find(func(m /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierLike */ any) /* TODO inferred type boolean */ any {
						return m.kind == SyntaxKindExportKeyword
					})
					if exportModifier {
						error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
				}
			}
			if isAmbientExternalModule {
				if isExternalModuleAugmentation(node) {
					checkBody := isGlobalAugmentation || (getSymbolOfDeclaration(node).flags & SymbolFlagsTransient)
					if checkBody && node.body {
						for _, statement := range node.body.statements {
							checkModuleAugmentationElement(statement, isGlobalAugmentation)
						}
					}
				} else if isGlobalSourceFile(node.parent) {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name)) {
						error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name)
					}
				} else {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else {
						error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces)
					}
				}
			}
		}
	}
	checkModuleAugmentationElement := func(node Node, isGlobalAugmentation bool) {
		switch node.kind {
		case SyntaxKindVariableStatement:
			for _, decl := range (node).declarationList.declarations {
				checkModuleAugmentationElement(decl, isGlobalAugmentation)
			}
			break
		case SyntaxKindExportAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindExportDeclaration:
			grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations)
			break
		case SyntaxKindImportEqualsDeclaration:
			if isInternalModuleImportEqualsDeclaration(node) {
				break
			}
			fallthrough
		case SyntaxKindImportDeclaration:
			grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module)
			break
		case SyntaxKindBindingElement:
			fallthrough // TODO: merge cases
		case SyntaxKindVariableDeclaration:
			name := (node).name
			if isBindingPattern(name) {
				for _, el := range name.elements {
					checkModuleAugmentationElement(el, isGlobalAugmentation)
				}
				break
			}
			fallthrough
		case SyntaxKindClassDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindEnumDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindInterfaceDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindModuleDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeAliasDeclaration:
			if isGlobalAugmentation {
				return
			}
			break
		}
	}
	getFirstNonModuleExportsIdentifier := func(node EntityNameOrEntityNameExpression) Identifier {
		switch node.kind {
		case SyntaxKindIdentifier:
			return node
		case SyntaxKindQualifiedName:
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = node.kind != SyntaxKindIdentifier {
				node = node.left
			}
			return node
		case SyntaxKindPropertyAccessExpression:
			// TODO: refactor do-while loop approximation
			for ok := true; ok; ok = node.kind != SyntaxKindIdentifier {
				if isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name) {
					return node.name
				}
				node = node.expression
			}
			return node
		}
	}
	checkExternalImportOrExportDeclaration := func(node /* TODO(TypeNode UnionType): ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
		moduleName := getExternalModuleName(node)
		if !moduleName || nodeIsMissing(moduleName) {
			return false
		}
		if !isStringLiteral(moduleName) {
			error(moduleName, Diagnostics.String_literal_expected)
			return false
		}
		inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
		if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule {
			error(moduleName /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.ExportDeclaration ? Diagnostics.Export_declarations_are_not_permitted_in_a_namespace : Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module */, TODO)
			return false
		}
		if inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text) {
			if !isTopLevelInExternalModuleAugmentation(node) {
				error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name)
				return false
			}
		}
		if !isImportEqualsDeclaration(node) && node.attributes {
			diagnostic := /* TODO(Node ConditionalExpression): node.attributes.token === SyntaxKind.WithKeyword ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions */ TODO
			hasError := false
			for _, attr := range node.attributes.elements {
				if !isStringLiteral(attr.value) {
					hasError = true
					error(attr.value, diagnostic)
				}
			}
			return !hasError
		}
		return true
	}
	checkModuleExportName := func(name *ModuleExportName, allowStringLiteral /* TODO inferred type boolean */ any /*  = true */) {
		if name == nil || name.kind != SyntaxKindStringLiteral {
			return
		}
		if !allowStringLiteral {
			grammarErrorOnNode(name, Diagnostics.Identifier_expected)
		} else if moduleKind == ModuleKindES2015 || moduleKind == ModuleKindES2020 {
			grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020)
		}
	}
	checkAliasSymbol := func(node AliasDeclarationNode) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target != unknownSymbol {
			symbol = getMergedSymbol(symbol.exportSymbol || symbol)
			if isInJSFile(node) && !(target.flags & SymbolFlagsValue) && !isTypeOnlyImportOrExportDeclaration(node) {
				errorNode := /* TODO(Node ConditionalExpression): isImportOrExportSpecifier(node) ? node.propertyName || node.name : isNamedDeclaration(node) ? node.name : node */ TODO
				Debug.assert(node.kind != SyntaxKindNamespaceExport)
				if node.kind == SyntaxKindExportSpecifier {
					diag := error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files)
					alreadyExportedSymbol := getSourceFileOfNode(node).symbol. /*?*/ exports. /*?*/ get(moduleExportNameTextEscaped(node.propertyName || node.name))
					if alreadyExportedSymbol == target {
						exportingDeclaration := alreadyExportedSymbol.declarations. /*?*/ find(isJSDocNode)
						if exportingDeclaration {
							addRelatedInfo(diag, createDiagnosticForNode(exportingDeclaration, Diagnostics._0_is_automatically_exported_here, unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)))
						}
					}
				} else {
					Debug.assert(node.kind != SyntaxKindVariableDeclaration)
					importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
					moduleSpecifier := /* TODO(Node BinaryExpression): (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
					importedIdentifier := unescapeLeadingUnderscores( /* TODO(Node ConditionalExpression): isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName */ TODO)
					error(errorNode, Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation, importedIdentifier /* TODO(Node TemplateExpression): `import("${moduleSpecifier}").${importedIdentifier}` */, TODO)
				}
				return
			}
			targetFlags := getSymbolFlags(target)
			excludedMeanings := ( /* TODO(Node ConditionalExpression): symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0 */ TODO) | ( /* TODO(Node ConditionalExpression): symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0 */ TODO)
			if targetFlags & excludedMeanings {
				message := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.ExportSpecifier ? Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 : Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0 */ TODO
				error(node, message, symbolToString(symbol))
			} else if node.kind != SyntaxKindExportSpecifier {
				appearsValueyToTranspiler := compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration)
				if appearsValueyToTranspiler && symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue) {
					error(node, Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, symbolToString(symbol), isolatedModulesLikeFlagName)
				}
			}
			if getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) {
				typeOnlyAlias := getTypeOnlyAliasDeclaration(symbol)
				isType := !(targetFlags & SymbolFlagsValue)
				if isType || typeOnlyAlias {
					switch node.kind {
					case SyntaxKindImportClause:
						fallthrough // TODO: merge cases
					case SyntaxKindImportSpecifier:
						fallthrough // TODO: merge cases
					case SyntaxKindImportEqualsDeclaration:
						if compilerOptions.verbatimModuleSyntax {
							Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name")
							message := /* TODO(Node ConditionalExpression): compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node) ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled : isType ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled */ TODO
							name := moduleExportNameTextUnescaped( /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name */ TODO)
							addTypeOnlyDeclarationRelatedInfo(error(node, message, name) /* TODO(Node ConditionalExpression): isType ? undefined : typeOnlyAlias */, TODO, name)
						}
						if isType && node.kind == SyntaxKindImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlagsExport) {
							error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName)
						}
						break
						fallthrough
					case SyntaxKindExportSpecifier:
						if compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) != getSourceFileOfNode(node) {
							name := moduleExportNameTextUnescaped(node.propertyName || node.name)
							diagnostic := /* TODO(Node ConditionalExpression): isType ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName) : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName) */ TODO
							addTypeOnlyDeclarationRelatedInfo(diagnostic /* TODO(Node ConditionalExpression): isType ? undefined : typeOnlyAlias */, TODO, name)
							break
						}
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.kind != SyntaxKindImportEqualsDeclaration && !isInJSFile(node) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
				} else if moduleKind == ModuleKindPreserve && node.kind != SyntaxKindImportEqualsDeclaration && node.kind != SyntaxKindVariableDeclaration && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve)
				}
				if compilerOptions.verbatimModuleSyntax && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) && targetFlags&SymbolFlagsConstEnum {
					constEnumDeclaration := target.valueDeclaration
					redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
					if constEnumDeclaration.flags&NodeFlagsAmbient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
						error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
					}
				}
			}
			if isImportSpecifier(node) {
				targetSymbol := resolveAliasWithDeprecationCheck(symbol, node)
				if isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations {
					addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName)
				}
			}
		}
	}
	resolveAliasWithDeprecationCheck := func(symbol Symbol, location Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		if !(symbol.flags & SymbolFlagsAlias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol) {
			return symbol
		}
		targetSymbol := resolveAlias(symbol)
		if targetSymbol == unknownSymbol {
			return targetSymbol
		}
		for symbol.flags & SymbolFlagsAlias {
			target := getImmediateAliasedSymbol(symbol)
			if target {
				if target == targetSymbol {
					break
				}
				if target.declarations && length(target.declarations) {
					if isDeprecatedSymbol(target) {
						addDeprecatedSuggestion(location, target.declarations, target.escapedName)
						break
					} else {
						if symbol == targetSymbol {
							break
						}
						symbol = target
					}
				}
			} else {
				break
			}
		}
		return targetSymbol
	}
	checkImportBinding := func(node /* TODO(TypeNode UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
		checkCollisionsForDeclarationName(node, node.name)
		checkAliasSymbol(node)
		if node.kind == SyntaxKindImportSpecifier {
			checkModuleExportName(node.propertyName)
			if moduleExportNameIsDefault(node.propertyName || node.name) && getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkImportAttributes := func(declaration /* TODO(TypeNode UnionType): ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) /* TODO inferred type boolean | undefined */ any {
		node := declaration.attributes
		if node {
			importAttributesType := getGlobalImportAttributesType(true)
			if importAttributesType != emptyObjectType {
				checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, TypeFlagsUndefined), node)
			}
			validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
			override := getResolutionModeOverride(node /* TODO(Node ConditionalExpression): validForTypeAttributes ? grammarErrorOnNode : undefined */, TODO)
			isImportAttributes := declaration.attributes.token == SyntaxKindWithKeyword
			if validForTypeAttributes && override {
				return
			}
			mode := (moduleKind == ModuleKindNodeNext) && declaration.moduleSpecifier && getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier)
			if mode != ModuleKindESNext && moduleKind != ModuleKindESNext && moduleKind != ModuleKindPreserve {
				message := /* TODO(Node ConditionalExpression): isImportAttributes ? moduleKind === ModuleKind.NodeNext ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls : Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve : moduleKind === ModuleKind.NodeNext ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve */ TODO
				return grammarErrorOnNode(node, message)
			}
			isTypeOnly := isJSDocImportTag(declaration) || ( /* TODO(Node ConditionalExpression): isImportDeclaration(declaration) ? declaration.importClause?.isTypeOnly : declaration.isTypeOnly */ TODO)
			if isTypeOnly {
				return grammarErrorOnNode(node /* TODO(Node ConditionalExpression): isImportAttributes ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports */, TODO)
			}
			if override {
				return grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports)
			}
		}
	}
	checkImportAttribute := func(node ImportAttribute) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		return getRegularTypeOfLiteralType(checkExpressionCached(node.value))
	}
	checkImportDeclaration := func(node ImportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(Node ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && node.modifiers {
			grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers)
		}
		if checkExternalImportOrExportDeclaration(node) {
			importClause := node.importClause
			if importClause && !checkGrammarImportClause(importClause) {
				if importClause.name {
					checkImportBinding(importClause)
				}
				if importClause.namedBindings {
					if importClause.namedBindings.kind == SyntaxKindNamespaceImport {
						checkImportBinding(importClause.namedBindings)
						if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						moduleExisted := resolveExternalModuleName(node, node.moduleSpecifier)
						if moduleExisted {
							forEach(importClause.namedBindings.elements, checkImportBinding)
						}
					}
				}
			} else if noUncheckedSideEffectImports && !importClause {
				resolveExternalModuleName(node, node.moduleSpecifier)
			}
		}
		checkImportAttributes(node)
	}
	checkImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(Node ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		checkGrammarModifiers(node)
		if isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node) {
			checkImportBinding(node)
			markLinkedReferences(node, ReferenceHintExportImportEquals)
			if node.moduleReference.kind != SyntaxKindExternalModuleReference {
				target := resolveAlias(getSymbolOfDeclaration(node))
				if target != unknownSymbol {
					targetFlags := getSymbolFlags(target)
					if targetFlags & SymbolFlagsValue {
						moduleName := getFirstIdentifier(node.moduleReference)
						if !(resolveEntityName(moduleName, SymbolFlagsValue|SymbolFlagsNamespace).flags & SymbolFlagsNamespace) {
							error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName))
						}
					}
					if targetFlags & SymbolFlagsType {
						checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0)
					}
				}
				if node.isTypeOnly {
					grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type)
				}
			} else {
				if ModuleKindES2015 <= moduleKind && moduleKind <= ModuleKindESNext && !node.isTypeOnly && !(node.flags & NodeFlagsAmbient) {
					grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead)
				}
			}
		}
	}
	checkExportDeclaration := func(node ExportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(Node ConditionalExpression): isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && hasSyntacticModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers)
		}
		checkGrammarExportDeclaration(node)
		if !node.moduleSpecifier || checkExternalImportOrExportDeclaration(node) {
			if node.exportClause && !isNamespaceExport(node.exportClause) {
				forEach(node.exportClause.elements, checkExportSpecifier)
				inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
				inAmbientNamespaceDeclaration := !inAmbientExternalModule && node.parent.kind == SyntaxKindModuleBlock && !node.moduleSpecifier && node.flags&NodeFlagsAmbient
				if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration {
					error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace)
				}
			} else {
				moduleSymbol := resolveExternalModuleName(node, node.moduleSpecifier)
				if moduleSymbol && hasExportAssignmentSymbol(moduleSymbol) {
					error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol))
				} else if node.exportClause {
					checkAliasSymbol(node.exportClause)
					checkModuleExportName(node.exportClause.name)
				}
				if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
					if node.exportClause {
						if getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						checkExternalEmitHelpers(node, ExternalEmitHelpersExportStar)
					}
				}
			}
		}
		checkImportAttributes(node)
	}
	checkGrammarExportDeclaration := func(node ExportDeclaration) bool {
		if node.isTypeOnly && node.exportClause. /*?*/ kind == SyntaxKindNamedExports {
			return checkGrammarNamedImportsOrExports(node.exportClause)
		}
		return false
	}
	checkGrammarModuleElementContext := func(node Statement, errorMessage DiagnosticMessage) bool {
		isInAppropriateContext := node.parent.kind == SyntaxKindSourceFile || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindModuleDeclaration
		if !isInAppropriateContext {
			grammarErrorOnFirstToken(node, errorMessage)
		}
		return !isInAppropriateContext
	}
	checkExportSpecifier := func(node ExportSpecifier) {
		checkAliasSymbol(node)
		hasModuleSpecifier := node.parent.parent.moduleSpecifier != nil
		checkModuleExportName(node.propertyName, hasModuleSpecifier)
		checkModuleExportName(node.name)
		if getEmitDeclarations(compilerOptions) {
			collectLinkedAliases(node.propertyName || node.name, true)
		}
		if !hasModuleSpecifier {
			exportedName := node.propertyName || node.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0]))) {
				error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName))
			} else {
				markLinkedReferences(node, ReferenceHintExportSpecifier)
			}
		} else {
			if getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && moduleExportNameIsDefault(node.propertyName || node.name) {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkExportAssignment := func(node ExportAssignment) {
		illegalContextMessage := /* TODO(Node ConditionalExpression): node.isExportEquals ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration */ TODO
		if checkGrammarModuleElementContext(node, illegalContextMessage) {
			return
		}
		container := /* TODO(Node ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent as ModuleDeclaration */ TODO
		if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
			if node.isExportEquals {
				error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace)
			} else {
				error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
			}
			return
		}
		if !checkGrammarModifiers(node) && hasEffectiveModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers)
		}
		typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
		if typeAnnotationNode {
			checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression)
		}
		isIllegalExportDefaultInCJS := !node.isExportEquals && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS
		if node.expression.kind == SyntaxKindIdentifier {
			id := node.expression
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll, true, true, node))
			if sym {
				markLinkedReferences(node, ReferenceHintExportAssignment)
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(sym, SymbolFlagsValue)
				if getSymbolFlags(sym) & SymbolFlagsValue {
					checkExpressionCached(id)
					if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration {
						error(id /* TODO(Node ConditionalExpression): node.isExportEquals ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration */, TODO, idText(id))
					}
				} else if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax {
					error(id /* TODO(Node ConditionalExpression): node.isExportEquals ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type */, TODO, idText(id))
				}
				if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && getIsolatedModules(compilerOptions) && !(sym.flags & SymbolFlagsValue) {
					nonLocalMeanings := getSymbolFlags(sym, false, true)
					if sym.flags&SymbolFlagsAlias && nonLocalMeanings&SymbolFlagsType && !(nonLocalMeanings & SymbolFlagsValue) && (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node)) {
						error(id /* TODO(Node ConditionalExpression): node.isExportEquals ? Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported : Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName)
					} else if typeOnlyDeclaration && getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node) {
						addTypeOnlyDeclarationRelatedInfo(error(id /* TODO(Node ConditionalExpression): node.isExportEquals ? Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName), typeOnlyDeclaration, idText(id))
					}
				}
			} else {
				checkExpressionCached(id)
			}
			if getEmitDeclarations(compilerOptions) {
				collectLinkedAliases(id, true)
			}
		} else {
			checkExpressionCached(node.expression)
		}
		if isIllegalExportDefaultInCJS {
			error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		checkExternalModuleExports(container)
		if (node.flags & NodeFlagsAmbient) && !isEntityNameExpression(node.expression) {
			grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context)
		}
		if node.isExportEquals {
			if moduleKind >= ModuleKindES2015 && moduleKind != ModuleKindPreserve && ((node.flags&NodeFlagsAmbient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) == ModuleKindESNext) || (!(node.flags & NodeFlagsAmbient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) != ModuleKindCommonJS)) {
				grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead)
			} else if moduleKind == ModuleKindSystem && !(node.flags & NodeFlagsAmbient) {
				grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system)
			}
		}
	}
	hasExportedMembers := func(moduleSymbol Symbol) /* TODO inferred type boolean | undefined */ any {
		return forEachEntry(moduleSymbol.exports, func(_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) /* TODO inferred type boolean */ any {
			return id != "export="
		})
	}
	checkExternalModuleExports := func(node /* TODO(TypeNode UnionType): SourceFile | ModuleDeclaration */ any) {
		moduleSymbol := getSymbolOfDeclaration(node)
		links := getSymbolLinks(moduleSymbol)
		if !links.exportsChecked {
			exportEqualsSymbol := moduleSymbol.exports.get("export=")
			if exportEqualsSymbol && hasExportedMembers(moduleSymbol) {
				declaration := getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration
				if declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) {
					error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements)
				}
			}
			exports := getExportsOfModule(moduleSymbol)
			if exports {
				exports.forEach(func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
					if id == "__export" {
						return
					}
					if flags & (SymbolFlagsNamespace | SymbolFlagsEnum) {
						return
					}
					exportedDeclarationsCount := countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)))
					if flags&SymbolFlagsTypeAlias && exportedDeclarationsCount <= 2 {
						return
					}
					if exportedDeclarationsCount > 1 {
						if !isDuplicatedCommonJSExport(declarations) {
							for _, declaration := range declarations {
								if isNotOverload(declaration) {
									diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)))
								}
							}
						}
					}
				})
			}
			links.exportsChecked = true
		}
	}
	isDuplicatedCommonJSExport := func(declarations *[]Declaration) /* TODO inferred type boolean | undefined */ any {
		return declarations && declarations.length > 1 && declarations.every(func(d /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
			return isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression))
		})
	}
	checkSourceElement := func(node Node) {
		if node {
			saveCurrentNode := currentNode
			currentNode = node
			instantiationCount = 0
			checkSourceElementWorker(node)
			currentNode = saveCurrentNode
		}
	}
	checkSourceElementWorker := func(node Node) {
		if getNodeCheckFlags(node) & NodeCheckFlagsPartiallyTypeChecked {
			return
		}
		if canHaveJSDoc(node) {
			forEach(node.jsDoc, func(TODO_IDENTIFIER /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDoc */ any) {
				checkJSDocCommentWorker(comment)
				forEach(tags, func(tag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocTag */ any) {
					checkJSDocCommentWorker(tag.comment)
					if isInJSFile(node) {
						checkSourceElement(tag)
					}
				})
			})
		}
		kind := node.kind
		if cancellationToken {
			switch kind {
			case SyntaxKindModuleDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindFunctionDeclaration:
				cancellationToken.throwIfCancellationRequested()
			}
		}
		if kind >= SyntaxKindFirstStatement && kind <= SyntaxKindLastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode) {
			errorOrSuggestion(compilerOptions.allowUnreachableCode == false, node, Diagnostics.Unreachable_code_detected)
		}
		switch kind {
		case SyntaxKindTypeParameter:
			return checkTypeParameter(node)
		case SyntaxKindParameter:
			return checkParameter(node)
		case SyntaxKindPropertyDeclaration:
			return checkPropertyDeclaration(node)
		case SyntaxKindPropertySignature:
			return checkPropertySignature(node)
		case SyntaxKindConstructorType:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionType:
			fallthrough // TODO: merge cases
		case SyntaxKindCallSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindConstructSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindIndexSignature:
			return checkSignatureDeclaration(node)
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			return checkMethodDeclaration(node)
		case SyntaxKindClassStaticBlockDeclaration:
			return checkClassStaticBlockDeclaration(node)
		case SyntaxKindConstructor:
			return checkConstructorDeclaration(node)
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			return checkAccessorDeclaration(node)
		case SyntaxKindTypeReference:
			return checkTypeReferenceNode(node)
		case SyntaxKindTypePredicate:
			return checkTypePredicate(node)
		case SyntaxKindTypeQuery:
			return checkTypeQuery(node)
		case SyntaxKindTypeLiteral:
			return checkTypeLiteral(node)
		case SyntaxKindArrayType:
			return checkArrayType(node)
		case SyntaxKindTupleType:
			return checkTupleType(node)
		case SyntaxKindUnionType:
			fallthrough // TODO: merge cases
		case SyntaxKindIntersectionType:
			return checkUnionOrIntersectionType(node)
		case SyntaxKindParenthesizedType:
			fallthrough // TODO: merge cases
		case SyntaxKindOptionalType:
			fallthrough // TODO: merge cases
		case SyntaxKindRestType:
			return checkSourceElement((node).type_)
		case SyntaxKindThisType:
			return checkThisType(node)
		case SyntaxKindTypeOperator:
			return checkTypeOperator(node)
		case SyntaxKindConditionalType:
			return checkConditionalType(node)
		case SyntaxKindInferType:
			return checkInferType(node)
		case SyntaxKindTemplateLiteralType:
			return checkTemplateLiteralType(node)
		case SyntaxKindImportType:
			return checkImportType(node)
		case SyntaxKindNamedTupleMember:
			return checkNamedTupleMember(node)
		case SyntaxKindJSDocAugmentsTag:
			return checkJSDocAugmentsTag(node)
		case SyntaxKindJSDocImplementsTag:
			return checkJSDocImplementsTag(node)
		case SyntaxKindJSDocTypedefTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocCallbackTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocEnumTag:
			return checkJSDocTypeAliasTag(node)
		case SyntaxKindJSDocTemplateTag:
			return checkJSDocTemplateTag(node)
		case SyntaxKindJSDocTypeTag:
			return checkJSDocTypeTag(node)
		case SyntaxKindJSDocLink:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocLinkCode:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocLinkPlain:
			return checkJSDocLinkLikeTag(node)
		case SyntaxKindJSDocParameterTag:
			return checkJSDocParameterTag(node)
		case SyntaxKindJSDocPropertyTag:
			return checkJSDocPropertyTag(node)
		case SyntaxKindJSDocFunctionType:
			checkJSDocFunctionType(node)
			fallthrough
		case SyntaxKindJSDocNonNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocNullableType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocAllType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocUnknownType:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocTypeLiteral:
			checkJSDocTypeIsInJsFile(node)
			forEachChild(node, checkSourceElement)
			return
		case SyntaxKindJSDocVariadicType:
			checkJSDocVariadicType(node)
			return
		case SyntaxKindJSDocTypeExpression:
			return checkSourceElement((node).type_)
		case SyntaxKindJSDocPublicTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocProtectedTag:
			fallthrough // TODO: merge cases
		case SyntaxKindJSDocPrivateTag:
			return checkJSDocAccessibilityModifiers(node)
		case SyntaxKindJSDocSatisfiesTag:
			return checkJSDocSatisfiesTag(node)
		case SyntaxKindJSDocThisTag:
			return checkJSDocThisTag(node)
		case SyntaxKindJSDocImportTag:
			return checkJSDocImportTag(node)
		case SyntaxKindIndexedAccessType:
			return checkIndexedAccessType(node)
		case SyntaxKindMappedType:
			return checkMappedType(node)
		case SyntaxKindFunctionDeclaration:
			return checkFunctionDeclaration(node)
		case SyntaxKindBlock:
			fallthrough // TODO: merge cases
		case SyntaxKindModuleBlock:
			return checkBlock(node)
		case SyntaxKindVariableStatement:
			return checkVariableStatement(node)
		case SyntaxKindExpressionStatement:
			return checkExpressionStatement(node)
		case SyntaxKindIfStatement:
			return checkIfStatement(node)
		case SyntaxKindDoStatement:
			return checkDoStatement(node)
		case SyntaxKindWhileStatement:
			return checkWhileStatement(node)
		case SyntaxKindForStatement:
			return checkForStatement(node)
		case SyntaxKindForInStatement:
			return checkForInStatement(node)
		case SyntaxKindForOfStatement:
			return checkForOfStatement(node)
		case SyntaxKindContinueStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindBreakStatement:
			return checkBreakOrContinueStatement(node)
		case SyntaxKindReturnStatement:
			return checkReturnStatement(node)
		case SyntaxKindWithStatement:
			return checkWithStatement(node)
		case SyntaxKindSwitchStatement:
			return checkSwitchStatement(node)
		case SyntaxKindLabeledStatement:
			return checkLabeledStatement(node)
		case SyntaxKindThrowStatement:
			return checkThrowStatement(node)
		case SyntaxKindTryStatement:
			return checkTryStatement(node)
		case SyntaxKindVariableDeclaration:
			return checkVariableDeclaration(node)
		case SyntaxKindBindingElement:
			return checkBindingElement(node)
		case SyntaxKindClassDeclaration:
			return checkClassDeclaration(node)
		case SyntaxKindInterfaceDeclaration:
			return checkInterfaceDeclaration(node)
		case SyntaxKindTypeAliasDeclaration:
			return checkTypeAliasDeclaration(node)
		case SyntaxKindEnumDeclaration:
			return checkEnumDeclaration(node)
		case SyntaxKindModuleDeclaration:
			return checkModuleDeclaration(node)
		case SyntaxKindImportDeclaration:
			return checkImportDeclaration(node)
		case SyntaxKindImportEqualsDeclaration:
			return checkImportEqualsDeclaration(node)
		case SyntaxKindExportDeclaration:
			return checkExportDeclaration(node)
		case SyntaxKindExportAssignment:
			return checkExportAssignment(node)
		case SyntaxKindEmptyStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindDebuggerStatement:
			checkGrammarStatementInAmbientContext(node)
			return
		case SyntaxKindMissingDeclaration:
			return checkMissingDeclaration(node)
		}
	}
	checkJSDocCommentWorker := func(node /* TODO(TypeNode UnionType): string | readonly JSDocComment[] | undefined */ any) {
		if isArray(node) {
			forEach(node, func(tag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocComment */ any) {
				if isJSDocLinkLike(tag) {
					checkSourceElement(tag)
				}
			})
		}
	}
	checkJSDocTypeIsInJsFile := func(node Node) {
		if !isInJSFile(node) {
			if isJSDocNonNullableType(node) || isJSDocNullableType(node) {
				token := tokenToString( /* TODO(Node ConditionalExpression): isJSDocNonNullableType(node) ? SyntaxKind.ExclamationToken : SyntaxKind.QuestionToken */ TODO)
				diagnostic := /* TODO(Node ConditionalExpression): node.postfix ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 */ TODO
				typeNode := node.type_
				type_ := getTypeFromTypeNode(typeNode)
				grammarErrorOnNode(node, diagnostic, token, typeToString( /* TODO(Node ConditionalExpression): isJSDocNullableType(node) && !(type === neverType || type === voidType) ? getUnionType(append([type, undefinedType], node.postfix ? undefined : nullType)) : type */ TODO))
			} else {
				grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
	}
	checkJSDocVariadicType := func(node JSDocVariadicType) {
		checkJSDocTypeIsInJsFile(node)
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			if last(parent.parent.parameters) != parent {
				error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
			}
			return
		}
		if !isJSDocTypeExpression(parent) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
		}
		paramTag := node.parent.parent
		if !isJSDocParameterTag(paramTag) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
			return
		}
		param := getParameterSymbolFromJSDoc(paramTag)
		if !param {
			return
		}
		host := getHostSignatureFromJSDoc(paramTag)
		if !host || last(host.parameters).symbol != param {
			error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
		}
	}
	getTypeFromJSDocVariadicType := func(node JSDocVariadicType) Type {
		type_ := getTypeFromTypeNode(node.type_)
		TODO_IDENTIFIER := node
		paramTag := node.parent.parent
		if isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag) {
			host := getHostSignatureFromJSDoc(paramTag)
			isCallbackTag := isJSDocCallbackTag(paramTag.parent.parent)
			if host || isCallbackTag {
				lastParamDeclaration := /* TODO(Node ConditionalExpression): isCallbackTag ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters) : lastOrUndefined(host!.parameters) */ TODO
				symbol := getParameterSymbolFromJSDoc(paramTag)
				if !lastParamDeclaration || symbol && lastParamDeclaration.symbol == symbol && isRestParameter(lastParamDeclaration) {
					return createArrayType(type_)
				}
			}
		}
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			return createArrayType(type_)
		}
		return addOptionality(type_)
	}
	checkNodeDeferred := func(node Node) {
		enclosingFile := getSourceFileOfNode(node)
		links := getNodeLinks(enclosingFile)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			/* TODO(Node BinaryExpression): links.deferredNodes ||= new Set() */ TODO
			links.deferredNodes.add(node)
		} else {
			Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.")
		}
	}
	checkDeferredNodes := func(context SourceFile) {
		links := getNodeLinks(context)
		if links.deferredNodes {
			links.deferredNodes.forEach(checkDeferredNode)
		}
		links.deferredNodes = nil
	}
	checkDeferredNode := func(node Node) {
		tracing. /*?*/ push(tracing.Phase.Check, "checkDeferredNode" /* TODO(Node ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		switch node.kind {
		case SyntaxKindCallExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindNewExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindTaggedTemplateExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindDecorator:
			fallthrough // TODO: merge cases
		case SyntaxKindJsxOpeningElement:
			resolveUntypedCall(node)
			break
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			checkFunctionExpressionOrObjectLiteralMethodDeferred(node)
			break
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			checkAccessorDeclaration(node)
			break
		case SyntaxKindClassExpression:
			checkClassExpressionDeferred(node)
			break
		case SyntaxKindTypeParameter:
			checkTypeParameterDeferred(node)
			break
		case SyntaxKindJsxSelfClosingElement:
			checkJsxSelfClosingElementDeferred(node)
			break
		case SyntaxKindJsxElement:
			checkJsxElementDeferred(node)
			break
		case SyntaxKindTypeAssertionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindAsExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindParenthesizedExpression:
			checkAssertionDeferred(node)
			break
		case SyntaxKindVoidExpression:
			checkExpression((node).expression)
			break
		case SyntaxKindBinaryExpression:
			if isInstanceOfExpression(node) {
				resolveUntypedCall(node)
			}
			break
		}
		currentNode = saveCurrentNode
		tracing. /*?*/ pop()
	}
	checkSourceFile := func(node SourceFile, nodesToCheck *[]Node) {
		tracing. /*?*/ push(tracing.Phase.Check /* TODO(Node ConditionalExpression): nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile" */, TODO /* TODO(Node ObjectLiteralExpression): { path: node.path } */, TODO, true)
		beforeMark := /* TODO(Node ConditionalExpression): nodesToCheck ? "beforeCheckNodes" : "beforeCheck" */ TODO
		afterMark := /* TODO(Node ConditionalExpression): nodesToCheck ? "afterCheckNodes" : "afterCheck" */ TODO
		performance.mark(beforeMark)
		/* TODO(Node ConditionalExpression): nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node) */ TODO
		performance.mark(afterMark)
		performance.measure("Check", beforeMark, afterMark)
		tracing. /*?*/ pop()
	}
	unusedIsError := func(kind UnusedKind, isAmbient bool) bool {
		if isAmbient {
			return false
		}
		switch kind {
		case UnusedKindLocal:
			return !!compilerOptions.noUnusedLocals
		case UnusedKindParameter:
			return !!compilerOptions.noUnusedParameters
		default:
			return Debug.assertNever(kind)
		}
	}
	getPotentiallyUnusedIdentifiers := func(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
		return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray
	}
	checkSourceFileWorker := func(node SourceFile) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(node, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(node)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			if links.flags & NodeCheckFlagsPartiallyTypeChecked {
				potentialThisCollisions = links.potentialThisCollisions
				potentialNewTargetCollisions = links.potentialNewTargetCollisions
				potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions
				potentialReflectCollisions = links.potentialReflectCollisions
				potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes
			}
			forEach(node.statements, checkSourceElement)
			checkSourceElement(node.endOfFileToken)
			checkDeferredNodes(node)
			if isExternalOrCommonJsModule(node) {
				registerForUnusedIdentifiersCheck(node)
			}
			addLazyDiagnostic(func() {
				if !node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters) {
					checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), func(containingNode /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any, kind /* TODO inferred type UnusedKind */ any, diag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any) {
						if !containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
							diagnostics.add(diag)
						}
					})
				}
				if !node.isDeclarationFile {
					checkPotentialUncheckedRenamedBindingElementsInTypes()
				}
			})
			if isExternalOrCommonJsModule(node) {
				checkExternalModuleExports(node)
			}
			if potentialThisCollisions.length {
				forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope)
				clear(potentialThisCollisions)
			}
			if potentialNewTargetCollisions.length {
				forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope)
				clear(potentialNewTargetCollisions)
			}
			if potentialWeakMapSetCollisions.length {
				forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision)
				clear(potentialWeakMapSetCollisions)
			}
			if potentialReflectCollisions.length {
				forEach(potentialReflectCollisions, checkReflectCollision)
				clear(potentialReflectCollisions)
			}
			links.flags |= NodeCheckFlagsTypeChecked
		}
	}
	checkSourceFileNodesWorker := func(file SourceFile, nodes []Node) {
		links := getNodeLinks(file)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(file, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(file)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			forEach(nodes, checkSourceElement)
			checkDeferredNodes(file)
			(links.potentialThisCollisions || ( /* TODO(Node BinaryExpression): links.potentialThisCollisions = [] */ TODO)).push(potentialThisCollisions...)
			(links.potentialNewTargetCollisions || ( /* TODO(Node BinaryExpression): links.potentialNewTargetCollisions = [] */ TODO)).push(potentialNewTargetCollisions...)
			(links.potentialWeakMapSetCollisions || ( /* TODO(Node BinaryExpression): links.potentialWeakMapSetCollisions = [] */ TODO)).push(potentialWeakMapSetCollisions...)
			(links.potentialReflectCollisions || ( /* TODO(Node BinaryExpression): links.potentialReflectCollisions = [] */ TODO)).push(potentialReflectCollisions...)
			(links.potentialUnusedRenamedBindingElementsInTypes || ( /* TODO(Node BinaryExpression): links.potentialUnusedRenamedBindingElementsInTypes = [] */ TODO)).push(potentialUnusedRenamedBindingElementsInTypes...)
			links.flags |= NodeCheckFlagsPartiallyTypeChecked
			for _, node := range nodes {
				nodeLinks := getNodeLinks(node)
				nodeLinks.flags |= NodeCheckFlagsPartiallyTypeChecked
			}
		}
	}
	getDiagnostics := func(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
		/* TODO(Node TryStatement): try { // Record the cancellation token so it can be checked later on during checkSourceElement. // Do this in a finally block so we can ensure that it gets reset back to nothing after // this call is done. cancellationToken = ct; return getDiagnosticsWorker(sourceFile, nodesToCheck); } finally { cancellationToken = undefined; } */
	}
	ensurePendingDiagnosticWorkComplete := func() {
		for _, cb := range deferredDiagnosticsCallbacks {
			cb()
		}
		deferredDiagnosticsCallbacks = [] /* TODO inferred type never */ any{}
	}
	checkSourceFileWithEagerDiagnostics := func(sourceFile SourceFile, nodesToCheck []Node) {
		ensurePendingDiagnosticWorkComplete()
		oldAddLazyDiagnostics := addLazyDiagnostic
		addLazyDiagnostic = func(cb /* TODO inferred type () => void */ any) {
			return cb()
		}
		checkSourceFile(sourceFile, nodesToCheck)
		addLazyDiagnostic = oldAddLazyDiagnostics
	}
	getDiagnosticsWorker := func(sourceFile SourceFile, nodesToCheck *[]Node) []Diagnostic {
		if sourceFile {
			ensurePendingDiagnosticWorkComplete()
			previousGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			previousGlobalDiagnosticsSize := previousGlobalDiagnostics.length
			checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck)
			semanticDiagnostics := diagnostics.getDiagnostics(sourceFile.fileName)
			if nodesToCheck {
				return semanticDiagnostics
			}
			currentGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			if currentGlobalDiagnostics != previousGlobalDiagnostics {
				deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
				return concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
			} else if previousGlobalDiagnosticsSize == 0 && currentGlobalDiagnostics.length > 0 {
				return concatenate(currentGlobalDiagnostics, semanticDiagnostics)
			}
			return semanticDiagnostics
		}
		forEach(host.getSourceFiles(), func(file /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile */ any) {
			return checkSourceFileWithEagerDiagnostics(file)
		})
		return diagnostics.getDiagnostics()
	}
	getGlobalDiagnostics := func() []Diagnostic {
		ensurePendingDiagnosticWorkComplete()
		return diagnostics.getGlobalDiagnostics()
	}
	getSymbolsInScope := func(location Node, meaning SymbolFlags) []Symbol {
		if location.flags & NodeFlagsInWithStatement {
			return [] /* TODO inferred type never */ any{}
		}
		symbols := createSymbolTable()
		isStaticSymbol := false
		populateSymbols()
		symbols.delete(InternalSymbolNameThis)
		return symbolsToArray(symbols)
		populateSymbols := func() {
			for location {
				if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
					copySymbols(location.locals, meaning)
				}
				switch location.kind {
				case SyntaxKindSourceFile:
					if !isExternalModule(location) {
						break
					}
					fallthrough
				case SyntaxKindModuleDeclaration:
					copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location).exports, meaning&SymbolFlagsModuleMember)
					break
				case SyntaxKindEnumDeclaration:
					copySymbols(getSymbolOfDeclaration(location).exports, meaning&SymbolFlagsEnumMember)
					break
				case SyntaxKindClassExpression:
					className := (location).name
					if className {
						copySymbol((location).symbol, meaning)
					}
					fallthrough
				case SyntaxKindClassDeclaration:
					fallthrough // TODO: merge cases
				case SyntaxKindInterfaceDeclaration:
					if !isStaticSymbol {
						copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location)), meaning&SymbolFlagsType)
					}
					break
				case SyntaxKindFunctionExpression:
					funcName := (location).name
					if funcName {
						copySymbol((location).symbol, meaning)
					}
					break
				}
				if introducesArgumentsExoticObject(location) {
					copySymbol(argumentsSymbol, meaning)
				}
				isStaticSymbol = isStatic(location)
				location = location.parent
			}
			copySymbols(globals, meaning)
		}
		copySymbol := func(symbol Symbol, meaning SymbolFlags) {
			if getCombinedLocalAndExportSymbolFlags(symbol) & meaning {
				id := symbol.escapedName
				if !symbols.has(id) {
					symbols.set(id, symbol)
				}
			}
		}
		copySymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
					copySymbol(symbol, meaning)
				})
			}
		}
		copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
					if !getDeclarationOfKind(symbol, SyntaxKindExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKindNamespaceExport) && symbol.escapedName != InternalSymbolNameDefault {
						copySymbol(symbol, meaning)
					}
				})
			}
		}
	}
	isTypeDeclarationName := func(name Node) bool {
		return name.kind == SyntaxKindIdentifier && isTypeDeclaration(name.parent) && getNameOfDeclaration(name.parent) == name
	}
	isTypeReferenceIdentifier := func(node EntityName) bool {
		for node.parent.kind == SyntaxKindQualifiedName {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindTypeReference
	}
	isInNameOfExpressionWithTypeArguments := func(node Node) bool {
		for node.parent.kind == SyntaxKindPropertyAccessExpression {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindExpressionWithTypeArguments
	}
	forEachEnclosingClass := func(node Node, callback func(node ClassLikeDeclaration) *T) *T {
		var result *T
		containingClass := getContainingClass(node)
		for containingClass {
			if /* TODO(Node BinaryExpression): result = callback(containingClass) */ TODO {
				break
			}
			containingClass = getContainingClass(containingClass)
		}
		return result
	}
	isNodeUsedDuringClassInitialization := func(node Node) /* TODO inferred type boolean */ any {
		return !!findAncestor(node, func(element /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean | "quit" */ any {
			if isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element) {
				return true
			} else if isClassLike(element) || isFunctionLikeDeclaration(element) {
				return "quit"
			}
			return false
		})
	}
	isNodeWithinClass := func(node Node, classDeclaration ClassLikeDeclaration) /* TODO inferred type boolean */ any {
		return !!forEachEnclosingClass(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration */ any) /* TODO inferred type boolean */ any {
			return n == classDeclaration
		})
	}
	getLeftSideOfImportEqualsOrExportAssignment := func(nodeOnRightSide EntityName) /* TODO(TypeNode UnionType): ImportEqualsDeclaration | ExportAssignment | undefined */ any {
		for nodeOnRightSide.parent.kind == SyntaxKindQualifiedName {
			nodeOnRightSide = nodeOnRightSide.parent
		}
		if nodeOnRightSide.parent.kind == SyntaxKindImportEqualsDeclaration {
			// converted from conditional expression
			switch {
			case (nodeOnRightSide.parent).moduleReference == nodeOnRightSide:
				return nodeOnRightSide.parent
			default:
				return nil
			}
		}
		if nodeOnRightSide.parent.kind == SyntaxKindExportAssignment {
			// converted from conditional expression
			switch {
			case (nodeOnRightSide.parent).expression == nodeOnRightSide:
				return nodeOnRightSide.parent
			default:
				return nil
			}
		}
		return nil
	}
	isInRightSideOfImportOrExportAssignment := func(node EntityName) /* TODO inferred type boolean */ any {
		return getLeftSideOfImportEqualsOrExportAssignment(node) != nil
	}
	getSpecialPropertyAssignmentSymbolFromEntityName := func(entityName /* TODO(TypeNode UnionType): EntityName | PropertyAccessExpression */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		specialPropertyAssignmentKind := getAssignmentDeclarationKind(entityName.parent.parent)
		switch specialPropertyAssignmentKind {
		case AssignmentDeclarationKindExportsProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindPrototypeProperty:
			return getSymbolOfNode(entityName.parent)
		case AssignmentDeclarationKindProperty:
			if isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) == entityName {
				return nil
			}
			fallthrough
		case AssignmentDeclarationKindThisProperty:
			fallthrough // TODO: merge cases
		case AssignmentDeclarationKindModuleExports:
			return getSymbolOfDeclaration(entityName.parent.parent)
		}
	}
	isImportTypeQualifierPart := func(node EntityName) *ImportTypeNode {
		parent := node.parent
		for isQualifiedName(parent) {
			node = parent
			parent = parent.parent
		}
		if parent && parent.kind == SyntaxKindImportType && (parent).qualifier == node {
			return parent
		}
		return nil
	}
	isThisPropertyAndThisTyped := func(node PropertyAccessExpression) /* TODO inferred type boolean | undefined */ any {
		if node.expression.kind == SyntaxKindThisKeyword {
			container := getThisContainer(node, false, false)
			if isFunctionLike(container) {
				containingLiteral := getContainingObjectLiteral(container)
				if containingLiteral {
					contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
					type_ := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
					return type_ && !isTypeAny(type_)
				}
			}
		}
	}
	getSymbolOfNameOrPropertyAccessExpression := func(name /* TODO(TypeNode UnionType): EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) *Symbol {
		if isDeclarationName(name) {
			return getSymbolOfNode(name.parent)
		}
		if isInJSFile(name) && name.parent.kind == SyntaxKindPropertyAccessExpression && name.parent == (name.parent.parent).left {
			if !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped(name.parent) {
				specialPropertyAssignmentSymbol := getSpecialPropertyAssignmentSymbolFromEntityName(name)
				if specialPropertyAssignmentSymbol {
					return specialPropertyAssignmentSymbol
				}
			}
		}
		if name.parent.kind == SyntaxKindExportAssignment && isEntityNameExpression(name) {
			success := resolveEntityName(name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, true)
			if success && success != unknownSymbol {
				return success
			}
		} else if isEntityName(name) && isInRightSideOfImportOrExportAssignment(name) {
			importEqualsDeclaration := getAncestor(name, SyntaxKindImportEqualsDeclaration)
			Debug.assert(importEqualsDeclaration != nil)
			return getSymbolOfPartOfRightHandSideOfImportEquals(name, true)
		}
		if isEntityName(name) {
			possibleImportNode := isImportTypeQualifierPart(name)
			if possibleImportNode {
				getTypeFromTypeNode(possibleImportNode)
				sym := getNodeLinks(name).resolvedSymbol
				// converted from conditional expression
				switch {
				case sym == unknownSymbol:
					return nil
				default:
					return sym
				}
			}
		}
		for isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name) {
			name = name.parent
		}
		if isInNameOfExpressionWithTypeArguments(name) {
			meaning := SymbolFlagsNone
			if name.parent.kind == SyntaxKindExpressionWithTypeArguments {
				meaning = /* TODO(Node ConditionalExpression): isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
				if isExpressionWithTypeArgumentsInClassExtendsClause(name.parent) {
					meaning |= SymbolFlagsValue
				}
			} else {
				meaning = SymbolFlagsNamespace
			}
			meaning |= SymbolFlagsAlias
			entityNameSymbol := /* TODO(Node ConditionalExpression): isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors* / true) : undefined */ TODO
			if entityNameSymbol {
				return entityNameSymbol
			}
		}
		if name.parent.kind == SyntaxKindJSDocParameterTag {
			return getParameterSymbolFromJSDoc(name.parent)
		}
		if name.parent.kind == SyntaxKindTypeParameter && name.parent.parent.kind == SyntaxKindJSDocTemplateTag {
			Debug.assert(!isInJSFile(name))
			typeParameter := getTypeParameterFromJsDoc(name.parent)
			return typeParameter && typeParameter.symbol
		}
		if isExpressionNode(name) {
			if nodeIsMissing(name) {
				return nil
			}
			isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
			meaning := /* TODO(Node ConditionalExpression): isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value */ TODO
			if name.kind == SyntaxKindIdentifier {
				if isJSXTagName(name) && isJsxIntrinsicTagName(name) {
					symbol := getIntrinsicTagSymbol(name.parent)
					// converted from conditional expression
					switch {
					case symbol == unknownSymbol:
						return nil
					default:
						return symbol
					}
				}
				result := resolveEntityName(name, meaning, true, true, getHostSignatureFromJSDoc(name))
				if !result && isJSDoc {
					container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
					if container {
						return resolveJSDocMemberName(name, true, getSymbolOfDeclaration(container))
					}
				}
				if result && isJSDoc {
					container := getJSDocHost(name)
					if container && isEnumMember(container) && container == result.valueDeclaration {
						return resolveEntityName(name, meaning, true, true, getSourceFileOfNode(container)) || result
					}
				}
				return result
			} else if isPrivateIdentifier(name) {
				return getSymbolForPrivateIdentifierExpression(name)
			} else if name.kind == SyntaxKindPropertyAccessExpression || name.kind == SyntaxKindQualifiedName {
				links := getNodeLinks(name)
				if links.resolvedSymbol {
					return links.resolvedSymbol
				}
				if name.kind == SyntaxKindPropertyAccessExpression {
					checkPropertyAccessExpression(name, CheckModeNormal)
					if !links.resolvedSymbol {
						links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name))
					}
				} else {
					checkQualifiedName(name, CheckModeNormal)
				}
				if !links.resolvedSymbol && isJSDoc && isQualifiedName(name) {
					return resolveJSDocMemberName(name)
				}
				return links.resolvedSymbol
			} else if isJSDocMemberName(name) {
				return resolveJSDocMemberName(name)
			}
		} else if isTypeReferenceIdentifier(name) {
			meaning := /* TODO(Node ConditionalExpression): name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO
			symbol := resolveEntityName(name, meaning, false, true)
			// converted from conditional expression
			switch {
			case symbol && symbol != unknownSymbol:
				return symbol
			default:
				return getUnresolvedSymbolForEntityName(name)
			}
		}
		if name.parent.kind == SyntaxKindTypePredicate {
			return resolveEntityName(name, SymbolFlagsFunctionScopedVariable)
		}
		return nil
	}
	getApplicableIndexSymbol := func(type_ Type, keyType Type) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		infos := getApplicableIndexInfos(type_, keyType)
		if infos.length && (type_).members {
			symbol := getIndexSymbolFromSymbolTable(resolveStructuredTypeMembers(type_).members)
			if infos == getIndexInfosOfType(type_) {
				return symbol
			} else if symbol {
				symbolLinks := getSymbolLinks(symbol)
				declarationList := mapDefined(infos, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined */ any {
					return i.declaration
				})
				nodeListId := map_(declarationList, getNodeId).join(",")
				if !symbolLinks.filteredIndexSymbolCache {
					symbolLinks.filteredIndexSymbolCache = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
				}
				if symbolLinks.filteredIndexSymbolCache.has(nodeListId) {
					return symbolLinks.filteredIndexSymbolCache.get(nodeListId)
				} else {
					copy := createSymbol(SymbolFlagsSignature, InternalSymbolNameIndex)
					copy.declarations = mapDefined(infos, func(i /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined */ any {
						return i.declaration
					})
					copy.parent = /* TODO(Node ConditionalExpression): type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent) */ TODO
					symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy)
					return copy
				}
			}
		}
	}
	resolveJSDocMemberName := func(name /* TODO(TypeNode UnionType): EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) *Symbol {
		if isEntityName(name) {
			meaning := SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
			symbol := resolveEntityName(name, meaning, ignoreErrors, true, getHostSignatureFromJSDoc(name))
			if !symbol && isIdentifier(name) && container {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning))
			}
			if symbol {
				return symbol
			}
		}
		left := /* TODO(Node ConditionalExpression): isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container) */ TODO
		right := /* TODO(Node ConditionalExpression): isIdentifier(name) ? name.escapedText : name.right.escapedText */ TODO
		if left {
			proto := left.flags&SymbolFlagsValue && getPropertyOfType(getTypeOfSymbol(left), "prototype")
			t := /* TODO(Node ConditionalExpression): proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left) */ TODO
			return getPropertyOfType(t, right)
		}
	}
	getSymbolAtLocation := func(node Node, ignoreErrors bool) *Symbol {
		if isSourceFile(node) {
			// converted from conditional expression
			switch {
			case isExternalModule(node):
				return getMergedSymbol(node.symbol)
			default:
				return nil
			}
		}
		TODO_IDENTIFIER := node
		grandParent := parent.parent
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		if isDeclarationNameOrImportPropertyName(node) {
			parentSymbol := getSymbolOfDeclaration(parent)
			// converted from conditional expression
			switch {
			case isImportOrExportSpecifier(node.parent) && node.parent.propertyName == node:
				return getImmediateAliasedSymbol(parentSymbol)
			default:
				return parentSymbol
			}
		} else if isLiteralComputedPropertyDeclarationName(node) {
			return getSymbolOfDeclaration(parent.parent)
		}
		if node.kind == SyntaxKindIdentifier {
			if isInRightSideOfImportOrExportAssignment(node) {
				return getSymbolOfNameOrPropertyAccessExpression(node)
			} else if parent.kind == SyntaxKindBindingElement && grandParent.kind == SyntaxKindObjectBindingPattern && node == (parent).propertyName {
				typeOfPattern := getTypeOfNode(grandParent)
				propertyDeclaration := getPropertyOfType(typeOfPattern, (node).escapedText)
				if propertyDeclaration {
					return propertyDeclaration
				}
			} else if isMetaProperty(parent) && parent.name == node {
				if parent.keywordToken == SyntaxKindNewKeyword && idText(node) == "target" {
					return checkNewTargetMetaProperty(parent).symbol
				}
				if parent.keywordToken == SyntaxKindImportKeyword && idText(node) == "meta" {
					return getGlobalImportMetaExpressionType().members.get("meta")
				}
				return nil
			}
		}
		switch node.kind {
		case SyntaxKindIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPrivateIdentifier:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindQualifiedName:
			if !isThisInTypeQuery(node) {
				return getSymbolOfNameOrPropertyAccessExpression(node)
			}
			fallthrough
		case SyntaxKindThisKeyword:
			container := getThisContainer(node, false, false)
			if isFunctionLike(container) {
				sig := getSignatureFromDeclaration(container)
				if sig.thisParameter {
					return sig.thisParameter
				}
			}
			if isInExpressionContext(node) {
				return checkExpression(node).symbol
			}
			fallthrough
		case SyntaxKindThisType:
			return getTypeFromThisTypeNode(node).symbol
		case SyntaxKindSuperKeyword:
			return checkExpression(node).symbol
		case SyntaxKindConstructorKeyword:
			constructorDeclaration := node.parent
			if constructorDeclaration && constructorDeclaration.kind == SyntaxKindConstructor {
				return (constructorDeclaration.parent).symbol
			}
			return nil
		case SyntaxKindStringLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindNoSubstitutionTemplateLiteral:
			if (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) == node) || ((node.parent.kind == SyntaxKindImportDeclaration || node.parent.kind == SyntaxKindExportDeclaration) && (node.parent).moduleSpecifier == node) || (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier == node) || ((isInJSFile(node) && isRequireCall(node.parent, false)) || isImportCall(node.parent)) || (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument == node.parent) {
				return resolveExternalModuleName(node, node, ignoreErrors)
			}
			if isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] == node {
				return getSymbolOfDeclaration(parent)
			}
			fallthrough
		case SyntaxKindNumericLiteral:
			objectType := /* TODO(Node ConditionalExpression): isElementAccessExpression(parent) ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent) ? getTypeFromTypeNode(grandParent.objectType) : undefined */ TODO
			return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node).text))
		case SyntaxKindDefaultKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindEqualsGreaterThanToken:
			fallthrough // TODO: merge cases
		case SyntaxKindClassKeyword:
			return getSymbolOfNode(node.parent)
		case SyntaxKindImportType:
			// converted from conditional expression
			switch {
			case isLiteralImportTypeNode(node):
				return getSymbolAtLocation(node.argument.literal, ignoreErrors)
			default:
				return nil
			}
		case SyntaxKindExportKeyword:
			// converted from conditional expression
			switch {
			case isExportAssignment(node.parent):
				return Debug.checkDefined(node.parent.symbol)
			default:
				return nil
			}
		case SyntaxKindImportKeyword:
			fallthrough // TODO: merge cases
		case SyntaxKindNewKeyword:
			// converted from conditional expression
			switch {
			case isMetaProperty(node.parent):
				return checkMetaPropertyKeyword(node.parent).symbol
			default:
				return nil
			}
		case SyntaxKindInstanceOfKeyword:
			if isBinaryExpression(node.parent) {
				type_ := getTypeOfExpression(node.parent.right)
				hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(type_)
				return /* TODO(Node BinaryExpression): hasInstanceMethodType?.symbol ?? type.symbol */ TODO
			}
			return nil
		case SyntaxKindMetaProperty:
			return checkExpression(node).symbol
		case SyntaxKindJsxNamespacedName:
			if isJSXTagName(node) && isJsxIntrinsicTagName(node) {
				symbol := getIntrinsicTagSymbol(node.parent)
				// converted from conditional expression
				switch {
				case symbol == unknownSymbol:
					return nil
				default:
					return symbol
				}
			}
			fallthrough
		default:
			return nil
		}
	}
	getIndexInfosAtLocation := func(node Node) *[]IndexInfo {
		if isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name == node {
			keyType := getLiteralTypeFromPropertyName(node)
			objectType := getTypeOfExpression(node.parent.expression)
			objectTypes := /* TODO(Node ConditionalExpression): objectType.flags & TypeFlags.Union ? (objectType as UnionType).types : [objectType] */ TODO
			return flatMap(objectTypes, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type readonly import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ any {
				return filter(getIndexInfosOfType(t), func(info /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ any) /* TODO inferred type boolean */ any {
					return isApplicableIndexType(keyType, info.keyType)
				})
			})
		}
		return nil
	}
	getShorthandAssignmentValueSymbol := func(location Node) *Symbol {
		if location && location.kind == SyntaxKindShorthandPropertyAssignment {
			return resolveEntityName((location).name, SymbolFlagsValue|SymbolFlagsAlias)
		}
		return nil
	}
	getExportSpecifierLocalTargetSymbol := func(node /* TODO(TypeNode UnionType): ExportSpecifier | Identifier */ any) *Symbol {
		if isExportSpecifier(node) {
			name := node.propertyName || node.name
			// converted from conditional expression
			switch {
			case node.parent.parent.moduleSpecifier:
				return getExternalModuleMember(node.parent.parent, node)
			case name.kind == SyntaxKindStringLiteral:
				return nil
			default:
				return resolveEntityName(name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
			}
		} else {
			return resolveEntityName(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
	}
	getTypeOfNode := func(node Node) Type {
		if isSourceFile(node) && !isExternalModule(node) {
			return errorType
		}
		if node.flags & NodeFlagsInWithStatement {
			return errorType
		}
		classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
		classType := classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class))
		if isPartOfTypeNode(node) {
			typeFromTypeNode := getTypeFromTypeNode(node)
			// converted from conditional expression
			switch {
			case classType:
				return getTypeWithThisArgument(typeFromTypeNode, classType.thisType)
			default:
				return typeFromTypeNode
			}
		}
		if isExpressionNode(node) {
			return getRegularTypeOfExpression(node)
		}
		if classType && !classDecl.isImplements {
			baseType := firstOrUndefined(getBaseTypes(classType))
			// converted from conditional expression
			switch {
			case baseType:
				return getTypeWithThisArgument(baseType, classType.thisType)
			default:
				return errorType
			}
		}
		if isTypeDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return getDeclaredTypeOfSymbol(symbol)
		}
		if isTypeDeclarationName(node) {
			symbol := getSymbolAtLocation(node)
			// converted from conditional expression
			switch {
			case symbol:
				return getDeclaredTypeOfSymbol(symbol)
			default:
				return errorType
			}
		}
		if isBindingElement(node) {
			return getTypeForVariableLikeDeclaration(node, true, CheckModeNormal) || errorType
		}
		if isDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			// converted from conditional expression
			switch {
			case symbol:
				return getTypeOfSymbol(symbol)
			default:
				return errorType
			}
		}
		if isDeclarationNameOrImportPropertyName(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				return getTypeOfSymbol(symbol)
			}
			return errorType
		}
		if isBindingPattern(node) {
			return getTypeForVariableLikeDeclaration(node.parent, true, CheckModeNormal) || errorType
		}
		if isInRightSideOfImportOrExportAssignment(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				declaredType := getDeclaredTypeOfSymbol(symbol)
				// converted from conditional expression
				switch {
				case !isErrorType(declaredType):
					return declaredType
				default:
					return getTypeOfSymbol(symbol)
				}
			}
		}
		if isMetaProperty(node.parent) && node.parent.keywordToken == node.kind {
			return checkMetaPropertyKeyword(node.parent)
		}
		if isImportAttributes(node) {
			return getGlobalImportAttributesType(false)
		}
		return errorType
	}
	getTypeOfAssignmentPattern := func(expr AssignmentPattern) *Type {
		Debug.assert(expr.kind == SyntaxKindObjectLiteralExpression || expr.kind == SyntaxKindArrayLiteralExpression)
		if expr.parent.kind == SyntaxKindForOfStatement {
			iteratedType := checkRightHandSideOfForOf(expr.parent)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if expr.parent.kind == SyntaxKindBinaryExpression {
			iteratedType := getTypeOfExpression((expr.parent).right)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if expr.parent.kind == SyntaxKindPropertyAssignment {
			node := cast(expr.parent.parent, isObjectLiteralExpression)
			typeOfParentObjectLiteral := getTypeOfAssignmentPattern(node) || errorType
			propertyIndex := indexOfNode(node.properties, expr.parent)
			return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
		}
		node := cast(expr.parent, isArrayLiteralExpression)
		typeOfArrayLiteral := getTypeOfAssignmentPattern(node) || errorType
		elementType := checkIteratedTypeOrElementType(IterationUseDestructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType
		return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType)
	}
	getPropertySymbolOfDestructuringAssignment := func(location Identifier) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
		typeOfObjectLiteral := getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern))
		return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText)
	}
	getRegularTypeOfExpression := func(expr Expression) Type {
		if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
			expr = expr.parent
		}
		return getRegularTypeOfLiteralType(getTypeOfExpression(expr))
	}
	getParentTypeOfClassElement := func(node ClassElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		classSymbol := getSymbolOfNode(node.parent)
		// converted from conditional expression
		switch {
		case isStatic(node):
			return getTypeOfSymbol(classSymbol)
		default:
			return getDeclaredTypeOfSymbol(classSymbol)
		}
	}
	getClassElementPropertyKeyType := func(element ClassElement) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		name := element.name
		switch name.kind {
		case SyntaxKindIdentifier:
			return getStringLiteralType(idText(name))
		case SyntaxKindNumericLiteral:
			fallthrough // TODO: merge cases
		case SyntaxKindStringLiteral:
			return getStringLiteralType(name.text)
		case SyntaxKindComputedPropertyName:
			nameType := checkComputedPropertyName(name)
			// converted from conditional expression
			switch {
			case isTypeAssignableToKind(nameType, TypeFlagsESSymbolLike):
				return nameType
			default:
				return stringType
			}
		default:
			return Debug.fail("Unsupported property name.")
		}
	}
	getAugmentedPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getApparentType(type_)
		propsByName := createSymbolTable(getPropertiesOfType(type_))
		functionType := /* TODO(Node ConditionalExpression): getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType : getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType : undefined */ TODO
		if functionType {
			forEach(getPropertiesOfType(functionType), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) {
				if !propsByName.has(p.escapedName) {
					propsByName.set(p.escapedName, p)
				}
			})
		}
		return getNamedMembers(propsByName)
	}
	typeHasCallOrConstructSignatures := func(type_ Type) bool {
		return getSignaturesOfType(type_, SignatureKindCall).length != 0 || getSignaturesOfType(type_, SignatureKindConstruct).length != 0
	}
	getRootSymbols := func(symbol Symbol) []Symbol {
		roots := getImmediateRootSymbols(symbol)
		// converted from conditional expression
		switch {
		case roots:
			return flatMap(roots, getRootSymbols)
		default:
			return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{symbol}
		}
	}
	getImmediateRootSymbols := func(symbol Symbol) *[]Symbol {
		if getCheckFlags(symbol) & CheckFlagsSynthetic {
			return mapDefined(getSymbolLinks(symbol).containingType.types, func(type_ /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ any {
				return getPropertyOfType(type_, symbol.escapedName)
			})
		} else if symbol.flags & SymbolFlagsTransient {
			TODO_IDENTIFIER := symbol
			// converted from conditional expression
			switch {
			case leftSpread:
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{leftSpread, rightSpread}
			case syntheticOrigin:
				return [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any{syntheticOrigin}
			default:
				return singleElementArray(tryGetTarget(symbol))
			}
		}
		return nil
	}
	tryGetTarget := func(symbol Symbol) *Symbol {
		var target *Symbol
		var next *Symbol = symbol
		for /* TODO(Node BinaryExpression): next = getSymbolLinks(next).target */ TODO {
			target = next
		}
		return target
	}
	isArgumentsLocalBinding := func(nodeIn Identifier) bool {
		if isGeneratedIdentifier(nodeIn) {
			return false
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if !node {
			return false
		}
		parent := node.parent
		if !parent {
			return false
		}
		isPropertyName := (isPropertyAccessExpression(parent) || isPropertyAssignment(parent)) && parent.name == node
		return !isPropertyName && getReferencedValueSymbol(node) == argumentsSymbol
	}
	isNameOfModuleOrEnumDeclaration := func(node Identifier) /* TODO inferred type boolean */ any {
		return isModuleOrEnumDeclaration(node.parent) && node == node.parent.name
	}
	getReferencedExportContainer := func(nodeIn Identifier, prefixLocals bool) /* TODO(TypeNode UnionType): SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node))
			if symbol {
				if symbol.flags & SymbolFlagsExportValue {
					exportSymbol := getMergedSymbol(symbol.exportSymbol)
					if !prefixLocals && exportSymbol.flags&SymbolFlagsExportHasLocal && !(exportSymbol.flags & SymbolFlagsVariable) {
						return nil
					}
					symbol = exportSymbol
				}
				parentSymbol := getParentOfSymbol(symbol)
				if parentSymbol {
					if parentSymbol.flags&SymbolFlagsValueModule && parentSymbol.valueDeclaration. /*?*/ kind == SyntaxKindSourceFile {
						symbolFile := parentSymbol.valueDeclaration
						referenceFile := getSourceFileOfNode(node)
						symbolIsUmdExport := symbolFile != referenceFile
						// converted from conditional expression
						switch {
						case symbolIsUmdExport:
							return nil
						default:
							return symbolFile
						}
					}
					return findAncestor(node.parent, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO(TypeNode TypePredicate): n is ModuleDeclaration | EnumDeclaration */ any {
						return isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) == parentSymbol
					})
				}
			}
		}
	}
	getReferencedImportDeclaration := func(nodeIn Identifier) Declaration {
		specifier := getIdentifierGeneratedImportReference(nodeIn)
		if specifier {
			return specifier
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueOrAliasSymbol(node)
			if isNonLocalAlias(symbol, SymbolFlagsValue) && !getTypeOnlyAliasDeclaration(symbol, SymbolFlagsValue) {
				return getDeclarationOfAliasSymbol(symbol)
			}
		}
		return nil
	}
	isSymbolOfDestructuredElementOfCatchBinding := func(symbol Symbol) /* TODO inferred type boolean | undefined */ any {
		return symbol.valueDeclaration && isBindingElement(symbol.valueDeclaration) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind == SyntaxKindCatchClause
	}
	isSymbolOfDeclarationWithCollidingName := func(symbol Symbol) bool {
		if symbol.flags&SymbolFlagsBlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isDeclarationWithCollidingName == nil {
				container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
				if isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol) {
					if resolveName(container.parent, symbol.escapedName, SymbolFlagsValue, nil, false) {
						links.isDeclarationWithCollidingName = true
					} else if hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsCapturedBlockScopedBinding) {
						isDeclaredInLoop := hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsBlockScopedBindingInLoop)
						inLoopInitializer := isIterationStatement(container, false)
						inLoopBodyBlock := container.kind == SyntaxKindBlock && isIterationStatement(container.parent, false)
						links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock))
					} else {
						links.isDeclarationWithCollidingName = false
					}
				}
			}
			return links.isDeclarationWithCollidingName
		}
		return false
	}
	getReferencedDeclarationWithCollidingName := func(nodeIn Identifier) Declaration {
		if !isGeneratedIdentifier(nodeIn) {
			node := getParseTreeNode(nodeIn, isIdentifier)
			if node {
				symbol := getReferencedValueSymbol(node)
				if symbol && isSymbolOfDeclarationWithCollidingName(symbol) {
					return symbol.valueDeclaration
				}
			}
		}
		return nil
	}
	isDeclarationWithCollidingName := func(nodeIn Declaration) bool {
		node := getParseTreeNode(nodeIn, isDeclaration)
		if node {
			symbol := getSymbolOfDeclaration(node)
			if symbol {
				return isSymbolOfDeclarationWithCollidingName(symbol)
			}
		}
		return false
	}
	isValueAliasDeclaration := func(node Node) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		switch node.kind {
		case SyntaxKindImportEqualsDeclaration:
			return isAliasResolvedToValue(getSymbolOfDeclaration(node))
		case SyntaxKindImportClause:
			fallthrough // TODO: merge cases
		case SyntaxKindNamespaceImport:
			fallthrough // TODO: merge cases
		case SyntaxKindImportSpecifier:
			fallthrough // TODO: merge cases
		case SyntaxKindExportSpecifier:
			symbol := getSymbolOfDeclaration(node)
			return !!symbol && isAliasResolvedToValue(symbol, true)
		case SyntaxKindExportDeclaration:
			exportClause := (node).exportClause
			return !!exportClause && (isNamespaceExport(exportClause) || some(exportClause.elements, isValueAliasDeclaration))
		case SyntaxKindExportAssignment:
			// converted from conditional expression
			switch {
			case (node).expression && (node).expression.kind == SyntaxKindIdentifier:
				return isAliasResolvedToValue(getSymbolOfDeclaration(node), true)
			default:
				return true
			}
		}
		return false
	}
	isTopLevelValueImportEqualsWithEntityName := func(nodeIn ImportEqualsDeclaration) bool {
		node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
		if node == nil || node.parent.kind != SyntaxKindSourceFile || !isInternalModuleImportEqualsDeclaration(node) {
			return false
		}
		isValue := isAliasResolvedToValue(getSymbolOfDeclaration(node))
		return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference)
	}
	isAliasResolvedToValue := func(symbol *Symbol, excludeTypeOnlyValues bool) bool {
		if !symbol {
			return false
		}
		container := getSourceFileOfNode(symbol.valueDeclaration)
		fileSymbol := container && getSymbolOfDeclaration(container)
		resolveExternalModuleSymbol(fileSymbol)
		target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
		if target == unknownSymbol {
			return !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol)
		}
		return !!(getSymbolFlags(symbol, excludeTypeOnlyValues, true) & SymbolFlagsValue) && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))
	}
	isConstEnumOrConstEnumOnlyModule := func(s Symbol) bool {
		return isConstEnumSymbol(s) || !!s.constEnumOnlyModule
	}
	isReferencedAliasDeclaration := func(node Node, checkChildren bool) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		if isAliasSymbolDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			links := symbol && getSymbolLinks(symbol)
			if links. /*?*/ referenced {
				return true
			}
			target := getSymbolLinks(symbol).aliasTarget
			if target && getEffectiveModifierFlags(node)&ModifierFlagsExport && getSymbolFlags(target)&SymbolFlagsValue && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) {
				return true
			}
		}
		if checkChildren {
			return !!forEachChild(node, func(node /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO inferred type boolean */ any {
				return isReferencedAliasDeclaration(node, checkChildren)
			})
		}
		return false
	}
	isImplementationOfOverload := func(node SignatureDeclaration) /* TODO inferred type boolean */ any {
		if nodeIsPresent((node).body) {
			if isGetAccessor(node) || isSetAccessor(node) {
				return false
			}
			symbol := getSymbolOfDeclaration(node)
			signaturesOfSymbol := getSignaturesOfSymbol(symbol)
			return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length == 1 && signaturesOfSymbol[0].declaration != node)
		}
		return false
	}
	declaredParameterTypeContainsUndefined := func(parameter /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO inferred type boolean */ any {
		typeNode := getNonlocalEffectiveTypeAnnotationNode(parameter)
		if !typeNode {
			return false
		}
		type_ := getTypeFromTypeNode(typeNode)
		return containsUndefinedType(type_)
	}
	requiresAddingImplicitUndefined := func(parameter /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) /* TODO inferred type boolean */ any {
		return (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter)
	}
	isRequiredInitializedParameter := func(parameter /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
		if !strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer {
			return false
		}
		if hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier) {
			return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration)
		}
		return true
	}
	isOptionalUninitializedParameterProperty := func(parameter /* TODO(TypeNode UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO inferred type boolean */ any {
		return strictNullChecks && isOptionalParameter(parameter) && (isJSDocParameterTag(parameter) || !parameter.initializer) && hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier)
	}
	isExpandoFunctionDeclaration := func(node Declaration) bool {
		declaration := getParseTreeNode(node, func(n /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ any) /* TODO(TypeNode TypePredicate): n is FunctionDeclaration | VariableDeclaration */ any {
			return isFunctionDeclaration(n) || isVariableDeclaration(n)
		})
		if !declaration {
			return false
		}
		var symbol *Symbol
		if isVariableDeclaration(declaration) {
			if declaration.type_ || (!isInJSFile(declaration) && !isVarConstLike(declaration)) {
				return false
			}
			initializer := getDeclaredExpandoInitializer(declaration)
			if !initializer || !canHaveSymbol(initializer) {
				return false
			}
			symbol = getSymbolOfDeclaration(initializer)
		} else {
			symbol = getSymbolOfDeclaration(declaration)
		}
		if !symbol || !(symbol.flags&SymbolFlagsFunction | SymbolFlagsVariable) {
			return false
		}
		return !!forEachEntry(getExportsOfSymbol(symbol), func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type boolean | 0 */ any {
			return p.flags&SymbolFlagsValue && isExpandoPropertyDeclaration(p.valueDeclaration)
		})
	}
	getPropertiesOfContainerFunction := func(node Declaration) []Symbol {
		declaration := getParseTreeNode(node, isFunctionDeclaration)
		if !declaration {
			return emptyArray
		}
		symbol := getSymbolOfDeclaration(declaration)
		return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray
	}
	getNodeCheckFlags := func(node Node) NodeCheckFlags {
		nodeId := node.id || 0
		if nodeId < 0 || nodeId >= nodeLinks.length {
			return 0
		}
		return nodeLinks[nodeId]. /*?*/ flags || 0
	}
	hasNodeCheckFlag := func(node Node, flag LazyNodeCheckFlags) /* TODO inferred type boolean */ any {
		calculateNodeCheckFlagWorker(node, flag)
		return !!(getNodeCheckFlags(node) & flag)
	}
	calculateNodeCheckFlagWorker := func(node Node, flag LazyNodeCheckFlags) {
		if !compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions) {
			return
		}
		links := getNodeLinks(node)
		if links.calculatedFlags & flag {
			return
		}
		switch flag {
		case NodeCheckFlagsSuperInstance:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsSuperStatic:
			return checkSingleSuperExpression(node)
		case NodeCheckFlagsMethodWithSuperPropertyAccessInAsync:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsContainsSuperPropertyInStaticInitializer:
			return checkChildSuperExpressions(node)
		case NodeCheckFlagsCaptureArguments:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsContainsCapturedBlockScopeBinding:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsNeedsLoopOutParameter:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsContainsConstructorReference:
			return checkChildIdentifiers(node)
		case NodeCheckFlagsConstructorReference:
			return checkSingleIdentifier(node)
		case NodeCheckFlagsLoopWithCapturedBlockScopedBinding:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsBlockScopedBindingInLoop:
			fallthrough // TODO: merge cases
		case NodeCheckFlagsCapturedBlockScopedBinding:
			return checkContainingBlockScopeBindingUses(node)
		default:
			return Debug.assertNever(flag /* TODO(Node TemplateExpression): `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}` */, TODO)
		}
		forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(TypeNode UnionType): T | "skip" | undefined */ any) *T {
			rootResult := cb(root, root.parent)
			if rootResult == "skip" {
				return nil
			}
			if rootResult {
				return rootResult
			}
			return forEachChildRecursively(root, cb)
		}
		checkSuperExpressions := func(node Node) /* TODO inferred type "skip" | undefined */ any {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync | NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync | NodeCheckFlagsContainsSuperPropertyInStaticInitializer
			checkSingleSuperExpression(node)
			return nil
		}
		checkChildSuperExpressions := func(node Node) {
			forEachNodeRecursively(node, checkSuperExpressions)
		}
		checkSingleSuperExpression := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsSuperInstance | NodeCheckFlagsSuperStatic
			if node.kind == SyntaxKindSuperKeyword {
				checkSuperExpression(node)
			}
		}
		checkIdentifiers := func(node Node) /* TODO inferred type "skip" | undefined */ any {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsCaptureArguments | NodeCheckFlagsContainsCapturedBlockScopeBinding | NodeCheckFlagsNeedsLoopOutParameter | NodeCheckFlagsContainsConstructorReference
			checkSingleIdentifier(node)
			return nil
		}
		checkChildIdentifiers := func(node Node) {
			forEachNodeRecursively(node, checkIdentifiers)
		}
		isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) /* TODO inferred type boolean */ any {
			return isExpressionNode(node) || isShorthandPropertyAssignment(node.parent) && ( /* TODO(Node BinaryExpression): node.parent.objectAssignmentInitializer ?? node.parent.name */ TODO) == node
		}
		checkSingleIdentifier := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsConstructorReference
			if isIdentifier(node) {
				nodeLinks.calculatedFlags |= NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
				if isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name == node) {
					s := getResolvedSymbol(node)
					if s && s != unknownSymbol {
						checkIdentifierCalculateNodeCheckFlags(node, s)
					}
				}
			}
		}
		checkBlockScopeBindings := func(node Node) /* TODO inferred type "skip" | undefined */ any {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				return "skip"
			}
			links.calculatedFlags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding | NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
			checkSingleBlockScopeBinding(node)
			return nil
		}
		checkContainingBlockScopeBindingUses := func(node Node) {
			scope := getEnclosingBlockScopeContainer( /* TODO(Node ConditionalExpression): isDeclarationName(node) ? node.parent : node */ TODO)
			forEachNodeRecursively(scope, checkBlockScopeBindings)
		}
		checkSingleBlockScopeBinding := func(node Node) {
			checkSingleIdentifier(node)
			if isComputedPropertyName(node) {
				checkComputedPropertyName(node)
			}
			if isPrivateIdentifier(node) && isClassElement(node.parent) {
				setNodeLinksForPrivateIdentifierScope(node.parent)
			}
		}
	}
	getEnumMemberValue := func(node EnumMember) EvaluatorResult {
		computeEnumMemberValues(node.parent)
		return /* TODO(Node BinaryExpression): getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
	}
	canHaveConstantValue := func(node Node) /* TODO(TypeNode TypePredicate): node is EnumMember | AccessExpression */ any {
		switch node.kind {
		case SyntaxKindEnumMember:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAccessExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindElementAccessExpression:
			return true
		}
		return false
	}
	getConstantValue := func(node /* TODO(TypeNode UnionType): EnumMember | AccessExpression */ any) /* TODO(TypeNode UnionType): string | number | undefined */ any {
		if node.kind == SyntaxKindEnumMember {
			return getEnumMemberValue(node).value
		}
		if !getNodeLinks(node).resolvedSymbol {
			checkExpressionCached(node)
		}
		symbol := getNodeLinks(node).resolvedSymbol || ( /* TODO(Node ConditionalExpression): isEntityNameExpression(node) ? resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors* / true) : undefined */ TODO)
		if symbol && (symbol.flags & SymbolFlagsEnumMember) {
			member := symbol.valueDeclaration
			if isEnumConst(member.parent) {
				return getEnumMemberValue(member).value
			}
		}
		return nil
	}
	isFunctionType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsObject) && getSignaturesOfType(type_, SignatureKindCall).length > 0
	}
	getTypeReferenceSerializationKind := func(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
		typeName := getParseTreeNode(typeNameIn, isEntityName)
		if !typeName {
			return TypeReferenceSerializationKindUnknown
		}
		if location {
			location = getParseTreeNode(location)
			if !location {
				return TypeReferenceSerializationKindUnknown
			}
		}
		isTypeOnly := false
		if isQualifiedName(typeName) {
			rootValueSymbol := resolveEntityName(getFirstIdentifier(typeName), SymbolFlagsValue, true, true, location)
			isTypeOnly = !!rootValueSymbol. /*?*/ declarations. /*?*/ every(isTypeOnlyImportOrExportDeclaration)
		}
		valueSymbol := resolveEntityName(typeName, SymbolFlagsValue, true, true, location)
		resolvedValueSymbol := /* TODO(Node ConditionalExpression): valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(valueSymbol) : valueSymbol */ TODO
		/* TODO(Node BinaryExpression): isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value)) */ TODO
		typeSymbol := resolveEntityName(typeName, SymbolFlagsType, true, true, location)
		resolvedTypeSymbol := /* TODO(Node ConditionalExpression): typeSymbol && typeSymbol.flags & SymbolFlags.Alias ? resolveAlias(typeSymbol) : typeSymbol */ TODO
		if !valueSymbol {
			/* TODO(Node BinaryExpression): isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type)) */ TODO
		}
		if resolvedValueSymbol && resolvedValueSymbol == resolvedTypeSymbol {
			globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
			if globalPromiseSymbol && resolvedValueSymbol == globalPromiseSymbol {
				return TypeReferenceSerializationKindPromise
			}
			constructorType := getTypeOfSymbol(resolvedValueSymbol)
			if constructorType && isConstructorType(constructorType) {
				// converted from conditional expression
				switch {
				case isTypeOnly:
					return TypeReferenceSerializationKindTypeWithCallSignature
				default:
					return TypeReferenceSerializationKindTypeWithConstructSignatureAndValue
				}
			}
		}
		if !resolvedTypeSymbol {
			// converted from conditional expression
			switch {
			case isTypeOnly:
				return TypeReferenceSerializationKindObjectType
			default:
				return TypeReferenceSerializationKindUnknown
			}
		}
		type_ := getDeclaredTypeOfSymbol(resolvedTypeSymbol)
		if isErrorType(type_) {
			// converted from conditional expression
			switch {
			case isTypeOnly:
				return TypeReferenceSerializationKindObjectType
			default:
				return TypeReferenceSerializationKindUnknown
			}
		} else if type_.flags & TypeFlagsAnyOrUnknown {
			return TypeReferenceSerializationKindObjectType
		} else if isTypeAssignableToKind(type_, TypeFlagsVoid|TypeFlagsNullable|TypeFlagsNever) {
			return TypeReferenceSerializationKindVoidNullableOrNeverType
		} else if isTypeAssignableToKind(type_, TypeFlagsBooleanLike) {
			return TypeReferenceSerializationKindBooleanType
		} else if isTypeAssignableToKind(type_, TypeFlagsNumberLike) {
			return TypeReferenceSerializationKindNumberLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsBigIntLike) {
			return TypeReferenceSerializationKindBigIntLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsStringLike) {
			return TypeReferenceSerializationKindStringLikeType
		} else if isTupleType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsESSymbolLike) {
			return TypeReferenceSerializationKindESSymbolType
		} else if isFunctionType(type_) {
			return TypeReferenceSerializationKindTypeWithCallSignature
		} else if isArrayType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else {
			return TypeReferenceSerializationKindObjectType
		}
	}
	createTypeOfDeclaration := func(declarationIn /* TODO(TypeNode UnionType): AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
		declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
		if !declaration {
			return factory.createToken(SyntaxKindAnyKeyword)
		}
		symbol := getSymbolOfDeclaration(declaration)
		type_ := /* TODO(Node ConditionalExpression): symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature)) ? getWidenedLiteralType(getTypeOfSymbol(symbol)) : errorType */ TODO
		return nodeBuilder.serializeTypeForDeclaration(declaration, type_, symbol, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	type DeclarationWithPotentialInnerNodeReuse /* TODO(TypeNode UnionType): | SignatureDeclaration | JSDocSignature | AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression | ExportAssignment */ any
	isDeclarationWithPossibleInnerTypeNodeReuse := func(declaration Declaration) /* TODO(TypeNode TypePredicate): declaration is DeclarationWithPotentialInnerNodeReuse */ any {
		return isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration)
	}
	getAllAccessorDeclarationsForDeclaration := func(accessor AccessorDeclaration) AllAccessorDeclarations {
		accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)
		otherKind := /* TODO(Node ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor */ TODO
		otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind)
		firstAccessor := /* TODO(Node ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor */ TODO
		secondAccessor := /* TODO(Node ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor */ TODO
		setAccessor := /* TODO(Node ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor as SetAccessorDeclaration */ TODO
		getAccessor := /* TODO(Node ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor as GetAccessorDeclaration */ TODO
		return /* TODO(Node ObjectLiteralExpression): { firstAccessor, secondAccessor, setAccessor, getAccessor, } */ TODO
	}
	getPossibleTypeNodeReuseExpression := func(declaration DeclarationWithPotentialInnerNodeReuse) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ any {
		// converted from conditional expression
		switch {
		case isFunctionLike(declaration) && !isSetAccessor(declaration):
			return getSingleReturnExpression(declaration)
		case isExportAssignment(declaration):
			return declaration.expression
		case !!(declaration).initializer:
			return (declaration).initializer
		case isParameter(declaration) && isSetAccessor(declaration.parent):
			return getSingleReturnExpression(getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)
		default:
			return nil
		}
	}
	getSingleReturnExpression := func(declaration *SignatureDeclaration) *Expression {
		var candidateExpr *Expression
		if declaration && !nodeIsMissing((declaration).body) {
			if getFunctionFlags(declaration) & FunctionFlagsAsyncGenerator {
				return nil
			}
			body := (declaration).body
			if body && isBlock(body) {
				forEachReturnStatement(body, func(s /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ any) /* TODO inferred type true | undefined */ any {
					if !candidateExpr {
						candidateExpr = s.expression
					} else {
						candidateExpr = nil
						return true
					}
				})
			} else {
				candidateExpr = body
			}
		}
		return candidateExpr
	}
	createReturnTypeOfSignatureDeclaration := func(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
		signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
		if !signatureDeclaration {
			return factory.createToken(SyntaxKindAnyKeyword)
		}
		return nodeBuilder.serializeReturnTypeForSignature(getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	createTypeOfExpression := func(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
		expr := getParseTreeNode(exprIn, isExpression)
		if !expr {
			return factory.createToken(SyntaxKindAnyKeyword)
		}
		type_ := getWidenedType(getRegularTypeOfExpression(expr))
		return nodeBuilder.expressionOrTypeToTypeNode(expr, type_, nil, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	hasGlobalName := func(name string) bool {
		return globals.has(escapeLeadingUnderscores(name))
	}
	getReferencedValueSymbol := func(reference Identifier, startInDeclarationContainer bool) *Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol {
			return resolvedSymbol
		}
		var location Node = reference
		if startInDeclarationContainer {
			parent := reference.parent
			if isDeclaration(parent) && reference == parent.name {
				location = getDeclarationContainer(parent)
			}
		}
		return resolveName(location, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true)
	}
	getReferencedValueOrAliasSymbol := func(reference Identifier) *Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol && resolvedSymbol != unknownSymbol {
			return resolvedSymbol
		}
		return resolveName(reference, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true, nil)
	}
	getReferencedValueDeclaration := func(referenceIn Identifier) Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration
				}
			}
		}
		return nil
	}
	getReferencedValueDeclarations := func(referenceIn Identifier) *[]Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return filter(getExportSymbolOfValueSymbolIfExported(symbol).declarations, func(declaration /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ any) /* TODO inferred type boolean */ any {
						switch declaration.kind {
						case SyntaxKindVariableDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindParameter:
							fallthrough // TODO: merge cases
						case SyntaxKindBindingElement:
							fallthrough // TODO: merge cases
						case SyntaxKindPropertyDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindPropertyAssignment:
							fallthrough // TODO: merge cases
						case SyntaxKindShorthandPropertyAssignment:
							fallthrough // TODO: merge cases
						case SyntaxKindEnumMember:
							fallthrough // TODO: merge cases
						case SyntaxKindObjectLiteralExpression:
							fallthrough // TODO: merge cases
						case SyntaxKindFunctionDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindFunctionExpression:
							fallthrough // TODO: merge cases
						case SyntaxKindArrowFunction:
							fallthrough // TODO: merge cases
						case SyntaxKindClassDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindClassExpression:
							fallthrough // TODO: merge cases
						case SyntaxKindEnumDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindMethodDeclaration:
							fallthrough // TODO: merge cases
						case SyntaxKindGetAccessor:
							fallthrough // TODO: merge cases
						case SyntaxKindSetAccessor:
							fallthrough // TODO: merge cases
						case SyntaxKindModuleDeclaration:
							return true
						}
						return false
					})
				}
			}
		}
		return nil
	}
	isLiteralConstDeclaration := func(node /* TODO(TypeNode UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
		if isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node) {
			return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)))
		}
		return false
	}
	literalTypeToNode := func(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
		enumResult := /* TODO(Node ConditionalExpression): type.flags & TypeFlags.EnumLike ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, /*flags* / undefined, /*internalFlags* / undefined, tracker) : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse() */ TODO
		if enumResult {
			return enumResult
		}
		literalValue := (type_).value
		// converted from conditional expression
		switch {
		case /* TODO(Node TypeOfExpression): typeof literalValue */ TODO == "object":
			return factory.createBigIntLiteral(literalValue)
		case /* TODO(Node TypeOfExpression): typeof literalValue */ TODO == "string":
			return factory.createStringLiteral(literalValue)
		case literalValue < 0:
			return factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-literalValue))
		default:
			return factory.createNumericLiteral(literalValue)
		}
	}
	createLiteralConstValue := func(node /* TODO(TypeNode UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ any {
		type_ := getTypeOfSymbol(getSymbolOfDeclaration(node))
		return literalTypeToNode(type_, node, tracker)
	}
	getJsxFactoryEntity := func(location Node) *EntityName {
		// converted from conditional expression
		switch {
		case location:
			return ( /* TODO(Node BinaryExpression): getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity) */ TODO)
		default:
			return _jsxFactoryEntity
		}
	}
	getJsxFragmentFactoryEntity := func(location Node) *EntityName {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if file.localJsxFragmentFactory {
					return file.localJsxFragmentFactory
				}
				jsxFragPragmas := file.pragmas.get("jsxfrag")
				jsxFragPragma := /* TODO(Node ConditionalExpression): isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas */ TODO
				if jsxFragPragma {
					file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion)
					return file.localJsxFragmentFactory
				}
			}
		}
		if compilerOptions.jsxFragmentFactory {
			return parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion)
		}
	}
	getNonlocalEffectiveTypeAnnotationNode := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
		direct := getEffectiveTypeAnnotationNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindParameter && node.parent.kind == SyntaxKindSetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node.parent).getAccessor
			if other {
				return getEffectiveReturnTypeNode(other)
			}
		}
		return nil
	}
	getNonlocalEffectiveReturnTypeAnnotationNode := func(node /* TODO(TypeNode UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ any {
		direct := getEffectiveReturnTypeNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindGetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node).setAccessor
			if other {
				param := getSetAccessorValueParameter(other)
				if param {
					return getEffectiveTypeAnnotationNode(param)
				}
			}
		}
		return nil
	}
	createResolver := func() EmitResolver {
		return /* TODO(Node ObjectLiteralExpression): { getReferencedExportContainer, getReferencedImportDeclaration, getReferencedDeclarationWithCollidingName, isDeclarationWithCollidingName, isValueAliasDeclaration: nodeIn => { const node = getParseTreeNode(nodeIn); // Synthesized nodes are always treated like values. return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true; }, hasGlobalName, isReferencedAliasDeclaration: (nodeIn, checkChildren?) => { const node = getParseTreeNode(nodeIn); // Synthesized nodes are always treated as referenced. return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true; }, hasNodeCheckFlag: (nodeIn, flag) => { const node = getParseTreeNode(nodeIn); if (!node) return false; return hasNodeCheckFlag(node, flag); }, isTopLevelValueImportEqualsWithEntityName, isDeclarationVisible, isImplementationOfOverload, requiresAddingImplicitUndefined, isExpandoFunctionDeclaration, getPropertiesOfContainerFunction, createTypeOfDeclaration, createReturnTypeOfSignatureDeclaration, createTypeOfExpression, createLiteralConstValue, isSymbolAccessible, isEntityNameVisible, getConstantValue: nodeIn => { const node = getParseTreeNode(nodeIn, canHaveConstantValue); return node ? getConstantValue(node) : undefined; }, getEnumMemberValue: nodeIn => { const node = getParseTreeNode(nodeIn, isEnumMember); return node ? getEnumMemberValue(node) : undefined; }, collectLinkedAliases, markLinkedReferences: nodeIn => { const node = getParseTreeNode(nodeIn); return node && markLinkedReferences(node, ReferenceHint.Unspecified); }, getReferencedValueDeclaration, getReferencedValueDeclarations, getTypeReferenceSerializationKind, isOptionalParameter, isArgumentsLocalBinding, getExternalModuleFileFromDeclaration: nodeIn => { const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference); return node && getExternalModuleFileFromDeclaration(node); }, isLiteralConstDeclaration, isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => { const node = getParseTreeNode(nodeIn, isDeclaration); const symbol = node && getSymbolOfDeclaration(node); return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late); }, getJsxFactoryEntity, getJsxFragmentFactoryEntity, isBindingCapturedByNode: (node, decl) => { const parseNode = getParseTreeNode(node); const parseDecl = getParseTreeNode(decl); return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl); }, getDeclarationStatementsForSourceFile: (node, flags, internalFlags, tracker) => { const n = getParseTreeNode(node) as SourceFile; Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile"); const sym = getSymbolOfDeclaration(node); if (!sym) { return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker); } resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker); }, isImportRequiredByAugmentation, isDefinitelyReferenceToGlobalSymbolObject, } */ TODO
		isImportRequiredByAugmentation := func(node ImportDeclaration) /* TODO inferred type boolean */ any {
			file := getSourceFileOfNode(node)
			if !file.symbol {
				return false
			}
			importTarget := getExternalModuleFileFromDeclaration(node)
			if !importTarget {
				return false
			}
			if importTarget == file {
				return false
			}
			exports := getExportsOfModule(file.symbol)
			for _, s := range arrayFrom(exports.values()) {
				if s.mergeId {
					merged := getMergedSymbol(s)
					if merged.declarations {
						for _, d := range merged.declarations {
							declFile := getSourceFileOfNode(d)
							if declFile == importTarget {
								return true
							}
						}
					}
				}
			}
			return false
		}
	}
	getExternalModuleFileFromDeclaration := func(declaration /* TODO(TypeNode UnionType): AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
		specifier := /* TODO(Node ConditionalExpression): declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration) */ TODO
		moduleSymbol := resolveExternalModuleNameWorker(specifier, specifier, nil)
		if !moduleSymbol {
			return nil
		}
		return getDeclarationOfKind(moduleSymbol, SyntaxKindSourceFile)
	}
	initializeTypeChecker := func() {
		for _, file := range host.getSourceFiles() {
			bindSourceFile(file, compilerOptions)
		}
		amalgamatedDuplicates = /* TODO(Node NewExpression): new Map() */ make(map[any]any)
		var augmentations *[][] /* TODO(TypeNode UnionType): StringLiteral | Identifier */ any
		for _, file := range host.getSourceFiles() {
			if file.redirectInfo {
				continue
			}
			if !isExternalOrCommonJsModule(file) {
				fileGlobalThisSymbol := file.locals.get("globalThis")
				if fileGlobalThisSymbol. /*?*/ declarations {
					for _, declaration := range fileGlobalThisSymbol.declarations {
						diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"))
					}
				}
				mergeSymbolTable(globals, file.locals)
			}
			if file.jsGlobalAugmentations {
				mergeSymbolTable(globals, file.jsGlobalAugmentations)
			}
			if file.patternAmbientModules && file.patternAmbientModules.length {
				patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules)
			}
			if file.moduleAugmentations.length {
				(augmentations || ( /* TODO(Node BinaryExpression): augmentations = [] */ TODO)).push(file.moduleAugmentations)
			}
			if file.symbol && file.symbol.globalExports {
				source := file.symbol.globalExports
				source.forEach(func(sourceSymbol /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, id /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
					if !globals.has(id) {
						globals.set(id, sourceSymbol)
					}
				})
			}
		}
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if !isGlobalScopeAugmentation(augmentation.parent) {
						continue
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		addUndefinedToGlobalsOrErrorOnRedeclaration()
		getSymbolLinks(undefinedSymbol).type_ = undefinedWideningType
		getSymbolLinks(argumentsSymbol).type_ = getGlobalType("IArguments", 0, true)
		getSymbolLinks(unknownSymbol).type_ = errorType
		getSymbolLinks(globalThisSymbol).type_ = createObjectType(ObjectFlagsAnonymous, globalThisSymbol)
		globalArrayType = getGlobalType("Array", 1, true)
		globalObjectType = getGlobalType("Object", 0, true)
		globalFunctionType = getGlobalType("Function", 0, true)
		globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction", 0, true) || globalFunctionType
		globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction", 0, true) || globalFunctionType
		globalStringType = getGlobalType("String", 0, true)
		globalNumberType = getGlobalType("Number", 0, true)
		globalBooleanType = getGlobalType("Boolean", 0, true)
		globalRegExpType = getGlobalType("RegExp", 0, true)
		anyArrayType = createArrayType(anyType)
		autoArrayType = createArrayType(autoType)
		if autoArrayType == emptyObjectType {
			autoArrayType = createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
		}
		globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", 1) || globalArrayType
		anyReadonlyArrayType = /* TODO(Node ConditionalExpression): globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType */ TODO
		globalThisType = getGlobalTypeOrUndefined("ThisType", 1)
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if isGlobalScopeAugmentation(augmentation.parent) {
						continue
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		amalgamatedDuplicates.forEach(func(TODO_IDENTIFIER /* TODO inferred type DuplicateInfoForFiles */ any) {
			if conflictingSymbols.size < 8 {
				conflictingSymbols.forEach(func(TODO_IDENTIFIER /* TODO inferred type DuplicateInfoForSymbol */ any, symbolName /* TODO inferred type string */ any) {
					message := /* TODO(Node ConditionalExpression): isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0 */ TODO
					for _, node := range firstFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, secondFileLocations)
					}
					for _, node := range secondFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, firstFileLocations)
					}
				})
			} else {
				list := arrayFrom(conflictingSymbols.keys()).join(", ")
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)))
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)))
			}
		})
		amalgamatedDuplicates = nil
	}
	checkExternalEmitHelpers := func(location Node, helpers ExternalEmitHelpers) {
		if compilerOptions.importHelpers {
			sourceFile := getSourceFileOfNode(location)
			if isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlagsAmbient) {
				helpersModule := resolveHelpersModule(sourceFile, location)
				if helpersModule != unknownSymbol {
					links := getSymbolLinks(helpersModule)
					/* TODO(Node BinaryExpression): links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers */ TODO
					if (links.requestedExternalEmitHelpers & helpers) != helpers {
						uncheckedHelpers := helpers & ~links.requestedExternalEmitHelpers
						for helper := ExternalEmitHelpersFirstEmitHelper; helper <= ExternalEmitHelpersLastEmitHelper; helper <<= 1 {
							if uncheckedHelpers & helper {
								for _, name := range getHelperNames(helper) {
									symbol := resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlagsValue))
									if !symbol {
										error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name)
									} else if helper & ExternalEmitHelpersClassPrivateFieldGet {
										if !some(getSignaturesOfSymbol(symbol), func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
											return getParameterCount(signature) > 3
										}) {
											error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4)
										}
									} else if helper & ExternalEmitHelpersClassPrivateFieldSet {
										if !some(getSignaturesOfSymbol(symbol), func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
											return getParameterCount(signature) > 4
										}) {
											error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5)
										}
									} else if helper & ExternalEmitHelpersSpreadArray {
										if !some(getSignaturesOfSymbol(symbol), func(signature /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ any) /* TODO inferred type boolean */ any {
											return getParameterCount(signature) > 2
										}) {
											error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3)
										}
									}
								}
							}
						}
					}
					links.requestedExternalEmitHelpers |= helpers
				}
			}
		}
	}
	getHelperNames := func(helper ExternalEmitHelpers) /* TODO inferred type string[] */ any {
		switch helper {
		case ExternalEmitHelpersExtends:
			return [] /* TODO inferred type string */ any{"__extends"}
		case ExternalEmitHelpersAssign:
			return [] /* TODO inferred type string */ any{"__assign"}
		case ExternalEmitHelpersRest:
			return [] /* TODO inferred type string */ any{"__rest"}
		case ExternalEmitHelpersDecorate:
			// converted from conditional expression
			switch {
			case legacyDecorators:
				return [] /* TODO inferred type string */ any{"__decorate"}
			default:
				return [] /* TODO inferred type string */ any{"__esDecorate", "__runInitializers"}
			}
		case ExternalEmitHelpersMetadata:
			return [] /* TODO inferred type string */ any{"__metadata"}
		case ExternalEmitHelpersParam:
			return [] /* TODO inferred type string */ any{"__param"}
		case ExternalEmitHelpersAwaiter:
			return [] /* TODO inferred type string */ any{"__awaiter"}
		case ExternalEmitHelpersGenerator:
			return [] /* TODO inferred type string */ any{"__generator"}
		case ExternalEmitHelpersValues:
			return [] /* TODO inferred type string */ any{"__values"}
		case ExternalEmitHelpersRead:
			return [] /* TODO inferred type string */ any{"__read"}
		case ExternalEmitHelpersSpreadArray:
			return [] /* TODO inferred type string */ any{"__spreadArray"}
		case ExternalEmitHelpersAwait:
			return [] /* TODO inferred type string */ any{"__await"}
		case ExternalEmitHelpersAsyncGenerator:
			return [] /* TODO inferred type string */ any{"__asyncGenerator"}
		case ExternalEmitHelpersAsyncDelegator:
			return [] /* TODO inferred type string */ any{"__asyncDelegator"}
		case ExternalEmitHelpersAsyncValues:
			return [] /* TODO inferred type string */ any{"__asyncValues"}
		case ExternalEmitHelpersExportStar:
			return [] /* TODO inferred type string */ any{"__exportStar"}
		case ExternalEmitHelpersImportStar:
			return [] /* TODO inferred type string */ any{"__importStar"}
		case ExternalEmitHelpersImportDefault:
			return [] /* TODO inferred type string */ any{"__importDefault"}
		case ExternalEmitHelpersMakeTemplateObject:
			return [] /* TODO inferred type string */ any{"__makeTemplateObject"}
		case ExternalEmitHelpersClassPrivateFieldGet:
			return [] /* TODO inferred type string */ any{"__classPrivateFieldGet"}
		case ExternalEmitHelpersClassPrivateFieldSet:
			return [] /* TODO inferred type string */ any{"__classPrivateFieldSet"}
		case ExternalEmitHelpersClassPrivateFieldIn:
			return [] /* TODO inferred type string */ any{"__classPrivateFieldIn"}
		case ExternalEmitHelpersSetFunctionName:
			return [] /* TODO inferred type string */ any{"__setFunctionName"}
		case ExternalEmitHelpersPropKey:
			return [] /* TODO inferred type string */ any{"__propKey"}
		case ExternalEmitHelpersAddDisposableResourceAndDisposeResources:
			return [] /* TODO inferred type string */ any{"__addDisposableResource", "__disposeResources"}
		default:
			return Debug.fail("Unrecognized helper")
		}
	}
	resolveHelpersModule := func(file SourceFile, errorNode Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any {
		links := getNodeLinks(file)
		if !links.externalHelpersModule {
			links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol
		}
		return links.externalHelpersModule
	}
	checkGrammarModifiers := func(node /* TODO(TypeNode UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
		quickResult := reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node)
		if quickResult != nil {
			return quickResult
		}
		if isParameter(node) && parameterIsThisKeyword(node) {
			return grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters)
		}
		blockScopeKind := /* TODO(Node ConditionalExpression): isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None */ TODO
		var lastStatic Node
		var lastDeclare Node
		var lastAsync Node
		var lastOverride Node
		var firstDecorator *Decorator
		flags := ModifierFlagsNone
		sawExportBeforeDecorators := false
		hasLeadingDecorators := false
		for _, modifier := range (node).modifiers {
			if isDecorator(modifier) {
				if !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
					if node.kind == SyntaxKindMethodDeclaration && !nodeIsPresent(node.body) {
						return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload)
					} else {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here)
					}
				} else if legacyDecorators && (node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor) {
					accessors := getAllAccessorDeclarationsForDeclaration(node)
					if hasDecorators(accessors.firstAccessor) && node == accessors.secondAccessor {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name)
					}
				}
				if flags & ~(ModifierFlagsExportDefault | ModifierFlagsDecorator) {
					return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here)
				}
				if hasLeadingDecorators && flags&ModifierFlagsModifier {
					Debug.assertIsDefined(firstDecorator)
					sourceFile := getSourceFileOfNode(modifier)
					if !hasParseDiagnostics(sourceFile) {
						addRelatedInfo(error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here))
						return true
					}
					return false
				}
				flags |= ModifierFlagsDecorator
				if !(flags & ModifierFlagsModifier) {
					hasLeadingDecorators = true
				} else if flags & ModifierFlagsExport {
					sawExportBeforeDecorators = true
				}
				/* TODO(Node BinaryExpression): firstDecorator ??= modifier */ TODO
			} else {
				if modifier.kind != SyntaxKindReadonlyKeyword {
					if node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodSignature {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind))
					}
					if node.kind == SyntaxKindIndexSignature && (modifier.kind != SyntaxKindStaticKeyword || !isClassLike(node.parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind))
					}
				}
				if modifier.kind != SyntaxKindInKeyword && modifier.kind != SyntaxKindOutKeyword && modifier.kind != SyntaxKindConstKeyword {
					if node.kind == SyntaxKindTypeParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind))
					}
				}
				switch modifier.kind {
				case SyntaxKindConstKeyword:
					if node.kind != SyntaxKindEnumDeclaration && node.kind != SyntaxKindTypeParameter {
						return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKindConstKeyword))
					}
					parent := (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent
					if node.kind == SyntaxKindTypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) || isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind))
					}
					break
					fallthrough
				case SyntaxKindOverrideKeyword:
					if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async")
					}
					flags |= ModifierFlagsOverride
					lastOverride = modifier
					break
				case SyntaxKindPublicKeyword:
					fallthrough // TODO: merge cases
				case SyntaxKindProtectedKeyword:
					fallthrough // TODO: merge cases
				case SyntaxKindPrivateKeyword:
					text := visibilityToString(modifierToFlag(modifier.kind))
					if flags & ModifierFlagsAccessibilityModifier {
						return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen)
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override")
					} else if flags & ModifierFlagsStatic {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async")
					} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text)
					} else if flags & ModifierFlagsAbstract {
						if modifier.kind == SyntaxKindPrivateKeyword {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract")
						} else {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract")
						}
					} else if isPrivateIdentifierClassElementDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
					}
					flags |= modifierToFlag(modifier.kind)
					break
				case SyntaxKindStaticKeyword:
					if flags & ModifierFlagsStatic {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor")
					} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static")
					} else if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override")
					}
					flags |= ModifierFlagsStatic
					lastStatic = modifier
					break
				case SyntaxKindAccessorKeyword:
					if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor")
					} else if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare")
					} else if node.kind != SyntaxKindPropertyDeclaration {
						return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration)
					}
					flags |= ModifierFlagsAccessor
					break
				case SyntaxKindReadonlyKeyword:
					if flags & ModifierFlagsReadonly {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly")
					} else if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature && node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature)
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor")
					}
					flags |= ModifierFlagsReadonly
					break
				case SyntaxKindExportKeyword:
					if compilerOptions.verbatimModuleSyntax && !(node.flags & NodeFlagsAmbient) && node.kind != SyntaxKindTypeAliasDeclaration && node.kind != SyntaxKindInterfaceDeclaration && node.kind != SyntaxKindModuleDeclaration && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
						return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
					if flags & ModifierFlagsExport {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export")
					} else if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare")
					} else if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async")
					} else if isClassLike(node.parent) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export")
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export")
					}
					flags |= ModifierFlagsExport
					break
				case SyntaxKindDefaultKeyword:
					container := /* TODO(Node ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent */ TODO
					if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
						return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default")
					} else if !(flags & ModifierFlagsExport) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default")
					} else if sawExportBeforeDecorators {
						return grammarErrorOnNode(firstDecorator, Diagnostics.Decorators_are_not_valid_here)
					}
					flags |= ModifierFlagsDefault
					break
				case SyntaxKindDeclareKeyword:
					if flags & ModifierFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare")
					} else if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
					} else if flags & ModifierFlagsOverride {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override")
					} else if isClassLike(node.parent) && !isPropertyDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare")
					} else if blockScopeKind == NodeFlagsUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare")
					} else if blockScopeKind == NodeFlagsAwaitUsing {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare")
					} else if (node.parent.flags & NodeFlagsAmbient) && node.parent.kind == SyntaxKindModuleBlock {
						return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context)
					} else if isPrivateIdentifierClassElementDeclaration(node) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare")
					} else if flags & ModifierFlagsAccessor {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor")
					}
					flags |= ModifierFlagsAmbient
					lastDeclare = modifier
					break
				case SyntaxKindAbstractKeyword:
					if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract")
					}
					if node.kind != SyntaxKindClassDeclaration && node.kind != SyntaxKindConstructorType {
						if node.kind != SyntaxKindMethodDeclaration && node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindGetAccessor && node.kind != SyntaxKindSetAccessor {
							return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration)
						}
						if !(node.parent.kind == SyntaxKindClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlagsAbstract)) {
							message := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.PropertyDeclaration ? Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class : Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class */ TODO
							return grammarErrorOnNode(modifier, message)
						}
						if flags & ModifierFlagsStatic {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
						}
						if flags & ModifierFlagsPrivate {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract")
						}
						if flags&ModifierFlagsAsync && lastAsync {
							return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
						}
						if flags & ModifierFlagsOverride {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override")
						}
						if flags & ModifierFlagsAccessor {
							return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor")
						}
					}
					if isNamedDeclaration(node) && node.name.kind == SyntaxKindPrivateIdentifier {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract")
					}
					flags |= ModifierFlagsAbstract
					break
				case SyntaxKindAsyncKeyword:
					if flags & ModifierFlagsAsync {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async")
					} else if flags&ModifierFlagsAmbient || node.parent.flags&NodeFlagsAmbient {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
					} else if node.kind == SyntaxKindParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async")
					}
					if flags & ModifierFlagsAbstract {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
					}
					flags |= ModifierFlagsAsync
					lastAsync = modifier
					break
				case SyntaxKindInKeyword:
					fallthrough // TODO: merge cases
				case SyntaxKindOutKeyword:
					inOutFlag := /* TODO(Node ConditionalExpression): modifier.kind === SyntaxKind.InKeyword ? ModifierFlags.In : ModifierFlags.Out */ TODO
					inOutText := /* TODO(Node ConditionalExpression): modifier.kind === SyntaxKind.InKeyword ? "in" : "out" */ TODO
					parent := isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent). /*?*/ tags, isJSDocTypedefTag)) || node.parent
					if node.kind != SyntaxKindTypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText)
					}
					if flags & inOutFlag {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText)
					}
					if inOutFlag&ModifierFlagsIn && flags&ModifierFlagsOut {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out")
					}
					flags |= inOutFlag
					break
				}
			}
		}
		if node.kind == SyntaxKindConstructor {
			if flags & ModifierFlagsStatic {
				return grammarErrorOnNode(lastStatic, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static")
			}
			if flags & ModifierFlagsOverride {
				return grammarErrorOnNode(lastOverride, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override")
			}
			if flags & ModifierFlagsAsync {
				return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async")
			}
			return false
		} else if (node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration) && flags&ModifierFlagsAmbient {
			return grammarErrorOnNode(lastDeclare, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare")
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && isBindingPattern(node.name) {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern)
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && node.dotDotDotToken {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter)
		}
		if flags & ModifierFlagsAsync {
			return checkGrammarAsyncModifier(node, lastAsync)
		}
		return false
	}
	reportObviousModifierErrors := func(node /* TODO(TypeNode UnionType): HasModifiers | HasIllegalModifiers */ any) *bool {
		if !node.modifiers {
			return false
		}
		modifier := findFirstIllegalModifier(node)
		return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here)
	}
	findFirstModifierExcept := func(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
		modifier := find(node.modifiers, isModifier)
		// converted from conditional expression
		switch {
		case modifier && modifier.kind != allowedModifier:
			return modifier
		default:
			return nil
		}
	}
	findFirstIllegalModifier := func(node /* TODO(TypeNode UnionType): HasModifiers | HasIllegalModifiers */ any) *Modifier {
		switch node.kind {
		case SyntaxKindGetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindSetAccessor:
			fallthrough // TODO: merge cases
		case SyntaxKindConstructor:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertySignature:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMethodSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindIndexSignature:
			fallthrough // TODO: merge cases
		case SyntaxKindModuleDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindImportDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindImportEqualsDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindExportDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindExportAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			fallthrough // TODO: merge cases
		case SyntaxKindParameter:
			fallthrough // TODO: merge cases
		case SyntaxKindTypeParameter:
			return nil
		case SyntaxKindClassStaticBlockDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindPropertyAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindShorthandPropertyAssignment:
			fallthrough // TODO: merge cases
		case SyntaxKindNamespaceExportDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindMissingDeclaration:
			return find(node.modifiers, isModifier)
		default:
			if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				return nil
			}
			switch node.kind {
			case SyntaxKindFunctionDeclaration:
				return findFirstModifierExcept(node, SyntaxKindAsyncKeyword)
			case SyntaxKindClassDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindConstructorType:
				return findFirstModifierExcept(node, SyntaxKindAbstractKeyword)
			case SyntaxKindClassExpression:
				fallthrough // TODO: merge cases
			case SyntaxKindInterfaceDeclaration:
				fallthrough // TODO: merge cases
			case SyntaxKindTypeAliasDeclaration:
				return find(node.modifiers, isModifier)
			case SyntaxKindVariableStatement:
				// converted from conditional expression
				switch {
				case node.declarationList.flags & NodeFlagsUsing:
					return findFirstModifierExcept(node, SyntaxKindAwaitKeyword)
				default:
					return find(node.modifiers, isModifier)
				}
			case SyntaxKindEnumDeclaration:
				return findFirstModifierExcept(node, SyntaxKindConstKeyword)
			default:
				Debug.assertNever(node)
			}
		}
	}
	reportObviousDecoratorErrors := func(node /* TODO(TypeNode UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) /* TODO inferred type boolean | undefined */ any {
		decorator := findFirstIllegalDecorator(node)
		return decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here)
	}
	findFirstIllegalDecorator := func(node /* TODO(TypeNode UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
		// converted from conditional expression
		switch {
		case canHaveIllegalDecorators(node):
			return find(node.modifiers, isDecorator)
		default:
			return nil
		}
	}
	checkGrammarAsyncModifier := func(node Node, asyncModifier Node) bool {
		switch node.kind {
		case SyntaxKindMethodDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionDeclaration:
			fallthrough // TODO: merge cases
		case SyntaxKindFunctionExpression:
			fallthrough // TODO: merge cases
		case SyntaxKindArrowFunction:
			return false
		}
		return grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async")
	}
	checkGrammarForDisallowedTrailingComma := func(list *NodeArray[Node], diag /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ any /*  = Diagnostics.Trailing_comma_not_allowed */) bool {
		if list && list.hasTrailingComma {
			return grammarErrorAtPos(list[0], list.end-",".length, ",".length, diag)
		}
		return false
	}
	checkGrammarTypeParameterList := func(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
		if typeParameters && typeParameters.length == 0 {
			start := typeParameters.pos - "<".length
			end := skipTrivia(file.text, typeParameters.end) + ">".length
			return grammarErrorAtPos(file, start, end-start, Diagnostics.Type_parameter_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarParameterList := func(parameters NodeArray[ParameterDeclaration]) /* TODO inferred type boolean | undefined */ any {
		seenOptionalParameter := false
		parameterCount := parameters.length
		for i := 0; i < parameterCount; i++ {
			parameter := parameters[i]
			if parameter.dotDotDotToken {
				if i != (parameterCount - 1) {
					return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
				}
				if !(parameter.flags & NodeFlagsAmbient) {
					checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				}
				if parameter.questionToken {
					return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional)
				}
				if parameter.initializer {
					return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer)
				}
			} else if hasEffectiveQuestionToken(parameter) {
				seenOptionalParameter = true
				if parameter.questionToken && parameter.initializer {
					return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer)
				}
			} else if seenOptionalParameter && !parameter.initializer {
				return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter)
			}
		}
	}
	getNonSimpleParameters := func(parameters []ParameterDeclaration) []ParameterDeclaration {
		return filter(parameters, func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any) /* TODO inferred type boolean */ any {
			return !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter)
		})
	}
	checkGrammarForUseStrictSimpleParameterList := func(node FunctionLikeDeclaration) bool {
		if languageVersion >= ScriptTargetES2016 {
			useStrictDirective := node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements)
			if useStrictDirective {
				nonSimpleParameters := getNonSimpleParameters(node.parameters)
				if length(nonSimpleParameters) {
					forEach(nonSimpleParameters, func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any) {
						addRelatedInfo(error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here))
					})
					diagnostics := nonSimpleParameters.map_(func(parameter /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any, index /* TODO inferred type number */ any) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ any {
						return ( /* TODO(Node ConditionalExpression): index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here) */ TODO)
					})
					addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), diagnostics...)
					return true
				}
			}
		}
		return false
	}
	checkGrammarFunctionLikeDeclaration := func(node /* TODO(TypeNode UnionType): FunctionLikeDeclaration | MethodSignature */ any) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) || checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file) || (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node))
	}
	checkGrammarClassLikeDeclaration := func(node ClassLikeDeclaration) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file)
	}
	checkGrammarArrowFunction := func(node Node, file SourceFile) bool {
		if !isArrowFunction(node) {
			return false
		}
		if node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint) {
			if file && fileExtensionIsOneOf(file.fileName, [] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Extension */ any{ExtensionMts, ExtensionCts}) {
				grammarErrorOnNode(node.typeParameters[0], Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint)
			}
		}
		TODO_IDENTIFIER := node
		startLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line
		endLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line
		return startLine != endLine && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow)
	}
	checkGrammarIndexSignatureParameters := func(node SignatureDeclaration) bool {
		parameter := node.parameters[0]
		if node.parameters.length != 1 {
			if parameter {
				return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			} else {
				return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			}
		}
		checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma)
		if parameter.dotDotDotToken {
			return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter)
		}
		if hasEffectiveModifiers(parameter) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier)
		}
		if parameter.questionToken {
			return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark)
		}
		if parameter.initializer {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer)
		}
		if !parameter.type_ {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation)
		}
		type_ := getTypeFromTypeNode(parameter.type_)
		if someType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
			return !!(t.flags & TypeFlagsStringOrNumberLiteralOrUnique)
		}) || isGenericType(type_) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead)
		}
		if !everyType(type_, isValidIndexKeyType) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type)
		}
		if !node.type_ {
			return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation)
		}
		return false
	}
	checkGrammarIndexSignature := func(node IndexSignatureDeclaration) /* TODO inferred type boolean */ any {
		return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node)
	}
	checkGrammarForAtLeastOneTypeArgument := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		if typeArguments && typeArguments.length == 0 {
			sourceFile := getSourceFileOfNode(node)
			start := typeArguments.pos - "<".length
			end := skipTrivia(sourceFile.text, typeArguments.end) + ">".length
			return grammarErrorAtPos(sourceFile, start, end-start, Diagnostics.Type_argument_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarTypeArguments := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments)
	}
	checkGrammarTaggedTemplateChain := func(node TaggedTemplateExpression) bool {
		if node.questionDotToken || node.flags&NodeFlagsOptionalChain {
			return grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain)
		}
		return false
	}
	checkGrammarHeritageClause := func(node HeritageClause) bool {
		types := node.types
		if checkGrammarForDisallowedTrailingComma(types) {
			return true
		}
		if types && types.length == 0 {
			listType := tokenToString(node.token)
			return grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType)
		}
		return some(types, checkGrammarExpressionWithTypeArguments)
	}
	checkGrammarExpressionWithTypeArguments := func(node /* TODO(TypeNode UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO inferred type boolean */ any {
		if isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		return checkGrammarTypeArguments(node, node.typeArguments)
	}
	checkGrammarClassDeclarationHeritageClauses := func(node ClassLikeDeclaration) /* TODO inferred type boolean | undefined */ any {
		seenExtendsClause := false
		seenImplementsClause := false
		if !checkGrammarModifiers(node) && node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause)
					}
					if heritageClause.types.length > 1 {
						return grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen)
					}
					seenImplementsClause = true
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
	}
	checkGrammarInterfaceDeclaration := func(node InterfaceDeclaration) /* TODO inferred type boolean */ any {
		seenExtendsClause := false
		if node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause)
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
		return false
	}
	checkGrammarComputedPropertyName := func(node Node) bool {
		if node.kind != SyntaxKindComputedPropertyName {
			return false
		}
		computedPropertyName := node
		if computedPropertyName.expression.kind == SyntaxKindBinaryExpression && (computedPropertyName.expression).operatorToken.kind == SyntaxKindCommaToken {
			return grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name)
		}
		return false
	}
	checkGrammarForGenerator := func(node FunctionLikeDeclaration) /* TODO inferred type boolean | undefined */ any {
		if node.asteriskToken {
			Debug.assert(node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindMethodDeclaration)
			if node.flags & NodeFlagsAmbient {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context)
			}
			if !node.body {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator)
			}
		}
	}
	checkGrammarForInvalidQuestionMark := func(questionToken *QuestionToken, message DiagnosticMessage) bool {
		return !!questionToken && grammarErrorOnNode(questionToken, message)
	}
	checkGrammarForInvalidExclamationToken := func(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
		return !!exclamationToken && grammarErrorOnNode(exclamationToken, message)
	}
	checkGrammarObjectLiteralExpression := func(node ObjectLiteralExpression, inDestructuring bool) /* TODO inferred type boolean | undefined */ any {
		seen := make(map[__String]DeclarationMeaning)
		for _, prop := range node.properties {
			if prop.kind == SyntaxKindSpreadAssignment {
				if inDestructuring {
					expression := skipParentheses(prop.expression)
					if isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression) {
						return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern)
					}
				}
				continue
			}
			name := prop.name
			if name.kind == SyntaxKindComputedPropertyName {
				checkGrammarComputedPropertyName(name)
			}
			if prop.kind == SyntaxKindShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer {
				grammarErrorOnNode(prop.equalsToken, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern)
			}
			if name.kind == SyntaxKindPrivateIdentifier {
				grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
			}
			if canHaveModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) && (mod.kind != SyntaxKindAsyncKeyword || prop.kind != SyntaxKindMethodDeclaration) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			} else if canHaveIllegalModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			}
			var currentKind DeclarationMeaning
			switch prop.kind {
			case SyntaxKindShorthandPropertyAssignment:
				fallthrough // TODO: merge cases
			case SyntaxKindPropertyAssignment:
				checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)
				checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional)
				if name.kind == SyntaxKindNumericLiteral {
					checkGrammarNumericLiteral(name)
				}
				if name.kind == SyntaxKindBigIntLiteral {
					addErrorOrSuggestion(true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name))
				}
				currentKind = DeclarationMeaningPropertyAssignment
				break
			case SyntaxKindMethodDeclaration:
				currentKind = DeclarationMeaningMethod
				break
			case SyntaxKindGetAccessor:
				currentKind = DeclarationMeaningGetAccessor
				break
			case SyntaxKindSetAccessor:
				currentKind = DeclarationMeaningSetAccessor
				break
			default:
				Debug.assertNever(prop, "Unexpected syntax kind:"+(prop).kind)
			}
			if !inDestructuring {
				effectiveName := getEffectivePropertyNameForPropertyNameNode(name)
				if effectiveName == nil {
					continue
				}
				existingKind := seen.get(effectiveName)
				if !existingKind {
					seen.set(effectiveName, currentKind)
				} else {
					if (currentKind & DeclarationMeaningMethod) && (existingKind & DeclarationMeaningMethod) {
						grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningPropertyAssignment) && (existingKind & DeclarationMeaningPropertyAssignment) {
						grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningGetOrSetAccessor) && (existingKind & DeclarationMeaningGetOrSetAccessor) {
						if existingKind != DeclarationMeaningGetOrSetAccessor && currentKind != existingKind {
							seen.set(effectiveName, currentKind|existingKind)
						} else {
							return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name)
						}
					} else {
						return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name)
					}
				}
			}
		}
	}
	checkGrammarJsxElement := func(node JsxOpeningLikeElement) /* TODO inferred type boolean | undefined */ any {
		checkGrammarJsxName(node.tagName)
		checkGrammarTypeArguments(node, node.typeArguments)
		seen := make(map[__String]bool)
		for _, attr := range node.attributes.properties {
			if attr.kind == SyntaxKindJsxSpreadAttribute {
				continue
			}
			TODO_IDENTIFIER := attr
			escapedText := getEscapedTextOfJsxAttributeName(name)
			if !seen.get(escapedText) {
				seen.set(escapedText, true)
			} else {
				return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name)
			}
			if initializer && initializer.kind == SyntaxKindJsxExpression && !initializer.expression {
				return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression)
			}
		}
	}
	checkGrammarJsxName := func(node JsxTagNameExpression) /* TODO inferred type boolean | undefined */ any {
		if isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names)
		}
		if isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText) {
			return grammarErrorOnNode(node, Diagnostics.React_components_cannot_include_JSX_namespace_names)
		}
	}
	checkGrammarJsxExpression := func(node JsxExpression) /* TODO inferred type boolean | undefined */ any {
		if node.expression && isCommaSequence(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array)
		}
	}
	checkGrammarForInOrForOfStatement := func(forInOrOfStatement ForInOrOfStatement) bool {
		if checkGrammarStatementInAmbientContext(forInOrOfStatement) {
			return true
		}
		if forInOrOfStatement.kind == SyntaxKindForOfStatement && forInOrOfStatement.awaitModifier {
			if !(forInOrOfStatement.flags & NodeFlagsAwaitContext) {
				sourceFile := getSourceFileOfNode(forInOrOfStatement)
				if isInTopLevelContext(forInOrOfStatement) {
					if !hasParseDiagnostics(sourceFile) {
						if !isEffectiveExternalModule(sourceFile, compilerOptions) {
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module))
						}
						switch moduleKind {
						case ModuleKindNode16:
							fallthrough // TODO: merge cases
						case ModuleKindNodeNext:
							if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
								diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
								break
							}
							fallthrough
						case ModuleKindES2022:
							fallthrough // TODO: merge cases
						case ModuleKindESNext:
							fallthrough // TODO: merge cases
						case ModuleKindPreserve:
							fallthrough // TODO: merge cases
						case ModuleKindSystem:
							if languageVersion >= ScriptTargetES2017 {
								break
							}
							fallthrough
						default:
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher))
							break
						}
					}
				} else {
					if !hasParseDiagnostics(sourceFile) {
						diagnostic := createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules)
						func_ := getContainingFunction(forInOrOfStatement)
						if func_ && func_.kind != SyntaxKindConstructor {
							Debug.assert((getFunctionFlags(func_)&FunctionFlagsAsync) == 0, "Enclosing function should never be an async function.")
							relatedInfo := createDiagnosticForNode(func_, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
							addRelatedInfo(diagnostic, relatedInfo)
						}
						diagnostics.add(diagnostic)
						return true
					}
				}
			}
		}
		if isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlagsAwaitContext) && isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText == "async" {
			grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async)
			return false
		}
		if forInOrOfStatement.initializer.kind == SyntaxKindVariableDeclarationList {
			variableList := forInOrOfStatement.initializer
			if !checkGrammarVariableDeclarationList(variableList) {
				declarations := variableList.declarations
				if !declarations.length {
					return false
				}
				if declarations.length > 1 {
					diagnostic := /* TODO(Node ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement */ TODO
					return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic)
				}
				firstDeclaration := declarations[0]
				if firstDeclaration.initializer {
					diagnostic := /* TODO(Node ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer */ TODO
					return grammarErrorOnNode(firstDeclaration.name, diagnostic)
				}
				if firstDeclaration.type_ {
					diagnostic := /* TODO(Node ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation */ TODO
					return grammarErrorOnNode(firstDeclaration, diagnostic)
				}
			}
		}
		return false
	}
	checkGrammarAccessor := func(accessor AccessorDeclaration) bool {
		if !(accessor.flags & NodeFlagsAmbient) && (accessor.parent.kind != SyntaxKindTypeLiteral) && (accessor.parent.kind != SyntaxKindInterfaceDeclaration) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(accessor.name) {
				return grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if accessor.body == nil && !hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorAtPos(accessor, accessor.end-1, ";".length, Diagnostics._0_expected, "{")
			}
		}
		if accessor.body {
			if hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation)
			}
			if accessor.parent.kind == SyntaxKindTypeLiteral || accessor.parent.kind == SyntaxKindInterfaceDeclaration {
				return grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
			}
		}
		if accessor.typeParameters {
			return grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters)
		}
		if !doesAccessorHaveCorrectParameterCount(accessor) {
			return grammarErrorOnNode(accessor.name /* TODO(Node ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? Diagnostics.A_get_accessor_cannot_have_parameters : Diagnostics.A_set_accessor_must_have_exactly_one_parameter */, TODO)
		}
		if accessor.kind == SyntaxKindSetAccessor {
			if accessor.type_ {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation)
			}
			parameter := Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
			if parameter.dotDotDotToken {
				return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter)
			}
			if parameter.questionToken {
				return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter)
			}
			if parameter.initializer {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer)
			}
		}
		return false
	}
	doesAccessorHaveCorrectParameterCount := func(accessor AccessorDeclaration) /* TODO inferred type boolean | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ any {
		return getAccessorThisParameter(accessor) || accessor.parameters.length == ( /* TODO(Node ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? 0 : 1 */ TODO)
	}
	getAccessorThisParameter := func(accessor AccessorDeclaration) *ParameterDeclaration {
		if accessor.parameters.length == ( /* TODO(Node ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? 1 : 2 */ TODO) {
			return getThisParameter(accessor)
		}
	}
	checkGrammarTypeOperatorNode := func(node TypeOperatorNode) /* TODO inferred type boolean | undefined */ any {
		if node.operator == SyntaxKindUniqueKeyword {
			if node.type_.kind != SyntaxKindSymbolKeyword {
				return grammarErrorOnNode(node.type_, Diagnostics._0_expected, tokenToString(SyntaxKindSymbolKeyword))
			}
			parent := walkUpParenthesizedTypes(node.parent)
			if isInJSFile(parent) && isJSDocTypeExpression(parent) {
				host := getJSDocHost(parent)
				if host {
					parent = getSingleVariableOfVariableStatement(host) || host
				}
			}
			switch parent.kind {
			case SyntaxKindVariableDeclaration:
				decl := parent
				if decl.name.kind != SyntaxKindIdentifier {
					return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name)
				}
				if !isVariableDeclarationInVariableStatement(decl) {
					return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement)
				}
				if !(decl.parent.flags & NodeFlagsConst) {
					return grammarErrorOnNode((parent).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const)
				}
				break
			case SyntaxKindPropertyDeclaration:
				if !isStatic(parent) || !hasEffectiveReadonlyModifier(parent) {
					return grammarErrorOnNode((parent).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly)
				}
				break
			case SyntaxKindPropertySignature:
				if !hasSyntacticModifier(parent, ModifierFlagsReadonly) {
					return grammarErrorOnNode((parent).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly)
				}
				break
			default:
				return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here)
			}
		} else if node.operator == SyntaxKindReadonlyKeyword {
			if node.type_.kind != SyntaxKindArrayType && node.type_.kind != SyntaxKindTupleType {
				return grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(SyntaxKindSymbolKeyword))
			}
		}
	}
	checkGrammarForInvalidDynamicName := func(node DeclarationName, message DiagnosticMessage) /* TODO inferred type boolean | undefined */ any {
		if isNonBindableDynamicName(node) {
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarMethod := func(node /* TODO(TypeNode UnionType): MethodDeclaration | MethodSignature */ any) /* TODO inferred type boolean | undefined */ any {
		if checkGrammarFunctionLikeDeclaration(node) {
			return true
		}
		if node.kind == SyntaxKindMethodDeclaration {
			if node.parent.kind == SyntaxKindObjectLiteralExpression {
				if node.modifiers && !(node.modifiers.length == 1 && first(node.modifiers).kind == SyntaxKindAsyncKeyword) {
					return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here)
				} else if checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional) {
					return true
				} else if checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context) {
					return true
				} else if node.body == nil {
					return grammarErrorAtPos(node, node.end-1, ";".length, Diagnostics._0_expected, "{")
				}
			}
			if checkGrammarForGenerator(node) {
				return true
			}
		}
		if isClassLike(node.parent) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if node.flags & NodeFlagsAmbient {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			} else if node.kind == SyntaxKindMethodDeclaration && !node.body {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		} else if node.parent.kind == SyntaxKindTypeLiteral {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		}
	}
	checkGrammarBreakOrContinueStatement := func(node BreakOrContinueStatement) bool {
		var current Node = node
		for current {
			if isFunctionLikeOrClassStaticBlockDeclaration(current) {
				return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary)
			}
			switch current.kind {
			case SyntaxKindLabeledStatement:
				if node.label && (current).label.escapedText == node.label.escapedText {
					isMisplacedContinueLabel := node.kind == SyntaxKindContinueStatement && !isIterationStatement((current).statement, true)
					if isMisplacedContinueLabel {
						return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement)
					}
					return false
				}
				break
			case SyntaxKindSwitchStatement:
				if node.kind == SyntaxKindBreakStatement && !node.label {
					return false
				}
				break
			default:
				if isIterationStatement(current, false) && !node.label {
					return false
				}
				break
			}
			current = current.parent
		}
		if node.label {
			message := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.BreakStatement ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		} else {
			message := /* TODO(Node ConditionalExpression): node.kind === SyntaxKind.BreakStatement ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarBindingElement := func(node BindingElement) /* TODO inferred type boolean | undefined */ any {
		if node.dotDotDotToken {
			elements := node.parent.elements
			if node != last(elements) {
				return grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			}
			checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
			if node.propertyName {
				return grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name)
			}
		}
		if node.dotDotDotToken && node.initializer {
			return grammarErrorAtPos(node, node.initializer.pos-1, 1, Diagnostics.A_rest_element_cannot_have_an_initializer)
		}
	}
	isStringOrNumberLiteralExpression := func(expr Expression) /* TODO inferred type boolean */ any {
		return isStringOrNumericLiteralLike(expr) || expr.kind == SyntaxKindPrefixUnaryExpression && (expr).operator == SyntaxKindMinusToken && (expr).operand.kind == SyntaxKindNumericLiteral
	}
	isBigIntLiteralExpression := func(expr Expression) /* TODO inferred type boolean */ any {
		return expr.kind == SyntaxKindBigIntLiteral || expr.kind == SyntaxKindPrefixUnaryExpression && (expr).operator == SyntaxKindMinusToken && (expr).operand.kind == SyntaxKindBigIntLiteral
	}
	isSimpleLiteralEnumReference := func(expr Expression) /* TODO inferred type boolean | undefined */ any {
		if (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) && isEntityNameExpression(expr.expression) {
			return !!(checkExpressionCached(expr).flags & TypeFlagsEnumLike)
		}
	}
	checkAmbientInitializer := func(node /* TODO(TypeNode UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature */ any) /* TODO inferred type boolean | undefined */ any {
		initializer := node.initializer
		if initializer {
			isInvalidInitializer := !(isStringOrNumberLiteralExpression(initializer) || isSimpleLiteralEnumReference(initializer) || initializer.kind == SyntaxKindTrueKeyword || initializer.kind == SyntaxKindFalseKeyword || isBigIntLiteralExpression(initializer))
			isConstOrReadonly := isDeclarationReadonly(node) || isVariableDeclaration(node) && (isVarConstLike(node))
			if isConstOrReadonly && !node.type_ {
				if isInvalidInitializer {
					return grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference)
				}
			} else {
				return grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts)
			}
		}
	}
	checkGrammarVariableDeclaration := func(node VariableDeclaration) /* TODO inferred type boolean */ any {
		nodeFlags := getCombinedNodeFlagsCached(node)
		blockScopeKind := nodeFlags & NodeFlagsBlockScoped
		if isBindingPattern(node.name) {
			switch blockScopeKind {
			case NodeFlagsAwaitUsing:
				return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using")
			case NodeFlagsUsing:
				return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using")
			}
		}
		if node.parent.parent.kind != SyntaxKindForInStatement && node.parent.parent.kind != SyntaxKindForOfStatement {
			if nodeFlags & NodeFlagsAmbient {
				checkAmbientInitializer(node)
			} else if !node.initializer {
				if isBindingPattern(node.name) && !isBindingPattern(node.parent) {
					return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer)
				}
				switch blockScopeKind {
				case NodeFlagsAwaitUsing:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using")
				case NodeFlagsUsing:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using")
				case NodeFlagsConst:
					return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const")
				}
			}
		}
		if node.exclamationToken && (node.parent.parent.kind != SyntaxKindVariableStatement || !node.type_ || node.initializer || nodeFlags&NodeFlagsAmbient) {
			message := /* TODO(Node ConditionalExpression): node.initializer ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions : !node.type ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode(node.exclamationToken, message)
		}
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && !(node.parent.parent.flags & NodeFlagsAmbient) && hasSyntacticModifier(node.parent.parent, ModifierFlagsExport) {
			checkESModuleMarker(node.name)
		}
		return !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations(node.name)
	}
	checkESModuleMarker := func(name /* TODO(TypeNode UnionType): Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if idText(name) == "__esModule" {
				return grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					return checkESModuleMarker(element.name)
				}
			}
		}
		return false
	}
	checkGrammarNameInLetOrConstDeclarations := func(name /* TODO(TypeNode UnionType): Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if name.escapedText == "let" {
				return grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					checkGrammarNameInLetOrConstDeclarations(element.name)
				}
			}
		}
		return false
	}
	checkGrammarVariableDeclarationList := func(declarationList VariableDeclarationList) bool {
		declarations := declarationList.declarations
		if checkGrammarForDisallowedTrailingComma(declarationList.declarations) {
			return true
		}
		if !declarationList.declarations.length {
			return grammarErrorAtPos(declarationList, declarations.pos, declarations.end-declarations.pos, Diagnostics.Variable_declaration_list_cannot_be_empty)
		}
		blockScopeFlags := declarationList.flags & NodeFlagsBlockScoped
		if (blockScopeFlags == NodeFlagsUsing || blockScopeFlags == NodeFlagsAwaitUsing) && isForInStatement(declarationList.parent) {
			return grammarErrorOnNode(declarationList /* TODO(Node ConditionalExpression): blockScopeFlags === NodeFlags.Using ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration : Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration */, TODO)
		}
		if blockScopeFlags == NodeFlagsAwaitUsing {
			return checkAwaitGrammar(declarationList)
		}
		return false
	}
	allowLetAndConstDeclarations := func(parent Node) bool {
		switch parent.kind {
		case SyntaxKindIfStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindDoStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindWhileStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindWithStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindForStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindForInStatement:
			fallthrough // TODO: merge cases
		case SyntaxKindForOfStatement:
			return false
		case SyntaxKindLabeledStatement:
			return allowLetAndConstDeclarations(parent.parent)
		}
		return true
	}
	checkGrammarForDisallowedBlockScopedVariableStatement := func(node VariableStatement) /* TODO inferred type boolean | undefined */ any {
		if !allowLetAndConstDeclarations(node.parent) {
			blockScopeKind := getCombinedNodeFlagsCached(node.declarationList) & NodeFlagsBlockScoped
			if blockScopeKind {
				keyword := /* TODO(Node ConditionalExpression): blockScopeKind === NodeFlags.Let ? "let" : blockScopeKind === NodeFlags.Const ? "const" : blockScopeKind === NodeFlags.Using ? "using" : blockScopeKind === NodeFlags.AwaitUsing ? "await using" : Debug.fail("Unknown BlockScope flag") */ TODO
				return grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword)
			}
		}
	}
	checkGrammarMetaProperty := func(node MetaProperty) /* TODO inferred type boolean | undefined */ any {
		escapedText := node.name.escapedText
		switch node.keywordToken {
		case SyntaxKindNewKeyword:
			if escapedText != "target" {
				return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target")
			}
			break
		case SyntaxKindImportKeyword:
			if escapedText != "meta" {
				return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta")
			}
			break
		}
	}
	hasParseDiagnostics := func(sourceFile SourceFile) bool {
		return sourceFile.parseDiagnostics.length > 0
	}
	grammarErrorOnFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message, args...))
			return true
		}
		return false
	}
	grammarErrorAtPos := func(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(nodeForSourceFile)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, args...))
			return true
		}
		return false
	}
	grammarErrorOnNodeSkippedOn := func(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			errorSkippedOn(key, node, message, args...)
			return true
		}
		return false
	}
	grammarErrorOnNode := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createDiagnosticForNode(node, message, args...))
			return true
		}
		return false
	}
	checkGrammarConstructorTypeParameters := func(node ConstructorDeclaration) /* TODO inferred type boolean | undefined */ any {
		jsdocTypeParameters := /* TODO(Node ConditionalExpression): isInJSFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined */ TODO
		range_ := node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters)
		if range_ {
			pos := /* TODO(Node ConditionalExpression): range.pos === range.end ? range.pos : skipTrivia(getSourceFileOfNode(node).text, range.pos) */ TODO
			return grammarErrorAtPos(node, pos, range_.end-pos, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarConstructorTypeAnnotation := func(node ConstructorDeclaration) /* TODO inferred type boolean | undefined */ any {
		type_ := node.type_ || getEffectiveReturnTypeNode(node)
		if type_ {
			return grammarErrorOnNode(type_, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarProperty := func(node /* TODO(TypeNode UnionType): PropertyDeclaration | PropertySignature */ any) /* TODO inferred type boolean | undefined */ any {
		if isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind == SyntaxKindInKeyword {
			return grammarErrorOnNode(node.parent.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
		if isClassLike(node.parent) {
			if isStringLiteral(node.name) && node.name.text == "constructor" {
				return grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor)
			}
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type) {
				return true
			}
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if languageVersion < ScriptTargetES2015 && isAutoAccessorPropertyDeclaration(node) {
				return grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional) {
				return true
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer)
			}
		} else if isTypeLiteralNode(node.parent) {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer)
			}
		}
		if node.flags & NodeFlagsAmbient {
			checkAmbientInitializer(node)
		}
		if isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type_ || node.initializer || node.flags&NodeFlagsAmbient || isStatic(node) || hasAbstractModifier(node)) {
			message := /* TODO(Node ConditionalExpression): node.initializer ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions : !node.type ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode(node.exclamationToken, message)
		}
	}
	checkGrammarTopLevelElementForRequiredDeclareModifier := func(node Node) bool {
		if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindTypeAliasDeclaration || node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindExportDeclaration || node.kind == SyntaxKindExportAssignment || node.kind == SyntaxKindNamespaceExportDeclaration || hasSyntacticModifier(node, ModifierFlagsAmbient|ModifierFlagsExport|ModifierFlagsDefault) {
			return false
		}
		return grammarErrorOnFirstToken(node, Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier)
	}
	checkGrammarTopLevelElementsForRequiredDeclareModifier := func(file SourceFile) bool {
		for _, decl := range file.statements {
			if isDeclaration(decl) || decl.kind == SyntaxKindVariableStatement {
				if checkGrammarTopLevelElementForRequiredDeclareModifier(decl) {
					return true
				}
			}
		}
		return false
	}
	checkGrammarSourceFile := func(node SourceFile) bool {
		return !!(node.flags & NodeFlagsAmbient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node)
	}
	checkGrammarStatementInAmbientContext := func(node Node) bool {
		if node.flags & NodeFlagsAmbient {
			links := getNodeLinks(node)
			if !links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent)) {
				getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
				return getNodeLinks(node).hasReportedStatementInAmbientContext
			}
			if node.parent.kind == SyntaxKindBlock || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				links := getNodeLinks(node.parent)
				if !links.hasReportedStatementInAmbientContext {
					links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts)
					return links.hasReportedStatementInAmbientContext
				}
			} else {
			}
		}
		return false
	}
	checkGrammarNumericLiteral := func(node NumericLiteral) {
		isFractional := getTextOfNode(node).includes(".")
		isScientific := node.numericLiteralFlags & TokenFlagsScientific
		if isFractional || isScientific {
			return
		}
		value := +node.text
		if value <= /* TODO(Node BinaryExpression): 2 ** 53 */ TODO-1 {
			return
		}
		addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers))
	}
	checkGrammarBigIntLiteral := func(node BigIntLiteral) bool {
		literalType := isLiteralTypeNode(node.parent) || isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent)
		if !literalType {
			if languageVersion < ScriptTargetES2020 {
				if grammarErrorOnNode(node, Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020) {
					return true
				}
			}
		}
		return false
	}
	grammarErrorAfterFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span), 0, message, args...))
			return true
		}
		return false
	}
	getAmbientModules := func() []Symbol {
		if !ambientModulesCache {
			ambientModulesCache = [] /* TODO inferred type never */ any{}
			globals.forEach(func(global /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any, sym /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ any) {
				if ambientModuleSymbolRegex.test(sym) {
					ambientModulesCache.push(global)
				}
			})
		}
		return ambientModulesCache
	}
	checkGrammarImportClause := func(node ImportClause) bool {
		if node.isTypeOnly && node.name && node.namedBindings {
			return grammarErrorOnNode(node, Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both)
		}
		if node.isTypeOnly && node.namedBindings. /*?*/ kind == SyntaxKindNamedImports {
			return checkGrammarNamedImportsOrExports(node.namedBindings)
		}
		return false
	}
	checkGrammarNamedImportsOrExports := func(namedBindings NamedImportsOrExports) bool {
		return !!forEach(namedBindings.elements, func(specifier /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ImportSpecifier | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ any) /* TODO inferred type boolean | undefined */ any {
			if specifier.isTypeOnly {
				return grammarErrorOnFirstToken(specifier /* TODO(Node ConditionalExpression): specifier.kind === SyntaxKind.ImportSpecifier ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement */, TODO)
			}
		})
	}
	checkGrammarImportCallExpression := func(node ImportCall) bool {
		if compilerOptions.verbatimModuleSyntax && moduleKind == ModuleKindCommonJS {
			return grammarErrorOnNode(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		if moduleKind == ModuleKindES2015 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext)
		}
		if node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		nodeArguments := node.arguments
		if moduleKind != ModuleKindESNext && moduleKind != ModuleKindNodeNext && moduleKind != ModuleKindNode16 && moduleKind != ModuleKindPreserve {
			checkGrammarForDisallowedTrailingComma(nodeArguments)
			if nodeArguments.length > 1 {
				importAttributesArgument := nodeArguments[1]
				return grammarErrorOnNode(importAttributesArgument, Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve)
			}
		}
		if nodeArguments.length == 0 || nodeArguments.length > 2 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments)
		}
		spreadElement := find(nodeArguments, isSpreadElement)
		if spreadElement {
			return grammarErrorOnNode(spreadElement, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element)
		}
		return false
	}
	findMatchingTypeReferenceOrTypeAliasReference := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		sourceObjectFlags := getObjectFlags(source)
		if sourceObjectFlags&(ObjectFlagsReference|ObjectFlagsAnonymous) && unionTarget.flags&TypeFlagsUnion {
			return find(unionTarget.types, func(target /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				if target.flags & TypeFlagsObject {
					overlapObjFlags := sourceObjectFlags & getObjectFlags(target)
					if overlapObjFlags & ObjectFlagsReference {
						return (source).target == (target).target
					}
					if overlapObjFlags & ObjectFlagsAnonymous {
						return !!(source).aliasSymbol && (source).aliasSymbol == (target).aliasSymbol
					}
				}
				return false
			})
		}
	}
	findBestTypeForObjectLiteral := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if getObjectFlags(source)&ObjectFlagsObjectLiteral && someType(unionTarget, isArrayLikeType) {
			return find(unionTarget.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !isArrayLikeType(t)
			})
		}
	}
	findBestTypeForInvokable := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		signatureKind := SignatureKindCall
		hasSignatures := getSignaturesOfType(source, signatureKind).length > 0 || ( /* TODO(Node BinaryExpression): signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0 */ TODO)
		if hasSignatures {
			return find(unionTarget.types, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return getSignaturesOfType(t, signatureKind).length > 0
			})
		}
	}
	findMostOverlappyType := func(source Type, unionTarget UnionOrIntersectionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		var bestMatch *Type
		if !(source.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
			matchingCount := 0
			for _, target := range unionTarget.types {
				if !(target.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
					overlap := getIntersectionType([] /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any{getIndexType(source), getIndexType(target)})
					if overlap.flags & TypeFlagsIndex {
						return target
					} else if isUnitType(overlap) || overlap.flags&TypeFlagsUnion {
						len := /* TODO(Node ConditionalExpression): overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1 */ TODO
						if len >= matchingCount {
							bestMatch = target
							matchingCount = len
						}
					}
				}
			}
		}
		return bestMatch
	}
	filterPrimitivesIfContainsNonPrimitive := func(type_ UnionType) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
		if maybeTypeOfKind(type_, TypeFlagsNonPrimitive) {
			result := filterType(type_, func(t /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any) /* TODO inferred type boolean */ any {
				return !(t.flags & TypeFlagsPrimitive)
			})
			if !(result.flags & TypeFlagsNever) {
				return result
			}
		}
		return type_
	}
	findMatchingDiscriminantType := func(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ any {
		if target.flags&TypeFlagsUnion && source.flags&(TypeFlagsIntersection|TypeFlagsObject) {
			match := getMatchingUnionConstituentForType(target, source)
			if match {
				return match
			}
			sourceProperties := getPropertiesOfType(source)
			if sourceProperties {
				sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
				if sourcePropertiesFiltered {
					discriminated := discriminateTypeByDiscriminableItems(target, map_(sourcePropertiesFiltered, func(p /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ any) /* TODO inferred type [() => import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ any {
						return ([]TODO{func() /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ any {
							return getTypeOfSymbol(p)
						}, p.escapedName})
					}), isRelatedTo)
					if discriminated != target {
						return discriminated
					}
				}
			}
		}
		return nil
	}
	getEffectivePropertyNameForPropertyNameNode := func(node PropertyName) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ any {
		name := getPropertyNameForPropertyNameNode(node)
		// converted from conditional expression
		switch {
		case name:
			return name
		case isComputedPropertyName(node):
			return tryGetNameFromType(getTypeOfExpression(node.expression))
		default:
			return nil
		}
	}
	getCombinedModifierFlagsCached := func(node Declaration) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ any {
		if lastGetCombinedModifierFlagsNode == node {
			return lastGetCombinedModifierFlagsResult
		}
		lastGetCombinedModifierFlagsNode = node
		lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node)
		return lastGetCombinedModifierFlagsResult
	}
	getCombinedNodeFlagsCached := func(node Node) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").NodeFlags */ any {
		if lastGetCombinedNodeFlagsNode == node {
			return lastGetCombinedNodeFlagsResult
		}
		lastGetCombinedNodeFlagsNode = node
		lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node)
		return lastGetCombinedNodeFlagsResult
	}
	isVarConstLike := func(node /* TODO(TypeNode UnionType): VariableDeclaration | VariableDeclarationList */ any) /* TODO inferred type boolean */ any {
		blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
		return blockScopeKind == NodeFlagsConst || blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing
	}
	getJSXRuntimeImportSpecifier := func(file *SourceFile, specifierText string) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike | undefined */ any {
		jsxImportIndex := /* TODO(Node ConditionalExpression): compilerOptions.importHelpers ? 1 : 0 */ TODO
		specifier := file. /*?*/ imports[jsxImportIndex]
		if specifier {
			Debug.assert(nodeIsSynthesized(specifier) && specifier.text == specifierText /* TODO(Node TemplateExpression): `Expected sourceFile.imports[${jsxImportIndex}] to be the synthesized JSX runtime import` */, TODO)
		}
		return specifier
	}
	getImportHelpersImportSpecifier := func(file SourceFile) /* TODO inferred type import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike */ any {
		Debug.assert(compilerOptions.importHelpers, "Expected importHelpers to be enabled")
		specifier := file.imports[0]
		Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text == "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`)
		return specifier
	}
}
func isNotAccessor(declaration Declaration) bool {
	return !isAccessor(declaration)
}
func isNotOverload(declaration Declaration) bool {
	return (declaration.kind != SyntaxKindFunctionDeclaration && declaration.kind != SyntaxKindMethodDeclaration) || !!(declaration).body
}
func isDeclarationNameOrImportPropertyName(name Node) bool {
	switch name.parent.kind {
	case SyntaxKindImportSpecifier:
		fallthrough // TODO: merge cases
	case SyntaxKindExportSpecifier:
		return isIdentifier(name) || name.kind == SyntaxKindStringLiteral
	default:
		return isDeclarationName(name)
	}
}

/*
	 TODO(Node ModuleDeclaration): namespace JsxNames { export const JSX = "JSX" as __String; export const IntrinsicElements = "IntrinsicElements" as __String; export const ElementClass = "ElementClass" as __String; export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String; export const Element = "Element" as __String; export const ElementType = "ElementType" as __String; export const IntrinsicAttributes = "IntrinsicAttributes" as __String; export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String; export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String;
	}
*/
func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO inferred type "yieldType" | "returnType" | "nextType" */ any {
	switch typeKind {
	case IterationTypeKindYield:
		return "yieldType"
	case IterationTypeKindReturn:
		return "returnType"
	case IterationTypeKindNext:
		return "nextType"
	}
}
func signatureHasRestParameter(s Signature) /* TODO inferred type boolean */ any {
	return !!(s.flags & SignatureFlagsHasRestParameter)
}
func signatureHasLiteralTypes(s Signature) /* TODO inferred type boolean */ any {
	return !!(s.flags & SignatureFlagsHasLiteralTypes)
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
	return /* TODO(Node ObjectLiteralExpression): { getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "", getCurrentDirectory: () => host.getCurrentDirectory(), getSymlinkCache: maybeBind(host, host.getSymlinkCache), getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(), useCaseSensitiveFileNames: maybeBind(host, host.useCaseSensitiveFileNames), redirectTargetsMap: host.redirectTargetsMap, getProjectReferenceRedirect: fileName => host.getProjectReferenceRedirect(fileName), isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName), fileExists: fileName => host.fileExists(fileName), getFileIncludeReasons: () => host.getFileIncludeReasons(), readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined, getDefaultResolutionModeForFile: file => host.getDefaultResolutionModeForFile(file), getModeForResolutionAtIndex: (file, index) => host.getModeForResolutionAtIndex(file, index), } */ TODO
}

type NodeBuilderContext struct {
	enclosingDeclaration                  Node
	enclosingFile                         *SourceFile
	flags                                 NodeBuilderFlags
	internalFlags                         InternalNodeBuilderFlags
	tracker                               SymbolTrackerImpl
	encounteredError                      bool
	reportedDiagnostic                    bool
	trackedSymbols                        *[]TrackedSymbol
	visitedTypes                          *Set[number]
	symbolDepth                           *Map[string, number]
	inferTypeParameters                   *[]TypeParameter
	approximateLength                     number
	truncating                            bool
	mustCreateTypeParameterSymbolList     bool
	typeParameterSymbolList               *Set[number]
	mustCreateTypeParametersNamesLookups  bool
	typeParameterNames                    *Map[TypeId, Identifier]
	typeParameterNamesByText              *Set[string]
	typeParameterNamesByTextNextNameCount *Map[string, number]
	usedSymbolNames                       *Set[string]
	remappedSymbolNames                   *Map[SymbolId, string]
	remappedSymbolReferences              *Map[SymbolId, Symbol]
	reverseMappedStack                    *[]ReverseMappedSymbol
	bundled                               bool
	mapper                                *TypeMapper
}

/* TODO(Node ClassDeclaration): class SymbolTrackerImpl implements SymbolTracker { moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined; context: NodeBuilderContext; readonly inner: SymbolTracker | undefined = undefined; readonly canTrackSymbol: boolean; disableTrackSymbol = false; constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) { while (tracker instanceof SymbolTrackerImpl) { tracker = tracker.inner; } this.inner = tracker; this.moduleResolverHost = moduleResolverHost; this.context = context; this.canTrackSymbol = !!this.inner?.trackSymbol; } trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean { if (this.inner?.trackSymbol && !this.disableTrackSymbol) { if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) { this.onDiagnosticReported(); return true; } // Skip recording type parameters as they dont contribute to late painted statements if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]); } return false; } reportInaccessibleThisError(): void { if (this.inner?.reportInaccessibleThisError) { this.onDiagnosticReported(); this.inner.reportInaccessibleThisError(); } } reportPrivateInBaseOfClassExpression(propertyName: string): void { if (this.inner?.reportPrivateInBaseOfClassExpression) { this.onDiagnosticReported(); this.inner.reportPrivateInBaseOfClassExpression(propertyName); } } reportInaccessibleUniqueSymbolError(): void { if (this.inner?.reportInaccessibleUniqueSymbolError) { this.onDiagnosticReported(); this.inner.reportInaccessibleUniqueSymbolError(); } } reportCyclicStructureError(): void { if (this.inner?.reportCyclicStructureError) { this.onDiagnosticReported(); this.inner.reportCyclicStructureError(); } } reportLikelyUnsafeImportRequiredError(specifier: string): void { if (this.inner?.reportLikelyUnsafeImportRequiredError) { this.onDiagnosticReported(); this.inner.reportLikelyUnsafeImportRequiredError(specifier); } } reportTruncationError(): void { if (this.inner?.reportTruncationError) { this.onDiagnosticReported(); this.inner.reportTruncationError(); } } reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void { if (this.inner?.reportNonlocalAugmentation) { this.onDiagnosticReported(); this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol); } } reportNonSerializableProperty(propertyName: string): void { if (this.inner?.reportNonSerializableProperty) { this.onDiagnosticReported(); this.inner.reportNonSerializableProperty(propertyName); } } private onDiagnosticReported() { this.context.reportedDiagnostic = true; } reportInferenceFallback(node: Node): void { if (this.inner?.reportInferenceFallback) { this.inner.reportInferenceFallback(node); } }
} */
