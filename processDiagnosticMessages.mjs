// @ts-check

import cp from "child_process";
import fs from "fs";
import path from "path";
import which from "which";

/** @typedef {{
    category: string;
    code: number;
    reportsUnnecessary?: {};
    reportsDeprecated?: {};
    isEarly?: boolean;
    elidedInCompatabilityPyramid?: boolean;
}} DiagnosticDetails */
void 0;

/** @typedef {Map<string, DiagnosticDetails>} InputDiagnosticMessageTable */

const inputFilePath = "/home/jabaile/work/ts-native-pin/src/compiler/diagnosticMessages.json";
const outputFilePath = "output/diagnostics_generated.go";

async function main() {
    const inputStr = await fs.promises.readFile(inputFilePath, { encoding: "utf-8" });

    /** @type {{ [key: string]: DiagnosticDetails }} */
    const diagnosticMessagesJson = JSON.parse(inputStr);

    /** @type {InputDiagnosticMessageTable} */
    const diagnosticMessages = new Map();
    for (const key in diagnosticMessagesJson) {
        if (Object.hasOwnProperty.call(diagnosticMessagesJson, key)) {
            diagnosticMessages.set(key, diagnosticMessagesJson[key]);
        }
    }

    const infoFileOutput = buildInfoFileOutput(diagnosticMessages);
    checkForUniqueCodes(diagnosticMessages);
    await fs.promises.writeFile(outputFilePath, infoFileOutput);

    try {
        cp.execFileSync(which.sync("gofmt"), ["-w", outputFilePath]);
        console.log("All good!");
    }
    catch (e) {
        console.error(e);
    }
}

/**
 * @param {InputDiagnosticMessageTable} diagnosticTable
 */
function checkForUniqueCodes(diagnosticTable) {
    /** @type {Record<number, true | undefined>} */
    const allCodes = [];
    diagnosticTable.forEach(({ code }) => {
        if (allCodes[code]) {
            throw new Error(`Diagnostic code ${code} appears more than once.`);
        }
        allCodes[code] = true;
    });
}

/**
 * @param {InputDiagnosticMessageTable} messageTable
 * @returns {string}
 */
function buildInfoFileOutput(messageTable) {
    const result = [
        `// GENERATED BY processDiagnosticMessages2.mjs; DO NOT EDIT`,
        `package compiler`,
        ``,
        `type DiagnosticCategory int32`,
        "",
        `const (`,
        `\tCategoryWarning    DiagnosticCategory = iota`,
        `\tCategoryError`,
        `\tCategorySuggestion`,
        `\tCategoryMessage`,
        `)`,
        ``,
        `type Message struct {`,
        `\tcode int32`,
        `\tcategory DiagnosticCategory`,
        `\tkey string`,
        `\ttext string`,
        `\treportsUnnecessary bool`,
        `\telidedInCompatabilityPyramid bool`,
        `\treportsDeprecated bool`,
        `}`,
        "",
        `func (m *Message) Code() int32 { return m.code }`,
        `func (m *Message) Category() DiagnosticCategory { return m.category }`,
        `func (m *Message) Key() string { return m.key }`,
        `func (m *Message) Message() string { return m.text }`,
        `func (m *Message) ReportsUnnecessary() bool { return m.reportsUnnecessary }`,
        `func (m *Message) ElidedInCompatabilityPyramid() bool { return m.elidedInCompatabilityPyramid }`,
        `func (m *Message) ReportsDeprecated() bool { return m.reportsDeprecated }`,
        "",
        `func diag(code int32, category DiagnosticCategory, key string, text string, reportsUnnecessary bool, elidedInCompatabilityPyramid bool, reportsDeprecated bool) *Message {`,
        `\treturn &Message{code, category, key, text, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated}`,
        `}`,
        ``,
    ];

    const typeDeclaration = [
        `type diagnostics struct {`,
    ];

    const valueDeclaration = [
        `var Diagnostics = diagnostics{`,
    ];

    messageTable.forEach(
        ({ code, category, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated }, name) => {
            const { propName, key } = convertPropertyName(name, code);

            typeDeclaration.push(`\t${propName} *Message`);
            valueDeclaration.push(
                `\t${propName}: diag(${code}, Category${category}, "${key}", ${
                    JSON.stringify(name)
                }, ${!!reportsUnnecessary}, ${!!elidedInCompatabilityPyramid}, ${!!reportsDeprecated}),`,
            );
        },
    );

    typeDeclaration.push("}");
    valueDeclaration.push("}");

    result.push(...typeDeclaration, "", ...valueDeclaration, "");

    return result.join("\n");
}

/**
 * @param {string} name
 * @param {number} code
 * @returns {string}
 */
function createKey(name, code) {
    return name.slice(0, 100) + "_" + code;
}

/**
 * @param {string} origName
 * @param {number} code
 */
function convertPropertyName(origName, code) {
    let result = origName.split("").map(char => {
        if (char === "*") return "_Asterisk";
        if (char === "/") return "_Slash";
        if (char === ":") return "_Colon";
        return /\w/.test(char) ? char : "_";
    }).join("");

    // get rid of all multi-underscores
    result = result.replace(/_+/g, "_");

    // remove any leading underscore, unless it is followed by a number.
    result = result.replace(/^_(\D)/, "$1");

    // get rid of all trailing underscores.
    result = result.replace(/_$/, "");

    const key = createKey(result, code);

    if (!/^[A-Z]/.test(result)) {
        if (result.startsWith("_")) {
            result = "X" + result;
        }
        else {
            result = "X_" + result;
        }
    }

    return { propName: result, key };
}

main();
